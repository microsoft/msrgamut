function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequireb474"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequireb474"] = parcelRequire;
}
parcelRequire.register("aaLBe", function(module, exports) {
module.exports = React;

});

parcelRequire.register("aSxGG", function(module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";

var $gR6sg = parcelRequire("gR6sg");
function $7eb91429e284f8f2$var$emptyFunction() {}
function $7eb91429e284f8f2$var$emptyFunctionWithReset() {}
$7eb91429e284f8f2$var$emptyFunctionWithReset.resetWarningCache = $7eb91429e284f8f2$var$emptyFunction;
module.exports = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret === $gR6sg) // It is still safe when called from React.
        return;
        var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
        err.name = "Invariant Violation";
        throw err;
    }
    shim.isRequired = shim;
    function getShim() {
        return shim;
    }
    // Important!
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: $7eb91429e284f8f2$var$emptyFunctionWithReset,
        resetWarningCache: $7eb91429e284f8f2$var$emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};

});
parcelRequire.register("gR6sg", function(module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
var $c4569a61786c8538$var$ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
module.exports = $c4569a61786c8538$var$ReactPropTypesSecret;

});


parcelRequire.register("lQcey", function(module, exports) {

$parcel$export(module.exports, "AsyncMode", () => $fe67f1ac7d84803d$export$2b8d127b894957b9, (v) => $fe67f1ac7d84803d$export$2b8d127b894957b9 = v);
$parcel$export(module.exports, "ConcurrentMode", () => $fe67f1ac7d84803d$export$cea3a54a6425200c, (v) => $fe67f1ac7d84803d$export$cea3a54a6425200c = v);
$parcel$export(module.exports, "ContextConsumer", () => $fe67f1ac7d84803d$export$a7c73072b1a182ae, (v) => $fe67f1ac7d84803d$export$a7c73072b1a182ae = v);
$parcel$export(module.exports, "ContextProvider", () => $fe67f1ac7d84803d$export$9f27bc3417b4524d, (v) => $fe67f1ac7d84803d$export$9f27bc3417b4524d = v);
$parcel$export(module.exports, "Element", () => $fe67f1ac7d84803d$export$db77ccec0bb4ccac, (v) => $fe67f1ac7d84803d$export$db77ccec0bb4ccac = v);
$parcel$export(module.exports, "ForwardRef", () => $fe67f1ac7d84803d$export$8392c0c9d3dcbd35, (v) => $fe67f1ac7d84803d$export$8392c0c9d3dcbd35 = v);
$parcel$export(module.exports, "Fragment", () => $fe67f1ac7d84803d$export$ffb0004e005737fa, (v) => $fe67f1ac7d84803d$export$ffb0004e005737fa = v);
$parcel$export(module.exports, "Lazy", () => $fe67f1ac7d84803d$export$b624eff549462981, (v) => $fe67f1ac7d84803d$export$b624eff549462981 = v);
$parcel$export(module.exports, "Memo", () => $fe67f1ac7d84803d$export$7897aa7841a5380c, (v) => $fe67f1ac7d84803d$export$7897aa7841a5380c = v);
$parcel$export(module.exports, "Portal", () => $fe67f1ac7d84803d$export$602eac185826482c, (v) => $fe67f1ac7d84803d$export$602eac185826482c = v);
$parcel$export(module.exports, "Profiler", () => $fe67f1ac7d84803d$export$e2c29f18771995cb, (v) => $fe67f1ac7d84803d$export$e2c29f18771995cb = v);
$parcel$export(module.exports, "StrictMode", () => $fe67f1ac7d84803d$export$5f8d39834fd61797, (v) => $fe67f1ac7d84803d$export$5f8d39834fd61797 = v);
$parcel$export(module.exports, "Suspense", () => $fe67f1ac7d84803d$export$74bf444e3cd11ea5, (v) => $fe67f1ac7d84803d$export$74bf444e3cd11ea5 = v);
$parcel$export(module.exports, "isAsyncMode", () => $fe67f1ac7d84803d$export$92387174baf9b227, (v) => $fe67f1ac7d84803d$export$92387174baf9b227 = v);
$parcel$export(module.exports, "isConcurrentMode", () => $fe67f1ac7d84803d$export$ec112efeb987d9c6, (v) => $fe67f1ac7d84803d$export$ec112efeb987d9c6 = v);
$parcel$export(module.exports, "isContextConsumer", () => $fe67f1ac7d84803d$export$b706b080d889d2c9, (v) => $fe67f1ac7d84803d$export$b706b080d889d2c9 = v);
$parcel$export(module.exports, "isContextProvider", () => $fe67f1ac7d84803d$export$5be5a87408f70ddc, (v) => $fe67f1ac7d84803d$export$5be5a87408f70ddc = v);
$parcel$export(module.exports, "isElement", () => $fe67f1ac7d84803d$export$45a5e7f76e0caa8d, (v) => $fe67f1ac7d84803d$export$45a5e7f76e0caa8d = v);
$parcel$export(module.exports, "isForwardRef", () => $fe67f1ac7d84803d$export$455c2e768291efa6, (v) => $fe67f1ac7d84803d$export$455c2e768291efa6 = v);
$parcel$export(module.exports, "isFragment", () => $fe67f1ac7d84803d$export$9522e17588c12572, (v) => $fe67f1ac7d84803d$export$9522e17588c12572 = v);
$parcel$export(module.exports, "isLazy", () => $fe67f1ac7d84803d$export$2110ac352bb060b9, (v) => $fe67f1ac7d84803d$export$2110ac352bb060b9 = v);
$parcel$export(module.exports, "isMemo", () => $fe67f1ac7d84803d$export$56885ab8b9c456ab, (v) => $fe67f1ac7d84803d$export$56885ab8b9c456ab = v);
$parcel$export(module.exports, "isPortal", () => $fe67f1ac7d84803d$export$d927fcb6adf8f9de, (v) => $fe67f1ac7d84803d$export$d927fcb6adf8f9de = v);
$parcel$export(module.exports, "isProfiler", () => $fe67f1ac7d84803d$export$b82d16f27459e05a, (v) => $fe67f1ac7d84803d$export$b82d16f27459e05a = v);
$parcel$export(module.exports, "isStrictMode", () => $fe67f1ac7d84803d$export$522c17b4f5e123e8, (v) => $fe67f1ac7d84803d$export$522c17b4f5e123e8 = v);
$parcel$export(module.exports, "isSuspense", () => $fe67f1ac7d84803d$export$1aabd8a0274ecfd6, (v) => $fe67f1ac7d84803d$export$1aabd8a0274ecfd6 = v);
$parcel$export(module.exports, "isValidElementType", () => $fe67f1ac7d84803d$export$9b621391a187a31a, (v) => $fe67f1ac7d84803d$export$9b621391a187a31a = v);
$parcel$export(module.exports, "typeOf", () => $fe67f1ac7d84803d$export$f5bbd400c2f4426f, (v) => $fe67f1ac7d84803d$export$f5bbd400c2f4426f = v);
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var $fe67f1ac7d84803d$export$2b8d127b894957b9;
var $fe67f1ac7d84803d$export$cea3a54a6425200c;
var $fe67f1ac7d84803d$export$a7c73072b1a182ae;
var $fe67f1ac7d84803d$export$9f27bc3417b4524d;
var $fe67f1ac7d84803d$export$db77ccec0bb4ccac;
var $fe67f1ac7d84803d$export$8392c0c9d3dcbd35;
var $fe67f1ac7d84803d$export$ffb0004e005737fa;
var $fe67f1ac7d84803d$export$b624eff549462981;
var $fe67f1ac7d84803d$export$7897aa7841a5380c;
var $fe67f1ac7d84803d$export$602eac185826482c;
var $fe67f1ac7d84803d$export$e2c29f18771995cb;
var $fe67f1ac7d84803d$export$5f8d39834fd61797;
var $fe67f1ac7d84803d$export$74bf444e3cd11ea5;
var $fe67f1ac7d84803d$export$92387174baf9b227;
var $fe67f1ac7d84803d$export$ec112efeb987d9c6;
var $fe67f1ac7d84803d$export$b706b080d889d2c9;
var $fe67f1ac7d84803d$export$5be5a87408f70ddc;
var $fe67f1ac7d84803d$export$45a5e7f76e0caa8d;
var $fe67f1ac7d84803d$export$455c2e768291efa6;
var $fe67f1ac7d84803d$export$9522e17588c12572;
var $fe67f1ac7d84803d$export$2110ac352bb060b9;
var $fe67f1ac7d84803d$export$56885ab8b9c456ab;
var $fe67f1ac7d84803d$export$d927fcb6adf8f9de;
var $fe67f1ac7d84803d$export$b82d16f27459e05a;
var $fe67f1ac7d84803d$export$522c17b4f5e123e8;
var $fe67f1ac7d84803d$export$1aabd8a0274ecfd6;
var $fe67f1ac7d84803d$export$9b621391a187a31a;
var $fe67f1ac7d84803d$export$f5bbd400c2f4426f;
"use strict";
var $fe67f1ac7d84803d$var$b = "function" === typeof Symbol && Symbol.for, $fe67f1ac7d84803d$var$c = $fe67f1ac7d84803d$var$b ? Symbol.for("react.element") : 60103, $fe67f1ac7d84803d$var$d = $fe67f1ac7d84803d$var$b ? Symbol.for("react.portal") : 60106, $fe67f1ac7d84803d$var$e = $fe67f1ac7d84803d$var$b ? Symbol.for("react.fragment") : 60107, $fe67f1ac7d84803d$var$f = $fe67f1ac7d84803d$var$b ? Symbol.for("react.strict_mode") : 60108, $fe67f1ac7d84803d$var$g = $fe67f1ac7d84803d$var$b ? Symbol.for("react.profiler") : 60114, $fe67f1ac7d84803d$var$h = $fe67f1ac7d84803d$var$b ? Symbol.for("react.provider") : 60109, $fe67f1ac7d84803d$var$k = $fe67f1ac7d84803d$var$b ? Symbol.for("react.context") : 60110, $fe67f1ac7d84803d$var$l = $fe67f1ac7d84803d$var$b ? Symbol.for("react.async_mode") : 60111, $fe67f1ac7d84803d$var$m = $fe67f1ac7d84803d$var$b ? Symbol.for("react.concurrent_mode") : 60111, $fe67f1ac7d84803d$var$n = $fe67f1ac7d84803d$var$b ? Symbol.for("react.forward_ref") : 60112, $fe67f1ac7d84803d$var$p = $fe67f1ac7d84803d$var$b ? Symbol.for("react.suspense") : 60113, $fe67f1ac7d84803d$var$q = $fe67f1ac7d84803d$var$b ? Symbol.for("react.suspense_list") : 60120, $fe67f1ac7d84803d$var$r = $fe67f1ac7d84803d$var$b ? Symbol.for("react.memo") : 60115, $fe67f1ac7d84803d$var$t = $fe67f1ac7d84803d$var$b ? Symbol.for("react.lazy") : 60116, $fe67f1ac7d84803d$var$v = $fe67f1ac7d84803d$var$b ? Symbol.for("react.block") : 60121, $fe67f1ac7d84803d$var$w = $fe67f1ac7d84803d$var$b ? Symbol.for("react.fundamental") : 60117, $fe67f1ac7d84803d$var$x = $fe67f1ac7d84803d$var$b ? Symbol.for("react.responder") : 60118, $fe67f1ac7d84803d$var$y = $fe67f1ac7d84803d$var$b ? Symbol.for("react.scope") : 60119;
function $fe67f1ac7d84803d$var$z(a) {
    if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch(u){
            case $fe67f1ac7d84803d$var$c:
                switch(a = a.type, a){
                    case $fe67f1ac7d84803d$var$l:
                    case $fe67f1ac7d84803d$var$m:
                    case $fe67f1ac7d84803d$var$e:
                    case $fe67f1ac7d84803d$var$g:
                    case $fe67f1ac7d84803d$var$f:
                    case $fe67f1ac7d84803d$var$p:
                        return a;
                    default:
                        switch(a = a && a.$$typeof, a){
                            case $fe67f1ac7d84803d$var$k:
                            case $fe67f1ac7d84803d$var$n:
                            case $fe67f1ac7d84803d$var$t:
                            case $fe67f1ac7d84803d$var$r:
                            case $fe67f1ac7d84803d$var$h:
                                return a;
                            default:
                                return u;
                        }
                }
            case $fe67f1ac7d84803d$var$d:
                return u;
        }
    }
}
function $fe67f1ac7d84803d$var$A(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$m;
}
$fe67f1ac7d84803d$export$2b8d127b894957b9 = $fe67f1ac7d84803d$var$l;
$fe67f1ac7d84803d$export$cea3a54a6425200c = $fe67f1ac7d84803d$var$m;
$fe67f1ac7d84803d$export$a7c73072b1a182ae = $fe67f1ac7d84803d$var$k;
$fe67f1ac7d84803d$export$9f27bc3417b4524d = $fe67f1ac7d84803d$var$h;
$fe67f1ac7d84803d$export$db77ccec0bb4ccac = $fe67f1ac7d84803d$var$c;
$fe67f1ac7d84803d$export$8392c0c9d3dcbd35 = $fe67f1ac7d84803d$var$n;
$fe67f1ac7d84803d$export$ffb0004e005737fa = $fe67f1ac7d84803d$var$e;
$fe67f1ac7d84803d$export$b624eff549462981 = $fe67f1ac7d84803d$var$t;
$fe67f1ac7d84803d$export$7897aa7841a5380c = $fe67f1ac7d84803d$var$r;
$fe67f1ac7d84803d$export$602eac185826482c = $fe67f1ac7d84803d$var$d;
$fe67f1ac7d84803d$export$e2c29f18771995cb = $fe67f1ac7d84803d$var$g;
$fe67f1ac7d84803d$export$5f8d39834fd61797 = $fe67f1ac7d84803d$var$f;
$fe67f1ac7d84803d$export$74bf444e3cd11ea5 = $fe67f1ac7d84803d$var$p;
$fe67f1ac7d84803d$export$92387174baf9b227 = function(a) {
    return $fe67f1ac7d84803d$var$A(a) || $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$l;
};
$fe67f1ac7d84803d$export$ec112efeb987d9c6 = $fe67f1ac7d84803d$var$A;
$fe67f1ac7d84803d$export$b706b080d889d2c9 = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$k;
};
$fe67f1ac7d84803d$export$5be5a87408f70ddc = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$h;
};
$fe67f1ac7d84803d$export$45a5e7f76e0caa8d = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === $fe67f1ac7d84803d$var$c;
};
$fe67f1ac7d84803d$export$455c2e768291efa6 = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$n;
};
$fe67f1ac7d84803d$export$9522e17588c12572 = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$e;
};
$fe67f1ac7d84803d$export$2110ac352bb060b9 = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$t;
};
$fe67f1ac7d84803d$export$56885ab8b9c456ab = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$r;
};
$fe67f1ac7d84803d$export$d927fcb6adf8f9de = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$d;
};
$fe67f1ac7d84803d$export$b82d16f27459e05a = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$g;
};
$fe67f1ac7d84803d$export$522c17b4f5e123e8 = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$f;
};
$fe67f1ac7d84803d$export$1aabd8a0274ecfd6 = function(a) {
    return $fe67f1ac7d84803d$var$z(a) === $fe67f1ac7d84803d$var$p;
};
$fe67f1ac7d84803d$export$9b621391a187a31a = function(a) {
    return "string" === typeof a || "function" === typeof a || a === $fe67f1ac7d84803d$var$e || a === $fe67f1ac7d84803d$var$m || a === $fe67f1ac7d84803d$var$g || a === $fe67f1ac7d84803d$var$f || a === $fe67f1ac7d84803d$var$p || a === $fe67f1ac7d84803d$var$q || "object" === typeof a && null !== a && (a.$$typeof === $fe67f1ac7d84803d$var$t || a.$$typeof === $fe67f1ac7d84803d$var$r || a.$$typeof === $fe67f1ac7d84803d$var$h || a.$$typeof === $fe67f1ac7d84803d$var$k || a.$$typeof === $fe67f1ac7d84803d$var$n || a.$$typeof === $fe67f1ac7d84803d$var$w || a.$$typeof === $fe67f1ac7d84803d$var$x || a.$$typeof === $fe67f1ac7d84803d$var$y || a.$$typeof === $fe67f1ac7d84803d$var$v);
};
$fe67f1ac7d84803d$export$f5bbd400c2f4426f = $fe67f1ac7d84803d$var$z;

});

parcelRequire.register("jxmMp", function(module, exports) {
"use strict";
Object.defineProperty(module.exports, "__esModule", {
    value: true
});
Object.defineProperty(module.exports, "default", {
    enumerable: true,
    get: function get() {
        return $i3Lx3.default;
    }
});

var $i3Lx3 = parcelRequire("i3Lx3");

});
parcelRequire.register("i3Lx3", function(module, exports) {

$parcel$export(module.exports, "default", () => $d25d60b457dc6a70$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $aaLBe = parcelRequire("aaLBe");

var $bkxnY = parcelRequire("bkxnY");
function $d25d60b457dc6a70$export$2e2bcd8739ae039(path, displayName) {
    var Component = function Component(props, ref) {
        return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, $bkxnY.default), (0, $29rXr.default)({
            ref: ref
        }, props), path);
    };
    Component.muiName = (0, $bkxnY.default).muiName;
    return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).memo(/*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).forwardRef(Component));
}

});
parcelRequire.register("29rXr", function(module, exports) {

$parcel$export(module.exports, "default", () => $19121be03c962dba$export$2e2bcd8739ae039);
function $19121be03c962dba$export$2e2bcd8739ae039() {
    $19121be03c962dba$export$2e2bcd8739ae039 = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return $19121be03c962dba$export$2e2bcd8739ae039.apply(this, arguments);
}

});

parcelRequire.register("bkxnY", function(module, exports) {

$parcel$export(module.exports, "default", () => $83fb75ad87f390e1$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");


var $2LmR0 = parcelRequire("2LmR0");

var $gqsD7 = parcelRequire("gqsD7");
var $83fb75ad87f390e1$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            userSelect: "none",
            width: "1em",
            height: "1em",
            display: "inline-block",
            fill: "currentColor",
            flexShrink: 0,
            fontSize: theme.typography.pxToRem(24),
            transition: theme.transitions.create("fill", {
                duration: theme.transitions.duration.shorter
            })
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            color: theme.palette.primary.main
        },
        /* Styles applied to the root element if `color="secondary"`. */ colorSecondary: {
            color: theme.palette.secondary.main
        },
        /* Styles applied to the root element if `color="action"`. */ colorAction: {
            color: theme.palette.action.active
        },
        /* Styles applied to the root element if `color="error"`. */ colorError: {
            color: theme.palette.error.main
        },
        /* Styles applied to the root element if `color="disabled"`. */ colorDisabled: {
            color: theme.palette.action.disabled
        },
        /* Styles applied to the root element if `fontSize="inherit"`. */ fontSizeInherit: {
            fontSize: "inherit"
        },
        /* Styles applied to the root element if `fontSize="small"`. */ fontSizeSmall: {
            fontSize: theme.typography.pxToRem(20)
        },
        /* Styles applied to the root element if `fontSize="large"`. */ fontSizeLarge: {
            fontSize: theme.typography.pxToRem(35)
        }
    };
};
var $83fb75ad87f390e1$var$SvgIcon = /*#__PURE__*/ $aaLBe.forwardRef(function SvgIcon(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "inherit" : _props$color, _props$component = props.component, Component = _props$component === void 0 ? "svg" : _props$component, _props$fontSize = props.fontSize, fontSize = _props$fontSize === void 0 ? "medium" : _props$fontSize, htmlColor = props.htmlColor, titleAccess = props.titleAccess, _props$viewBox = props.viewBox, viewBox = _props$viewBox === void 0 ? "0 0 24 24" : _props$viewBox, other = (0, $kqze3.default)(props, [
        "children",
        "classes",
        "className",
        "color",
        "component",
        "fontSize",
        "htmlColor",
        "titleAccess",
        "viewBox"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, color !== "inherit" && classes["color".concat((0, $gqsD7.default)(color))], fontSize !== "default" && fontSize !== "medium" && classes["fontSize".concat((0, $gqsD7.default)(fontSize))]),
        focusable: "false",
        viewBox: viewBox,
        color: htmlColor,
        "aria-hidden": titleAccess ? undefined : true,
        role: titleAccess ? "img" : undefined,
        ref: ref
    }, other), children, titleAccess ? /*#__PURE__*/ $aaLBe.createElement("title", null, titleAccess) : null);
});
$83fb75ad87f390e1$var$SvgIcon.muiName = "SvgIcon";
var $83fb75ad87f390e1$export$2e2bcd8739ae039 = (0, $2LmR0.default)($83fb75ad87f390e1$export$9dd6ff9ea0189349, {
    name: "MuiSvgIcon"
})($83fb75ad87f390e1$var$SvgIcon);

});
parcelRequire.register("kqze3", function(module, exports) {

$parcel$export(module.exports, "default", () => $edf18f7381515c02$export$2e2bcd8739ae039);

var $9Zx8w = parcelRequire("9Zx8w");
function $edf18f7381515c02$export$2e2bcd8739ae039(source, excluded) {
    if (source == null) return {};
    var target = (0, $9Zx8w.default)(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}

});
parcelRequire.register("9Zx8w", function(module, exports) {

$parcel$export(module.exports, "default", () => $746383c9ca16b298$export$2e2bcd8739ae039);
function $746383c9ca16b298$export$2e2bcd8739ae039(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}

});


parcelRequire.register("h0TGs", function(module, exports) {

$parcel$export(module.exports, "default", () => $c62da169c755bd5c$export$2e2bcd8739ae039);
function $c62da169c755bd5c$var$r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) {
        if (Array.isArray(e)) for(t = 0; t < e.length; t++)e[t] && (f = $c62da169c755bd5c$var$r(e[t])) && (n && (n += " "), n += f);
        else for(t in e)e[t] && (n && (n += " "), n += t);
    }
    return n;
}
function $c62da169c755bd5c$export$4f5d2d50c9deca37() {
    for(var e, t, f = 0, n = ""; f < arguments.length;)(e = arguments[f++]) && (t = $c62da169c755bd5c$var$r(e)) && (n && (n += " "), n += t);
    return n;
}
var $c62da169c755bd5c$export$2e2bcd8739ae039 = $c62da169c755bd5c$export$4f5d2d50c9deca37;

});

parcelRequire.register("2LmR0", function(module, exports) {

$parcel$export(module.exports, "default", () => $2031b2dfaafa8346$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $fD6Hu = parcelRequire("fD6Hu");

var $gukLY = parcelRequire("gukLY");
function $2031b2dfaafa8346$var$withStyles(stylesOrCreator, options) {
    return (0, $fD6Hu.default)(stylesOrCreator, (0, $29rXr.default)({
        defaultTheme: (0, $gukLY.default)
    }, options));
}
var $2031b2dfaafa8346$export$2e2bcd8739ae039 = $2031b2dfaafa8346$var$withStyles;

});
parcelRequire.register("fD6Hu", function(module, exports) {

$parcel$export(module.exports, "default", () => $b60fb213d5b0229d$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $8Kqnn = parcelRequire("8Kqnn");


var $i0S8n = parcelRequire("i0S8n");

var $dowsg = parcelRequire("dowsg");

var $3f5nj = parcelRequire("3f5nj");
// It does not modify the component passed to it;
// instead, it returns a new component, with a `classes` property.
var $b60fb213d5b0229d$var$withStyles = function withStyles(stylesOrCreator) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function(Component) {
        var defaultTheme = options.defaultTheme, _options$withTheme = options.withTheme, withTheme = _options$withTheme === void 0 ? false : _options$withTheme, name = options.name, stylesOptions = (0, $kqze3.default)(options, [
            "defaultTheme",
            "withTheme",
            "name"
        ]);
        var classNamePrefix = name;
        var displayName;
        var useStyles = (0, $i0S8n.default)(stylesOrCreator, (0, $29rXr.default)({
            defaultTheme: defaultTheme,
            Component: Component,
            name: name || Component.displayName,
            classNamePrefix: classNamePrefix
        }, stylesOptions));
        var WithStyles = /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).forwardRef(function WithStyles(props, ref) {
            var classesProp = props.classes, innerRef = props.innerRef, other = (0, $kqze3.default)(props, [
                "classes",
                "innerRef"
            ]); // The wrapper receives only user supplied props, which could be a subset of
            // the actual props Component might receive due to merging with defaultProps.
            // So copying it here would give us the same result in the wrapper as well.
            var classes = useStyles((0, $29rXr.default)({}, Component.defaultProps, props));
            var theme;
            var more = other;
            if (typeof name === "string" || withTheme) {
                // name and withTheme are invariant in the outer scope
                // eslint-disable-next-line react-hooks/rules-of-hooks
                theme = (0, $3f5nj.default)() || defaultTheme;
                if (name) more = (0, $dowsg.default)({
                    theme: theme,
                    name: name,
                    props: other
                });
                 // Provide the theme to the wrapped component.
                // So we don't have to use the `withTheme()` Higher-order Component.
                if (withTheme && !more.theme) more.theme = theme;
            }
            return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(Component, (0, $29rXr.default)({
                ref: innerRef || ref,
                classes: classes
            }, more));
        });
        (0, (/*@__PURE__*/$parcel$interopDefault($8Kqnn)))(WithStyles, Component);
        return WithStyles;
    };
};
var $b60fb213d5b0229d$export$2e2bcd8739ae039 = $b60fb213d5b0229d$var$withStyles;

});
parcelRequire.register("8Kqnn", function(module, exports) {
"use strict";

var $RIa3D = parcelRequire("RIa3D");
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */ var $65e71459f6a7dc47$var$REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};
var $65e71459f6a7dc47$var$KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};
var $65e71459f6a7dc47$var$FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};
var $65e71459f6a7dc47$var$MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};
var $65e71459f6a7dc47$var$TYPE_STATICS = {};
$65e71459f6a7dc47$var$TYPE_STATICS[$RIa3D.ForwardRef] = $65e71459f6a7dc47$var$FORWARD_REF_STATICS;
$65e71459f6a7dc47$var$TYPE_STATICS[$RIa3D.Memo] = $65e71459f6a7dc47$var$MEMO_STATICS;
function $65e71459f6a7dc47$var$getStatics(component) {
    // React v16.11 and below
    if ($RIa3D.isMemo(component)) return $65e71459f6a7dc47$var$MEMO_STATICS;
     // React v16.12 and above
    return $65e71459f6a7dc47$var$TYPE_STATICS[component["$$typeof"]] || $65e71459f6a7dc47$var$REACT_STATICS;
}
var $65e71459f6a7dc47$var$defineProperty = Object.defineProperty;
var $65e71459f6a7dc47$var$getOwnPropertyNames = Object.getOwnPropertyNames;
var $65e71459f6a7dc47$var$getOwnPropertySymbols = Object.getOwnPropertySymbols;
var $65e71459f6a7dc47$var$getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var $65e71459f6a7dc47$var$getPrototypeOf = Object.getPrototypeOf;
var $65e71459f6a7dc47$var$objectPrototype = Object.prototype;
function $65e71459f6a7dc47$var$hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
        // don't hoist over string (html) components
        if ($65e71459f6a7dc47$var$objectPrototype) {
            var inheritedComponent = $65e71459f6a7dc47$var$getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== $65e71459f6a7dc47$var$objectPrototype) $65e71459f6a7dc47$var$hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
        var keys = $65e71459f6a7dc47$var$getOwnPropertyNames(sourceComponent);
        if ($65e71459f6a7dc47$var$getOwnPropertySymbols) keys = keys.concat($65e71459f6a7dc47$var$getOwnPropertySymbols(sourceComponent));
        var targetStatics = $65e71459f6a7dc47$var$getStatics(targetComponent);
        var sourceStatics = $65e71459f6a7dc47$var$getStatics(sourceComponent);
        for(var i = 0; i < keys.length; ++i){
            var key = keys[i];
            if (!$65e71459f6a7dc47$var$KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = $65e71459f6a7dc47$var$getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    $65e71459f6a7dc47$var$defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }
    }
    return targetComponent;
}
module.exports = $65e71459f6a7dc47$var$hoistNonReactStatics;

});
parcelRequire.register("RIa3D", function(module, exports) {
"use strict";

module.exports = (parcelRequire("lQcey"));

});


parcelRequire.register("i0S8n", function(module, exports) {

$parcel$export(module.exports, "default", () => $d1d237ff1492738d$export$2e2bcd8739ae039);

var $kqze3 = parcelRequire("kqze3");

var $29rXr = parcelRequire("29rXr");

var $aaLBe = parcelRequire("aaLBe");

var $dXwEQ = parcelRequire("dXwEQ");

var $heuOI = parcelRequire("heuOI");

var $jmddd = parcelRequire("jmddd");

var $3f5nj = parcelRequire("3f5nj");

var $6552k = parcelRequire("6552k");

var $5Zn7U = parcelRequire("5Zn7U");

var $27E1h = parcelRequire("27E1h");

var $gIgen = parcelRequire("gIgen");
function $d1d237ff1492738d$var$getClasses(_ref, classes, Component) {
    var state = _ref.state, stylesOptions = _ref.stylesOptions;
    if (stylesOptions.disableGeneration) return classes || {};
    if (!state.cacheClasses) state.cacheClasses = {
        // Cache for the finalized classes value.
        value: null,
        // Cache for the last used classes prop pointer.
        lastProp: null,
        // Cache for the last used rendered classes pointer.
        lastJSS: {}
    };
     // Tracks if either the rendered classes or classes prop has changed,
    // requiring the generation of a new finalized classes object.
    var generate = false;
    if (state.classes !== state.cacheClasses.lastJSS) {
        state.cacheClasses.lastJSS = state.classes;
        generate = true;
    }
    if (classes !== state.cacheClasses.lastProp) {
        state.cacheClasses.lastProp = classes;
        generate = true;
    }
    if (generate) state.cacheClasses.value = (0, $heuOI.default)({
        baseClasses: state.cacheClasses.lastJSS,
        newClasses: classes,
        Component: Component
    });
    return state.cacheClasses.value;
}
function $d1d237ff1492738d$var$attach(_ref2, props) {
    var state = _ref2.state, theme = _ref2.theme, stylesOptions = _ref2.stylesOptions, stylesCreator = _ref2.stylesCreator, name = _ref2.name;
    if (stylesOptions.disableGeneration) return;
    var sheetManager = (0, $jmddd.default).get(stylesOptions.sheetsManager, stylesCreator, theme);
    if (!sheetManager) {
        sheetManager = {
            refs: 0,
            staticSheet: null,
            dynamicStyles: null
        };
        (0, $jmddd.default).set(stylesOptions.sheetsManager, stylesCreator, theme, sheetManager);
    }
    var options = (0, $29rXr.default)({}, stylesCreator.options, stylesOptions, {
        theme: theme,
        flip: typeof stylesOptions.flip === "boolean" ? stylesOptions.flip : theme.direction === "rtl"
    });
    options.generateId = options.serverGenerateClassName || options.generateClassName;
    var sheetsRegistry = stylesOptions.sheetsRegistry;
    if (sheetManager.refs === 0) {
        var staticSheet;
        if (stylesOptions.sheetsCache) staticSheet = (0, $jmddd.default).get(stylesOptions.sheetsCache, stylesCreator, theme);
        var styles = stylesCreator.create(theme, name);
        if (!staticSheet) {
            staticSheet = stylesOptions.jss.createStyleSheet(styles, (0, $29rXr.default)({
                link: false
            }, options));
            staticSheet.attach();
            if (stylesOptions.sheetsCache) (0, $jmddd.default).set(stylesOptions.sheetsCache, stylesCreator, theme, staticSheet);
        }
        if (sheetsRegistry) sheetsRegistry.add(staticSheet);
        sheetManager.staticSheet = staticSheet;
        sheetManager.dynamicStyles = (0, $dXwEQ.getDynamicStyles)(styles);
    }
    if (sheetManager.dynamicStyles) {
        var dynamicSheet = stylesOptions.jss.createStyleSheet(sheetManager.dynamicStyles, (0, $29rXr.default)({
            link: true
        }, options));
        dynamicSheet.update(props);
        dynamicSheet.attach();
        state.dynamicSheet = dynamicSheet;
        state.classes = (0, $heuOI.default)({
            baseClasses: sheetManager.staticSheet.classes,
            newClasses: dynamicSheet.classes
        });
        if (sheetsRegistry) sheetsRegistry.add(dynamicSheet);
    } else state.classes = sheetManager.staticSheet.classes;
    sheetManager.refs += 1;
}
function $d1d237ff1492738d$var$update(_ref3, props) {
    var state = _ref3.state;
    if (state.dynamicSheet) state.dynamicSheet.update(props);
}
function $d1d237ff1492738d$var$detach(_ref4) {
    var state = _ref4.state, theme = _ref4.theme, stylesOptions = _ref4.stylesOptions, stylesCreator = _ref4.stylesCreator;
    if (stylesOptions.disableGeneration) return;
    var sheetManager = (0, $jmddd.default).get(stylesOptions.sheetsManager, stylesCreator, theme);
    sheetManager.refs -= 1;
    var sheetsRegistry = stylesOptions.sheetsRegistry;
    if (sheetManager.refs === 0) {
        (0, $jmddd.default).delete(stylesOptions.sheetsManager, stylesCreator, theme);
        stylesOptions.jss.removeStyleSheet(sheetManager.staticSheet);
        if (sheetsRegistry) sheetsRegistry.remove(sheetManager.staticSheet);
    }
    if (state.dynamicSheet) {
        stylesOptions.jss.removeStyleSheet(state.dynamicSheet);
        if (sheetsRegistry) sheetsRegistry.remove(state.dynamicSheet);
    }
}
function $d1d237ff1492738d$var$useSynchronousEffect(func, values) {
    var key = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useRef([]);
    var output; // Store "generation" key. Just returns a new object every time
    var currentKey = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useMemo(function() {
        return {};
    }, values); // eslint-disable-line react-hooks/exhaustive-deps
    // "the first render", or "memo dropped the value"
    if (key.current !== currentKey) {
        key.current = currentKey;
        output = func();
    }
    (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useEffect(function() {
        return function() {
            if (output) output();
        };
    }, [
        currentKey
    ] // eslint-disable-line react-hooks/exhaustive-deps
    );
}
function $d1d237ff1492738d$export$2e2bcd8739ae039(stylesOrCreator) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var name = options.name, classNamePrefixOption = options.classNamePrefix, Component = options.Component, _options$defaultTheme = options.defaultTheme, defaultTheme = _options$defaultTheme === void 0 ? (0, $gIgen.default) : _options$defaultTheme, stylesOptions2 = (0, $kqze3.default)(options, [
        "name",
        "classNamePrefix",
        "Component",
        "defaultTheme"
    ]);
    var stylesCreator = (0, $27E1h.default)(stylesOrCreator);
    var classNamePrefix = name || classNamePrefixOption || "makeStyles";
    stylesCreator.options = {
        index: (0, $5Zn7U.increment)(),
        name: name,
        meta: classNamePrefix,
        classNamePrefix: classNamePrefix
    };
    var useStyles = function useStyles() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var theme = (0, $3f5nj.default)() || defaultTheme;
        var stylesOptions = (0, $29rXr.default)({}, (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useContext((0, $6552k.StylesContext)), stylesOptions2);
        var instance = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useRef();
        var shouldUpdate = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useRef();
        $d1d237ff1492738d$var$useSynchronousEffect(function() {
            var current = {
                name: name,
                state: {},
                stylesCreator: stylesCreator,
                stylesOptions: stylesOptions,
                theme: theme
            };
            $d1d237ff1492738d$var$attach(current, props);
            shouldUpdate.current = false;
            instance.current = current;
            return function() {
                $d1d237ff1492738d$var$detach(current);
            };
        }, [
            theme,
            stylesCreator
        ]);
        (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useEffect(function() {
            if (shouldUpdate.current) $d1d237ff1492738d$var$update(instance.current, props);
            shouldUpdate.current = true;
        });
        var classes = $d1d237ff1492738d$var$getClasses(instance.current, props.classes, Component);
        return classes;
    };
    return useStyles;
}

});
parcelRequire.register("dXwEQ", function(module, exports) {

$parcel$export(module.exports, "createRule", () => $a29a1e3a9ac4286d$export$56e87122f905fac0);
$parcel$export(module.exports, "toCssValue", () => $a29a1e3a9ac4286d$export$5ac341d5e3cf9273);
$parcel$export(module.exports, "RuleList", () => $a29a1e3a9ac4286d$export$d9da2a13178d3d68);
$parcel$export(module.exports, "create", () => $a29a1e3a9ac4286d$export$185802fd694ee1f5);
$parcel$export(module.exports, "hasCSSTOMSupport", () => $a29a1e3a9ac4286d$export$2305122a7d881dec);
$parcel$export(module.exports, "getDynamicStyles", () => $a29a1e3a9ac4286d$export$8558f2aefa046992);

var $29rXr = parcelRequire("29rXr");

var $7nD0Z = parcelRequire("7nD0Z");

var $iDATp = parcelRequire("iDATp");

var $67Du8 = parcelRequire("67Du8");

var $fiJE0 = parcelRequire("fiJE0");

var $bPInb = parcelRequire("bPInb");

var $9Zx8w = parcelRequire("9Zx8w");
var $a29a1e3a9ac4286d$var$plainObjectConstrurctor = {}.constructor;
function $a29a1e3a9ac4286d$var$cloneStyle(style) {
    if (style == null || typeof style !== "object") return style;
    if (Array.isArray(style)) return style.map($a29a1e3a9ac4286d$var$cloneStyle);
    if (style.constructor !== $a29a1e3a9ac4286d$var$plainObjectConstrurctor) return style;
    var newStyle = {};
    for(var name in style)newStyle[name] = $a29a1e3a9ac4286d$var$cloneStyle(style[name]);
    return newStyle;
}
/**
 * Create a rule instance.
 */ function $a29a1e3a9ac4286d$export$56e87122f905fac0(name, decl, options) {
    if (name === void 0) name = "unnamed";
    var jss = options.jss;
    var declCopy = $a29a1e3a9ac4286d$var$cloneStyle(decl);
    var rule = jss.plugins.onCreateRule(name, declCopy, options);
    if (rule) return rule; // It is an at-rule and it has no instance.
    name[0];
    return null;
}
var $a29a1e3a9ac4286d$var$join = function join(value, by) {
    var result = "";
    for(var i = 0; i < value.length; i++){
        // Remove !important from the value, it will be readded later.
        if (value[i] === "!important") break;
        if (result) result += by;
        result += value[i];
    }
    return result;
};
/**
 * Converts JSS array value to a CSS string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */ var $a29a1e3a9ac4286d$export$5ac341d5e3cf9273 = function toCssValue(value) {
    if (!Array.isArray(value)) return value;
    var cssValue = ""; // Support space separated values via `[['5px', '10px']]`.
    if (Array.isArray(value[0])) for(var i = 0; i < value.length; i++){
        if (value[i] === "!important") break;
        if (cssValue) cssValue += ", ";
        cssValue += $a29a1e3a9ac4286d$var$join(value[i], " ");
    }
    else cssValue = $a29a1e3a9ac4286d$var$join(value, ", "); // Add !important, because it was ignored.
    if (value[value.length - 1] === "!important") cssValue += " !important";
    return cssValue;
};
function $a29a1e3a9ac4286d$var$getWhitespaceSymbols(options) {
    if (options && options.format === false) return {
        linebreak: "",
        space: ""
    };
    return {
        linebreak: "\n",
        space: " "
    };
}
/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */ function $a29a1e3a9ac4286d$var$indentStr(str, indent) {
    var result = "";
    for(var index = 0; index < indent; index++)result += "  ";
    return result + str;
}
/**
 * Converts a Rule to CSS string.
 */ function $a29a1e3a9ac4286d$var$toCss(selector, style, options) {
    if (options === void 0) options = {};
    var result = "";
    if (!style) return result;
    var _options = options, _options$indent = _options.indent, indent = _options$indent === void 0 ? 0 : _options$indent;
    var fallbacks = style.fallbacks;
    if (options.format === false) indent = -Infinity;
    var _getWhitespaceSymbols = $a29a1e3a9ac4286d$var$getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak, space = _getWhitespaceSymbols.space;
    if (selector) indent++; // Apply fallbacks first.
    if (fallbacks) {
        // Array syntax {fallbacks: [{prop: value}]}
        if (Array.isArray(fallbacks)) for(var index = 0; index < fallbacks.length; index++){
            var fallback = fallbacks[index];
            for(var prop in fallback){
                var value = fallback[prop];
                if (value != null) {
                    if (result) result += linebreak;
                    result += $a29a1e3a9ac4286d$var$indentStr(prop + ":" + space + $a29a1e3a9ac4286d$export$5ac341d5e3cf9273(value) + ";", indent);
                }
            }
        }
        else // Object syntax {fallbacks: {prop: value}}
        for(var _prop in fallbacks){
            var _value = fallbacks[_prop];
            if (_value != null) {
                if (result) result += linebreak;
                result += $a29a1e3a9ac4286d$var$indentStr(_prop + ":" + space + $a29a1e3a9ac4286d$export$5ac341d5e3cf9273(_value) + ";", indent);
            }
        }
    }
    for(var _prop2 in style){
        var _value2 = style[_prop2];
        if (_value2 != null && _prop2 !== "fallbacks") {
            if (result) result += linebreak;
            result += $a29a1e3a9ac4286d$var$indentStr(_prop2 + ":" + space + $a29a1e3a9ac4286d$export$5ac341d5e3cf9273(_value2) + ";", indent);
        }
    } // Allow empty style in this case, because properties will be added dynamically.
    if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.
    if (!selector) return result;
    indent--;
    if (result) result = "" + linebreak + result + linebreak;
    return $a29a1e3a9ac4286d$var$indentStr("" + selector + space + "{" + result, indent) + $a29a1e3a9ac4286d$var$indentStr("}", indent);
}
var $a29a1e3a9ac4286d$var$escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var $a29a1e3a9ac4286d$var$nativeEscape = typeof CSS !== "undefined" && CSS.escape;
var $a29a1e3a9ac4286d$var$escape = function(str) {
    return $a29a1e3a9ac4286d$var$nativeEscape ? $a29a1e3a9ac4286d$var$nativeEscape(str) : str.replace($a29a1e3a9ac4286d$var$escapeRegex, "\\$1");
};
var $a29a1e3a9ac4286d$var$BaseStyleRule = /*#__PURE__*/ function() {
    function BaseStyleRule(key, style, options) {
        this.type = "style";
        this.isProcessed = false;
        var sheet = options.sheet, Renderer = options.Renderer;
        this.key = key;
        this.options = options;
        this.style = style;
        if (sheet) this.renderer = sheet.renderer;
        else if (Renderer) this.renderer = new Renderer();
    }
    /**
   * Get or set a style property.
   */ var _proto = BaseStyleRule.prototype;
    _proto.prop = function prop(name, value, options) {
        // It's a getter.
        if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.
        var force = options ? options.force : false;
        if (!force && this.style[name] === value) return this;
        var newValue = value;
        if (!options || options.process !== false) newValue = this.options.jss.plugins.onChangeValue(value, name, this);
        var isEmpty = newValue == null || newValue === false;
        var isDefined = name in this.style; // Value is empty and wasn't defined before.
        if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.
        var remove = isEmpty && isDefined;
        if (remove) delete this.style[name];
        else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.
        if (this.renderable && this.renderer) {
            if (remove) this.renderer.removeProperty(this.renderable, name);
            else this.renderer.setProperty(this.renderable, name, newValue);
            return this;
        }
        var sheet = this.options.sheet;
        sheet && sheet.attached;
        return this;
    };
    return BaseStyleRule;
}();
var $a29a1e3a9ac4286d$var$StyleRule = /*#__PURE__*/ function(_BaseStyleRule) {
    (0, $fiJE0.default)(StyleRule, _BaseStyleRule);
    function StyleRule(key, style, options) {
        var _this;
        _this = _BaseStyleRule.call(this, key, style, options) || this;
        var selector = options.selector, scoped = options.scoped, sheet = options.sheet, generateId = options.generateId;
        if (selector) _this.selectorText = selector;
        else if (scoped !== false) {
            _this.id = generateId((0, $bPInb.default)((0, $bPInb.default)(_this)), sheet);
            _this.selectorText = "." + $a29a1e3a9ac4286d$var$escape(_this.id);
        }
        return _this;
    }
    /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */ var _proto2 = StyleRule.prototype;
    /**
   * Apply rule to an element inline.
   */ _proto2.applyTo = function applyTo(renderable) {
        var renderer = this.renderer;
        if (renderer) {
            var json = this.toJSON();
            for(var prop in json)renderer.setProperty(renderable, prop, json[prop]);
        }
        return this;
    } /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */ ;
    _proto2.toJSON = function toJSON() {
        var json = {};
        for(var prop in this.style){
            var value = this.style[prop];
            if (typeof value !== "object") json[prop] = value;
            else if (Array.isArray(value)) json[prop] = $a29a1e3a9ac4286d$export$5ac341d5e3cf9273(value);
        }
        return json;
    } /**
   * Generates a CSS string.
   */ ;
    _proto2.toString = function toString(options) {
        var sheet = this.options.sheet;
        var link = sheet ? sheet.options.link : false;
        var opts = link ? (0, $29rXr.default)({}, options, {
            allowEmpty: true
        }) : options;
        return $a29a1e3a9ac4286d$var$toCss(this.selectorText, this.style, opts);
    };
    (0, $67Du8.default)(StyleRule, [
        {
            key: "selector",
            set: function set(selector) {
                if (selector === this.selectorText) return;
                this.selectorText = selector;
                var renderer = this.renderer, renderable = this.renderable;
                if (!renderable || !renderer) return;
                var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.
                if (!hasChanged) renderer.replaceRule(renderable, this);
            },
            get: function get() {
                return this.selectorText;
            }
        }
    ]);
    return StyleRule;
}($a29a1e3a9ac4286d$var$BaseStyleRule);
var $a29a1e3a9ac4286d$var$pluginStyleRule = {
    onCreateRule: function onCreateRule(key, style, options) {
        if (key[0] === "@" || options.parent && options.parent.type === "keyframes") return null;
        return new $a29a1e3a9ac4286d$var$StyleRule(key, style, options);
    }
};
var $a29a1e3a9ac4286d$var$defaultToStringOptions = {
    indent: 1,
    children: true
};
var $a29a1e3a9ac4286d$var$atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */ var $a29a1e3a9ac4286d$var$ConditionalRule = /*#__PURE__*/ function() {
    function ConditionalRule(key, styles, options) {
        this.type = "conditional";
        this.isProcessed = false;
        this.key = key;
        var atMatch = key.match($a29a1e3a9ac4286d$var$atRegExp);
        this.at = atMatch ? atMatch[1] : "unknown"; // Key might contain a unique suffix in case the `name` passed by user was duplicate.
        this.query = options.name || "@" + this.at;
        this.options = options;
        this.rules = new $a29a1e3a9ac4286d$export$d9da2a13178d3d68((0, $29rXr.default)({}, options, {
            parent: this
        }));
        for(var name in styles)this.rules.add(name, styles[name]);
        this.rules.process();
    }
    /**
   * Get a rule.
   */ var _proto = ConditionalRule.prototype;
    _proto.getRule = function getRule(name) {
        return this.rules.get(name);
    } /**
   * Get index of a rule.
   */ ;
    _proto.indexOf = function indexOf(rule) {
        return this.rules.indexOf(rule);
    } /**
   * Create and register rule, run plugins.
   */ ;
    _proto.addRule = function addRule(name, style, options) {
        var rule = this.rules.add(name, style, options);
        if (!rule) return null;
        this.options.jss.plugins.onProcessRule(rule);
        return rule;
    } /**
   * Replace rule, run plugins.
   */ ;
    _proto.replaceRule = function replaceRule(name, style, options) {
        var newRule = this.rules.replace(name, style, options);
        if (newRule) this.options.jss.plugins.onProcessRule(newRule);
        return newRule;
    } /**
   * Generates a CSS string.
   */ ;
    _proto.toString = function toString(options) {
        if (options === void 0) options = $a29a1e3a9ac4286d$var$defaultToStringOptions;
        var _getWhitespaceSymbols = $a29a1e3a9ac4286d$var$getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;
        if (options.indent == null) options.indent = $a29a1e3a9ac4286d$var$defaultToStringOptions.indent;
        if (options.children == null) options.children = $a29a1e3a9ac4286d$var$defaultToStringOptions.children;
        if (options.children === false) return this.query + " {}";
        var children = this.rules.toString(options);
        return children ? this.query + " {" + linebreak + children + linebreak + "}" : "";
    };
    return ConditionalRule;
}();
var $a29a1e3a9ac4286d$var$keyRegExp = /@container|@media|@supports\s+/;
var $a29a1e3a9ac4286d$var$pluginConditionalRule = {
    onCreateRule: function onCreateRule(key, styles, options) {
        return $a29a1e3a9ac4286d$var$keyRegExp.test(key) ? new $a29a1e3a9ac4286d$var$ConditionalRule(key, styles, options) : null;
    }
};
var $a29a1e3a9ac4286d$var$defaultToStringOptions$1 = {
    indent: 1,
    children: true
};
var $a29a1e3a9ac4286d$var$nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */ var $a29a1e3a9ac4286d$var$KeyframesRule = /*#__PURE__*/ function() {
    function KeyframesRule(key, frames, options) {
        this.type = "keyframes";
        this.at = "@keyframes";
        this.isProcessed = false;
        var nameMatch = key.match($a29a1e3a9ac4286d$var$nameRegExp);
        if (nameMatch && nameMatch[1]) this.name = nameMatch[1];
        else this.name = "noname";
        this.key = this.type + "-" + this.name;
        this.options = options;
        var scoped = options.scoped, sheet = options.sheet, generateId = options.generateId;
        this.id = scoped === false ? this.name : $a29a1e3a9ac4286d$var$escape(generateId(this, sheet));
        this.rules = new $a29a1e3a9ac4286d$export$d9da2a13178d3d68((0, $29rXr.default)({}, options, {
            parent: this
        }));
        for(var name in frames)this.rules.add(name, frames[name], (0, $29rXr.default)({}, options, {
            parent: this
        }));
        this.rules.process();
    }
    /**
   * Generates a CSS string.
   */ var _proto = KeyframesRule.prototype;
    _proto.toString = function toString(options) {
        if (options === void 0) options = $a29a1e3a9ac4286d$var$defaultToStringOptions$1;
        var _getWhitespaceSymbols = $a29a1e3a9ac4286d$var$getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;
        if (options.indent == null) options.indent = $a29a1e3a9ac4286d$var$defaultToStringOptions$1.indent;
        if (options.children == null) options.children = $a29a1e3a9ac4286d$var$defaultToStringOptions$1.children;
        if (options.children === false) return this.at + " " + this.id + " {}";
        var children = this.rules.toString(options);
        if (children) children = "" + linebreak + children + linebreak;
        return this.at + " " + this.id + " {" + children + "}";
    };
    return KeyframesRule;
}();
var $a29a1e3a9ac4286d$var$keyRegExp$1 = /@keyframes\s+/;
var $a29a1e3a9ac4286d$var$refRegExp = /\$([\w-]+)/g;
var $a29a1e3a9ac4286d$var$findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
    if (typeof val === "string") return val.replace($a29a1e3a9ac4286d$var$refRegExp, function(match, name) {
        if (name in keyframes) return keyframes[name];
        return match;
    });
    return val;
};
/**
 * Replace the reference for a animation name.
 */ var $a29a1e3a9ac4286d$var$replaceRef = function replaceRef(style, prop, keyframes) {
    var value = style[prop];
    var refKeyframe = $a29a1e3a9ac4286d$var$findReferencedKeyframe(value, keyframes);
    if (refKeyframe !== value) style[prop] = refKeyframe;
};
var $a29a1e3a9ac4286d$var$pluginKeyframesRule = {
    onCreateRule: function onCreateRule(key, frames, options) {
        return typeof key === "string" && $a29a1e3a9ac4286d$var$keyRegExp$1.test(key) ? new $a29a1e3a9ac4286d$var$KeyframesRule(key, frames, options) : null;
    },
    // Animation name ref replacer.
    onProcessStyle: function onProcessStyle(style, rule, sheet) {
        if (rule.type !== "style" || !sheet) return style;
        if ("animation-name" in style) $a29a1e3a9ac4286d$var$replaceRef(style, "animation-name", sheet.keyframes);
        if ("animation" in style) $a29a1e3a9ac4286d$var$replaceRef(style, "animation", sheet.keyframes);
        return style;
    },
    onChangeValue: function onChangeValue(val, prop, rule) {
        var sheet = rule.options.sheet;
        if (!sheet) return val;
        switch(prop){
            case "animation":
                return $a29a1e3a9ac4286d$var$findReferencedKeyframe(val, sheet.keyframes);
            case "animation-name":
                return $a29a1e3a9ac4286d$var$findReferencedKeyframe(val, sheet.keyframes);
            default:
                return val;
        }
    }
};
var $a29a1e3a9ac4286d$var$KeyframeRule = /*#__PURE__*/ function(_BaseStyleRule) {
    (0, $fiJE0.default)(KeyframeRule, _BaseStyleRule);
    function KeyframeRule() {
        return _BaseStyleRule.apply(this, arguments) || this;
    }
    var _proto = KeyframeRule.prototype;
    /**
   * Generates a CSS string.
   */ _proto.toString = function toString(options) {
        var sheet = this.options.sheet;
        var link = sheet ? sheet.options.link : false;
        var opts = link ? (0, $29rXr.default)({}, options, {
            allowEmpty: true
        }) : options;
        return $a29a1e3a9ac4286d$var$toCss(this.key, this.style, opts);
    };
    return KeyframeRule;
}($a29a1e3a9ac4286d$var$BaseStyleRule);
var $a29a1e3a9ac4286d$var$pluginKeyframeRule = {
    onCreateRule: function onCreateRule(key, style, options) {
        if (options.parent && options.parent.type === "keyframes") return new $a29a1e3a9ac4286d$var$KeyframeRule(key, style, options);
        return null;
    }
};
var $a29a1e3a9ac4286d$var$FontFaceRule = /*#__PURE__*/ function() {
    function FontFaceRule(key, style, options) {
        this.type = "font-face";
        this.at = "@font-face";
        this.isProcessed = false;
        this.key = key;
        this.style = style;
        this.options = options;
    }
    /**
   * Generates a CSS string.
   */ var _proto = FontFaceRule.prototype;
    _proto.toString = function toString(options) {
        var _getWhitespaceSymbols = $a29a1e3a9ac4286d$var$getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;
        if (Array.isArray(this.style)) {
            var str = "";
            for(var index = 0; index < this.style.length; index++){
                str += $a29a1e3a9ac4286d$var$toCss(this.at, this.style[index]);
                if (this.style[index + 1]) str += linebreak;
            }
            return str;
        }
        return $a29a1e3a9ac4286d$var$toCss(this.at, this.style, options);
    };
    return FontFaceRule;
}();
var $a29a1e3a9ac4286d$var$keyRegExp$2 = /@font-face/;
var $a29a1e3a9ac4286d$var$pluginFontFaceRule = {
    onCreateRule: function onCreateRule(key, style, options) {
        return $a29a1e3a9ac4286d$var$keyRegExp$2.test(key) ? new $a29a1e3a9ac4286d$var$FontFaceRule(key, style, options) : null;
    }
};
var $a29a1e3a9ac4286d$var$ViewportRule = /*#__PURE__*/ function() {
    function ViewportRule(key, style, options) {
        this.type = "viewport";
        this.at = "@viewport";
        this.isProcessed = false;
        this.key = key;
        this.style = style;
        this.options = options;
    }
    /**
   * Generates a CSS string.
   */ var _proto = ViewportRule.prototype;
    _proto.toString = function toString(options) {
        return $a29a1e3a9ac4286d$var$toCss(this.key, this.style, options);
    };
    return ViewportRule;
}();
var $a29a1e3a9ac4286d$var$pluginViewportRule = {
    onCreateRule: function onCreateRule(key, style, options) {
        return key === "@viewport" || key === "@-ms-viewport" ? new $a29a1e3a9ac4286d$var$ViewportRule(key, style, options) : null;
    }
};
var $a29a1e3a9ac4286d$var$SimpleRule = /*#__PURE__*/ function() {
    function SimpleRule(key, value, options) {
        this.type = "simple";
        this.isProcessed = false;
        this.key = key;
        this.value = value;
        this.options = options;
    }
    /**
   * Generates a CSS string.
   */ // eslint-disable-next-line no-unused-vars
    var _proto = SimpleRule.prototype;
    _proto.toString = function toString(options) {
        if (Array.isArray(this.value)) {
            var str = "";
            for(var index = 0; index < this.value.length; index++){
                str += this.key + " " + this.value[index] + ";";
                if (this.value[index + 1]) str += "\n";
            }
            return str;
        }
        return this.key + " " + this.value + ";";
    };
    return SimpleRule;
}();
var $a29a1e3a9ac4286d$var$keysMap = {
    "@charset": true,
    "@import": true,
    "@namespace": true
};
var $a29a1e3a9ac4286d$var$pluginSimpleRule = {
    onCreateRule: function onCreateRule(key, value, options) {
        return key in $a29a1e3a9ac4286d$var$keysMap ? new $a29a1e3a9ac4286d$var$SimpleRule(key, value, options) : null;
    }
};
var $a29a1e3a9ac4286d$var$plugins = [
    $a29a1e3a9ac4286d$var$pluginStyleRule,
    $a29a1e3a9ac4286d$var$pluginConditionalRule,
    $a29a1e3a9ac4286d$var$pluginKeyframesRule,
    $a29a1e3a9ac4286d$var$pluginKeyframeRule,
    $a29a1e3a9ac4286d$var$pluginFontFaceRule,
    $a29a1e3a9ac4286d$var$pluginViewportRule,
    $a29a1e3a9ac4286d$var$pluginSimpleRule
];
var $a29a1e3a9ac4286d$var$defaultUpdateOptions = {
    process: true
};
var $a29a1e3a9ac4286d$var$forceUpdateOptions = {
    force: true,
    process: true
};
var $a29a1e3a9ac4286d$export$d9da2a13178d3d68 = /*#__PURE__*/ function() {
    // Rules registry for access by .get() method.
    // It contains the same rule registered by name and by selector.
    // Original styles object.
    // Used to ensure correct rules order.
    function RuleList(options) {
        this.map = {};
        this.raw = {};
        this.index = [];
        this.counter = 0;
        this.options = options;
        this.classes = options.classes;
        this.keyframes = options.keyframes;
    }
    /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */ var _proto = RuleList.prototype;
    _proto.add = function add(name, decl, ruleOptions) {
        var _this$options = this.options, parent = _this$options.parent, sheet = _this$options.sheet, jss = _this$options.jss, Renderer = _this$options.Renderer, generateId = _this$options.generateId, scoped = _this$options.scoped;
        var options = (0, $29rXr.default)({
            classes: this.classes,
            parent: parent,
            sheet: sheet,
            jss: jss,
            Renderer: Renderer,
            generateId: generateId,
            scoped: scoped,
            name: name,
            keyframes: this.keyframes,
            selector: undefined
        }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
        // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
        // we need to make the key unique within this RuleList instance scope.
        var key = name;
        if (name in this.raw) key = name + "-d" + this.counter++;
         // We need to save the original decl before creating the rule
        // because cache plugin needs to use it as a key to return a cached rule.
        this.raw[key] = decl;
        if (key in this.classes) // E.g. rules inside of @media container
        options.selector = "." + $a29a1e3a9ac4286d$var$escape(this.classes[key]);
        var rule = $a29a1e3a9ac4286d$export$56e87122f905fac0(key, decl, options);
        if (!rule) return null;
        this.register(rule);
        var index = options.index === undefined ? this.index.length : options.index;
        this.index.splice(index, 0, rule);
        return rule;
    } /**
   * Replace rule.
   * Create a new rule and remove old one instead of overwriting
   * because we want to invoke onCreateRule hook to make plugins work.
   */ ;
    _proto.replace = function replace(name, decl, ruleOptions) {
        var oldRule = this.get(name);
        var oldIndex = this.index.indexOf(oldRule);
        if (oldRule) this.remove(oldRule);
        var options = ruleOptions;
        if (oldIndex !== -1) options = (0, $29rXr.default)({}, ruleOptions, {
            index: oldIndex
        });
        return this.add(name, decl, options);
    } /**
   * Get a rule by name or selector.
   */ ;
    _proto.get = function get(nameOrSelector) {
        return this.map[nameOrSelector];
    } /**
   * Delete a rule.
   */ ;
    _proto.remove = function remove(rule) {
        this.unregister(rule);
        delete this.raw[rule.key];
        this.index.splice(this.index.indexOf(rule), 1);
    } /**
   * Get index of a rule.
   */ ;
    _proto.indexOf = function indexOf(rule) {
        return this.index.indexOf(rule);
    } /**
   * Run `onProcessRule()` plugins on every rule.
   */ ;
    _proto.process = function process() {
        var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
        // we end up with very hard-to-track-down side effects.
        this.index.slice(0).forEach(plugins.onProcessRule, plugins);
    } /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */ ;
    _proto.register = function register(rule) {
        this.map[rule.key] = rule;
        if (rule instanceof $a29a1e3a9ac4286d$var$StyleRule) {
            this.map[rule.selector] = rule;
            if (rule.id) this.classes[rule.key] = rule.id;
        } else if (rule instanceof $a29a1e3a9ac4286d$var$KeyframesRule && this.keyframes) this.keyframes[rule.name] = rule.id;
    } /**
   * Unregister a rule.
   */ ;
    _proto.unregister = function unregister(rule) {
        delete this.map[rule.key];
        if (rule instanceof $a29a1e3a9ac4286d$var$StyleRule) {
            delete this.map[rule.selector];
            delete this.classes[rule.key];
        } else if (rule instanceof $a29a1e3a9ac4286d$var$KeyframesRule) delete this.keyframes[rule.name];
    } /**
   * Update the function values with a new data.
   */ ;
    _proto.update = function update() {
        var name;
        var data;
        var options;
        if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === "string") {
            name = arguments.length <= 0 ? undefined : arguments[0];
            data = arguments.length <= 1 ? undefined : arguments[1];
            options = arguments.length <= 2 ? undefined : arguments[2];
        } else {
            data = arguments.length <= 0 ? undefined : arguments[0];
            options = arguments.length <= 1 ? undefined : arguments[1];
            name = null;
        }
        if (name) this.updateOne(this.get(name), data, options);
        else for(var index = 0; index < this.index.length; index++)this.updateOne(this.index[index], data, options);
    } /**
   * Execute plugins, update rule props.
   */ ;
    _proto.updateOne = function updateOne(rule, data, options) {
        if (options === void 0) options = $a29a1e3a9ac4286d$var$defaultUpdateOptions;
        var _this$options2 = this.options, plugins = _this$options2.jss.plugins, sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.
        if (rule.rules instanceof RuleList) {
            rule.rules.update(data, options);
            return;
        }
        var style = rule.style;
        plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.
        if (options.process && style && style !== rule.style) {
            // We need to run the plugins in case new `style` relies on syntax plugins.
            plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.
            for(var prop in rule.style){
                var nextValue = rule.style[prop];
                var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
                // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.
                if (nextValue !== prevValue) rule.prop(prop, nextValue, $a29a1e3a9ac4286d$var$forceUpdateOptions);
            } // Remove props.
            for(var _prop in style){
                var _nextValue = rule.style[_prop];
                var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
                // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.
                if (_nextValue == null && _nextValue !== _prevValue) rule.prop(_prop, null, $a29a1e3a9ac4286d$var$forceUpdateOptions);
            }
        }
    } /**
   * Convert rules to a CSS string.
   */ ;
    _proto.toString = function toString(options) {
        var str = "";
        var sheet = this.options.sheet;
        var link = sheet ? sheet.options.link : false;
        var _getWhitespaceSymbols = $a29a1e3a9ac4286d$var$getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;
        for(var index = 0; index < this.index.length; index++){
            var rule = this.index[index];
            var css = rule.toString(options); // No need to render an empty rule.
            if (!css && !link) continue;
            if (str) str += linebreak;
            str += css;
        }
        return str;
    };
    return RuleList;
}();
var $a29a1e3a9ac4286d$var$StyleSheet = /*#__PURE__*/ function() {
    function StyleSheet(styles, options) {
        this.attached = false;
        this.deployed = false;
        this.classes = {};
        this.keyframes = {};
        this.options = (0, $29rXr.default)({}, options, {
            sheet: this,
            parent: this,
            classes: this.classes,
            keyframes: this.keyframes
        });
        if (options.Renderer) this.renderer = new options.Renderer(this);
        this.rules = new $a29a1e3a9ac4286d$export$d9da2a13178d3d68(this.options);
        for(var name in styles)this.rules.add(name, styles[name]);
        this.rules.process();
    }
    /**
   * Attach renderable to the render tree.
   */ var _proto = StyleSheet.prototype;
    _proto.attach = function attach() {
        if (this.attached) return this;
        if (this.renderer) this.renderer.attach();
        this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.
        if (!this.deployed) this.deploy();
        return this;
    } /**
   * Remove renderable from render tree.
   */ ;
    _proto.detach = function detach() {
        if (!this.attached) return this;
        if (this.renderer) this.renderer.detach();
        this.attached = false;
        return this;
    } /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */ ;
    _proto.addRule = function addRule(name, decl, options) {
        var queue = this.queue; // Plugins can create rules.
        // In order to preserve the right order, we need to queue all `.addRule` calls,
        // which happen after the first `rules.add()` call.
        if (this.attached && !queue) this.queue = [];
        var rule = this.rules.add(name, decl, options);
        if (!rule) return null;
        this.options.jss.plugins.onProcessRule(rule);
        if (this.attached) {
            if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
            // It will be inserted all together when .attach is called.
            if (queue) queue.push(rule);
            else {
                this.insertRule(rule);
                if (this.queue) {
                    this.queue.forEach(this.insertRule, this);
                    this.queue = undefined;
                }
            }
            return rule;
        } // We can't add rules to a detached style node.
        // We will redeploy the sheet once user will attach it.
        this.deployed = false;
        return rule;
    } /**
   * Replace a rule in the current stylesheet.
   */ ;
    _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {
        var oldRule = this.rules.get(nameOrSelector);
        if (!oldRule) return this.addRule(nameOrSelector, decl, options);
        var newRule = this.rules.replace(nameOrSelector, decl, options);
        if (newRule) this.options.jss.plugins.onProcessRule(newRule);
        if (this.attached) {
            if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.
            // It will be inserted all together when .attach is called.
            if (this.renderer) {
                if (!newRule) this.renderer.deleteRule(oldRule);
                else if (oldRule.renderable) this.renderer.replaceRule(oldRule.renderable, newRule);
            }
            return newRule;
        } // We can't replace rules to a detached style node.
        // We will redeploy the sheet once user will attach it.
        this.deployed = false;
        return newRule;
    } /**
   * Insert rule into the StyleSheet
   */ ;
    _proto.insertRule = function insertRule(rule) {
        if (this.renderer) this.renderer.insertRule(rule);
    } /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */ ;
    _proto.addRules = function addRules(styles, options) {
        var added = [];
        for(var name in styles){
            var rule = this.addRule(name, styles[name], options);
            if (rule) added.push(rule);
        }
        return added;
    } /**
   * Get a rule by name or selector.
   */ ;
    _proto.getRule = function getRule(nameOrSelector) {
        return this.rules.get(nameOrSelector);
    } /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */ ;
    _proto.deleteRule = function deleteRule(name) {
        var rule = typeof name === "object" ? name : this.rules.get(name);
        if (!rule || // Style sheet was created without link: true and attached, in this case we
        // won't be able to remove the CSS rule from the DOM.
        this.attached && !rule.renderable) return false;
        this.rules.remove(rule);
        if (this.attached && rule.renderable && this.renderer) return this.renderer.deleteRule(rule.renderable);
        return true;
    } /**
   * Get index of a rule.
   */ ;
    _proto.indexOf = function indexOf(rule) {
        return this.rules.indexOf(rule);
    } /**
   * Deploy pure CSS string to a renderable.
   */ ;
    _proto.deploy = function deploy() {
        if (this.renderer) this.renderer.deploy();
        this.deployed = true;
        return this;
    } /**
   * Update the function values with a new data.
   */ ;
    _proto.update = function update() {
        var _this$rules;
        (_this$rules = this.rules).update.apply(_this$rules, arguments);
        return this;
    } /**
   * Updates a single rule.
   */ ;
    _proto.updateOne = function updateOne(rule, data, options) {
        this.rules.updateOne(rule, data, options);
        return this;
    } /**
   * Convert rules to a CSS string.
   */ ;
    _proto.toString = function toString(options) {
        return this.rules.toString(options);
    };
    return StyleSheet;
}();
var $a29a1e3a9ac4286d$var$PluginsRegistry = /*#__PURE__*/ function() {
    function PluginsRegistry() {
        this.plugins = {
            internal: [],
            external: []
        };
        this.registry = {};
    }
    var _proto = PluginsRegistry.prototype;
    /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */ _proto.onCreateRule = function onCreateRule(name, decl, options) {
        for(var i = 0; i < this.registry.onCreateRule.length; i++){
            var rule = this.registry.onCreateRule[i](name, decl, options);
            if (rule) return rule;
        }
        return null;
    } /**
   * Call `onProcessRule` hooks.
   */ ;
    _proto.onProcessRule = function onProcessRule(rule) {
        if (rule.isProcessed) return;
        var sheet = rule.options.sheet;
        for(var i = 0; i < this.registry.onProcessRule.length; i++)this.registry.onProcessRule[i](rule, sheet);
        if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
        rule.isProcessed = true;
    } /**
   * Call `onProcessStyle` hooks.
   */ ;
    _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
        for(var i = 0; i < this.registry.onProcessStyle.length; i++)rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    } /**
   * Call `onProcessSheet` hooks.
   */ ;
    _proto.onProcessSheet = function onProcessSheet(sheet) {
        for(var i = 0; i < this.registry.onProcessSheet.length; i++)this.registry.onProcessSheet[i](sheet);
    } /**
   * Call `onUpdate` hooks.
   */ ;
    _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
        for(var i = 0; i < this.registry.onUpdate.length; i++)this.registry.onUpdate[i](data, rule, sheet, options);
    } /**
   * Call `onChangeValue` hooks.
   */ ;
    _proto.onChangeValue = function onChangeValue(value, prop, rule) {
        var processedValue = value;
        for(var i = 0; i < this.registry.onChangeValue.length; i++)processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
        return processedValue;
    } /**
   * Register a plugin.
   */ ;
    _proto.use = function use(newPlugin, options) {
        if (options === void 0) options = {
            queue: "external"
        };
        var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.
        if (plugins.indexOf(newPlugin) !== -1) return;
        plugins.push(newPlugin);
        this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(registry, plugin) {
            for(var name in plugin)if (name in registry) registry[name].push(plugin[name]);
            return registry;
        }, {
            onCreateRule: [],
            onProcessRule: [],
            onProcessStyle: [],
            onProcessSheet: [],
            onChangeValue: [],
            onUpdate: []
        });
    };
    return PluginsRegistry;
}();
/**
 * Sheets registry to access all instances in one place.
 */ var $a29a1e3a9ac4286d$export$bcb2f1d96ff51db3 = /*#__PURE__*/ function() {
    function SheetsRegistry() {
        this.registry = [];
    }
    var _proto = SheetsRegistry.prototype;
    /**
   * Register a Style Sheet.
   */ _proto.add = function add(sheet) {
        var registry = this.registry;
        var index = sheet.options.index;
        if (registry.indexOf(sheet) !== -1) return;
        if (registry.length === 0 || index >= this.index) {
            registry.push(sheet);
            return;
        } // Find a position.
        for(var i = 0; i < registry.length; i++)if (registry[i].options.index > index) {
            registry.splice(i, 0, sheet);
            return;
        }
    } /**
   * Reset the registry.
   */ ;
    _proto.reset = function reset() {
        this.registry = [];
    } /**
   * Remove a Style Sheet.
   */ ;
    _proto.remove = function remove(sheet) {
        var index = this.registry.indexOf(sheet);
        this.registry.splice(index, 1);
    } /**
   * Convert all attached sheets to a CSS string.
   */ ;
    _proto.toString = function toString(_temp) {
        var _ref = _temp === void 0 ? {} : _temp, attached = _ref.attached, options = (0, $9Zx8w.default)(_ref, [
            "attached"
        ]);
        var _getWhitespaceSymbols = $a29a1e3a9ac4286d$var$getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;
        var css = "";
        for(var i = 0; i < this.registry.length; i++){
            var sheet = this.registry[i];
            if (attached != null && sheet.attached !== attached) continue;
            if (css) css += linebreak;
            css += sheet.toString(options);
        }
        return css;
    };
    (0, $67Du8.default)(SheetsRegistry, [
        {
            key: "index",
            /**
     * Current highest index number.
     */ get: function get() {
                return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
            }
        }
    ]);
    return SheetsRegistry;
}();
/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */ var $a29a1e3a9ac4286d$export$d1f2fc3a3d47c5af = new $a29a1e3a9ac4286d$export$bcb2f1d96ff51db3();
/* eslint-disable */ /**
 * Now that `globalThis` is available on most platforms
 * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)
 * we check for `globalThis` first. `globalThis` is necessary for jss
 * to run in Agoric's secure version of JavaScript (SES). Under SES,
 * `globalThis` exists, but `window`, `self`, and `Function('return
 * this')()` are all undefined for security reasons.
 *
 * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 */ var $a29a1e3a9ac4286d$var$globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" && window.Math === Math ? window : typeof self !== "undefined" && self.Math === Math ? self : Function("return this")();
var $a29a1e3a9ac4286d$var$ns = "2f1acc6c3a606b082e5eef5e54414ffb";
if ($a29a1e3a9ac4286d$var$globalThis$1[$a29a1e3a9ac4286d$var$ns] == null) $a29a1e3a9ac4286d$var$globalThis$1[$a29a1e3a9ac4286d$var$ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.
var $a29a1e3a9ac4286d$var$moduleId = $a29a1e3a9ac4286d$var$globalThis$1[$a29a1e3a9ac4286d$var$ns]++;
var $a29a1e3a9ac4286d$var$maxRules = 1e10;
/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */ var $a29a1e3a9ac4286d$export$ddff9cce7c732c82 = function createGenerateId(options) {
    if (options === void 0) options = {};
    var ruleCounter = 0;
    var generateId = function generateId(rule, sheet) {
        ruleCounter += 1;
        var jssId = "";
        var prefix = "";
        if (sheet) {
            if (sheet.options.classNamePrefix) prefix = sheet.options.classNamePrefix;
            if (sheet.options.jss.id != null) jssId = String(sheet.options.jss.id);
        }
        if (options.minify) // Using "c" because a number can't be the first char in a class name.
        return "" + (prefix || "c") + $a29a1e3a9ac4286d$var$moduleId + jssId + ruleCounter;
        return prefix + rule.key + "-" + $a29a1e3a9ac4286d$var$moduleId + (jssId ? "-" + jssId : "") + "-" + ruleCounter;
    };
    return generateId;
};
/**
 * Cache the value from the first time a function is called.
 */ var $a29a1e3a9ac4286d$var$memoize = function memoize(fn) {
    var value;
    return function() {
        if (!value) value = fn();
        return value;
    };
};
/**
 * Get a style property value.
 */ var $a29a1e3a9ac4286d$var$getPropertyValue = function getPropertyValue(cssRule, prop) {
    try {
        // Support CSSTOM.
        if (cssRule.attributeStyleMap) return cssRule.attributeStyleMap.get(prop);
        return cssRule.style.getPropertyValue(prop);
    } catch (err) {
        // IE may throw if property is unknown.
        return "";
    }
};
/**
 * Set a style property.
 */ var $a29a1e3a9ac4286d$var$setProperty = function setProperty(cssRule, prop, value) {
    try {
        var cssValue = value;
        if (Array.isArray(value)) cssValue = $a29a1e3a9ac4286d$export$5ac341d5e3cf9273(value);
         // Support CSSTOM.
        if (cssRule.attributeStyleMap) cssRule.attributeStyleMap.set(prop, cssValue);
        else {
            var indexOfImportantFlag = cssValue ? cssValue.indexOf("!important") : -1;
            var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;
            cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? "important" : "");
        }
    } catch (err) {
        // IE may throw if property is unknown.
        return false;
    }
    return true;
};
/**
 * Remove a style property.
 */ var $a29a1e3a9ac4286d$var$removeProperty = function removeProperty(cssRule, prop) {
    try {
        // Support CSSTOM.
        if (cssRule.attributeStyleMap) cssRule.attributeStyleMap.delete(prop);
        else cssRule.style.removeProperty(prop);
    } catch (err) {}
};
/**
 * Set the selector.
 */ var $a29a1e3a9ac4286d$var$setSelector = function setSelector(cssRule, selectorText) {
    cssRule.selectorText = selectorText; // Return false if setter was not successful.
    // Currently works in chrome only.
    return cssRule.selectorText === selectorText;
};
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */ var $a29a1e3a9ac4286d$var$getHead = $a29a1e3a9ac4286d$var$memoize(function() {
    return document.querySelector("head");
});
/**
 * Find attached sheet with an index higher than the passed one.
 */ function $a29a1e3a9ac4286d$var$findHigherSheet(registry, options) {
    for(var i = 0; i < registry.length; i++){
        var sheet = registry[i];
        if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) return sheet;
    }
    return null;
}
/**
 * Find attached sheet with the highest index.
 */ function $a29a1e3a9ac4286d$var$findHighestSheet(registry, options) {
    for(var i = registry.length - 1; i >= 0; i--){
        var sheet = registry[i];
        if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) return sheet;
    }
    return null;
}
/**
 * Find a comment with "jss" inside.
 */ function $a29a1e3a9ac4286d$var$findCommentNode(text) {
    var head = $a29a1e3a9ac4286d$var$getHead();
    for(var i = 0; i < head.childNodes.length; i++){
        var node = head.childNodes[i];
        if (node.nodeType === 8 && node.nodeValue.trim() === text) return node;
    }
    return null;
}
/**
 * Find a node before which we can insert the sheet.
 */ function $a29a1e3a9ac4286d$var$findPrevNode(options) {
    var registry = $a29a1e3a9ac4286d$export$d1f2fc3a3d47c5af.registry;
    if (registry.length > 0) {
        // Try to insert before the next higher sheet.
        var sheet = $a29a1e3a9ac4286d$var$findHigherSheet(registry, options);
        if (sheet && sheet.renderer) return {
            parent: sheet.renderer.element.parentNode,
            node: sheet.renderer.element
        };
         // Otherwise insert after the last attached.
        sheet = $a29a1e3a9ac4286d$var$findHighestSheet(registry, options);
        if (sheet && sheet.renderer) return {
            parent: sheet.renderer.element.parentNode,
            node: sheet.renderer.element.nextSibling
        };
    } // Try to find a comment placeholder if registry is empty.
    var insertionPoint = options.insertionPoint;
    if (insertionPoint && typeof insertionPoint === "string") {
        var comment = $a29a1e3a9ac4286d$var$findCommentNode(insertionPoint);
        if (comment) return {
            parent: comment.parentNode,
            node: comment.nextSibling
        };
         // If user specifies an insertion point and it can't be found in the document -
    }
    return false;
}
/**
 * Insert style element into the DOM.
 */ function $a29a1e3a9ac4286d$var$insertStyle(style, options) {
    var insertionPoint = options.insertionPoint;
    var nextNode = $a29a1e3a9ac4286d$var$findPrevNode(options);
    if (nextNode !== false && nextNode.parent) {
        nextNode.parent.insertBefore(style, nextNode.node);
        return;
    } // Works with iframes and any node types.
    if (insertionPoint && typeof insertionPoint.nodeType === "number") {
        var insertionPointElement = insertionPoint;
        var parentNode = insertionPointElement.parentNode;
        if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);
        return;
    }
    $a29a1e3a9ac4286d$var$getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */ var $a29a1e3a9ac4286d$var$getNonce = $a29a1e3a9ac4286d$var$memoize(function() {
    var node = document.querySelector('meta[property="csp-nonce"]');
    return node ? node.getAttribute("content") : null;
});
var $a29a1e3a9ac4286d$var$_insertRule = function insertRule(container, rule, index) {
    try {
        if ("insertRule" in container) container.insertRule(rule, index);
        else if ("appendRule" in container) container.appendRule(rule);
    } catch (err) {
        return false;
    }
    return container.cssRules[index];
};
var $a29a1e3a9ac4286d$var$getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {
    var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong
    if (index === undefined || index > maxIndex) // eslint-disable-next-line no-param-reassign
    return maxIndex;
    return index;
};
var $a29a1e3a9ac4286d$var$createStyle = function createStyle() {
    var el = document.createElement("style"); // Without it, IE will have a broken source order specificity if we
    // insert rules after we insert the style tag.
    // It seems to kick-off the source order specificity algorithm.
    el.textContent = "\n";
    return el;
};
var $a29a1e3a9ac4286d$var$DomRenderer = /*#__PURE__*/ function() {
    // Will be empty if link: true option is not set, because
    // it is only for use together with insertRule API.
    function DomRenderer(sheet) {
        this.getPropertyValue = $a29a1e3a9ac4286d$var$getPropertyValue;
        this.setProperty = $a29a1e3a9ac4286d$var$setProperty;
        this.removeProperty = $a29a1e3a9ac4286d$var$removeProperty;
        this.setSelector = $a29a1e3a9ac4286d$var$setSelector;
        this.hasInsertedRules = false;
        this.cssRules = [];
        // There is no sheet when the renderer is used from a standalone StyleRule.
        if (sheet) $a29a1e3a9ac4286d$export$d1f2fc3a3d47c5af.add(sheet);
        this.sheet = sheet;
        var _ref = this.sheet ? this.sheet.options : {}, media = _ref.media, meta = _ref.meta, element = _ref.element;
        this.element = element || $a29a1e3a9ac4286d$var$createStyle();
        this.element.setAttribute("data-jss", "");
        if (media) this.element.setAttribute("media", media);
        if (meta) this.element.setAttribute("data-meta", meta);
        var nonce = $a29a1e3a9ac4286d$var$getNonce();
        if (nonce) this.element.setAttribute("nonce", nonce);
    }
    /**
   * Insert style element into render tree.
   */ var _proto = DomRenderer.prototype;
    _proto.attach = function attach() {
        // In the case the element node is external and it is already in the DOM.
        if (this.element.parentNode || !this.sheet) return;
        $a29a1e3a9ac4286d$var$insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
        // most browsers create a new CSSStyleSheet, except of all IEs.
        var deployed = Boolean(this.sheet && this.sheet.deployed);
        if (this.hasInsertedRules && deployed) {
            this.hasInsertedRules = false;
            this.deploy();
        }
    } /**
   * Remove style element from render tree.
   */ ;
    _proto.detach = function detach() {
        if (!this.sheet) return;
        var parentNode = this.element.parentNode;
        if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.
        // Though IE will keep them and we need a consistent behavior.
        if (this.sheet.options.link) {
            this.cssRules = [];
            this.element.textContent = "\n";
        }
    } /**
   * Inject CSS string into element.
   */ ;
    _proto.deploy = function deploy() {
        var sheet = this.sheet;
        if (!sheet) return;
        if (sheet.options.link) {
            this.insertRules(sheet.rules);
            return;
        }
        this.element.textContent = "\n" + sheet.toString() + "\n";
    } /**
   * Insert RuleList into an element.
   */ ;
    _proto.insertRules = function insertRules(rules, nativeParent) {
        for(var i = 0; i < rules.index.length; i++)this.insertRule(rules.index[i], i, nativeParent);
    } /**
   * Insert a rule into element.
   */ ;
    _proto.insertRule = function insertRule(rule, index, nativeParent) {
        if (nativeParent === void 0) nativeParent = this.element.sheet;
        if (rule.rules) {
            var parent = rule;
            var latestNativeParent = nativeParent;
            if (rule.type === "conditional" || rule.type === "keyframes") {
                var _insertionIndex = $a29a1e3a9ac4286d$var$getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.
                latestNativeParent = $a29a1e3a9ac4286d$var$_insertRule(nativeParent, parent.toString({
                    children: false
                }), _insertionIndex);
                if (latestNativeParent === false) return false;
                this.refCssRule(rule, _insertionIndex, latestNativeParent);
            }
            this.insertRules(parent.rules, latestNativeParent);
            return latestNativeParent;
        }
        var ruleStr = rule.toString();
        if (!ruleStr) return false;
        var insertionIndex = $a29a1e3a9ac4286d$var$getValidRuleInsertionIndex(nativeParent, index);
        var nativeRule = $a29a1e3a9ac4286d$var$_insertRule(nativeParent, ruleStr, insertionIndex);
        if (nativeRule === false) return false;
        this.hasInsertedRules = true;
        this.refCssRule(rule, insertionIndex, nativeRule);
        return nativeRule;
    };
    _proto.refCssRule = function refCssRule(rule, index, cssRule) {
        rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules
        // like rules inside media queries or keyframes
        if (rule.options.parent instanceof $a29a1e3a9ac4286d$var$StyleSheet) this.cssRules.splice(index, 0, cssRule);
    } /**
   * Delete a rule.
   */ ;
    _proto.deleteRule = function deleteRule(cssRule) {
        var sheet = this.element.sheet;
        var index = this.indexOf(cssRule);
        if (index === -1) return false;
        sheet.deleteRule(index);
        this.cssRules.splice(index, 1);
        return true;
    } /**
   * Get index of a CSS Rule.
   */ ;
    _proto.indexOf = function indexOf(cssRule) {
        return this.cssRules.indexOf(cssRule);
    } /**
   * Generate a new CSS rule and replace the existing one.
   */ ;
    _proto.replaceRule = function replaceRule(cssRule, rule) {
        var index = this.indexOf(cssRule);
        if (index === -1) return false;
        this.element.sheet.deleteRule(index);
        this.cssRules.splice(index, 1);
        return this.insertRule(rule, index);
    } /**
   * Get all rules elements.
   */ ;
    _proto.getRules = function getRules() {
        return this.element.sheet.cssRules;
    };
    return DomRenderer;
}();
var $a29a1e3a9ac4286d$var$instanceCounter = 0;
var $a29a1e3a9ac4286d$var$Jss = /*#__PURE__*/ function() {
    function Jss(options) {
        this.id = $a29a1e3a9ac4286d$var$instanceCounter++;
        this.version = "10.10.0";
        this.plugins = new $a29a1e3a9ac4286d$var$PluginsRegistry();
        this.options = {
            id: {
                minify: false
            },
            createGenerateId: $a29a1e3a9ac4286d$export$ddff9cce7c732c82,
            Renderer: (0, $7nD0Z.default) ? $a29a1e3a9ac4286d$var$DomRenderer : null,
            plugins: []
        };
        this.generateId = $a29a1e3a9ac4286d$export$ddff9cce7c732c82({
            minify: false
        });
        for(var i = 0; i < $a29a1e3a9ac4286d$var$plugins.length; i++)this.plugins.use($a29a1e3a9ac4286d$var$plugins[i], {
            queue: "internal"
        });
        this.setup(options);
    }
    /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */ var _proto = Jss.prototype;
    _proto.setup = function setup(options) {
        if (options === void 0) options = {};
        if (options.createGenerateId) this.options.createGenerateId = options.createGenerateId;
        if (options.id) this.options.id = (0, $29rXr.default)({}, this.options.id, options.id);
        if (options.createGenerateId || options.id) this.generateId = this.options.createGenerateId(this.options.id);
        if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;
        if ("Renderer" in options) this.options.Renderer = options.Renderer;
         // eslint-disable-next-line prefer-spread
        if (options.plugins) this.use.apply(this, options.plugins);
        return this;
    } /**
   * Create a Style Sheet.
   */ ;
    _proto.createStyleSheet = function createStyleSheet(styles, options) {
        if (options === void 0) options = {};
        var _options = options, index = _options.index;
        if (typeof index !== "number") index = $a29a1e3a9ac4286d$export$d1f2fc3a3d47c5af.index === 0 ? 0 : $a29a1e3a9ac4286d$export$d1f2fc3a3d47c5af.index + 1;
        var sheet = new $a29a1e3a9ac4286d$var$StyleSheet(styles, (0, $29rXr.default)({}, options, {
            jss: this,
            generateId: options.generateId || this.generateId,
            insertionPoint: this.options.insertionPoint,
            Renderer: this.options.Renderer,
            index: index
        }));
        this.plugins.onProcessSheet(sheet);
        return sheet;
    } /**
   * Detach the Style Sheet and remove it from the registry.
   */ ;
    _proto.removeStyleSheet = function removeStyleSheet(sheet) {
        sheet.detach();
        $a29a1e3a9ac4286d$export$d1f2fc3a3d47c5af.remove(sheet);
        return this;
    } /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */ ;
    _proto.createRule = function createRule$1(name, style, options) {
        if (style === void 0) style = {};
        if (options === void 0) options = {};
        // Enable rule without name for inline styles.
        if (typeof name === "object") return this.createRule(undefined, name, style);
        var ruleOptions = (0, $29rXr.default)({}, options, {
            name: name,
            jss: this,
            Renderer: this.options.Renderer
        });
        if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
        if (!ruleOptions.classes) ruleOptions.classes = {};
        if (!ruleOptions.keyframes) ruleOptions.keyframes = {};
        var rule = $a29a1e3a9ac4286d$export$56e87122f905fac0(name, style, ruleOptions);
        if (rule) this.plugins.onProcessRule(rule);
        return rule;
    } /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */ ;
    _proto.use = function use() {
        var _this = this;
        for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++)plugins[_key] = arguments[_key];
        plugins.forEach(function(plugin) {
            _this.plugins.use(plugin);
        });
        return this;
    };
    return Jss;
}();
var $a29a1e3a9ac4286d$export$185802fd694ee1f5 = function createJss(options) {
    return new $a29a1e3a9ac4286d$var$Jss(options);
};
/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 * Used in react-jss.
 */ var $a29a1e3a9ac4286d$export$c72bb5031d779271 = /*#__PURE__*/ function() {
    function SheetsManager() {
        this.length = 0;
        this.sheets = new WeakMap();
    }
    var _proto = SheetsManager.prototype;
    _proto.get = function get(key) {
        var entry = this.sheets.get(key);
        return entry && entry.sheet;
    };
    _proto.add = function add(key, sheet) {
        if (this.sheets.has(key)) return;
        this.length++;
        this.sheets.set(key, {
            sheet: sheet,
            refs: 0
        });
    };
    _proto.manage = function manage(key) {
        var entry = this.sheets.get(key);
        if (entry) {
            if (entry.refs === 0) entry.sheet.attach();
            entry.refs++;
            return entry.sheet;
        }
        (0, $iDATp.default)(false, "[JSS] SheetsManager: can't find sheet to manage");
        return undefined;
    };
    _proto.unmanage = function unmanage(key) {
        var entry = this.sheets.get(key);
        if (entry) {
            if (entry.refs > 0) {
                entry.refs--;
                if (entry.refs === 0) entry.sheet.detach();
            }
        } else (0, $iDATp.default)(false, "SheetsManager: can't find sheet to unmanage");
    };
    (0, $67Du8.default)(SheetsManager, [
        {
            key: "size",
            get: function get() {
                return this.length;
            }
        }
    ]);
    return SheetsManager;
}();
/**
* Export a constant indicating if this browser has CSSTOM support.
* https://developers.google.com/web/updates/2018/03/cssom
*/ var $a29a1e3a9ac4286d$export$2305122a7d881dec = typeof CSS === "object" && CSS != null && "number" in CSS;
/**
 * Extracts a styles object with only props that contain function values.
 */ function $a29a1e3a9ac4286d$export$8558f2aefa046992(styles) {
    var to = null;
    for(var key in styles){
        var value = styles[key];
        var type = typeof value;
        if (type === "function") {
            if (!to) to = {};
            to[key] = value;
        } else if (type === "object" && value !== null && !Array.isArray(value)) {
            var extracted = $a29a1e3a9ac4286d$export$8558f2aefa046992(value);
            if (extracted) {
                if (!to) to = {};
                to[key] = extracted;
            }
        }
    }
    return to;
}
/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */ var $a29a1e3a9ac4286d$var$index = $a29a1e3a9ac4286d$export$185802fd694ee1f5();
var $a29a1e3a9ac4286d$export$2e2bcd8739ae039 = $a29a1e3a9ac4286d$var$index;

});
parcelRequire.register("7nD0Z", function(module, exports) {

$parcel$export(module.exports, "default", () => $55f8f1eb767a7a0a$export$2e2bcd8739ae039);
var $55f8f1eb767a7a0a$var$_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var $55f8f1eb767a7a0a$export$4e09c449d6c407f7 = (typeof window === "undefined" ? "undefined" : $55f8f1eb767a7a0a$var$_typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : $55f8f1eb767a7a0a$var$_typeof(document)) === "object" && document.nodeType === 9;
var $55f8f1eb767a7a0a$export$2e2bcd8739ae039 = $55f8f1eb767a7a0a$export$4e09c449d6c407f7;

});

parcelRequire.register("iDATp", function(module, exports) {

$parcel$export(module.exports, "default", () => $d9187c9ca8f6e28c$export$2e2bcd8739ae039);
var $d9187c9ca8f6e28c$var$isProduction = true;
function $d9187c9ca8f6e28c$var$warning(condition, message) {
    if (!$d9187c9ca8f6e28c$var$isProduction) {
        if (condition) return;
        var text = "Warning: " + message;
        if (typeof console !== "undefined") console.warn(text);
        try {
            throw Error(text);
        } catch (x) {}
    }
}
var $d9187c9ca8f6e28c$export$2e2bcd8739ae039 = $d9187c9ca8f6e28c$var$warning;

});

parcelRequire.register("67Du8", function(module, exports) {

$parcel$export(module.exports, "default", () => $4752066b3dd2e8c3$export$2e2bcd8739ae039);

var $ebtpK = parcelRequire("ebtpK");
function $4752066b3dd2e8c3$var$_defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, (0, $ebtpK.default)(descriptor.key), descriptor);
    }
}
function $4752066b3dd2e8c3$export$2e2bcd8739ae039(Constructor, protoProps, staticProps) {
    if (protoProps) $4752066b3dd2e8c3$var$_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) $4752066b3dd2e8c3$var$_defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}

});
parcelRequire.register("ebtpK", function(module, exports) {

$parcel$export(module.exports, "default", () => $a538e8d8b0aca776$export$2e2bcd8739ae039);

var $gwz1k = parcelRequire("gwz1k");

var $hs08k = parcelRequire("hs08k");
function $a538e8d8b0aca776$export$2e2bcd8739ae039(arg) {
    var key = (0, $hs08k.default)(arg, "string");
    return (0, $gwz1k.default)(key) === "symbol" ? key : String(key);
}

});
parcelRequire.register("gwz1k", function(module, exports) {

$parcel$export(module.exports, "default", () => $c07accda4266ea38$export$2e2bcd8739ae039);
function $c07accda4266ea38$export$2e2bcd8739ae039(obj) {
    "@babel/helpers - typeof";
    return $c07accda4266ea38$export$2e2bcd8739ae039 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, $c07accda4266ea38$export$2e2bcd8739ae039(obj);
}

});

parcelRequire.register("hs08k", function(module, exports) {

$parcel$export(module.exports, "default", () => $cb4527a8c83d63e8$export$2e2bcd8739ae039);

var $gwz1k = parcelRequire("gwz1k");
function $cb4527a8c83d63e8$export$2e2bcd8739ae039(input, hint) {
    if ((0, $gwz1k.default)(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if ((0, $gwz1k.default)(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}

});



parcelRequire.register("fiJE0", function(module, exports) {

$parcel$export(module.exports, "default", () => $b23bf179b32f510c$export$2e2bcd8739ae039);

var $88mgw = parcelRequire("88mgw");
function $b23bf179b32f510c$export$2e2bcd8739ae039(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    (0, $88mgw.default)(subClass, superClass);
}

});
parcelRequire.register("88mgw", function(module, exports) {

$parcel$export(module.exports, "default", () => $5ec05790c66d983c$export$2e2bcd8739ae039);
function $5ec05790c66d983c$export$2e2bcd8739ae039(o, p) {
    $5ec05790c66d983c$export$2e2bcd8739ae039 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return $5ec05790c66d983c$export$2e2bcd8739ae039(o, p);
}

});


parcelRequire.register("bPInb", function(module, exports) {

$parcel$export(module.exports, "default", () => $89d6e0a9c011c784$export$2e2bcd8739ae039);
function $89d6e0a9c011c784$export$2e2bcd8739ae039(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}

});


parcelRequire.register("heuOI", function(module, exports) {

$parcel$export(module.exports, "default", () => $c8bba61031421442$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

function $c8bba61031421442$export$2e2bcd8739ae039() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var baseClasses = options.baseClasses, newClasses = options.newClasses, Component = options.Component;
    if (!newClasses) return baseClasses;
    var nextClasses = (0, $29rXr.default)({}, baseClasses);
    Object.keys(newClasses).forEach(function(key) {
        if (newClasses[key]) nextClasses[key] = "".concat(baseClasses[key], " ").concat(newClasses[key]);
    });
    return nextClasses;
}

});

parcelRequire.register("jmddd", function(module, exports) {

$parcel$export(module.exports, "default", () => $e17a520771113462$export$2e2bcd8739ae039);
// Used https://github.com/thinkloop/multi-key-cache as inspiration
var $e17a520771113462$var$multiKeyStore = {
    set: function set(cache, key1, key2, value) {
        var subCache = cache.get(key1);
        if (!subCache) {
            subCache = new Map();
            cache.set(key1, subCache);
        }
        subCache.set(key2, value);
    },
    get: function get(cache, key1, key2) {
        var subCache = cache.get(key1);
        return subCache ? subCache.get(key2) : undefined;
    },
    delete: function _delete(cache, key1, key2) {
        var subCache = cache.get(key1);
        subCache.delete(key2);
    }
};
var $e17a520771113462$export$2e2bcd8739ae039 = $e17a520771113462$var$multiKeyStore;

});

parcelRequire.register("3f5nj", function(module, exports) {

$parcel$export(module.exports, "default", () => $25c6f1283036ee40$export$2e2bcd8739ae039);

var $aaLBe = parcelRequire("aaLBe");

var $byRp6 = parcelRequire("byRp6");
function $25c6f1283036ee40$export$2e2bcd8739ae039() {
    var theme = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useContext((0, $byRp6.default));
    return theme;
}

});
parcelRequire.register("byRp6", function(module, exports) {

$parcel$export(module.exports, "default", () => $86ac4b94d4baf5a4$export$2e2bcd8739ae039);

var $aaLBe = parcelRequire("aaLBe");
var $86ac4b94d4baf5a4$var$ThemeContext = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createContext(null);
var $86ac4b94d4baf5a4$export$2e2bcd8739ae039 = $86ac4b94d4baf5a4$var$ThemeContext;

});


parcelRequire.register("6552k", function(module, exports) {

$parcel$export(module.exports, "StylesContext", () => $46d71dd96b8b2c6c$export$f4de434b269fe487);

var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");



var $hSXdt = parcelRequire("hSXdt");

var $dXwEQ = parcelRequire("dXwEQ");

var $8PkQN = parcelRequire("8PkQN");
var $46d71dd96b8b2c6c$var$jss = (0, $dXwEQ.create)((0, $8PkQN.default)()); // Use a singleton or the provided one by the context.
//
// The counter-based approach doesn't tolerate any mistake.
// It's much safer to use the same counter everywhere.
var $46d71dd96b8b2c6c$var$generateClassName = (0, $hSXdt.default)(); // Exported for test purposes
var $46d71dd96b8b2c6c$export$70a8aea9ff58d1cd = new Map();
var $46d71dd96b8b2c6c$var$defaultOptions = {
    disableGeneration: false,
    generateClassName: $46d71dd96b8b2c6c$var$generateClassName,
    jss: $46d71dd96b8b2c6c$var$jss,
    sheetsCache: null,
    sheetsManager: $46d71dd96b8b2c6c$export$70a8aea9ff58d1cd,
    sheetsRegistry: null
};
var $46d71dd96b8b2c6c$export$f4de434b269fe487 = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createContext($46d71dd96b8b2c6c$var$defaultOptions);
var $46d71dd96b8b2c6c$var$injectFirstNode;
function $46d71dd96b8b2c6c$export$2e2bcd8739ae039(props) {
    var children = props.children, _props$injectFirst = props.injectFirst, injectFirst = _props$injectFirst === void 0 ? false : _props$injectFirst, _props$disableGenerat = props.disableGeneration, disableGeneration = _props$disableGenerat === void 0 ? false : _props$disableGenerat, localOptions = (0, $kqze3.default)(props, [
        "children",
        "injectFirst",
        "disableGeneration"
    ]);
    var outerOptions = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useContext($46d71dd96b8b2c6c$export$f4de434b269fe487);
    var context = (0, $29rXr.default)({}, outerOptions, {
        disableGeneration: disableGeneration
    }, localOptions);
    if (!context.jss.options.insertionPoint && injectFirst && typeof window !== "undefined") {
        if (!$46d71dd96b8b2c6c$var$injectFirstNode) {
            var head = document.head;
            $46d71dd96b8b2c6c$var$injectFirstNode = document.createComment("mui-inject-first");
            head.insertBefore($46d71dd96b8b2c6c$var$injectFirstNode, head.firstChild);
        }
        context.jss = (0, $dXwEQ.create)({
            plugins: (0, $8PkQN.default)().plugins,
            insertionPoint: $46d71dd96b8b2c6c$var$injectFirstNode
        });
    }
    return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($46d71dd96b8b2c6c$export$f4de434b269fe487.Provider, {
        value: context
    }, children);
}

});
parcelRequire.register("hSXdt", function(module, exports) {

$parcel$export(module.exports, "default", () => $d05569eddd951f54$export$2e2bcd8739ae039);

var $bn8tT = parcelRequire("bn8tT");
/**
 * This is the list of the style rule name we use as drop in replacement for the built-in
 * pseudo classes (:checked, :disabled, :focused, etc.).
 *
 * Why do they exist in the first place?
 * These classes are used at a specificity of 2.
 * It allows them to override previously definied styles as well as
 * being untouched by simple user overrides.
 */ var $d05569eddd951f54$var$pseudoClasses = [
    "checked",
    "disabled",
    "error",
    "focused",
    "focusVisible",
    "required",
    "expanded",
    "selected"
]; // Returns a function which generates unique class names based on counters.
function $d05569eddd951f54$export$2e2bcd8739ae039() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$disableGloba = options.disableGlobal, disableGlobal = _options$disableGloba === void 0 ? false : _options$disableGloba, _options$productionPr = options.productionPrefix, productionPrefix = _options$productionPr === void 0 ? "jss" : _options$productionPr, _options$seed = options.seed, seed = _options$seed === void 0 ? "" : _options$seed;
    var seedPrefix = seed === "" ? "" : "".concat(seed, "-");
    var ruleCounter = 0;
    var getNextCounterId = function getNextCounterId() {
        ruleCounter += 1;
        return ruleCounter;
    };
    return function(rule, styleSheet) {
        var name = styleSheet.options.name; // Is a global static MUI style?
        if (name && name.indexOf("Mui") === 0 && !styleSheet.options.link && !disableGlobal) {
            // We can use a shorthand class name, we never use the keys to style the components.
            if ($d05569eddd951f54$var$pseudoClasses.indexOf(rule.key) !== -1) return "Mui-".concat(rule.key);
            var prefix = "".concat(seedPrefix).concat(name, "-").concat(rule.key);
            if (!styleSheet.options.theme[0, $bn8tT.default] || seed !== "") return prefix;
            return "".concat(prefix, "-").concat(getNextCounterId());
        }
        var suffix;
        return "".concat(seedPrefix).concat(productionPrefix).concat(getNextCounterId());
    };
}

});
parcelRequire.register("bn8tT", function(module, exports) {

$parcel$export(module.exports, "default", () => $84786be49e6c9414$export$2e2bcd8739ae039);
var $84786be49e6c9414$var$hasSymbol = typeof Symbol === "function" && Symbol.for;
var $84786be49e6c9414$export$2e2bcd8739ae039 = $84786be49e6c9414$var$hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";

});


parcelRequire.register("8PkQN", function(module, exports) {

$parcel$export(module.exports, "default", () => $66d342a7671d82f5$export$2e2bcd8739ae039);

var $aoN01 = parcelRequire("aoN01");

var $cymGh = parcelRequire("cymGh");

var $d0leF = parcelRequire("d0leF");

var $gUA2W = parcelRequire("gUA2W");

var $i2JG7 = parcelRequire("i2JG7");

var $ePCbo = parcelRequire("ePCbo");

var $2De41 = parcelRequire("2De41");
function $66d342a7671d82f5$export$2e2bcd8739ae039() {
    return {
        plugins: [
            (0, $aoN01.default)(),
            (0, $cymGh.default)(),
            (0, $d0leF.default)(),
            (0, $gUA2W.default)(),
            (0, $i2JG7.default)(),
            // This way, we can get a performance boost.
            // In the documentation, we are using `autoprefixer` to solve this problem.
            typeof window === "undefined" ? null : (0, $ePCbo.default)(),
            (0, $2De41.default)()
        ]
    };
}

});
parcelRequire.register("aoN01", function(module, exports) {

$parcel$export(module.exports, "default", () => $79222788a1f760c6$export$2e2bcd8739ae039);


var $dXwEQ = parcelRequire("dXwEQ");
var $79222788a1f760c6$var$now = Date.now();
var $79222788a1f760c6$var$fnValuesNs = "fnValues" + $79222788a1f760c6$var$now;
var $79222788a1f760c6$var$fnRuleNs = "fnStyle" + ++$79222788a1f760c6$var$now;
var $79222788a1f760c6$var$functionPlugin = function functionPlugin() {
    return {
        onCreateRule: function onCreateRule(name, decl, options) {
            if (typeof decl !== "function") return null;
            var rule = (0, $dXwEQ.createRule)(name, {}, options);
            rule[$79222788a1f760c6$var$fnRuleNs] = decl;
            return rule;
        },
        onProcessStyle: function onProcessStyle(style, rule) {
            // We need to extract function values from the declaration, so that we can keep core unaware of them.
            // We need to do that only once.
            // We don't need to extract functions on each style update, since this can happen only once.
            // We don't support function values inside of function rules.
            if ($79222788a1f760c6$var$fnValuesNs in rule || $79222788a1f760c6$var$fnRuleNs in rule) return style;
            var fnValues = {};
            for(var prop in style){
                var value = style[prop];
                if (typeof value !== "function") continue;
                delete style[prop];
                fnValues[prop] = value;
            }
            rule[$79222788a1f760c6$var$fnValuesNs] = fnValues;
            return style;
        },
        onUpdate: function onUpdate(data, rule, sheet, options) {
            var styleRule = rule;
            var fnRule = styleRule[$79222788a1f760c6$var$fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
            // will be returned from that function.
            if (fnRule) {
                // Empty object will remove all currently defined props
                // in case function rule returns a falsy value.
                styleRule.style = fnRule(data) || {};
                var prop;
            }
            var fnValues = styleRule[$79222788a1f760c6$var$fnValuesNs]; // If we have a fn values map, it is a rule with function values.
            if (fnValues) for(var _prop in fnValues)styleRule.prop(_prop, fnValues[_prop](data), options);
        }
    };
};
var $79222788a1f760c6$export$2e2bcd8739ae039 = $79222788a1f760c6$var$functionPlugin;

});

parcelRequire.register("cymGh", function(module, exports) {

$parcel$export(module.exports, "default", () => $923a40f9e42820e9$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $dXwEQ = parcelRequire("dXwEQ");
var $923a40f9e42820e9$var$at = "@global";
var $923a40f9e42820e9$var$atPrefix = "@global ";
var $923a40f9e42820e9$var$GlobalContainerRule = /*#__PURE__*/ function() {
    function GlobalContainerRule(key, styles, options) {
        this.type = "global";
        this.at = $923a40f9e42820e9$var$at;
        this.isProcessed = false;
        this.key = key;
        this.options = options;
        this.rules = new (0, $dXwEQ.RuleList)((0, $29rXr.default)({}, options, {
            parent: this
        }));
        for(var selector in styles)this.rules.add(selector, styles[selector]);
        this.rules.process();
    }
    /**
   * Get a rule.
   */ var _proto = GlobalContainerRule.prototype;
    _proto.getRule = function getRule(name) {
        return this.rules.get(name);
    } /**
   * Create and register rule, run plugins.
   */ ;
    _proto.addRule = function addRule(name, style, options) {
        var rule = this.rules.add(name, style, options);
        if (rule) this.options.jss.plugins.onProcessRule(rule);
        return rule;
    } /**
   * Replace rule, run plugins.
   */ ;
    _proto.replaceRule = function replaceRule(name, style, options) {
        var newRule = this.rules.replace(name, style, options);
        if (newRule) this.options.jss.plugins.onProcessRule(newRule);
        return newRule;
    } /**
   * Get index of a rule.
   */ ;
    _proto.indexOf = function indexOf(rule) {
        return this.rules.indexOf(rule);
    } /**
   * Generates a CSS string.
   */ ;
    _proto.toString = function toString(options) {
        return this.rules.toString(options);
    };
    return GlobalContainerRule;
}();
var $923a40f9e42820e9$var$GlobalPrefixedRule = /*#__PURE__*/ function() {
    function GlobalPrefixedRule(key, style, options) {
        this.type = "global";
        this.at = $923a40f9e42820e9$var$at;
        this.isProcessed = false;
        this.key = key;
        this.options = options;
        var selector = key.substr($923a40f9e42820e9$var$atPrefix.length);
        this.rule = options.jss.createRule(selector, style, (0, $29rXr.default)({}, options, {
            parent: this
        }));
    }
    var _proto2 = GlobalPrefixedRule.prototype;
    _proto2.toString = function toString(options) {
        return this.rule ? this.rule.toString(options) : "";
    };
    return GlobalPrefixedRule;
}();
var $923a40f9e42820e9$var$separatorRegExp = /\s*,\s*/g;
function $923a40f9e42820e9$var$addScope(selector, scope) {
    var parts = selector.split($923a40f9e42820e9$var$separatorRegExp);
    var scoped = "";
    for(var i = 0; i < parts.length; i++){
        scoped += scope + " " + parts[i].trim();
        if (parts[i + 1]) scoped += ", ";
    }
    return scoped;
}
function $923a40f9e42820e9$var$handleNestedGlobalContainerRule(rule, sheet) {
    var options = rule.options, style = rule.style;
    var rules = style ? style[$923a40f9e42820e9$var$at] : null;
    if (!rules) return;
    for(var name in rules)sheet.addRule(name, rules[name], (0, $29rXr.default)({}, options, {
        selector: $923a40f9e42820e9$var$addScope(name, rule.selector)
    }));
    delete style[$923a40f9e42820e9$var$at];
}
function $923a40f9e42820e9$var$handlePrefixedGlobalRule(rule, sheet) {
    var options = rule.options, style = rule.style;
    for(var prop in style){
        if (prop[0] !== "@" || prop.substr(0, $923a40f9e42820e9$var$at.length) !== $923a40f9e42820e9$var$at) continue;
        var selector = $923a40f9e42820e9$var$addScope(prop.substr($923a40f9e42820e9$var$at.length), rule.selector);
        sheet.addRule(selector, style[prop], (0, $29rXr.default)({}, options, {
            selector: selector
        }));
        delete style[prop];
    }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 */ function $923a40f9e42820e9$var$jssGlobal() {
    function onCreateRule(name, styles, options) {
        if (!name) return null;
        if (name === $923a40f9e42820e9$var$at) return new $923a40f9e42820e9$var$GlobalContainerRule(name, styles, options);
        if (name[0] === "@" && name.substr(0, $923a40f9e42820e9$var$atPrefix.length) === $923a40f9e42820e9$var$atPrefix) return new $923a40f9e42820e9$var$GlobalPrefixedRule(name, styles, options);
        var parent = options.parent;
        if (parent) {
            if (parent.type === "global" || parent.options.parent && parent.options.parent.type === "global") options.scoped = false;
        }
        if (!options.selector && options.scoped === false) options.selector = name;
        return null;
    }
    function onProcessRule(rule, sheet) {
        if (rule.type !== "style" || !sheet) return;
        $923a40f9e42820e9$var$handleNestedGlobalContainerRule(rule, sheet);
        $923a40f9e42820e9$var$handlePrefixedGlobalRule(rule, sheet);
    }
    return {
        onCreateRule: onCreateRule,
        onProcessRule: onProcessRule
    };
}
var $923a40f9e42820e9$export$2e2bcd8739ae039 = $923a40f9e42820e9$var$jssGlobal;

});

parcelRequire.register("d0leF", function(module, exports) {

$parcel$export(module.exports, "default", () => $977bbf6624488494$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $977bbf6624488494$var$separatorRegExp = /\s*,\s*/g;
var $977bbf6624488494$var$parentRegExp = /&/g;
var $977bbf6624488494$var$refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 */ function $977bbf6624488494$var$jssNested() {
    // Get a function to be used for $ref replacement.
    function getReplaceRef(container, sheet) {
        return function(match, key) {
            var rule = container.getRule(key) || sheet && sheet.getRule(key);
            if (rule) return rule.selector;
            return key;
        };
    }
    function replaceParentRefs(nestedProp, parentProp) {
        var parentSelectors = parentProp.split($977bbf6624488494$var$separatorRegExp);
        var nestedSelectors = nestedProp.split($977bbf6624488494$var$separatorRegExp);
        var result = "";
        for(var i = 0; i < parentSelectors.length; i++){
            var parent = parentSelectors[i];
            for(var j = 0; j < nestedSelectors.length; j++){
                var nested = nestedSelectors[j];
                if (result) result += ", "; // Replace all & by the parent or prefix & with the parent.
                result += nested.indexOf("&") !== -1 ? nested.replace($977bbf6624488494$var$parentRegExp, parent) : parent + " " + nested;
            }
        }
        return result;
    }
    function getOptions(rule, container, prevOptions) {
        // Options has been already created, now we only increase index.
        if (prevOptions) return (0, $29rXr.default)({}, prevOptions, {
            index: prevOptions.index + 1
        });
        var nestingLevel = rule.options.nestingLevel;
        nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;
        var options = (0, $29rXr.default)({}, rule.options, {
            nestingLevel: nestingLevel,
            index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.
        });
        delete options.name;
        return options;
    }
    function onProcessStyle(style, rule, sheet) {
        if (rule.type !== "style") return style;
        var styleRule = rule;
        var container = styleRule.options.parent;
        var options;
        var replaceRef;
        for(var prop in style){
            var isNested = prop.indexOf("&") !== -1;
            var isNestedConditional = prop[0] === "@";
            if (!isNested && !isNestedConditional) continue;
            options = getOptions(styleRule, container, options);
            if (isNested) {
                var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
                // all nested rules within the sheet.
                if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.
                selector = selector.replace($977bbf6624488494$var$refRegExp, replaceRef);
                var name = styleRule.key + "-" + prop;
                if ("replaceRule" in container) // for backward compatibility
                container.replaceRule(name, style[prop], (0, $29rXr.default)({}, options, {
                    selector: selector
                }));
                else container.addRule(name, style[prop], (0, $29rXr.default)({}, options, {
                    selector: selector
                }));
            } else if (isNestedConditional) // Place conditional right after the parent rule to ensure right ordering.
            container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {
                selector: styleRule.selector
            });
            delete style[prop];
        }
        return style;
    }
    return {
        onProcessStyle: onProcessStyle
    };
}
var $977bbf6624488494$export$2e2bcd8739ae039 = $977bbf6624488494$var$jssNested;

});

parcelRequire.register("gUA2W", function(module, exports) {

$parcel$export(module.exports, "default", () => $c4fdd666a12d687c$export$2e2bcd8739ae039);

var $iciNe = parcelRequire("iciNe");
/**
 * Convert camel cased property names to dash separated.
 */ function $c4fdd666a12d687c$var$convertCase(style) {
    var converted = {};
    for(var prop in style){
        var key = prop.indexOf("--") === 0 ? prop : (0, $iciNe.default)(prop);
        converted[key] = style[prop];
    }
    if (style.fallbacks) {
        if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map($c4fdd666a12d687c$var$convertCase);
        else converted.fallbacks = $c4fdd666a12d687c$var$convertCase(style.fallbacks);
    }
    return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 */ function $c4fdd666a12d687c$var$camelCase() {
    function onProcessStyle(style) {
        if (Array.isArray(style)) {
            // Handle rules like @font-face, which can have multiple styles in an array
            for(var index = 0; index < style.length; index++)style[index] = $c4fdd666a12d687c$var$convertCase(style[index]);
            return style;
        }
        return $c4fdd666a12d687c$var$convertCase(style);
    }
    function onChangeValue(value, prop, rule) {
        if (prop.indexOf("--") === 0) return value;
        var hyphenatedProp = (0, $iciNe.default)(prop); // There was no camel case in place
        if (prop === hyphenatedProp) return value;
        rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.
        return null;
    }
    return {
        onProcessStyle: onProcessStyle,
        onChangeValue: onChangeValue
    };
}
var $c4fdd666a12d687c$export$2e2bcd8739ae039 = $c4fdd666a12d687c$var$camelCase;

});
parcelRequire.register("iciNe", function(module, exports) {

$parcel$export(module.exports, "default", () => $d3f7ece98df264d6$export$2e2bcd8739ae039);
/* eslint-disable no-var, prefer-template */ var $d3f7ece98df264d6$var$uppercasePattern = /[A-Z]/g;
var $d3f7ece98df264d6$var$msPattern = /^ms-/;
var $d3f7ece98df264d6$var$cache = {};
function $d3f7ece98df264d6$var$toHyphenLower(match) {
    return "-" + match.toLowerCase();
}
function $d3f7ece98df264d6$var$hyphenateStyleName(name) {
    if ($d3f7ece98df264d6$var$cache.hasOwnProperty(name)) return $d3f7ece98df264d6$var$cache[name];
    var hName = name.replace($d3f7ece98df264d6$var$uppercasePattern, $d3f7ece98df264d6$var$toHyphenLower);
    return $d3f7ece98df264d6$var$cache[name] = $d3f7ece98df264d6$var$msPattern.test(hName) ? "-" + hName : hName;
}
var $d3f7ece98df264d6$export$2e2bcd8739ae039 = $d3f7ece98df264d6$var$hyphenateStyleName;

});


parcelRequire.register("i2JG7", function(module, exports) {

$parcel$export(module.exports, "default", () => $d22bd8ab7f950ca8$export$2e2bcd8739ae039);

var $dXwEQ = parcelRequire("dXwEQ");
var $d22bd8ab7f950ca8$var$px = (0, $dXwEQ.hasCSSTOMSupport) && CSS ? CSS.px : "px";
var $d22bd8ab7f950ca8$var$ms = (0, $dXwEQ.hasCSSTOMSupport) && CSS ? CSS.ms : "ms";
var $d22bd8ab7f950ca8$var$percent = (0, $dXwEQ.hasCSSTOMSupport) && CSS ? CSS.percent : "%";
/**
 * Generated jss-plugin-default-unit CSS property units
 */ var $d22bd8ab7f950ca8$var$defaultUnits = {
    // Animation properties
    "animation-delay": $d22bd8ab7f950ca8$var$ms,
    "animation-duration": $d22bd8ab7f950ca8$var$ms,
    // Background properties
    "background-position": $d22bd8ab7f950ca8$var$px,
    "background-position-x": $d22bd8ab7f950ca8$var$px,
    "background-position-y": $d22bd8ab7f950ca8$var$px,
    "background-size": $d22bd8ab7f950ca8$var$px,
    // Border Properties
    border: $d22bd8ab7f950ca8$var$px,
    "border-bottom": $d22bd8ab7f950ca8$var$px,
    "border-bottom-left-radius": $d22bd8ab7f950ca8$var$px,
    "border-bottom-right-radius": $d22bd8ab7f950ca8$var$px,
    "border-bottom-width": $d22bd8ab7f950ca8$var$px,
    "border-left": $d22bd8ab7f950ca8$var$px,
    "border-left-width": $d22bd8ab7f950ca8$var$px,
    "border-radius": $d22bd8ab7f950ca8$var$px,
    "border-right": $d22bd8ab7f950ca8$var$px,
    "border-right-width": $d22bd8ab7f950ca8$var$px,
    "border-top": $d22bd8ab7f950ca8$var$px,
    "border-top-left-radius": $d22bd8ab7f950ca8$var$px,
    "border-top-right-radius": $d22bd8ab7f950ca8$var$px,
    "border-top-width": $d22bd8ab7f950ca8$var$px,
    "border-width": $d22bd8ab7f950ca8$var$px,
    "border-block": $d22bd8ab7f950ca8$var$px,
    "border-block-end": $d22bd8ab7f950ca8$var$px,
    "border-block-end-width": $d22bd8ab7f950ca8$var$px,
    "border-block-start": $d22bd8ab7f950ca8$var$px,
    "border-block-start-width": $d22bd8ab7f950ca8$var$px,
    "border-block-width": $d22bd8ab7f950ca8$var$px,
    "border-inline": $d22bd8ab7f950ca8$var$px,
    "border-inline-end": $d22bd8ab7f950ca8$var$px,
    "border-inline-end-width": $d22bd8ab7f950ca8$var$px,
    "border-inline-start": $d22bd8ab7f950ca8$var$px,
    "border-inline-start-width": $d22bd8ab7f950ca8$var$px,
    "border-inline-width": $d22bd8ab7f950ca8$var$px,
    "border-start-start-radius": $d22bd8ab7f950ca8$var$px,
    "border-start-end-radius": $d22bd8ab7f950ca8$var$px,
    "border-end-start-radius": $d22bd8ab7f950ca8$var$px,
    "border-end-end-radius": $d22bd8ab7f950ca8$var$px,
    // Margin properties
    margin: $d22bd8ab7f950ca8$var$px,
    "margin-bottom": $d22bd8ab7f950ca8$var$px,
    "margin-left": $d22bd8ab7f950ca8$var$px,
    "margin-right": $d22bd8ab7f950ca8$var$px,
    "margin-top": $d22bd8ab7f950ca8$var$px,
    "margin-block": $d22bd8ab7f950ca8$var$px,
    "margin-block-end": $d22bd8ab7f950ca8$var$px,
    "margin-block-start": $d22bd8ab7f950ca8$var$px,
    "margin-inline": $d22bd8ab7f950ca8$var$px,
    "margin-inline-end": $d22bd8ab7f950ca8$var$px,
    "margin-inline-start": $d22bd8ab7f950ca8$var$px,
    // Padding properties
    padding: $d22bd8ab7f950ca8$var$px,
    "padding-bottom": $d22bd8ab7f950ca8$var$px,
    "padding-left": $d22bd8ab7f950ca8$var$px,
    "padding-right": $d22bd8ab7f950ca8$var$px,
    "padding-top": $d22bd8ab7f950ca8$var$px,
    "padding-block": $d22bd8ab7f950ca8$var$px,
    "padding-block-end": $d22bd8ab7f950ca8$var$px,
    "padding-block-start": $d22bd8ab7f950ca8$var$px,
    "padding-inline": $d22bd8ab7f950ca8$var$px,
    "padding-inline-end": $d22bd8ab7f950ca8$var$px,
    "padding-inline-start": $d22bd8ab7f950ca8$var$px,
    // Mask properties
    "mask-position-x": $d22bd8ab7f950ca8$var$px,
    "mask-position-y": $d22bd8ab7f950ca8$var$px,
    "mask-size": $d22bd8ab7f950ca8$var$px,
    // Width and height properties
    height: $d22bd8ab7f950ca8$var$px,
    width: $d22bd8ab7f950ca8$var$px,
    "min-height": $d22bd8ab7f950ca8$var$px,
    "max-height": $d22bd8ab7f950ca8$var$px,
    "min-width": $d22bd8ab7f950ca8$var$px,
    "max-width": $d22bd8ab7f950ca8$var$px,
    // Position properties
    bottom: $d22bd8ab7f950ca8$var$px,
    left: $d22bd8ab7f950ca8$var$px,
    top: $d22bd8ab7f950ca8$var$px,
    right: $d22bd8ab7f950ca8$var$px,
    inset: $d22bd8ab7f950ca8$var$px,
    "inset-block": $d22bd8ab7f950ca8$var$px,
    "inset-block-end": $d22bd8ab7f950ca8$var$px,
    "inset-block-start": $d22bd8ab7f950ca8$var$px,
    "inset-inline": $d22bd8ab7f950ca8$var$px,
    "inset-inline-end": $d22bd8ab7f950ca8$var$px,
    "inset-inline-start": $d22bd8ab7f950ca8$var$px,
    // Shadow properties
    "box-shadow": $d22bd8ab7f950ca8$var$px,
    "text-shadow": $d22bd8ab7f950ca8$var$px,
    // Column properties
    "column-gap": $d22bd8ab7f950ca8$var$px,
    "column-rule": $d22bd8ab7f950ca8$var$px,
    "column-rule-width": $d22bd8ab7f950ca8$var$px,
    "column-width": $d22bd8ab7f950ca8$var$px,
    // Font and text properties
    "font-size": $d22bd8ab7f950ca8$var$px,
    "font-size-delta": $d22bd8ab7f950ca8$var$px,
    "letter-spacing": $d22bd8ab7f950ca8$var$px,
    "text-decoration-thickness": $d22bd8ab7f950ca8$var$px,
    "text-indent": $d22bd8ab7f950ca8$var$px,
    "text-stroke": $d22bd8ab7f950ca8$var$px,
    "text-stroke-width": $d22bd8ab7f950ca8$var$px,
    "word-spacing": $d22bd8ab7f950ca8$var$px,
    // Motion properties
    motion: $d22bd8ab7f950ca8$var$px,
    "motion-offset": $d22bd8ab7f950ca8$var$px,
    // Outline properties
    outline: $d22bd8ab7f950ca8$var$px,
    "outline-offset": $d22bd8ab7f950ca8$var$px,
    "outline-width": $d22bd8ab7f950ca8$var$px,
    // Perspective properties
    perspective: $d22bd8ab7f950ca8$var$px,
    "perspective-origin-x": $d22bd8ab7f950ca8$var$percent,
    "perspective-origin-y": $d22bd8ab7f950ca8$var$percent,
    // Transform properties
    "transform-origin": $d22bd8ab7f950ca8$var$percent,
    "transform-origin-x": $d22bd8ab7f950ca8$var$percent,
    "transform-origin-y": $d22bd8ab7f950ca8$var$percent,
    "transform-origin-z": $d22bd8ab7f950ca8$var$percent,
    // Transition properties
    "transition-delay": $d22bd8ab7f950ca8$var$ms,
    "transition-duration": $d22bd8ab7f950ca8$var$ms,
    // Alignment properties
    "vertical-align": $d22bd8ab7f950ca8$var$px,
    "flex-basis": $d22bd8ab7f950ca8$var$px,
    // Some random properties
    "shape-margin": $d22bd8ab7f950ca8$var$px,
    size: $d22bd8ab7f950ca8$var$px,
    gap: $d22bd8ab7f950ca8$var$px,
    // Grid properties
    grid: $d22bd8ab7f950ca8$var$px,
    "grid-gap": $d22bd8ab7f950ca8$var$px,
    "row-gap": $d22bd8ab7f950ca8$var$px,
    "grid-row-gap": $d22bd8ab7f950ca8$var$px,
    "grid-column-gap": $d22bd8ab7f950ca8$var$px,
    "grid-template-rows": $d22bd8ab7f950ca8$var$px,
    "grid-template-columns": $d22bd8ab7f950ca8$var$px,
    "grid-auto-rows": $d22bd8ab7f950ca8$var$px,
    "grid-auto-columns": $d22bd8ab7f950ca8$var$px,
    // Not existing properties.
    // Used to avoid issues with jss-plugin-expand integration.
    "box-shadow-x": $d22bd8ab7f950ca8$var$px,
    "box-shadow-y": $d22bd8ab7f950ca8$var$px,
    "box-shadow-blur": $d22bd8ab7f950ca8$var$px,
    "box-shadow-spread": $d22bd8ab7f950ca8$var$px,
    "font-line-height": $d22bd8ab7f950ca8$var$px,
    "text-shadow-x": $d22bd8ab7f950ca8$var$px,
    "text-shadow-y": $d22bd8ab7f950ca8$var$px,
    "text-shadow-blur": $d22bd8ab7f950ca8$var$px
};
/**
 * Clones the object and adds a camel cased property version.
 */ function $d22bd8ab7f950ca8$var$addCamelCasedVersion(obj) {
    var regExp = /(-[a-z])/g;
    var replace = function replace(str) {
        return str[1].toUpperCase();
    };
    var newObj = {};
    for(var key in obj){
        newObj[key] = obj[key];
        newObj[key.replace(regExp, replace)] = obj[key];
    }
    return newObj;
}
var $d22bd8ab7f950ca8$var$units = $d22bd8ab7f950ca8$var$addCamelCasedVersion($d22bd8ab7f950ca8$var$defaultUnits);
/**
 * Recursive deep style passing function
 */ function $d22bd8ab7f950ca8$var$iterate(prop, value, options) {
    if (value == null) return value;
    if (Array.isArray(value)) for(var i = 0; i < value.length; i++)value[i] = $d22bd8ab7f950ca8$var$iterate(prop, value[i], options);
    else if (typeof value === "object") {
        if (prop === "fallbacks") for(var innerProp in value)value[innerProp] = $d22bd8ab7f950ca8$var$iterate(innerProp, value[innerProp], options);
        else for(var _innerProp in value)value[_innerProp] = $d22bd8ab7f950ca8$var$iterate(prop + "-" + _innerProp, value[_innerProp], options);
         // eslint-disable-next-line no-restricted-globals
    } else if (typeof value === "number" && isNaN(value) === false) {
        var unit = options[prop] || $d22bd8ab7f950ca8$var$units[prop]; // Add the unit if available, except for the special case of 0px.
        if (unit && !(value === 0 && unit === $d22bd8ab7f950ca8$var$px)) return typeof unit === "function" ? unit(value).toString() : "" + value + unit;
        return value.toString();
    }
    return value;
}
/**
 * Add unit to numeric values.
 */ function $d22bd8ab7f950ca8$var$defaultUnit(options) {
    if (options === void 0) options = {};
    var camelCasedOptions = $d22bd8ab7f950ca8$var$addCamelCasedVersion(options);
    function onProcessStyle(style, rule) {
        if (rule.type !== "style") return style;
        for(var prop in style)style[prop] = $d22bd8ab7f950ca8$var$iterate(prop, style[prop], camelCasedOptions);
        return style;
    }
    function onChangeValue(value, prop) {
        return $d22bd8ab7f950ca8$var$iterate(prop, value, camelCasedOptions);
    }
    return {
        onProcessStyle: onProcessStyle,
        onChangeValue: onChangeValue
    };
}
var $d22bd8ab7f950ca8$export$2e2bcd8739ae039 = $d22bd8ab7f950ca8$var$defaultUnit;

});

parcelRequire.register("ePCbo", function(module, exports) {

$parcel$export(module.exports, "default", () => $acc3726a9641e998$export$2e2bcd8739ae039);

var $lGZXe = parcelRequire("lGZXe");

var $dXwEQ = parcelRequire("dXwEQ");
/**
 * Add vendor prefix to a property name when needed.
 */ function $acc3726a9641e998$var$jssVendorPrefixer() {
    function onProcessRule(rule) {
        if (rule.type === "keyframes") {
            var atRule = rule;
            atRule.at = (0, $lGZXe.supportedKeyframes)(atRule.at);
        }
    }
    function prefixStyle(style) {
        for(var prop in style){
            var value = style[prop];
            if (prop === "fallbacks" && Array.isArray(value)) {
                style[prop] = value.map(prefixStyle);
                continue;
            }
            var changeProp = false;
            var supportedProp = (0, $lGZXe.supportedProperty)(prop);
            if (supportedProp && supportedProp !== prop) changeProp = true;
            var changeValue = false;
            var supportedValue$1 = (0, $lGZXe.supportedValue)(supportedProp, (0, $dXwEQ.toCssValue)(value));
            if (supportedValue$1 && supportedValue$1 !== value) changeValue = true;
            if (changeProp || changeValue) {
                if (changeProp) delete style[prop];
                style[supportedProp || prop] = supportedValue$1 || value;
            }
        }
        return style;
    }
    function onProcessStyle(style, rule) {
        if (rule.type !== "style") return style;
        return prefixStyle(style);
    }
    function onChangeValue(value, prop) {
        return (0, $lGZXe.supportedValue)(prop, (0, $dXwEQ.toCssValue)(value)) || value;
    }
    return {
        onProcessRule: onProcessRule,
        onProcessStyle: onProcessStyle,
        onChangeValue: onChangeValue
    };
}
var $acc3726a9641e998$export$2e2bcd8739ae039 = $acc3726a9641e998$var$jssVendorPrefixer;

});
parcelRequire.register("lGZXe", function(module, exports) {

$parcel$export(module.exports, "supportedKeyframes", () => $fcad940d66d27a40$export$b6aa0648d950180a);
$parcel$export(module.exports, "supportedProperty", () => $fcad940d66d27a40$export$ce097f82c2e4551a);
$parcel$export(module.exports, "supportedValue", () => $fcad940d66d27a40$export$511766124059c277);

var $7nD0Z = parcelRequire("7nD0Z");

var $j7CoL = parcelRequire("j7CoL");
// Export javascript style and css style vendor prefixes.
var $fcad940d66d27a40$var$js = "";
var $fcad940d66d27a40$var$css = "";
var $fcad940d66d27a40$var$vendor = "";
var $fcad940d66d27a40$var$browser = "";
var $fcad940d66d27a40$var$isTouch = (0, $7nD0Z.default) && "ontouchstart" in document.documentElement; // We should not do anything if required serverside.
if (0, $7nD0Z.default) {
    // Order matters. We need to check Webkit the last one because
    // other vendors use to add Webkit prefixes to some properties
    var $fcad940d66d27a40$var$jsCssMap = {
        Moz: "-moz-",
        ms: "-ms-",
        O: "-o-",
        Webkit: "-webkit-"
    };
    var $fcad940d66d27a40$var$_document$createEleme = document.createElement("p"), $fcad940d66d27a40$var$style = $fcad940d66d27a40$var$_document$createEleme.style;
    var $fcad940d66d27a40$var$testProp = "Transform";
    for(var $fcad940d66d27a40$var$key in $fcad940d66d27a40$var$jsCssMap)if ($fcad940d66d27a40$var$key + $fcad940d66d27a40$var$testProp in $fcad940d66d27a40$var$style) {
        $fcad940d66d27a40$var$js = $fcad940d66d27a40$var$key;
        $fcad940d66d27a40$var$css = $fcad940d66d27a40$var$jsCssMap[$fcad940d66d27a40$var$key];
        break;
    }
     // Correctly detect the Edge browser.
    if ($fcad940d66d27a40$var$js === "Webkit" && "msHyphens" in $fcad940d66d27a40$var$style) {
        $fcad940d66d27a40$var$js = "ms";
        $fcad940d66d27a40$var$css = $fcad940d66d27a40$var$jsCssMap.ms;
        $fcad940d66d27a40$var$browser = "edge";
    } // Correctly detect the Safari browser.
    if ($fcad940d66d27a40$var$js === "Webkit" && "-apple-trailing-word" in $fcad940d66d27a40$var$style) $fcad940d66d27a40$var$vendor = "apple";
}
/**
 * Vendor prefix string for the current browser.
 *
 * @type {{js: String, css: String, vendor: String, browser: String}}
 * @api public
 */ var $fcad940d66d27a40$export$82e9f45cca5ba907 = {
    js: $fcad940d66d27a40$var$js,
    css: $fcad940d66d27a40$var$css,
    vendor: $fcad940d66d27a40$var$vendor,
    browser: $fcad940d66d27a40$var$browser,
    isTouch: $fcad940d66d27a40$var$isTouch
};
/**
 * Test if a keyframe at-rule should be prefixed or not
 *
 * @param {String} vendor prefix string for the current browser.
 * @return {String}
 * @api public
 */ function $fcad940d66d27a40$export$b6aa0648d950180a(key) {
    // Keyframes is already prefixed. e.g. key = '@-webkit-keyframes a'
    if (key[1] === "-") return key; // No need to prefix IE/Edge. Older browsers will ignore unsupported rules.
    // https://caniuse.com/#search=keyframes
    if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "ms") return key;
    return "@" + $fcad940d66d27a40$export$82e9f45cca5ba907.css + "keyframes" + key.substr(10);
}
// https://caniuse.com/#search=appearance
var $fcad940d66d27a40$var$appearence = {
    noPrefill: [
        "appearance"
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== "appearance") return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "ms") return "-webkit-" + prop;
        return $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop;
    }
};
// https://caniuse.com/#search=color-adjust
var $fcad940d66d27a40$var$colorAdjust = {
    noPrefill: [
        "color-adjust"
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== "color-adjust") return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "Webkit") return $fcad940d66d27a40$export$82e9f45cca5ba907.css + "print-" + prop;
        return prop;
    }
};
var $fcad940d66d27a40$var$regExp = /[-\s]+(.)?/g;
/**
 * Replaces the letter with the capital letter
 *
 * @param {String} match
 * @param {String} c
 * @return {String}
 * @api private
 */ function $fcad940d66d27a40$var$toUpper(match, c) {
    return c ? c.toUpperCase() : "";
}
/**
 * Convert dash separated strings to camel-cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */ function $fcad940d66d27a40$var$camelize(str) {
    return str.replace($fcad940d66d27a40$var$regExp, $fcad940d66d27a40$var$toUpper);
}
/**
 * Convert dash separated strings to pascal cased.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */ function $fcad940d66d27a40$var$pascalize(str) {
    return $fcad940d66d27a40$var$camelize("-" + str);
}
// but we can use a longhand property instead.
// https://caniuse.com/#search=mask
var $fcad940d66d27a40$var$mask = {
    noPrefill: [
        "mask"
    ],
    supportedProperty: function supportedProperty(prop, style) {
        if (!/^mask/.test(prop)) return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "Webkit") {
            var longhand = "mask-image";
            if ($fcad940d66d27a40$var$camelize(longhand) in style) return prop;
            if ($fcad940d66d27a40$export$82e9f45cca5ba907.js + $fcad940d66d27a40$var$pascalize(longhand) in style) return $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop;
        }
        return prop;
    }
};
// https://caniuse.com/#search=text-orientation
var $fcad940d66d27a40$var$textOrientation = {
    noPrefill: [
        "text-orientation"
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== "text-orientation") return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.vendor === "apple" && !$fcad940d66d27a40$export$82e9f45cca5ba907.isTouch) return $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop;
        return prop;
    }
};
// https://caniuse.com/#search=transform
var $fcad940d66d27a40$var$transform = {
    noPrefill: [
        "transform"
    ],
    supportedProperty: function supportedProperty(prop, style, options) {
        if (prop !== "transform") return false;
        if (options.transform) return prop;
        return $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop;
    }
};
// https://caniuse.com/#search=transition
var $fcad940d66d27a40$var$transition = {
    noPrefill: [
        "transition"
    ],
    supportedProperty: function supportedProperty(prop, style, options) {
        if (prop !== "transition") return false;
        if (options.transition) return prop;
        return $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop;
    }
};
// https://caniuse.com/#search=writing-mode
var $fcad940d66d27a40$var$writingMode = {
    noPrefill: [
        "writing-mode"
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== "writing-mode") return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "Webkit" || $fcad940d66d27a40$export$82e9f45cca5ba907.js === "ms" && $fcad940d66d27a40$export$82e9f45cca5ba907.browser !== "edge") return $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop;
        return prop;
    }
};
// https://caniuse.com/#search=user-select
var $fcad940d66d27a40$var$userSelect = {
    noPrefill: [
        "user-select"
    ],
    supportedProperty: function supportedProperty(prop) {
        if (prop !== "user-select") return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "Moz" || $fcad940d66d27a40$export$82e9f45cca5ba907.js === "ms" || $fcad940d66d27a40$export$82e9f45cca5ba907.vendor === "apple") return $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop;
        return prop;
    }
};
// https://caniuse.com/#search=multicolumn
// https://github.com/postcss/autoprefixer/issues/491
// https://github.com/postcss/autoprefixer/issues/177
var $fcad940d66d27a40$var$breakPropsOld = {
    supportedProperty: function supportedProperty(prop, style) {
        if (!/^break-/.test(prop)) return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "Webkit") {
            var jsProp = "WebkitColumn" + $fcad940d66d27a40$var$pascalize(prop);
            return jsProp in style ? $fcad940d66d27a40$export$82e9f45cca5ba907.css + "column-" + prop : false;
        }
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "Moz") {
            var _jsProp = "page" + $fcad940d66d27a40$var$pascalize(prop);
            return _jsProp in style ? "page-" + prop : false;
        }
        return false;
    }
};
// See https://github.com/postcss/autoprefixer/issues/324.
var $fcad940d66d27a40$var$inlineLogicalOld = {
    supportedProperty: function supportedProperty(prop, style) {
        if (!/^(border|margin|padding)-inline/.test(prop)) return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "Moz") return prop;
        var newProp = prop.replace("-inline", "");
        return $fcad940d66d27a40$export$82e9f45cca5ba907.js + $fcad940d66d27a40$var$pascalize(newProp) in style ? $fcad940d66d27a40$export$82e9f45cca5ba907.css + newProp : false;
    }
};
// Camelization is required because we can't test using.
// CSS syntax for e.g. in FF.
var $fcad940d66d27a40$var$unprefixed = {
    supportedProperty: function supportedProperty(prop, style) {
        return $fcad940d66d27a40$var$camelize(prop) in style ? prop : false;
    }
};
var $fcad940d66d27a40$var$prefixed = {
    supportedProperty: function supportedProperty(prop, style) {
        var pascalized = $fcad940d66d27a40$var$pascalize(prop); // Return custom CSS variable without prefixing.
        if (prop[0] === "-") return prop; // Return already prefixed value without prefixing.
        if (prop[0] === "-" && prop[1] === "-") return prop;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js + pascalized in style) return $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop; // Try webkit fallback.
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js !== "Webkit" && "Webkit" + pascalized in style) return "-webkit-" + prop;
        return false;
    }
};
// https://caniuse.com/#search=scroll-snap
var $fcad940d66d27a40$var$scrollSnap = {
    supportedProperty: function supportedProperty(prop) {
        if (prop.substring(0, 11) !== "scroll-snap") return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "ms") return "" + $fcad940d66d27a40$export$82e9f45cca5ba907.css + prop;
        return prop;
    }
};
// https://caniuse.com/#search=overscroll-behavior
var $fcad940d66d27a40$var$overscrollBehavior = {
    supportedProperty: function supportedProperty(prop) {
        if (prop !== "overscroll-behavior") return false;
        if ($fcad940d66d27a40$export$82e9f45cca5ba907.js === "ms") return $fcad940d66d27a40$export$82e9f45cca5ba907.css + "scroll-chaining";
        return prop;
    }
};
var $fcad940d66d27a40$var$propMap = {
    "flex-grow": "flex-positive",
    "flex-shrink": "flex-negative",
    "flex-basis": "flex-preferred-size",
    "justify-content": "flex-pack",
    order: "flex-order",
    "align-items": "flex-align",
    "align-content": "flex-line-pack" // 'align-self' is handled by 'align-self' plugin.
}; // Support old flex spec from 2012.
var $fcad940d66d27a40$var$flex2012 = {
    supportedProperty: function supportedProperty(prop, style) {
        var newProp = $fcad940d66d27a40$var$propMap[prop];
        if (!newProp) return false;
        return $fcad940d66d27a40$export$82e9f45cca5ba907.js + $fcad940d66d27a40$var$pascalize(newProp) in style ? $fcad940d66d27a40$export$82e9f45cca5ba907.css + newProp : false;
    }
};
var $fcad940d66d27a40$var$propMap$1 = {
    flex: "box-flex",
    "flex-grow": "box-flex",
    "flex-direction": [
        "box-orient",
        "box-direction"
    ],
    order: "box-ordinal-group",
    "align-items": "box-align",
    "flex-flow": [
        "box-orient",
        "box-direction"
    ],
    "justify-content": "box-pack"
};
var $fcad940d66d27a40$var$propKeys = Object.keys($fcad940d66d27a40$var$propMap$1);
var $fcad940d66d27a40$var$prefixCss = function prefixCss(p) {
    return $fcad940d66d27a40$export$82e9f45cca5ba907.css + p;
}; // Support old flex spec from 2009.
var $fcad940d66d27a40$var$flex2009 = {
    supportedProperty: function supportedProperty(prop, style, _ref) {
        var multiple = _ref.multiple;
        if ($fcad940d66d27a40$var$propKeys.indexOf(prop) > -1) {
            var newProp = $fcad940d66d27a40$var$propMap$1[prop];
            if (!Array.isArray(newProp)) return $fcad940d66d27a40$export$82e9f45cca5ba907.js + $fcad940d66d27a40$var$pascalize(newProp) in style ? $fcad940d66d27a40$export$82e9f45cca5ba907.css + newProp : false;
            if (!multiple) return false;
            for(var i = 0; i < newProp.length; i++){
                if (!($fcad940d66d27a40$export$82e9f45cca5ba907.js + $fcad940d66d27a40$var$pascalize(newProp[0]) in style)) return false;
            }
            return newProp.map($fcad940d66d27a40$var$prefixCss);
        }
        return false;
    }
};
// plugins = [
//   ...plugins,
//    breakPropsOld,
//    inlineLogicalOld,
//    unprefixed,
//    prefixed,
//    scrollSnap,
//    flex2012,
//    flex2009
// ]
// Plugins without 'noPrefill' value, going last.
// 'flex-*' plugins should be at the bottom.
// 'flex2009' going after 'flex2012'.
// 'prefixed' going after 'unprefixed'
var $fcad940d66d27a40$var$plugins = [
    $fcad940d66d27a40$var$appearence,
    $fcad940d66d27a40$var$colorAdjust,
    $fcad940d66d27a40$var$mask,
    $fcad940d66d27a40$var$textOrientation,
    $fcad940d66d27a40$var$transform,
    $fcad940d66d27a40$var$transition,
    $fcad940d66d27a40$var$writingMode,
    $fcad940d66d27a40$var$userSelect,
    $fcad940d66d27a40$var$breakPropsOld,
    $fcad940d66d27a40$var$inlineLogicalOld,
    $fcad940d66d27a40$var$unprefixed,
    $fcad940d66d27a40$var$prefixed,
    $fcad940d66d27a40$var$scrollSnap,
    $fcad940d66d27a40$var$overscrollBehavior,
    $fcad940d66d27a40$var$flex2012,
    $fcad940d66d27a40$var$flex2009
];
var $fcad940d66d27a40$var$propertyDetectors = $fcad940d66d27a40$var$plugins.filter(function(p) {
    return p.supportedProperty;
}).map(function(p) {
    return p.supportedProperty;
});
var $fcad940d66d27a40$var$noPrefill = $fcad940d66d27a40$var$plugins.filter(function(p) {
    return p.noPrefill;
}).reduce(function(a, p) {
    a.push.apply(a, (0, $j7CoL.default)(p.noPrefill));
    return a;
}, []);
var $fcad940d66d27a40$var$el;
var $fcad940d66d27a40$var$cache = {};
if (0, $7nD0Z.default) {
    $fcad940d66d27a40$var$el = document.createElement("p"); // We test every property on vendor prefix requirement.
    // Once tested, result is cached. It gives us up to 70% perf boost.
    // http://jsperf.com/element-style-object-access-vs-plain-object
    //
    // Prefill cache with known css properties to reduce amount of
    // properties we need to feature test at runtime.
    // http://davidwalsh.name/vendor-prefix
    var $fcad940d66d27a40$var$computed = window.getComputedStyle(document.documentElement, "");
    for(var $fcad940d66d27a40$var$key$1 in $fcad940d66d27a40$var$computed)// eslint-disable-next-line no-restricted-globals
    if (!isNaN($fcad940d66d27a40$var$key$1)) $fcad940d66d27a40$var$cache[$fcad940d66d27a40$var$computed[$fcad940d66d27a40$var$key$1]] = $fcad940d66d27a40$var$computed[$fcad940d66d27a40$var$key$1];
     // Properties that cannot be correctly detected using the
    // cache prefill method.
    $fcad940d66d27a40$var$noPrefill.forEach(function(x) {
        return delete $fcad940d66d27a40$var$cache[x];
    });
}
/**
 * Test if a property is supported, returns supported property with vendor
 * prefix if required. Returns `false` if not supported.
 *
 * @param {String} prop dash separated
 * @param {Object} [options]
 * @return {String|Boolean}
 * @api public
 */ function $fcad940d66d27a40$export$ce097f82c2e4551a(prop, options) {
    if (options === void 0) options = {};
    // For server-side rendering.
    if (!$fcad940d66d27a40$var$el) return prop; // Remove cache for benchmark tests or return property from the cache.
    if ($fcad940d66d27a40$var$cache[prop] != null) return $fcad940d66d27a40$var$cache[prop];
     // Check if 'transition' or 'transform' natively supported in browser.
    if (prop === "transition" || prop === "transform") options[prop] = prop in $fcad940d66d27a40$var$el.style;
     // Find a plugin for current prefix property.
    for(var i = 0; i < $fcad940d66d27a40$var$propertyDetectors.length; i++){
        $fcad940d66d27a40$var$cache[prop] = $fcad940d66d27a40$var$propertyDetectors[i](prop, $fcad940d66d27a40$var$el.style, options); // Break loop, if value found.
        if ($fcad940d66d27a40$var$cache[prop]) break;
    } // Reset styles for current property.
    // Firefox can even throw an error for invalid properties, e.g., "0".
    try {
        $fcad940d66d27a40$var$el.style[prop] = "";
    } catch (err) {
        return false;
    }
    return $fcad940d66d27a40$var$cache[prop];
}
var $fcad940d66d27a40$var$cache$1 = {};
var $fcad940d66d27a40$var$transitionProperties = {
    transition: 1,
    "transition-property": 1,
    "-webkit-transition": 1,
    "-webkit-transition-property": 1
};
var $fcad940d66d27a40$var$transPropsRegExp = /(^\s*[\w-]+)|, (\s*[\w-]+)(?![^()]*\))/g;
var $fcad940d66d27a40$var$el$1;
/**
 * Returns prefixed value transition/transform if needed.
 *
 * @param {String} match
 * @param {String} p1
 * @param {String} p2
 * @return {String}
 * @api private
 */ function $fcad940d66d27a40$var$prefixTransitionCallback(match, p1, p2) {
    if (p1 === "var") return "var";
    if (p1 === "all") return "all";
    if (p2 === "all") return ", all";
    var prefixedValue = p1 ? $fcad940d66d27a40$export$ce097f82c2e4551a(p1) : ", " + $fcad940d66d27a40$export$ce097f82c2e4551a(p2);
    if (!prefixedValue) return p1 || p2;
    return prefixedValue;
}
if (0, $7nD0Z.default) $fcad940d66d27a40$var$el$1 = document.createElement("p");
/**
 * Returns prefixed value if needed. Returns `false` if value is not supported.
 *
 * @param {String} property
 * @param {String} value
 * @return {String|Boolean}
 * @api public
 */ function $fcad940d66d27a40$export$511766124059c277(property, value) {
    // For server-side rendering.
    var prefixedValue = value;
    if (!$fcad940d66d27a40$var$el$1 || property === "content") return value; // It is a string or a number as a string like '1'.
    // We want only prefixable values here.
    // eslint-disable-next-line no-restricted-globals
    if (typeof prefixedValue !== "string" || !isNaN(parseInt(prefixedValue, 10))) return prefixedValue;
     // Create cache key for current value.
    var cacheKey = property + prefixedValue; // Remove cache for benchmark tests or return value from cache.
    if ($fcad940d66d27a40$var$cache$1[cacheKey] != null) return $fcad940d66d27a40$var$cache$1[cacheKey];
     // IE can even throw an error in some cases, for e.g. style.content = 'bar'.
    try {
        // Test value as it is.
        $fcad940d66d27a40$var$el$1.style[property] = prefixedValue;
    } catch (err) {
        // Return false if value not supported.
        $fcad940d66d27a40$var$cache$1[cacheKey] = false;
        return false;
    } // If 'transition' or 'transition-property' property.
    if ($fcad940d66d27a40$var$transitionProperties[property]) prefixedValue = prefixedValue.replace($fcad940d66d27a40$var$transPropsRegExp, $fcad940d66d27a40$var$prefixTransitionCallback);
    else if ($fcad940d66d27a40$var$el$1.style[property] === "") {
        // Value with a vendor prefix.
        prefixedValue = $fcad940d66d27a40$export$82e9f45cca5ba907.css + prefixedValue; // Hardcode test to convert "flex" to "-ms-flexbox" for IE10.
        if (prefixedValue === "-ms-flex") $fcad940d66d27a40$var$el$1.style[property] = "-ms-flexbox"; // Test prefixed value.
        $fcad940d66d27a40$var$el$1.style[property] = prefixedValue; // Return false if value not supported.
        if ($fcad940d66d27a40$var$el$1.style[property] === "") {
            $fcad940d66d27a40$var$cache$1[cacheKey] = false;
            return false;
        }
    } // Reset styles for current property.
    $fcad940d66d27a40$var$el$1.style[property] = ""; // Write current value to cache.
    $fcad940d66d27a40$var$cache$1[cacheKey] = prefixedValue;
    return $fcad940d66d27a40$var$cache$1[cacheKey];
}

});
parcelRequire.register("j7CoL", function(module, exports) {

$parcel$export(module.exports, "default", () => $debc74e751586e01$export$2e2bcd8739ae039);

var $8gs4n = parcelRequire("8gs4n");

var $6uskw = parcelRequire("6uskw");

var $e7gQ5 = parcelRequire("e7gQ5");

var $bmVhr = parcelRequire("bmVhr");
function $debc74e751586e01$export$2e2bcd8739ae039(arr) {
    return (0, $8gs4n.default)(arr) || (0, $6uskw.default)(arr) || (0, $e7gQ5.default)(arr) || (0, $bmVhr.default)();
}

});
parcelRequire.register("8gs4n", function(module, exports) {

$parcel$export(module.exports, "default", () => $6045975d87eb315b$export$2e2bcd8739ae039);

var $lJzHf = parcelRequire("lJzHf");
function $6045975d87eb315b$export$2e2bcd8739ae039(arr) {
    if (Array.isArray(arr)) return (0, $lJzHf.default)(arr);
}

});
parcelRequire.register("lJzHf", function(module, exports) {

$parcel$export(module.exports, "default", () => $fd297d891b1b2c6f$export$2e2bcd8739ae039);
function $fd297d891b1b2c6f$export$2e2bcd8739ae039(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}

});


parcelRequire.register("6uskw", function(module, exports) {

$parcel$export(module.exports, "default", () => $4b9b85314d16b428$export$2e2bcd8739ae039);
function $4b9b85314d16b428$export$2e2bcd8739ae039(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

});

parcelRequire.register("e7gQ5", function(module, exports) {

$parcel$export(module.exports, "default", () => $a46ec80d976a30c5$export$2e2bcd8739ae039);

var $lJzHf = parcelRequire("lJzHf");
function $a46ec80d976a30c5$export$2e2bcd8739ae039(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return (0, $lJzHf.default)(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0, $lJzHf.default)(o, minLen);
}

});

parcelRequire.register("bmVhr", function(module, exports) {

$parcel$export(module.exports, "default", () => $846e2e767f2439a8$export$2e2bcd8739ae039);
function $846e2e767f2439a8$export$2e2bcd8739ae039() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

});




parcelRequire.register("2De41", function(module, exports) {

$parcel$export(module.exports, "default", () => $1eaa2219bbdd6c00$export$2e2bcd8739ae039);
/**
 * Sort props by length.
 */ function $1eaa2219bbdd6c00$var$jssPropsSort() {
    var sort = function sort(prop0, prop1) {
        if (prop0.length === prop1.length) return prop0 > prop1 ? 1 : -1;
        return prop0.length - prop1.length;
    };
    return {
        onProcessStyle: function onProcessStyle(style, rule) {
            if (rule.type !== "style") return style;
            var newStyle = {};
            var props = Object.keys(style).sort(sort);
            for(var i = 0; i < props.length; i++)newStyle[props[i]] = style[props[i]];
            return newStyle;
        }
    };
}
var $1eaa2219bbdd6c00$export$2e2bcd8739ae039 = $1eaa2219bbdd6c00$var$jssPropsSort;

});



parcelRequire.register("5Zn7U", function(module, exports) {

$parcel$export(module.exports, "increment", () => $45c496b72a82f414$export$a2647aa13413c947);
/* eslint-disable import/prefer-default-export */ // Global index counter to preserve source order.
// We create the style sheet during the creation of the component,
// children are handled after the parents, so the order of style elements would be parent->child.
// It is a problem though when a parent passes a className
// which needs to override any child's styles.
// StyleSheet of the child has a higher specificity, because of the source order.
// So our solution is to render sheets them in the reverse order child->sheet, so
// that parent has a higher specificity.
var $45c496b72a82f414$var$indexCounter = -1000000000;
function $45c496b72a82f414$export$a2647aa13413c947() {
    $45c496b72a82f414$var$indexCounter += 1;
    return $45c496b72a82f414$var$indexCounter;
}

});

parcelRequire.register("27E1h", function(module, exports) {

$parcel$export(module.exports, "default", () => $18bb4742d36b6dc1$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");
parcelRequire("gwz1k");

var $75w9e = parcelRequire("75w9e");

function $18bb4742d36b6dc1$export$2e2bcd8739ae039(stylesOrCreator) {
    var themingEnabled = typeof stylesOrCreator === "function";
    return {
        create: function create(theme, name) {
            var styles;
            try {
                styles = themingEnabled ? stylesOrCreator(theme) : stylesOrCreator;
            } catch (err) {
                throw err;
            }
            if (!name || !theme.overrides || !theme.overrides[name]) return styles;
            var overrides = theme.overrides[name];
            var stylesWithOverrides = (0, $29rXr.default)({}, styles);
            Object.keys(overrides).forEach(function(key) {
                stylesWithOverrides[key] = (0, $75w9e.default)(stylesWithOverrides[key], overrides[key]);
            });
            return stylesWithOverrides;
        },
        options: {}
    };
}

});
parcelRequire.register("75w9e", function(module, exports) {

$parcel$export(module.exports, "default", () => $5291eff155ac232f$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $gwz1k = parcelRequire("gwz1k");
function $5291eff155ac232f$export$53b83ca8eaab0383(item) {
    return item && (0, $gwz1k.default)(item) === "object" && item.constructor === Object;
}
function $5291eff155ac232f$export$2e2bcd8739ae039(target, source) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        clone: true
    };
    var output = options.clone ? (0, $29rXr.default)({}, target) : target;
    if ($5291eff155ac232f$export$53b83ca8eaab0383(target) && $5291eff155ac232f$export$53b83ca8eaab0383(source)) Object.keys(source).forEach(function(key) {
        // Avoid prototype pollution
        if (key === "__proto__") return;
        if ($5291eff155ac232f$export$53b83ca8eaab0383(source[key]) && key in target) output[key] = $5291eff155ac232f$export$2e2bcd8739ae039(target[key], source[key], options);
        else output[key] = source[key];
    });
    return output;
}

});


parcelRequire.register("gIgen", function(module, exports) {

$parcel$export(module.exports, "default", () => $c2ad587f2506fe8e$export$2e2bcd8739ae039);
// We use the same empty object to ref count the styles that don't need a theme object.
var $c2ad587f2506fe8e$var$noopTheme = {};
var $c2ad587f2506fe8e$export$2e2bcd8739ae039 = $c2ad587f2506fe8e$var$noopTheme;

});


parcelRequire.register("dowsg", function(module, exports) {

$parcel$export(module.exports, "default", () => $9c06b1183e636a20$export$2e2bcd8739ae039);
/* eslint-disable no-restricted-syntax */ function $9c06b1183e636a20$export$2e2bcd8739ae039(params) {
    var theme = params.theme, name = params.name, props = params.props;
    if (!theme || !theme.props || !theme.props[name]) return props;
     // Resolve default props, code borrow from React source.
    // https://github.com/facebook/react/blob/15a8f031838a553e41c0b66eb1bcf1da8448104d/packages/react/src/ReactElement.js#L221
    var defaultProps = theme.props[name];
    var propName;
    for(propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
    return props;
}

});


parcelRequire.register("gukLY", function(module, exports) {

$parcel$export(module.exports, "default", () => $c00f8fb6927c8497$export$2e2bcd8739ae039);

var $i3Ixz = parcelRequire("i3Ixz");
var $c00f8fb6927c8497$var$defaultTheme = (0, $i3Ixz.default)();
var $c00f8fb6927c8497$export$2e2bcd8739ae039 = $c00f8fb6927c8497$var$defaultTheme;

});
parcelRequire.register("i3Ixz", function(module, exports) {

$parcel$export(module.exports, "default", () => $d25b0e98fbd17fb5$export$2e2bcd8739ae039);
parcelRequire("gzGrO");

var $kqze3 = parcelRequire("kqze3");

var $75w9e = parcelRequire("75w9e");

var $gBAbl = parcelRequire("gBAbl");

var $dCMpC = parcelRequire("dCMpC");

var $elfXg = parcelRequire("elfXg");

var $6WUN9 = parcelRequire("6WUN9");

var $dorKF = parcelRequire("dorKF");

var $dqpvk = parcelRequire("dqpvk");

var $k1Uxk = parcelRequire("k1Uxk");

var $9oVmk = parcelRequire("9oVmk");

var $kEMyV = parcelRequire("kEMyV");
function $d25b0e98fbd17fb5$var$createTheme() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$breakpoints = options.breakpoints, breakpointsInput = _options$breakpoints === void 0 ? {} : _options$breakpoints, _options$mixins = options.mixins, mixinsInput = _options$mixins === void 0 ? {} : _options$mixins, _options$palette = options.palette, paletteInput = _options$palette === void 0 ? {} : _options$palette, spacingInput = options.spacing, _options$typography = options.typography, typographyInput = _options$typography === void 0 ? {} : _options$typography, other = (0, $kqze3.default)(options, [
        "breakpoints",
        "mixins",
        "palette",
        "spacing",
        "typography"
    ]);
    var palette = (0, $elfXg.default)(paletteInput);
    var breakpoints = (0, $gBAbl.default)(breakpointsInput);
    var spacing = (0, $k1Uxk.default)(spacingInput);
    var muiTheme = (0, $75w9e.default)({
        breakpoints: breakpoints,
        direction: "ltr",
        mixins: (0, $dCMpC.default)(breakpoints, spacing, mixinsInput),
        overrides: {},
        // Inject custom styles
        palette: palette,
        props: {},
        // Provide default props
        shadows: (0, $dorKF.default),
        typography: (0, $6WUN9.default)(palette, typographyInput),
        spacing: spacing,
        shape: (0, $dqpvk.default),
        transitions: (0, $9oVmk.default),
        zIndex: (0, $kEMyV.default)
    }, other);
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
    muiTheme = args.reduce(function(acc, argument) {
        return (0, $75w9e.default)(acc, argument);
    }, muiTheme);
    var pseudoClasses, traverse;
    return muiTheme;
}
var $d25b0e98fbd17fb5$var$warnedOnce = false;
function $d25b0e98fbd17fb5$export$c469355549431d9b() {
    return $d25b0e98fbd17fb5$var$createTheme.apply(void 0, arguments);
}
var $d25b0e98fbd17fb5$export$2e2bcd8739ae039 = $d25b0e98fbd17fb5$var$createTheme;

});
parcelRequire.register("gzGrO", function(module, exports) {

$parcel$export(module.exports, "default", () => $c110d76aa929de29$export$2e2bcd8739ae039);

var $ebtpK = parcelRequire("ebtpK");
function $c110d76aa929de29$export$2e2bcd8739ae039(obj, key, value) {
    key = (0, $ebtpK.default)(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}

});

parcelRequire.register("gBAbl", function(module, exports) {

$parcel$export(module.exports, "default", () => $c16c2b0987c56656$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");
var $c16c2b0987c56656$export$ed97f33186d4b816 = [
    "xs",
    "sm",
    "md",
    "lg",
    "xl"
]; // Keep in mind that @media is inclusive by the CSS specification.
function $c16c2b0987c56656$export$2e2bcd8739ae039(breakpoints) {
    var _breakpoints$values = breakpoints.values, values = _breakpoints$values === void 0 ? {
        xs: 0,
        sm: 600,
        md: 960,
        lg: 1280,
        xl: 1920
    } : _breakpoints$values, _breakpoints$unit = breakpoints.unit, unit = _breakpoints$unit === void 0 ? "px" : _breakpoints$unit, _breakpoints$step = breakpoints.step, step = _breakpoints$step === void 0 ? 5 : _breakpoints$step, other = (0, $kqze3.default)(breakpoints, [
        "values",
        "unit",
        "step"
    ]);
    function up(key) {
        var value = typeof values[key] === "number" ? values[key] : key;
        return "@media (min-width:".concat(value).concat(unit, ")");
    }
    function down(key) {
        var endIndex = $c16c2b0987c56656$export$ed97f33186d4b816.indexOf(key) + 1;
        var upperbound = values[$c16c2b0987c56656$export$ed97f33186d4b816[endIndex]];
        if (endIndex === $c16c2b0987c56656$export$ed97f33186d4b816.length) // xl down applies to all sizes
        return up("xs");
        var value = typeof upperbound === "number" && endIndex > 0 ? upperbound : key;
        return "@media (max-width:".concat(value - step / 100).concat(unit, ")");
    }
    function between(start, end) {
        var endIndex = $c16c2b0987c56656$export$ed97f33186d4b816.indexOf(end);
        if (endIndex === $c16c2b0987c56656$export$ed97f33186d4b816.length - 1) return up(start);
        return "@media (min-width:".concat(typeof values[start] === "number" ? values[start] : start).concat(unit, ") and ") + "(max-width:".concat((endIndex !== -1 && typeof values[$c16c2b0987c56656$export$ed97f33186d4b816[endIndex + 1]] === "number" ? values[$c16c2b0987c56656$export$ed97f33186d4b816[endIndex + 1]] : end) - step / 100).concat(unit, ")");
    }
    function only(key) {
        return between(key, key);
    }
    var warnedOnce = false;
    function width(key) {
        return values[key];
    }
    return (0, $29rXr.default)({
        keys: $c16c2b0987c56656$export$ed97f33186d4b816,
        values: values,
        up: up,
        down: down,
        between: between,
        only: only,
        width: width
    }, other);
}

});

parcelRequire.register("dCMpC", function(module, exports) {

$parcel$export(module.exports, "default", () => $9eb460a39c088f10$export$2e2bcd8739ae039);

var $gzGrO = parcelRequire("gzGrO");

var $29rXr = parcelRequire("29rXr");
function $9eb460a39c088f10$export$2e2bcd8739ae039(breakpoints, spacing, mixins) {
    var _toolbar;
    return (0, $29rXr.default)({
        gutters: function gutters() {
            var styles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            console.warn([
                "Material-UI: theme.mixins.gutters() is deprecated.",
                "You can use the source of the mixin directly:",
                "\n      paddingLeft: theme.spacing(2),\n      paddingRight: theme.spacing(2),\n      [theme.breakpoints.up('sm')]: {\n        paddingLeft: theme.spacing(3),\n        paddingRight: theme.spacing(3),\n      },\n      "
            ].join("\n"));
            return (0, $29rXr.default)({
                paddingLeft: spacing(2),
                paddingRight: spacing(2)
            }, styles, (0, $gzGrO.default)({}, breakpoints.up("sm"), (0, $29rXr.default)({
                paddingLeft: spacing(3),
                paddingRight: spacing(3)
            }, styles[breakpoints.up("sm")])));
        },
        toolbar: (_toolbar = {
            minHeight: 56
        }, (0, $gzGrO.default)(_toolbar, "".concat(breakpoints.up("xs"), " and (orientation: landscape)"), {
            minHeight: 48
        }), (0, $gzGrO.default)(_toolbar, breakpoints.up("sm"), {
            minHeight: 64
        }), _toolbar)
    }, mixins);
}

});

parcelRequire.register("elfXg", function(module, exports) {

$parcel$export(module.exports, "default", () => $a70f67297ae824c9$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $75w9e = parcelRequire("75w9e");
var $34UnS = parcelRequire("34UnS");

var $75w9e = parcelRequire("75w9e");
var $34UnS = parcelRequire("34UnS");

var $hN0cn = parcelRequire("hN0cn");

var $eleGx = parcelRequire("eleGx");

var $f8HQ9 = parcelRequire("f8HQ9");

var $1LTz6 = parcelRequire("1LTz6");

var $4gjWS = parcelRequire("4gjWS");

var $997YL = parcelRequire("997YL");

var $9d3mA = parcelRequire("9d3mA");

var $4ZREK = parcelRequire("4ZREK");

var $5tnPj = parcelRequire("5tnPj");
var $a70f67297ae824c9$export$a43af521ac8c3202 = {
    // The colors used to style the text.
    text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.54)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)",
        // Text hints.
        hint: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
        paper: (0, $hN0cn.default).white,
        default: (0, $eleGx.default)[50]
    },
    // The colors used to style the action elements.
    action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
    }
};
var $a70f67297ae824c9$export$55ce6f3a06c59543 = {
    text: {
        primary: (0, $hN0cn.default).white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        hint: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
        paper: (0, $eleGx.default)[800],
        default: "#303030"
    },
    action: {
        active: (0, $hN0cn.default).white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
    }
};
function $a70f67297ae824c9$var$addLightOrDark(intent, direction, shade, tonalOffset) {
    var tonalOffsetLight = tonalOffset.light || tonalOffset;
    var tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
    if (!intent[direction]) {
        if (intent.hasOwnProperty(shade)) intent[direction] = intent[shade];
        else if (direction === "light") intent.light = (0, $5tnPj.lighten)(intent.main, tonalOffsetLight);
        else if (direction === "dark") intent.dark = (0, $5tnPj.darken)(intent.main, tonalOffsetDark);
    }
}
function $a70f67297ae824c9$export$2e2bcd8739ae039(palette) {
    var _palette$primary = palette.primary, primary = _palette$primary === void 0 ? {
        light: (0, $f8HQ9.default)[300],
        main: (0, $f8HQ9.default)[500],
        dark: (0, $f8HQ9.default)[700]
    } : _palette$primary, _palette$secondary = palette.secondary, secondary = _palette$secondary === void 0 ? {
        light: (0, $1LTz6.default).A200,
        main: (0, $1LTz6.default).A400,
        dark: (0, $1LTz6.default).A700
    } : _palette$secondary, _palette$error = palette.error, error = _palette$error === void 0 ? {
        light: (0, $4gjWS.default)[300],
        main: (0, $4gjWS.default)[500],
        dark: (0, $4gjWS.default)[700]
    } : _palette$error, _palette$warning = palette.warning, warning = _palette$warning === void 0 ? {
        light: (0, $997YL.default)[300],
        main: (0, $997YL.default)[500],
        dark: (0, $997YL.default)[700]
    } : _palette$warning, _palette$info = palette.info, info = _palette$info === void 0 ? {
        light: (0, $9d3mA.default)[300],
        main: (0, $9d3mA.default)[500],
        dark: (0, $9d3mA.default)[700]
    } : _palette$info, _palette$success = palette.success, success = _palette$success === void 0 ? {
        light: (0, $4ZREK.default)[300],
        main: (0, $4ZREK.default)[500],
        dark: (0, $4ZREK.default)[700]
    } : _palette$success, _palette$type = palette.type, type = _palette$type === void 0 ? "light" : _palette$type, _palette$contrastThre = palette.contrastThreshold, contrastThreshold = _palette$contrastThre === void 0 ? 3 : _palette$contrastThre, _palette$tonalOffset = palette.tonalOffset, tonalOffset = _palette$tonalOffset === void 0 ? 0.2 : _palette$tonalOffset, other = (0, $kqze3.default)(palette, [
        "primary",
        "secondary",
        "error",
        "warning",
        "info",
        "success",
        "type",
        "contrastThreshold",
        "tonalOffset"
    ]); // Use the same logic as
    // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
    // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54
    function getContrastText(background) {
        var contrastText = (0, $5tnPj.getContrastRatio)(background, $a70f67297ae824c9$export$55ce6f3a06c59543.text.primary) >= contrastThreshold ? $a70f67297ae824c9$export$55ce6f3a06c59543.text.primary : $a70f67297ae824c9$export$a43af521ac8c3202.text.primary;
        var contrast;
        return contrastText;
    }
    var augmentColor = function augmentColor(color) {
        var mainShade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
        var lightShade = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;
        var darkShade = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 700;
        color = (0, $29rXr.default)({}, color);
        if (!color.main && color[mainShade]) color.main = color[mainShade];
        if (!color.main) throw new Error((0, $34UnS.default)(4, mainShade));
        if (typeof color.main !== "string") throw new Error((0, $34UnS.default)(5, JSON.stringify(color.main)));
        $a70f67297ae824c9$var$addLightOrDark(color, "light", lightShade, tonalOffset);
        $a70f67297ae824c9$var$addLightOrDark(color, "dark", darkShade, tonalOffset);
        if (!color.contrastText) color.contrastText = getContrastText(color.main);
        return color;
    };
    var types = {
        dark: $a70f67297ae824c9$export$55ce6f3a06c59543,
        light: $a70f67297ae824c9$export$a43af521ac8c3202
    };
    var paletteOutput = (0, $75w9e.default)((0, $29rXr.default)({
        // A collection of common colors.
        common: (0, $hN0cn.default),
        // The palette type, can be light or dark.
        type: type,
        // The colors used to represent primary interface elements for a user.
        primary: augmentColor(primary),
        // The colors used to represent secondary interface elements for a user.
        secondary: augmentColor(secondary, "A400", "A200", "A700"),
        // The colors used to represent interface elements that the user should be made aware of.
        error: augmentColor(error),
        // The colors used to represent potentially dangerous actions or important messages.
        warning: augmentColor(warning),
        // The colors used to present information to the user that is neutral and not necessarily important.
        info: augmentColor(info),
        // The colors used to indicate the successful completion of an action that user triggered.
        success: augmentColor(success),
        // The grey colors.
        grey: (0, $eleGx.default),
        // Used by `getContrastText()` to maximize the contrast between
        // the background and the text.
        contrastThreshold: contrastThreshold,
        // Takes a background color and returns the text color that maximizes the contrast.
        getContrastText: getContrastText,
        // Generate a rich color object.
        augmentColor: augmentColor,
        // Used by the functions below to shift a color's luminance by approximately
        // two indexes within its tonal palette.
        // E.g., shift from Red 500 to Red 300 or Red 700.
        tonalOffset: tonalOffset
    }, types[type]), other);
    return paletteOutput;
}

});
parcelRequire.register("34UnS", function(module, exports) {

$parcel$export(module.exports, "default", () => $23dd7b829b70f196$export$2e2bcd8739ae039);
/**
 * WARNING: Don't import this directly.
 * Use `MuiError` from `@material-ui/utils/macros/MuiError.macro` instead.
 * @param {number} code
 */ function $23dd7b829b70f196$export$2e2bcd8739ae039(code) {
    // Apply babel-plugin-transform-template-literals in loose mode
    // loose mode is safe iff we're concatenating primitives
    // see https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose
    /* eslint-disable prefer-template */ var url = "https://mui.com/production-error/?code=" + code;
    for(var i = 1; i < arguments.length; i += 1)// rest params over-transpile for this case
    // eslint-disable-next-line prefer-rest-params
    url += "&args[]=" + encodeURIComponent(arguments[i]);
    return "Minified Material-UI error #" + code + "; visit " + url + " for the full message.";
/* eslint-enable prefer-template */ }

});

parcelRequire.register("hN0cn", function(module, exports) {

$parcel$export(module.exports, "default", () => $cf372ab9107eee55$export$2e2bcd8739ae039);
var $cf372ab9107eee55$var$common = {
    black: "#000",
    white: "#fff"
};
var $cf372ab9107eee55$export$2e2bcd8739ae039 = $cf372ab9107eee55$var$common;

});

parcelRequire.register("eleGx", function(module, exports) {

$parcel$export(module.exports, "default", () => $a70e6afcec7b5d5d$export$2e2bcd8739ae039);
var $a70e6afcec7b5d5d$var$grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#d5d5d5",
    A200: "#aaaaaa",
    A400: "#303030",
    A700: "#616161"
};
var $a70e6afcec7b5d5d$export$2e2bcd8739ae039 = $a70e6afcec7b5d5d$var$grey;

});

parcelRequire.register("f8HQ9", function(module, exports) {

$parcel$export(module.exports, "default", () => $b0599c204bf850d4$export$2e2bcd8739ae039);
var $b0599c204bf850d4$var$indigo = {
    50: "#e8eaf6",
    100: "#c5cae9",
    200: "#9fa8da",
    300: "#7986cb",
    400: "#5c6bc0",
    500: "#3f51b5",
    600: "#3949ab",
    700: "#303f9f",
    800: "#283593",
    900: "#1a237e",
    A100: "#8c9eff",
    A200: "#536dfe",
    A400: "#3d5afe",
    A700: "#304ffe"
};
var $b0599c204bf850d4$export$2e2bcd8739ae039 = $b0599c204bf850d4$var$indigo;

});

parcelRequire.register("1LTz6", function(module, exports) {

$parcel$export(module.exports, "default", () => $14a5485520485e22$export$2e2bcd8739ae039);
var $14a5485520485e22$var$pink = {
    50: "#fce4ec",
    100: "#f8bbd0",
    200: "#f48fb1",
    300: "#f06292",
    400: "#ec407a",
    500: "#e91e63",
    600: "#d81b60",
    700: "#c2185b",
    800: "#ad1457",
    900: "#880e4f",
    A100: "#ff80ab",
    A200: "#ff4081",
    A400: "#f50057",
    A700: "#c51162"
};
var $14a5485520485e22$export$2e2bcd8739ae039 = $14a5485520485e22$var$pink;

});

parcelRequire.register("4gjWS", function(module, exports) {

$parcel$export(module.exports, "default", () => $31a82169a59a4ebc$export$2e2bcd8739ae039);
var $31a82169a59a4ebc$var$red = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
};
var $31a82169a59a4ebc$export$2e2bcd8739ae039 = $31a82169a59a4ebc$var$red;

});

parcelRequire.register("997YL", function(module, exports) {

$parcel$export(module.exports, "default", () => $6a8b24d2514d8048$export$2e2bcd8739ae039);
var $6a8b24d2514d8048$var$orange = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00"
};
var $6a8b24d2514d8048$export$2e2bcd8739ae039 = $6a8b24d2514d8048$var$orange;

});

parcelRequire.register("9d3mA", function(module, exports) {

$parcel$export(module.exports, "default", () => $6b47efd64276f2fa$export$2e2bcd8739ae039);
var $6b47efd64276f2fa$var$blue = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff"
};
var $6b47efd64276f2fa$export$2e2bcd8739ae039 = $6b47efd64276f2fa$var$blue;

});

parcelRequire.register("4ZREK", function(module, exports) {

$parcel$export(module.exports, "default", () => $3a367aebddd41e4c$export$2e2bcd8739ae039);
var $3a367aebddd41e4c$var$green = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853"
};
var $3a367aebddd41e4c$export$2e2bcd8739ae039 = $3a367aebddd41e4c$var$green;

});

parcelRequire.register("5tnPj", function(module, exports) {

$parcel$export(module.exports, "getContrastRatio", () => $3fc224a97fe12b7b$export$d061e26956a60b0a);
$parcel$export(module.exports, "darken", () => $3fc224a97fe12b7b$export$4b073707ff63303);
$parcel$export(module.exports, "lighten", () => $3fc224a97fe12b7b$export$c0816ed86df316af);
$parcel$export(module.exports, "alpha", () => $3fc224a97fe12b7b$export$58f0f39f63f3cf42);

var $34UnS = parcelRequire("34UnS");
/* eslint-disable no-use-before-define */ /**
 * Returns a number whose value is limited to the given range.
 *
 * @param {number} value The value to be clamped
 * @param {number} min The lower boundary of the output range
 * @param {number} max The upper boundary of the output range
 * @returns {number} A number in the range [min, max]
 */ function $3fc224a97fe12b7b$var$clamp(value) {
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return Math.min(Math.max(min, value), max);
}
function $3fc224a97fe12b7b$export$5a544e13ad4e1fa5(color) {
    color = color.substr(1);
    var re = new RegExp(".{1,".concat(color.length >= 6 ? 2 : 1, "}"), "g");
    var colors = color.match(re);
    if (colors && colors[0].length === 1) colors = colors.map(function(n) {
        return n + n;
    });
    return colors ? "rgb".concat(colors.length === 4 ? "a" : "", "(").concat(colors.map(function(n, index) {
        return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
    }).join(", "), ")") : "";
}
function $3fc224a97fe12b7b$var$intToHex(int) {
    var hex = int.toString(16);
    return hex.length === 1 ? "0".concat(hex) : hex;
}
function $3fc224a97fe12b7b$export$34d09c4a771c46ef(color) {
    // Idempotent
    if (color.indexOf("#") === 0) return color;
    var _decomposeColor = $3fc224a97fe12b7b$export$677b39864803984e(color), values = _decomposeColor.values;
    return "#".concat(values.map(function(n) {
        return $3fc224a97fe12b7b$var$intToHex(n);
    }).join(""));
}
function $3fc224a97fe12b7b$export$29fb7152bd3f781a(color) {
    color = $3fc224a97fe12b7b$export$677b39864803984e(color);
    var _color = color, values = _color.values;
    var h = values[0];
    var s = values[1] / 100;
    var l = values[2] / 100;
    var a = s * Math.min(l, 1 - l);
    var f = function f(n) {
        var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (n + h / 30) % 12;
        return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    };
    var type = "rgb";
    var rgb = [
        Math.round(f(0) * 255),
        Math.round(f(8) * 255),
        Math.round(f(4) * 255)
    ];
    if (color.type === "hsla") {
        type += "a";
        rgb.push(values[3]);
    }
    return $3fc224a97fe12b7b$export$211a73f2b8c10ce4({
        type: type,
        values: rgb
    });
}
function $3fc224a97fe12b7b$export$677b39864803984e(color) {
    // Idempotent
    if (color.type) return color;
    if (color.charAt(0) === "#") return $3fc224a97fe12b7b$export$677b39864803984e($3fc224a97fe12b7b$export$5a544e13ad4e1fa5(color));
    var marker = color.indexOf("(");
    var type = color.substring(0, marker);
    if ([
        "rgb",
        "rgba",
        "hsl",
        "hsla"
    ].indexOf(type) === -1) throw new Error((0, $34UnS.default)(3, color));
    var values = color.substring(marker + 1, color.length - 1).split(",");
    values = values.map(function(value) {
        return parseFloat(value);
    });
    return {
        type: type,
        values: values
    };
}
function $3fc224a97fe12b7b$export$211a73f2b8c10ce4(color) {
    var type = color.type;
    var values = color.values;
    if (type.indexOf("rgb") !== -1) // Only convert the first 3 values to int (i.e. not alpha)
    values = values.map(function(n, i) {
        return i < 3 ? parseInt(n, 10) : n;
    });
    else if (type.indexOf("hsl") !== -1) {
        values[1] = "".concat(values[1], "%");
        values[2] = "".concat(values[2], "%");
    }
    return "".concat(type, "(").concat(values.join(", "), ")");
}
function $3fc224a97fe12b7b$export$d061e26956a60b0a(foreground, background) {
    var lumA = $3fc224a97fe12b7b$export$c852d90bf7403b62(foreground);
    var lumB = $3fc224a97fe12b7b$export$c852d90bf7403b62(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function $3fc224a97fe12b7b$export$c852d90bf7403b62(color) {
    color = $3fc224a97fe12b7b$export$677b39864803984e(color);
    var rgb = color.type === "hsl" ? $3fc224a97fe12b7b$export$677b39864803984e($3fc224a97fe12b7b$export$29fb7152bd3f781a(color)).values : color.values;
    rgb = rgb.map(function(val) {
        val /= 255; // normalized
        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
    }); // Truncate at 3 digits
    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function $3fc224a97fe12b7b$export$e665714f76e581fd(color) {
    var coefficient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.15;
    return $3fc224a97fe12b7b$export$c852d90bf7403b62(color) > 0.5 ? $3fc224a97fe12b7b$export$4b073707ff63303(color, coefficient) : $3fc224a97fe12b7b$export$c0816ed86df316af(color, coefficient);
}
var $3fc224a97fe12b7b$var$warnedOnce = false;
function $3fc224a97fe12b7b$export$cbea29d068a2e18f(color, value) {
    return $3fc224a97fe12b7b$export$58f0f39f63f3cf42(color, value);
}
function $3fc224a97fe12b7b$export$58f0f39f63f3cf42(color, value) {
    color = $3fc224a97fe12b7b$export$677b39864803984e(color);
    value = $3fc224a97fe12b7b$var$clamp(value);
    if (color.type === "rgb" || color.type === "hsl") color.type += "a";
    color.values[3] = value;
    return $3fc224a97fe12b7b$export$211a73f2b8c10ce4(color);
}
function $3fc224a97fe12b7b$export$4b073707ff63303(color, coefficient) {
    color = $3fc224a97fe12b7b$export$677b39864803984e(color);
    coefficient = $3fc224a97fe12b7b$var$clamp(coefficient);
    if (color.type.indexOf("hsl") !== -1) color.values[2] *= 1 - coefficient;
    else if (color.type.indexOf("rgb") !== -1) for(var i = 0; i < 3; i += 1)color.values[i] *= 1 - coefficient;
    return $3fc224a97fe12b7b$export$211a73f2b8c10ce4(color);
}
function $3fc224a97fe12b7b$export$c0816ed86df316af(color, coefficient) {
    color = $3fc224a97fe12b7b$export$677b39864803984e(color);
    coefficient = $3fc224a97fe12b7b$var$clamp(coefficient);
    if (color.type.indexOf("hsl") !== -1) color.values[2] += (100 - color.values[2]) * coefficient;
    else if (color.type.indexOf("rgb") !== -1) for(var i = 0; i < 3; i += 1)color.values[i] += (255 - color.values[i]) * coefficient;
    return $3fc224a97fe12b7b$export$211a73f2b8c10ce4(color);
}

});


parcelRequire.register("6WUN9", function(module, exports) {

$parcel$export(module.exports, "default", () => $50f43683de4fac5d$export$2e2bcd8739ae039);

var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $75w9e = parcelRequire("75w9e");
function $50f43683de4fac5d$var$round(value) {
    return Math.round(value * 1e5) / 1e5;
}
var $50f43683de4fac5d$var$warnedOnce = false;
function $50f43683de4fac5d$var$roundWithDeprecationWarning(value) {
    return $50f43683de4fac5d$var$round(value);
}
var $50f43683de4fac5d$var$caseAllCaps = {
    textTransform: "uppercase"
};
var $50f43683de4fac5d$var$defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function $50f43683de4fac5d$export$2e2bcd8739ae039(palette, typography) {
    var _ref = typeof typography === "function" ? typography(palette) : typography, _ref$fontFamily = _ref.fontFamily, fontFamily = _ref$fontFamily === void 0 ? $50f43683de4fac5d$var$defaultFontFamily : _ref$fontFamily, _ref$fontSize = _ref.fontSize, fontSize = _ref$fontSize === void 0 ? 14 : _ref$fontSize, _ref$fontWeightLight = _ref.fontWeightLight, fontWeightLight = _ref$fontWeightLight === void 0 ? 300 : _ref$fontWeightLight, _ref$fontWeightRegula = _ref.fontWeightRegular, fontWeightRegular = _ref$fontWeightRegula === void 0 ? 400 : _ref$fontWeightRegula, _ref$fontWeightMedium = _ref.fontWeightMedium, fontWeightMedium = _ref$fontWeightMedium === void 0 ? 500 : _ref$fontWeightMedium, _ref$fontWeightBold = _ref.fontWeightBold, fontWeightBold = _ref$fontWeightBold === void 0 ? 700 : _ref$fontWeightBold, _ref$htmlFontSize = _ref.htmlFontSize, htmlFontSize = _ref$htmlFontSize === void 0 ? 16 : _ref$htmlFontSize, allVariants = _ref.allVariants, pxToRem2 = _ref.pxToRem, other = (0, $kqze3.default)(_ref, [
        "fontFamily",
        "fontSize",
        "fontWeightLight",
        "fontWeightRegular",
        "fontWeightMedium",
        "fontWeightBold",
        "htmlFontSize",
        "allVariants",
        "pxToRem"
    ]);
    var coef = fontSize / 14;
    var pxToRem = pxToRem2 || function(size) {
        return "".concat(size / htmlFontSize * coef, "rem");
    };
    var buildVariant = function buildVariant(fontWeight, size, lineHeight, letterSpacing, casing) {
        return (0, $29rXr.default)({
            fontFamily: fontFamily,
            fontWeight: fontWeight,
            fontSize: pxToRem(size),
            // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
            lineHeight: lineHeight
        }, fontFamily === $50f43683de4fac5d$var$defaultFontFamily ? {
            letterSpacing: "".concat($50f43683de4fac5d$var$round(letterSpacing / size), "em")
        } : {}, casing, allVariants);
    };
    var variants = {
        h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
        h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
        h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
        h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
        h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
        h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
        subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
        subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
        body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
        body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
        button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, $50f43683de4fac5d$var$caseAllCaps),
        caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
        overline: buildVariant(fontWeightRegular, 12, 2.66, 1, $50f43683de4fac5d$var$caseAllCaps)
    };
    return (0, $75w9e.default)((0, $29rXr.default)({
        htmlFontSize: htmlFontSize,
        pxToRem: pxToRem,
        round: $50f43683de4fac5d$var$roundWithDeprecationWarning,
        // TODO v5: remove
        fontFamily: fontFamily,
        fontSize: fontSize,
        fontWeightLight: fontWeightLight,
        fontWeightRegular: fontWeightRegular,
        fontWeightMedium: fontWeightMedium,
        fontWeightBold: fontWeightBold
    }, variants), other, {
        clone: false // No need to clone deep
    });
}

});

parcelRequire.register("dorKF", function(module, exports) {

$parcel$export(module.exports, "default", () => $9c030b22f48e0aa2$export$2e2bcd8739ae039);
var $9c030b22f48e0aa2$var$shadowKeyUmbraOpacity = 0.2;
var $9c030b22f48e0aa2$var$shadowKeyPenumbraOpacity = 0.14;
var $9c030b22f48e0aa2$var$shadowAmbientShadowOpacity = 0.12;
function $9c030b22f48e0aa2$var$createShadow() {
    return [
        "".concat(arguments.length <= 0 ? undefined : arguments[0], "px ").concat(arguments.length <= 1 ? undefined : arguments[1], "px ").concat(arguments.length <= 2 ? undefined : arguments[2], "px ").concat(arguments.length <= 3 ? undefined : arguments[3], "px rgba(0,0,0,").concat($9c030b22f48e0aa2$var$shadowKeyUmbraOpacity, ")"),
        "".concat(arguments.length <= 4 ? undefined : arguments[4], "px ").concat(arguments.length <= 5 ? undefined : arguments[5], "px ").concat(arguments.length <= 6 ? undefined : arguments[6], "px ").concat(arguments.length <= 7 ? undefined : arguments[7], "px rgba(0,0,0,").concat($9c030b22f48e0aa2$var$shadowKeyPenumbraOpacity, ")"),
        "".concat(arguments.length <= 8 ? undefined : arguments[8], "px ").concat(arguments.length <= 9 ? undefined : arguments[9], "px ").concat(arguments.length <= 10 ? undefined : arguments[10], "px ").concat(arguments.length <= 11 ? undefined : arguments[11], "px rgba(0,0,0,").concat($9c030b22f48e0aa2$var$shadowAmbientShadowOpacity, ")")
    ].join(",");
} // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss
var $9c030b22f48e0aa2$var$shadows = [
    "none",
    $9c030b22f48e0aa2$var$createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    $9c030b22f48e0aa2$var$createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    $9c030b22f48e0aa2$var$createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    $9c030b22f48e0aa2$var$createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    $9c030b22f48e0aa2$var$createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    $9c030b22f48e0aa2$var$createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    $9c030b22f48e0aa2$var$createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    $9c030b22f48e0aa2$var$createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    $9c030b22f48e0aa2$var$createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    $9c030b22f48e0aa2$var$createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    $9c030b22f48e0aa2$var$createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    $9c030b22f48e0aa2$var$createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    $9c030b22f48e0aa2$var$createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    $9c030b22f48e0aa2$var$createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    $9c030b22f48e0aa2$var$createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    $9c030b22f48e0aa2$var$createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    $9c030b22f48e0aa2$var$createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    $9c030b22f48e0aa2$var$createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    $9c030b22f48e0aa2$var$createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    $9c030b22f48e0aa2$var$createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    $9c030b22f48e0aa2$var$createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    $9c030b22f48e0aa2$var$createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    $9c030b22f48e0aa2$var$createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    $9c030b22f48e0aa2$var$createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)
];
var $9c030b22f48e0aa2$export$2e2bcd8739ae039 = $9c030b22f48e0aa2$var$shadows;

});

parcelRequire.register("dqpvk", function(module, exports) {

$parcel$export(module.exports, "default", () => $9c617cb547fde7ae$export$2e2bcd8739ae039);
var $9c617cb547fde7ae$var$shape = {
    borderRadius: 4
};
var $9c617cb547fde7ae$export$2e2bcd8739ae039 = $9c617cb547fde7ae$var$shape;

});

parcelRequire.register("k1Uxk", function(module, exports) {

$parcel$export(module.exports, "default", () => $e94fc1a600fa762f$export$2e2bcd8739ae039);

var $4rP4M = parcelRequire("4rP4M");
var $e94fc1a600fa762f$var$warnOnce;
function $e94fc1a600fa762f$export$2e2bcd8739ae039() {
    var spacingInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
    // Already transformed.
    if (spacingInput.mui) return spacingInput;
     // Material Design layouts are visually balanced. Most measurements align to an 8dp grid applied, which aligns both spacing and the overall layout.
    // Smaller components, such as icons and type, can align to a 4dp grid.
    // https://material.io/design/layout/understanding-layout.html#usage
    var transform = (0, $4rP4M.createUnarySpacing)({
        spacing: spacingInput
    });
    var spacing = function spacing() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        if (args.length === 0) return transform(1);
        if (args.length === 1) return transform(args[0]);
        return args.map(function(argument) {
            if (typeof argument === "string") return argument;
            var output = transform(argument);
            return typeof output === "number" ? "".concat(output, "px") : output;
        }).join(" ");
    }; // Backward compatibility, to remove in v5.
    Object.defineProperty(spacing, "unit", {
        get: function get() {
            return spacingInput;
        }
    });
    spacing.mui = true;
    return spacing;
}

});
parcelRequire.register("4rP4M", function(module, exports) {

$parcel$export(module.exports, "createUnarySpacing", () => $33d14daa7f23a753$export$1def6f833384e3d1);

var $1CrQC = parcelRequire("1CrQC");


var $8wdp9 = parcelRequire("8wdp9");

var $gVuD6 = parcelRequire("gVuD6");

var $3mR4L = parcelRequire("3mR4L");
var $33d14daa7f23a753$var$properties = {
    m: "margin",
    p: "padding"
};
var $33d14daa7f23a753$var$directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: [
        "Left",
        "Right"
    ],
    y: [
        "Top",
        "Bottom"
    ]
};
var $33d14daa7f23a753$var$aliases = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
}; // memoize() impact:
// From 300,000 ops/sec
// To 350,000 ops/sec
var $33d14daa7f23a753$var$getCssProperties = (0, $3mR4L.default)(function(prop) {
    // It's not a shorthand notation.
    if (prop.length > 2) {
        if ($33d14daa7f23a753$var$aliases[prop]) prop = $33d14daa7f23a753$var$aliases[prop];
        else return [
            prop
        ];
    }
    var _prop$split = prop.split(""), _prop$split2 = (0, $1CrQC.default)(_prop$split, 2), a = _prop$split2[0], b = _prop$split2[1];
    var property = $33d14daa7f23a753$var$properties[a];
    var direction = $33d14daa7f23a753$var$directions[b] || "";
    return Array.isArray(direction) ? direction.map(function(dir) {
        return property + dir;
    }) : [
        property + direction
    ];
});
var $33d14daa7f23a753$var$spacingKeys = [
    "m",
    "mt",
    "mr",
    "mb",
    "ml",
    "mx",
    "my",
    "p",
    "pt",
    "pr",
    "pb",
    "pl",
    "px",
    "py",
    "margin",
    "marginTop",
    "marginRight",
    "marginBottom",
    "marginLeft",
    "marginX",
    "marginY",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "paddingX",
    "paddingY"
];
function $33d14daa7f23a753$export$1def6f833384e3d1(theme) {
    var themeSpacing = theme.spacing || 8;
    if (typeof themeSpacing === "number") return function(abs) {
        return themeSpacing * abs;
    };
    if (Array.isArray(themeSpacing)) return function(abs) {
        return themeSpacing[abs];
    };
    if (typeof themeSpacing === "function") return themeSpacing;
    return function() {
        return undefined;
    };
}
function $33d14daa7f23a753$var$getValue(transformer, propValue) {
    if (typeof propValue === "string" || propValue == null) return propValue;
    var abs = Math.abs(propValue);
    var transformed = transformer(abs);
    if (propValue >= 0) return transformed;
    if (typeof transformed === "number") return -transformed;
    return "-".concat(transformed);
}
function $33d14daa7f23a753$var$getStyleFromPropValue(cssProperties, transformer) {
    return function(propValue) {
        return cssProperties.reduce(function(acc, cssProperty) {
            acc[cssProperty] = $33d14daa7f23a753$var$getValue(transformer, propValue);
            return acc;
        }, {});
    };
}
function $33d14daa7f23a753$var$spacing(props) {
    var theme = props.theme;
    var transformer = $33d14daa7f23a753$export$1def6f833384e3d1(theme);
    return Object.keys(props).map(function(prop) {
        // Using a hash computation over an array iteration could be faster, but with only 28 items,
        // it's doesn't worth the bundle size.
        if ($33d14daa7f23a753$var$spacingKeys.indexOf(prop) === -1) return null;
        var cssProperties = $33d14daa7f23a753$var$getCssProperties(prop);
        var styleFromPropValue = $33d14daa7f23a753$var$getStyleFromPropValue(cssProperties, transformer);
        var propValue = props[prop];
        return (0, $8wdp9.handleBreakpoints)(props, propValue, styleFromPropValue);
    }).reduce((0, $gVuD6.default), {});
}
$33d14daa7f23a753$var$spacing.propTypes = {};
$33d14daa7f23a753$var$spacing.filterProps = $33d14daa7f23a753$var$spacingKeys;
var $33d14daa7f23a753$export$2e2bcd8739ae039 = $33d14daa7f23a753$var$spacing;

});
parcelRequire.register("1CrQC", function(module, exports) {

$parcel$export(module.exports, "default", () => $12def105beb428cb$export$2e2bcd8739ae039);

var $h8baZ = parcelRequire("h8baZ");

var $cWZzK = parcelRequire("cWZzK");

var $e7gQ5 = parcelRequire("e7gQ5");

var $inX56 = parcelRequire("inX56");
function $12def105beb428cb$export$2e2bcd8739ae039(arr, i) {
    return (0, $h8baZ.default)(arr) || (0, $cWZzK.default)(arr, i) || (0, $e7gQ5.default)(arr, i) || (0, $inX56.default)();
}

});
parcelRequire.register("h8baZ", function(module, exports) {

$parcel$export(module.exports, "default", () => $c78bda6204747d08$export$2e2bcd8739ae039);
function $c78bda6204747d08$export$2e2bcd8739ae039(arr) {
    if (Array.isArray(arr)) return arr;
}

});

parcelRequire.register("cWZzK", function(module, exports) {

$parcel$export(module.exports, "default", () => $96daaa71ebf25409$export$2e2bcd8739ae039);
function $96daaa71ebf25409$export$2e2bcd8739ae039(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}

});

parcelRequire.register("inX56", function(module, exports) {

$parcel$export(module.exports, "default", () => $d628345074334650$export$2e2bcd8739ae039);
function $d628345074334650$export$2e2bcd8739ae039() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

});


parcelRequire.register("8wdp9", function(module, exports) {

$parcel$export(module.exports, "handleBreakpoints", () => $633bb5c61a9260a0$export$88347efdb2e19abd);

var $j7CoL = parcelRequire("j7CoL");

var $29rXr = parcelRequire("29rXr");

var $gwz1k = parcelRequire("gwz1k");


var $gVuD6 = parcelRequire("gVuD6");
// For instance with the first breakpoint xs: [xs, sm[.
var $633bb5c61a9260a0$var$values = {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920
};
var $633bb5c61a9260a0$var$defaultBreakpoints = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: [
        "xs",
        "sm",
        "md",
        "lg",
        "xl"
    ],
    up: function up(key) {
        return "@media (min-width:".concat($633bb5c61a9260a0$var$values[key], "px)");
    }
};
function $633bb5c61a9260a0$export$88347efdb2e19abd(props, propValue, styleFromPropValue) {
    if (Array.isArray(propValue)) {
        var themeBreakpoints = props.theme.breakpoints || $633bb5c61a9260a0$var$defaultBreakpoints;
        return propValue.reduce(function(acc, item, index) {
            acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
            return acc;
        }, {});
    }
    if ((0, $gwz1k.default)(propValue) === "object") {
        var _themeBreakpoints = props.theme.breakpoints || $633bb5c61a9260a0$var$defaultBreakpoints;
        return Object.keys(propValue).reduce(function(acc, breakpoint) {
            acc[_themeBreakpoints.up(breakpoint)] = styleFromPropValue(propValue[breakpoint]);
            return acc;
        }, {});
    }
    var output = styleFromPropValue(propValue);
    return output;
}
function $633bb5c61a9260a0$var$breakpoints(styleFunction) {
    var newStyleFunction = function newStyleFunction(props) {
        var base = styleFunction(props);
        var themeBreakpoints = props.theme.breakpoints || $633bb5c61a9260a0$var$defaultBreakpoints;
        var extended = themeBreakpoints.keys.reduce(function(acc, key) {
            if (props[key]) {
                acc = acc || {};
                acc[themeBreakpoints.up(key)] = styleFunction((0, $29rXr.default)({
                    theme: props.theme
                }, props[key]));
            }
            return acc;
        }, null);
        return (0, $gVuD6.default)(base, extended);
    };
    newStyleFunction.propTypes = {};
    newStyleFunction.filterProps = [
        "xs",
        "sm",
        "md",
        "lg",
        "xl"
    ].concat((0, $j7CoL.default)(styleFunction.filterProps));
    return newStyleFunction;
}
var $633bb5c61a9260a0$export$2e2bcd8739ae039 = $633bb5c61a9260a0$var$breakpoints;

});
parcelRequire.register("gVuD6", function(module, exports) {

$parcel$export(module.exports, "default", () => $c529ba9d528ca741$export$2e2bcd8739ae039);

var $75w9e = parcelRequire("75w9e");
function $c529ba9d528ca741$var$merge(acc, item) {
    if (!item) return acc;
    return (0, $75w9e.default)(acc, item, {
        clone: false // No need to clone deep, it's way faster.
    });
}
var $c529ba9d528ca741$export$2e2bcd8739ae039 = $c529ba9d528ca741$var$merge;

});


parcelRequire.register("3mR4L", function(module, exports) {

$parcel$export(module.exports, "default", () => $273c98eb2320b52c$export$2e2bcd8739ae039);
function $273c98eb2320b52c$export$2e2bcd8739ae039(fn) {
    var cache = {};
    return function(arg) {
        if (cache[arg] === undefined) cache[arg] = fn(arg);
        return cache[arg];
    };
}

});



parcelRequire.register("9oVmk", function(module, exports) {

$parcel$export(module.exports, "default", () => $6d82d94cf9e75108$export$2e2bcd8739ae039);

var $kqze3 = parcelRequire("kqze3");
var $6d82d94cf9e75108$export$24c5ac7c37452e7d = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
var $6d82d94cf9e75108$export$1f34108aa9eb96ab = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
};
function $6d82d94cf9e75108$var$formatMs(milliseconds) {
    return "".concat(Math.round(milliseconds), "ms");
}
var /**
 * @param {string|Array} props
 * @param {object} param
 * @param {string} param.prop
 * @param {number} param.duration
 * @param {string} param.easing
 * @param {number} param.delay
 */ $6d82d94cf9e75108$export$2e2bcd8739ae039 = {
    easing: $6d82d94cf9e75108$export$24c5ac7c37452e7d,
    duration: $6d82d94cf9e75108$export$1f34108aa9eb96ab,
    create: function create() {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [
            "all"
        ];
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$duration = options.duration, durationOption = _options$duration === void 0 ? $6d82d94cf9e75108$export$1f34108aa9eb96ab.standard : _options$duration, _options$easing = options.easing, easingOption = _options$easing === void 0 ? $6d82d94cf9e75108$export$24c5ac7c37452e7d.easeInOut : _options$easing, _options$delay = options.delay, delay = _options$delay === void 0 ? 0 : _options$delay, other = (0, $kqze3.default)(options, [
            "duration",
            "easing",
            "delay"
        ]);
        var isString, isNumber;
        return (Array.isArray(props) ? props : [
            props
        ]).map(function(animatedProp) {
            return "".concat(animatedProp, " ").concat(typeof durationOption === "string" ? durationOption : $6d82d94cf9e75108$var$formatMs(durationOption), " ").concat(easingOption, " ").concat(typeof delay === "string" ? delay : $6d82d94cf9e75108$var$formatMs(delay));
        }).join(",");
    },
    getAutoHeightDuration: function getAutoHeightDuration(height) {
        if (!height) return 0;
        var constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10
        return Math.round((4 + 15 * Math.pow(constant, 0.25) + constant / 5) * 10);
    }
};

});

parcelRequire.register("kEMyV", function(module, exports) {

$parcel$export(module.exports, "default", () => $f09d3685c8ddf894$export$2e2bcd8739ae039);
// We need to centralize the zIndex definitions as they work
// like global values in the browser.
var $f09d3685c8ddf894$var$zIndex = {
    mobileStepper: 1000,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
};
var $f09d3685c8ddf894$export$2e2bcd8739ae039 = $f09d3685c8ddf894$var$zIndex;

});




parcelRequire.register("gqsD7", function(module, exports) {

$parcel$export(module.exports, "default", () => $bf5548607697856e$export$2e2bcd8739ae039);

var $34UnS = parcelRequire("34UnS");
function $bf5548607697856e$export$2e2bcd8739ae039(string) {
    if (typeof string !== "string") throw new Error((0, $34UnS.default)(7));
    return string.charAt(0).toUpperCase() + string.slice(1);
}

});




parcelRequire.register("3RiQf", function(module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var $2cf4efeb0ce83047$var$ReactIs, $2cf4efeb0ce83047$var$throwOnDirectAccess;

// By explicitly using `prop-types` you are opting into new production behavior.
// http://fb.me/prop-types-in-prod
module.exports = (parcelRequire("aSxGG"))();

});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var $aaLBe = parcelRequire("aaLBe");
var $ba021dca0cbd5bec$exports = {};
$ba021dca0cbd5bec$exports = ReactDOM;


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ var $12cfff73c068c586$var$extendStatics = function(d, b) {
    $12cfff73c068c586$var$extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return $12cfff73c068c586$var$extendStatics(d, b);
};
function $12cfff73c068c586$export$a8ba968b8961cb8a(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    $12cfff73c068c586$var$extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var $12cfff73c068c586$export$18ce0697a983be9b = function() {
    $12cfff73c068c586$export$18ce0697a983be9b = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return $12cfff73c068c586$export$18ce0697a983be9b.apply(this, arguments);
};
function $12cfff73c068c586$export$3c9a16f847548506(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function $12cfff73c068c586$export$29e00dfd3077644b(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function $12cfff73c068c586$export$d5ad3fd78186038f(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function $12cfff73c068c586$export$3a84e1ae4e97e9b0(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.push(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.push(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
function $12cfff73c068c586$export$d831c04e792af3d(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++)value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    return useValue ? value : void 0;
}
function $12cfff73c068c586$export$6a2a36740a146cb8(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
function $12cfff73c068c586$export$d1a06452d3489bc7(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
function $12cfff73c068c586$export$f1db080c865becb9(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function $12cfff73c068c586$export$1050f835b63b671e(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function $12cfff73c068c586$export$67ebef60e6f28a6(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var $12cfff73c068c586$export$45d3717a4c69092e = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function $12cfff73c068c586$export$f33643c0debef087(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) $12cfff73c068c586$export$45d3717a4c69092e(o, m, p);
}
function $12cfff73c068c586$export$19a8beecd37a4c45(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function $12cfff73c068c586$export$8d051b38c9118094(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function $12cfff73c068c586$export$afc72e2116322959() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat($12cfff73c068c586$export$8d051b38c9118094(arguments[i]));
    return ar;
}
function $12cfff73c068c586$export$6388937ca91ccae8() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function $12cfff73c068c586$export$1216008129fb82ed(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function $12cfff73c068c586$export$10c90e4f7922046c(v) {
    return this instanceof $12cfff73c068c586$export$10c90e4f7922046c ? (this.v = v, this) : new $12cfff73c068c586$export$10c90e4f7922046c(v);
}
function $12cfff73c068c586$export$e427f37a30a4de9b(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof $12cfff73c068c586$export$10c90e4f7922046c ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function $12cfff73c068c586$export$bbd80228419bb833(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: $12cfff73c068c586$export$10c90e4f7922046c(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function $12cfff73c068c586$export$e3b29a3d6162315f(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof $12cfff73c068c586$export$19a8beecd37a4c45 === "function" ? $12cfff73c068c586$export$19a8beecd37a4c45(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function $12cfff73c068c586$export$4fb47efe1390b86f(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
var $12cfff73c068c586$var$__setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
function $12cfff73c068c586$export$c21735bcef00d192(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) $12cfff73c068c586$export$45d3717a4c69092e(result, mod, k);
    }
    $12cfff73c068c586$var$__setModuleDefault(result, mod);
    return result;
}
function $12cfff73c068c586$export$da59b14a69baef04(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function $12cfff73c068c586$export$d5dcaf168c640c35(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function $12cfff73c068c586$export$d40a35129aaff81f(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function $12cfff73c068c586$export$81fdc39f203e4e04(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}



var $i3Ixz = parcelRequire("i3Ixz");
var $29rXr = parcelRequire("29rXr");

var $aaLBe = parcelRequire("aaLBe");



var $byRp6 = parcelRequire("byRp6");

var $3f5nj = parcelRequire("3f5nj");

var $bn8tT = parcelRequire("bn8tT");
function $f493791dfb5b1ced$var$mergeOuterLocalTheme(outerTheme, localTheme) {
    if (typeof localTheme === "function") {
        var mergedTheme = localTheme(outerTheme);
        return mergedTheme;
    }
    return (0, $29rXr.default)({}, outerTheme, localTheme);
}
/**
 * This component takes a `theme` prop.
 * It makes the `theme` available down the React tree thanks to React context.
 * This component should preferably be used at **the root of your component tree**.
 */ function $f493791dfb5b1ced$var$ThemeProvider(props) {
    var children = props.children, localTheme = props.theme;
    var outerTheme = (0, $3f5nj.default)();
    var theme = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).useMemo(function() {
        var output = outerTheme === null ? localTheme : $f493791dfb5b1ced$var$mergeOuterLocalTheme(outerTheme, localTheme);
        if (output != null) output[0, $bn8tT.default] = outerTheme !== null;
        return output;
    }, [
        localTheme,
        outerTheme
    ]);
    return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, $byRp6.default).Provider, {
        value: theme
    }, children);
}
var $f493791dfb5b1ced$export$2e2bcd8739ae039 = $f493791dfb5b1ced$var$ThemeProvider;



var $29rXr = parcelRequire("29rXr");

var $aaLBe = parcelRequire("aaLBe");


var $2LmR0 = parcelRequire("2LmR0");

var $ef8b3f7a4714a72f$export$c0bb0b647f701bb5 = {
    WebkitFontSmoothing: "antialiased",
    // Antialiasing.
    MozOsxFontSmoothing: "grayscale",
    // Antialiasing.
    // Change from `box-sizing: content-box` so that `width`
    // is not affected by `padding` or `border`.
    boxSizing: "border-box"
};
var $ef8b3f7a4714a72f$export$32180ef41b15b513 = function body(theme) {
    return (0, $29rXr.default)({
        color: theme.palette.text.primary
    }, theme.typography.body2, {
        backgroundColor: theme.palette.background.default,
        "@media print": {
            // Save printer ink.
            backgroundColor: theme.palette.common.white
        }
    });
};
var $ef8b3f7a4714a72f$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        "@global": {
            html: $ef8b3f7a4714a72f$export$c0bb0b647f701bb5,
            "*, *::before, *::after": {
                boxSizing: "inherit"
            },
            "strong, b": {
                fontWeight: theme.typography.fontWeightBold
            },
            body: (0, $29rXr.default)({
                margin: 0
            }, $ef8b3f7a4714a72f$export$32180ef41b15b513(theme), {
                // Add support for document.body.requestFullScreen().
                // Other elements, if background transparent, are not supported.
                "&::backdrop": {
                    backgroundColor: theme.palette.background.default
                }
            })
        }
    };
};
/**
 * Kickstart an elegant, consistent, and simple baseline to build upon.
 */ function $ef8b3f7a4714a72f$var$CssBaseline(props) {
    /* eslint-disable no-unused-vars */ var _props$children = props.children, children = _props$children === void 0 ? null : _props$children, classes = props.classes;
    /* eslint-enable no-unused-vars */ return /*#__PURE__*/ $aaLBe.createElement($aaLBe.Fragment, null, children);
}
var $ef8b3f7a4714a72f$export$2e2bcd8739ae039 = (0, $2LmR0.default)($ef8b3f7a4714a72f$export$9dd6ff9ea0189349, {
    name: "MuiCssBaseline"
})($ef8b3f7a4714a72f$var$CssBaseline);


/** MobX - (c) Michel Weststrate 2015 - 2018 - MIT Licensed */ /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */ /* global Reflect, Promise */ var $361a76e6ea33591f$exports = {};
// shim for using process in browser
var $361a76e6ea33591f$var$process = $361a76e6ea33591f$exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var $361a76e6ea33591f$var$cachedSetTimeout;
var $361a76e6ea33591f$var$cachedClearTimeout;
function $361a76e6ea33591f$var$defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function $361a76e6ea33591f$var$defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") $361a76e6ea33591f$var$cachedSetTimeout = setTimeout;
        else $361a76e6ea33591f$var$cachedSetTimeout = $361a76e6ea33591f$var$defaultSetTimout;
    } catch (e) {
        $361a76e6ea33591f$var$cachedSetTimeout = $361a76e6ea33591f$var$defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") $361a76e6ea33591f$var$cachedClearTimeout = clearTimeout;
        else $361a76e6ea33591f$var$cachedClearTimeout = $361a76e6ea33591f$var$defaultClearTimeout;
    } catch (e) {
        $361a76e6ea33591f$var$cachedClearTimeout = $361a76e6ea33591f$var$defaultClearTimeout;
    }
})();
function $361a76e6ea33591f$var$runTimeout(fun) {
    if ($361a76e6ea33591f$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if (($361a76e6ea33591f$var$cachedSetTimeout === $361a76e6ea33591f$var$defaultSetTimout || !$361a76e6ea33591f$var$cachedSetTimeout) && setTimeout) {
        $361a76e6ea33591f$var$cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return $361a76e6ea33591f$var$cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return $361a76e6ea33591f$var$cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return $361a76e6ea33591f$var$cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function $361a76e6ea33591f$var$runClearTimeout(marker) {
    if ($361a76e6ea33591f$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if (($361a76e6ea33591f$var$cachedClearTimeout === $361a76e6ea33591f$var$defaultClearTimeout || !$361a76e6ea33591f$var$cachedClearTimeout) && clearTimeout) {
        $361a76e6ea33591f$var$cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return $361a76e6ea33591f$var$cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return $361a76e6ea33591f$var$cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return $361a76e6ea33591f$var$cachedClearTimeout.call(this, marker);
        }
    }
}
var $361a76e6ea33591f$var$queue = [];
var $361a76e6ea33591f$var$draining = false;
var $361a76e6ea33591f$var$currentQueue;
var $361a76e6ea33591f$var$queueIndex = -1;
function $361a76e6ea33591f$var$cleanUpNextTick() {
    if (!$361a76e6ea33591f$var$draining || !$361a76e6ea33591f$var$currentQueue) return;
    $361a76e6ea33591f$var$draining = false;
    if ($361a76e6ea33591f$var$currentQueue.length) $361a76e6ea33591f$var$queue = $361a76e6ea33591f$var$currentQueue.concat($361a76e6ea33591f$var$queue);
    else $361a76e6ea33591f$var$queueIndex = -1;
    if ($361a76e6ea33591f$var$queue.length) $361a76e6ea33591f$var$drainQueue();
}
function $361a76e6ea33591f$var$drainQueue() {
    if ($361a76e6ea33591f$var$draining) return;
    var timeout = $361a76e6ea33591f$var$runTimeout($361a76e6ea33591f$var$cleanUpNextTick);
    $361a76e6ea33591f$var$draining = true;
    var len = $361a76e6ea33591f$var$queue.length;
    while(len){
        $361a76e6ea33591f$var$currentQueue = $361a76e6ea33591f$var$queue;
        $361a76e6ea33591f$var$queue = [];
        while(++$361a76e6ea33591f$var$queueIndex < len)if ($361a76e6ea33591f$var$currentQueue) $361a76e6ea33591f$var$currentQueue[$361a76e6ea33591f$var$queueIndex].run();
        $361a76e6ea33591f$var$queueIndex = -1;
        len = $361a76e6ea33591f$var$queue.length;
    }
    $361a76e6ea33591f$var$currentQueue = null;
    $361a76e6ea33591f$var$draining = false;
    $361a76e6ea33591f$var$runClearTimeout(timeout);
}
$361a76e6ea33591f$var$process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    $361a76e6ea33591f$var$queue.push(new $361a76e6ea33591f$var$Item(fun, args));
    if ($361a76e6ea33591f$var$queue.length === 1 && !$361a76e6ea33591f$var$draining) $361a76e6ea33591f$var$runTimeout($361a76e6ea33591f$var$drainQueue);
};
// v8 likes predictible objects
function $361a76e6ea33591f$var$Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
$361a76e6ea33591f$var$Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
$361a76e6ea33591f$var$process.title = "browser";
$361a76e6ea33591f$var$process.browser = true;
$361a76e6ea33591f$var$process.env = {};
$361a76e6ea33591f$var$process.argv = [];
$361a76e6ea33591f$var$process.version = ""; // empty string to avoid regexp issues
$361a76e6ea33591f$var$process.versions = {};
function $361a76e6ea33591f$var$noop() {}
$361a76e6ea33591f$var$process.on = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.addListener = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.once = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.off = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.removeListener = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.removeAllListeners = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.emit = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.prependListener = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.prependOnceListener = $361a76e6ea33591f$var$noop;
$361a76e6ea33591f$var$process.listeners = function(name) {
    return [];
};
$361a76e6ea33591f$var$process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
$361a76e6ea33591f$var$process.cwd = function() {
    return "/";
};
$361a76e6ea33591f$var$process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
$361a76e6ea33591f$var$process.umask = function() {
    return 0;
};


var $11a86e62e4f971e6$var$extendStatics = Object.setPrototypeOf || ({
    __proto__: []
}) instanceof Array && function(d, b) {
    d.__proto__ = b;
} || function(d, b) {
    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
};
function $11a86e62e4f971e6$var$__extends(d, b) {
    $11a86e62e4f971e6$var$extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var $11a86e62e4f971e6$var$__assign = Object.assign || function __assign(t) {
    for(var s, i = 1, n = arguments.length; i < n; i++){
        s = arguments[i];
        for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};
function $11a86e62e4f971e6$var$__values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
}
function $11a86e62e4f971e6$var$__read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function $11a86e62e4f971e6$var$__spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat($11a86e62e4f971e6$var$__read(arguments[i]));
    return ar;
}
var $11a86e62e4f971e6$var$OBFUSCATED_ERROR$$1 = "An invariant failed, however the error is obfuscated because this is an production build.";
var $11a86e62e4f971e6$var$EMPTY_ARRAY$$1 = [];
Object.freeze($11a86e62e4f971e6$var$EMPTY_ARRAY$$1);
var $11a86e62e4f971e6$var$EMPTY_OBJECT$$1 = {};
Object.freeze($11a86e62e4f971e6$var$EMPTY_OBJECT$$1);
function $11a86e62e4f971e6$var$getNextId$$1() {
    return ++$11a86e62e4f971e6$var$globalState$$1.mobxGuid;
}
function $11a86e62e4f971e6$var$fail$$1(message) {
    $11a86e62e4f971e6$var$invariant$$1(false, message);
    throw "X"; // unreachable
}
function $11a86e62e4f971e6$var$invariant$$1(check, message) {
    if (!check) throw new Error("[mobx] " + (message || $11a86e62e4f971e6$var$OBFUSCATED_ERROR$$1));
}
/**
 * Prints a deprecation message, but only one time.
 * Returns false if the deprecated message was already printed before
 */ var $11a86e62e4f971e6$var$deprecatedMessages = [];
function $11a86e62e4f971e6$var$deprecated$$1(msg, thing) {
    return false;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */ function $11a86e62e4f971e6$var$once$$1(func) {
    var invoked = false;
    return function() {
        if (invoked) return;
        invoked = true;
        return func.apply(this, arguments);
    };
}
var $11a86e62e4f971e6$var$noop$$1 = function() {};
function $11a86e62e4f971e6$var$unique$$1(list) {
    var res = [];
    list.forEach(function(item) {
        if (res.indexOf(item) === -1) res.push(item);
    });
    return res;
}
function $11a86e62e4f971e6$var$isObject$$1(value) {
    return value !== null && typeof value === "object";
}
function $11a86e62e4f971e6$var$isPlainObject$$1(value) {
    if (value === null || typeof value !== "object") return false;
    var proto = Object.getPrototypeOf(value);
    return proto === Object.prototype || proto === null;
}
function $11a86e62e4f971e6$var$addHiddenProp$$1(object, propName, value) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: true,
        configurable: true,
        value: value
    });
}
function $11a86e62e4f971e6$var$addHiddenFinalProp$$1(object, propName, value) {
    Object.defineProperty(object, propName, {
        enumerable: false,
        writable: false,
        configurable: true,
        value: value
    });
}
function $11a86e62e4f971e6$var$isPropertyConfigurable$$1(object, prop) {
    var descriptor = Object.getOwnPropertyDescriptor(object, prop);
    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;
}
function $11a86e62e4f971e6$var$assertPropertyConfigurable$$1(object, prop) {}
function $11a86e62e4f971e6$var$createInstanceofPredicate$$1(name, clazz) {
    var propName = "isMobX" + name;
    clazz.prototype[propName] = true;
    return function(x) {
        return $11a86e62e4f971e6$var$isObject$$1(x) && x[propName] === true;
    };
}
/**
 * Returns whether the argument is an array, disregarding observability.
 */ function $11a86e62e4f971e6$export$1e2f57719e155213(x) {
    return Array.isArray(x) || $11a86e62e4f971e6$export$f5afceff386badf9(x);
}
function $11a86e62e4f971e6$var$isES6Map$$1(thing) {
    return thing instanceof Map;
}
function $11a86e62e4f971e6$var$isES6Set$$1(thing) {
    return thing instanceof Set;
}
function $11a86e62e4f971e6$var$getMapLikeKeys$$1(map) {
    if ($11a86e62e4f971e6$var$isPlainObject$$1(map)) return Object.keys(map);
    if (Array.isArray(map)) return map.map(function(_a) {
        var _b = $11a86e62e4f971e6$var$__read(_a, 1), key = _b[0];
        return key;
    });
    if ($11a86e62e4f971e6$var$isES6Map$$1(map) || $11a86e62e4f971e6$export$27a7faddcfd44960(map)) return Array.from(map.keys());
    return $11a86e62e4f971e6$var$fail$$1("Cannot get keys from '" + map + "'");
}
function $11a86e62e4f971e6$var$toPrimitive$$1(value) {
    return value === null ? null : typeof value === "object" ? "" + value : value;
}
var $11a86e62e4f971e6$export$f246528900dd4467 = Symbol("mobx administration");
var $11a86e62e4f971e6$var$Atom$$1 = /** @class */ function() {
    /**
     * Create a new atom. For debugging purposes it is recommended to give it a name.
     * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
     */ function Atom$$1(name) {
        if (name === void 0) name = "Atom@" + $11a86e62e4f971e6$var$getNextId$$1();
        this.name = name;
        this.isPendingUnobservation = false; // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed
        this.isBeingObserved = false;
        this.observers = new Set();
        this.diffValue = 0;
        this.lastAccessedBy = 0;
        this.lowestObserverState = $11a86e62e4f971e6$export$7670cbf9718f5a36.NOT_TRACKING;
    }
    Atom$$1.prototype.onBecomeObserved = function() {
        if (this.onBecomeObservedListeners) this.onBecomeObservedListeners.forEach(function(listener) {
            return listener();
        });
    };
    Atom$$1.prototype.onBecomeUnobserved = function() {
        if (this.onBecomeUnobservedListeners) this.onBecomeUnobservedListeners.forEach(function(listener) {
            return listener();
        });
    };
    /**
     * Invoke this method to notify mobx that your atom has been used somehow.
     * Returns true if there is currently a reactive context.
     */ Atom$$1.prototype.reportObserved = function() {
        return $11a86e62e4f971e6$var$reportObserved$$1(this);
    };
    /**
     * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
     */ Atom$$1.prototype.reportChanged = function() {
        $11a86e62e4f971e6$var$startBatch$$1();
        $11a86e62e4f971e6$var$propagateChanged$$1(this);
        $11a86e62e4f971e6$var$endBatch$$1();
    };
    Atom$$1.prototype.toString = function() {
        return this.name;
    };
    return Atom$$1;
}();
var $11a86e62e4f971e6$var$isAtom$$1 = $11a86e62e4f971e6$var$createInstanceofPredicate$$1("Atom", $11a86e62e4f971e6$var$Atom$$1);
function $11a86e62e4f971e6$export$2e17fe64ec9a826e(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (onBecomeObservedHandler === void 0) onBecomeObservedHandler = $11a86e62e4f971e6$var$noop$$1;
    if (onBecomeUnobservedHandler === void 0) onBecomeUnobservedHandler = $11a86e62e4f971e6$var$noop$$1;
    var atom = new $11a86e62e4f971e6$var$Atom$$1(name);
    // default `noop` listener will not initialize the hook Set
    if (onBecomeObservedHandler !== $11a86e62e4f971e6$var$noop$$1) $11a86e62e4f971e6$export$24d7f9cdf0de2679(atom, onBecomeObservedHandler);
    if (onBecomeUnobservedHandler !== $11a86e62e4f971e6$var$noop$$1) $11a86e62e4f971e6$export$f8586f6f22b9cba9(atom, onBecomeUnobservedHandler);
    return atom;
}
function $11a86e62e4f971e6$var$identityComparer(a, b) {
    return a === b;
}
function $11a86e62e4f971e6$var$structuralComparer(a, b) {
    return $11a86e62e4f971e6$var$deepEqual$$1(a, b);
}
function $11a86e62e4f971e6$var$defaultComparer(a, b) {
    return Object.is(a, b);
}
var $11a86e62e4f971e6$export$d9328cbeeb64e882 = {
    identity: $11a86e62e4f971e6$var$identityComparer,
    structural: $11a86e62e4f971e6$var$structuralComparer,
    default: $11a86e62e4f971e6$var$defaultComparer
};
var $11a86e62e4f971e6$var$mobxDidRunLazyInitializersSymbol$$1 = Symbol("mobx did run lazy initializers");
var $11a86e62e4f971e6$var$mobxPendingDecorators$$1 = Symbol("mobx pending decorators");
var $11a86e62e4f971e6$var$enumerableDescriptorCache = {};
var $11a86e62e4f971e6$var$nonEnumerableDescriptorCache = {};
function $11a86e62e4f971e6$var$createPropertyInitializerDescriptor(prop, enumerable) {
    var cache = enumerable ? $11a86e62e4f971e6$var$enumerableDescriptorCache : $11a86e62e4f971e6$var$nonEnumerableDescriptorCache;
    return cache[prop] || (cache[prop] = {
        configurable: true,
        enumerable: enumerable,
        get: function() {
            $11a86e62e4f971e6$var$initializeInstance$$1(this);
            return this[prop];
        },
        set: function(value) {
            $11a86e62e4f971e6$var$initializeInstance$$1(this);
            this[prop] = value;
        }
    });
}
function $11a86e62e4f971e6$var$initializeInstance$$1(target) {
    if (target[$11a86e62e4f971e6$var$mobxDidRunLazyInitializersSymbol$$1] === true) return;
    var decorators = target[$11a86e62e4f971e6$var$mobxPendingDecorators$$1];
    if (decorators) {
        $11a86e62e4f971e6$var$addHiddenProp$$1(target, $11a86e62e4f971e6$var$mobxDidRunLazyInitializersSymbol$$1, true);
        for(var key in decorators){
            var d = decorators[key];
            d.propertyCreator(target, d.prop, d.descriptor, d.decoratorTarget, d.decoratorArguments);
        }
    }
}
function $11a86e62e4f971e6$var$createPropDecorator$$1(propertyInitiallyEnumerable, propertyCreator) {
    return function decoratorFactory() {
        var decoratorArguments;
        var decorator = function decorate$$1(target, prop, descriptor, applyImmediately) {
            if (applyImmediately === true) {
                propertyCreator(target, prop, descriptor, target, decoratorArguments);
                return null;
            }
            if (!Object.prototype.hasOwnProperty.call(target, $11a86e62e4f971e6$var$mobxPendingDecorators$$1)) {
                var inheritedDecorators = target[$11a86e62e4f971e6$var$mobxPendingDecorators$$1];
                $11a86e62e4f971e6$var$addHiddenProp$$1(target, $11a86e62e4f971e6$var$mobxPendingDecorators$$1, $11a86e62e4f971e6$var$__assign({}, inheritedDecorators));
            }
            target[$11a86e62e4f971e6$var$mobxPendingDecorators$$1][prop] = {
                prop: prop,
                propertyCreator: propertyCreator,
                descriptor: descriptor,
                decoratorTarget: target,
                decoratorArguments: decoratorArguments
            };
            return $11a86e62e4f971e6$var$createPropertyInitializerDescriptor(prop, propertyInitiallyEnumerable);
        };
        if ($11a86e62e4f971e6$var$quacksLikeADecorator$$1(arguments)) {
            // @decorator
            decoratorArguments = $11a86e62e4f971e6$var$EMPTY_ARRAY$$1;
            return decorator.apply(null, arguments);
        } else {
            // @decorator(args)
            decoratorArguments = Array.prototype.slice.call(arguments);
            return decorator;
        }
    };
}
function $11a86e62e4f971e6$var$quacksLikeADecorator$$1(args) {
    return (args.length === 2 || args.length === 3) && typeof args[1] === "string" || args.length === 4 && args[3] === true;
}
function $11a86e62e4f971e6$var$deepEnhancer$$1(v, _, name) {
    // it is an observable already, done
    if ($11a86e62e4f971e6$export$5cd057a6046189f9(v)) return v;
    // something that can be converted and mutated?
    if (Array.isArray(v)) return $11a86e62e4f971e6$export$5ab46cbf6120b33a.array(v, {
        name: name
    });
    if ($11a86e62e4f971e6$var$isPlainObject$$1(v)) return $11a86e62e4f971e6$export$5ab46cbf6120b33a.object(v, undefined, {
        name: name
    });
    if ($11a86e62e4f971e6$var$isES6Map$$1(v)) return $11a86e62e4f971e6$export$5ab46cbf6120b33a.map(v, {
        name: name
    });
    if ($11a86e62e4f971e6$var$isES6Set$$1(v)) return $11a86e62e4f971e6$export$5ab46cbf6120b33a.set(v, {
        name: name
    });
    return v;
}
function $11a86e62e4f971e6$var$shallowEnhancer$$1(v, _, name) {
    if (v === undefined || v === null) return v;
    if ($11a86e62e4f971e6$export$31960fb081a18155(v) || $11a86e62e4f971e6$export$f5afceff386badf9(v) || $11a86e62e4f971e6$export$27a7faddcfd44960(v) || $11a86e62e4f971e6$export$da6b063694cb52c1(v)) return v;
    if (Array.isArray(v)) return $11a86e62e4f971e6$export$5ab46cbf6120b33a.array(v, {
        name: name,
        deep: false
    });
    if ($11a86e62e4f971e6$var$isPlainObject$$1(v)) return $11a86e62e4f971e6$export$5ab46cbf6120b33a.object(v, undefined, {
        name: name,
        deep: false
    });
    if ($11a86e62e4f971e6$var$isES6Map$$1(v)) return $11a86e62e4f971e6$export$5ab46cbf6120b33a.map(v, {
        name: name,
        deep: false
    });
    if ($11a86e62e4f971e6$var$isES6Set$$1(v)) return $11a86e62e4f971e6$export$5ab46cbf6120b33a.set(v, {
        name: name,
        deep: false
    });
    return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$var$referenceEnhancer$$1(newValue) {
    // never turn into an observable
    return newValue;
}
function $11a86e62e4f971e6$var$refStructEnhancer$$1(v, oldValue, name) {
    if ($11a86e62e4f971e6$var$deepEqual$$1(v, oldValue)) return oldValue;
    return v;
}
function $11a86e62e4f971e6$var$createDecoratorForEnhancer$$1(enhancer) {
    $11a86e62e4f971e6$var$invariant$$1(enhancer);
    var decorator = $11a86e62e4f971e6$var$createPropDecorator$$1(true, function(target, propertyName, descriptor, _decoratorTarget, decoratorArgs) {
        var initialValue = descriptor ? descriptor.initializer ? descriptor.initializer.call(target) : descriptor.value : undefined;
        $11a86e62e4f971e6$var$asObservableObject$$1(target).addObservableProp(propertyName, initialValue, enhancer);
    });
    var res = // Extra process checks, as this happens during module initialization
    (typeof $361a76e6ea33591f$exports !== "undefined" && $361a76e6ea33591f$exports.env, decorator);
    res.enhancer = enhancer;
    return res;
}
// Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases
var $11a86e62e4f971e6$var$defaultCreateObservableOptions$$1 = {
    deep: true,
    name: undefined,
    defaultDecorator: undefined,
    proxy: true
};
Object.freeze($11a86e62e4f971e6$var$defaultCreateObservableOptions$$1);
function $11a86e62e4f971e6$var$assertValidOption(key) {
    if (!/^(deep|name|equals|defaultDecorator|proxy)$/.test(key)) $11a86e62e4f971e6$var$fail$$1("invalid option for (extend)observable: " + key);
}
function $11a86e62e4f971e6$var$asCreateObservableOptions$$1(thing) {
    if (thing === null || thing === undefined) return $11a86e62e4f971e6$var$defaultCreateObservableOptions$$1;
    if (typeof thing === "string") return {
        name: thing,
        deep: true,
        proxy: true
    };
    return thing;
}
var $11a86e62e4f971e6$var$deepDecorator$$1 = $11a86e62e4f971e6$var$createDecoratorForEnhancer$$1($11a86e62e4f971e6$var$deepEnhancer$$1);
var $11a86e62e4f971e6$var$shallowDecorator = $11a86e62e4f971e6$var$createDecoratorForEnhancer$$1($11a86e62e4f971e6$var$shallowEnhancer$$1);
var $11a86e62e4f971e6$var$refDecorator$$1 = $11a86e62e4f971e6$var$createDecoratorForEnhancer$$1($11a86e62e4f971e6$var$referenceEnhancer$$1);
var $11a86e62e4f971e6$var$refStructDecorator = $11a86e62e4f971e6$var$createDecoratorForEnhancer$$1($11a86e62e4f971e6$var$refStructEnhancer$$1);
function $11a86e62e4f971e6$var$getEnhancerFromOptions(options) {
    return options.defaultDecorator ? options.defaultDecorator.enhancer : options.deep === false ? $11a86e62e4f971e6$var$referenceEnhancer$$1 : $11a86e62e4f971e6$var$deepEnhancer$$1;
}
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */ function $11a86e62e4f971e6$var$createObservable(v, arg2, arg3) {
    // @observable someProp;
    if (typeof arguments[1] === "string") return $11a86e62e4f971e6$var$deepDecorator$$1.apply(null, arguments);
    // it is an observable already, done
    if ($11a86e62e4f971e6$export$5cd057a6046189f9(v)) return v;
    // something that can be converted and mutated?
    var res = $11a86e62e4f971e6$var$isPlainObject$$1(v) ? $11a86e62e4f971e6$export$5ab46cbf6120b33a.object(v, arg2, arg3) : Array.isArray(v) ? $11a86e62e4f971e6$export$5ab46cbf6120b33a.array(v, arg2) : $11a86e62e4f971e6$var$isES6Map$$1(v) ? $11a86e62e4f971e6$export$5ab46cbf6120b33a.map(v, arg2) : $11a86e62e4f971e6$var$isES6Set$$1(v) ? $11a86e62e4f971e6$export$5ab46cbf6120b33a.set(v, arg2) : v;
    // this value could be converted to a new observable data structure, return it
    if (res !== v) return res;
    // otherwise, just box it
    $11a86e62e4f971e6$var$fail$$1(false);
}
var $11a86e62e4f971e6$var$observableFactories = {
    box: function(value, options) {
        if (arguments.length > 2) $11a86e62e4f971e6$var$incorrectlyUsedAsDecorator("box");
        var o = $11a86e62e4f971e6$var$asCreateObservableOptions$$1(options);
        return new $11a86e62e4f971e6$var$ObservableValue$$1(value, $11a86e62e4f971e6$var$getEnhancerFromOptions(o), o.name, true, o.equals);
    },
    array: function(initialValues, options) {
        if (arguments.length > 2) $11a86e62e4f971e6$var$incorrectlyUsedAsDecorator("array");
        var o = $11a86e62e4f971e6$var$asCreateObservableOptions$$1(options);
        return $11a86e62e4f971e6$var$createObservableArray$$1(initialValues, $11a86e62e4f971e6$var$getEnhancerFromOptions(o), o.name);
    },
    map: function(initialValues, options) {
        if (arguments.length > 2) $11a86e62e4f971e6$var$incorrectlyUsedAsDecorator("map");
        var o = $11a86e62e4f971e6$var$asCreateObservableOptions$$1(options);
        return new $11a86e62e4f971e6$export$db1c0901f08fc6fd(initialValues, $11a86e62e4f971e6$var$getEnhancerFromOptions(o), o.name);
    },
    set: function(initialValues, options) {
        if (arguments.length > 2) $11a86e62e4f971e6$var$incorrectlyUsedAsDecorator("set");
        var o = $11a86e62e4f971e6$var$asCreateObservableOptions$$1(options);
        return new $11a86e62e4f971e6$export$2235f602a7a77c81(initialValues, $11a86e62e4f971e6$var$getEnhancerFromOptions(o), o.name);
    },
    object: function(props, decorators, options) {
        if (typeof arguments[1] === "string") $11a86e62e4f971e6$var$incorrectlyUsedAsDecorator("object");
        var o = $11a86e62e4f971e6$var$asCreateObservableOptions$$1(options);
        if (o.proxy === false) return $11a86e62e4f971e6$export$59d8134e963031bd({}, props, decorators, o);
        else {
            var defaultDecorator = $11a86e62e4f971e6$var$getDefaultDecoratorFromObjectOptions$$1(o);
            var base = $11a86e62e4f971e6$export$59d8134e963031bd({}, undefined, undefined, o);
            var proxy = $11a86e62e4f971e6$var$createDynamicObservableObject$$1(base);
            $11a86e62e4f971e6$var$extendObservableObjectWithProperties$$1(proxy, props, decorators, defaultDecorator);
            return proxy;
        }
    },
    ref: $11a86e62e4f971e6$var$refDecorator$$1,
    shallow: $11a86e62e4f971e6$var$shallowDecorator,
    deep: $11a86e62e4f971e6$var$deepDecorator$$1,
    struct: $11a86e62e4f971e6$var$refStructDecorator
};
var $11a86e62e4f971e6$export$5ab46cbf6120b33a = $11a86e62e4f971e6$var$createObservable;
// weird trick to keep our typings nicely with our funcs, and still extend the observable function
Object.keys($11a86e62e4f971e6$var$observableFactories).forEach(function(name) {
    return $11a86e62e4f971e6$export$5ab46cbf6120b33a[name] = $11a86e62e4f971e6$var$observableFactories[name];
});
function $11a86e62e4f971e6$var$incorrectlyUsedAsDecorator(methodName) {
    $11a86e62e4f971e6$var$fail$$1(// process.env.NODE_ENV !== "production" &&
    "Expected one or two arguments to observable." + methodName + ". Did you accidentally try to use observable." + methodName + " as decorator?");
}
var $11a86e62e4f971e6$var$computedDecorator$$1 = $11a86e62e4f971e6$var$createPropDecorator$$1(false, function(instance, propertyName, descriptor, decoratorTarget, decoratorArgs) {
    var get$$1 = descriptor.get, set$$1 = descriptor.set; // initialValue is the descriptor for get / set props
    // Optimization: faster on decorator target or instance? Assuming target
    // Optimization: find out if declaring on instance isn't just faster. (also makes the property descriptor simpler). But, more memory usage..
    // Forcing instance now, fixes hot reloadig issues on React Native:
    var options = decoratorArgs[0] || {};
    $11a86e62e4f971e6$var$asObservableObject$$1(instance).addComputedProp(instance, propertyName, $11a86e62e4f971e6$var$__assign({
        get: get$$1,
        set: set$$1,
        context: instance
    }, options));
});
var $11a86e62e4f971e6$var$computedStructDecorator = $11a86e62e4f971e6$var$computedDecorator$$1({
    equals: $11a86e62e4f971e6$export$d9328cbeeb64e882.structural
});
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */ var $11a86e62e4f971e6$export$2983e091f1a1e8e2 = function computed$$1(arg1, arg2, arg3) {
    if (typeof arg2 === "string") // @computed
    return $11a86e62e4f971e6$var$computedDecorator$$1.apply(null, arguments);
    if (arg1 !== null && typeof arg1 === "object" && arguments.length === 1) // @computed({ options })
    return $11a86e62e4f971e6$var$computedDecorator$$1.apply(null, arguments);
    var opts = typeof arg2 === "object" ? arg2 : {};
    opts.get = arg1;
    opts.set = typeof arg2 === "function" ? arg2 : opts.set;
    opts.name = opts.name || arg1.name || ""; /* for generated name */ 
    return new $11a86e62e4f971e6$var$ComputedValue$$1(opts);
};
$11a86e62e4f971e6$export$2983e091f1a1e8e2.struct = $11a86e62e4f971e6$var$computedStructDecorator;
function $11a86e62e4f971e6$var$createAction$$1(actionName, fn) {
    var res = function() {
        return $11a86e62e4f971e6$var$executeAction$$1(actionName, fn, this, arguments);
    };
    res.isMobxAction = true;
    return res;
}
function $11a86e62e4f971e6$var$executeAction$$1(actionName, fn, scope, args) {
    var runInfo = $11a86e62e4f971e6$var$startAction(actionName, fn, scope, args);
    var shouldSupressReactionError = true;
    try {
        var res = fn.apply(scope, args);
        shouldSupressReactionError = false;
        return res;
    } finally{
        if (shouldSupressReactionError) {
            $11a86e62e4f971e6$var$globalState$$1.suppressReactionErrors = shouldSupressReactionError;
            $11a86e62e4f971e6$var$endAction(runInfo);
            $11a86e62e4f971e6$var$globalState$$1.suppressReactionErrors = false;
        } else $11a86e62e4f971e6$var$endAction(runInfo);
    }
}
function $11a86e62e4f971e6$var$startAction(actionName, fn, scope, args) {
    var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1() && !!actionName;
    var startTime = 0;
    var l, flattendArgs, i;
    var prevDerivation = $11a86e62e4f971e6$var$untrackedStart$$1();
    $11a86e62e4f971e6$var$startBatch$$1();
    var prevAllowStateChanges = $11a86e62e4f971e6$var$allowStateChangesStart$$1(true);
    return {
        prevDerivation: prevDerivation,
        prevAllowStateChanges: prevAllowStateChanges,
        notifySpy: notifySpy,
        startTime: startTime
    };
}
function $11a86e62e4f971e6$var$endAction(runInfo) {
    $11a86e62e4f971e6$var$allowStateChangesEnd$$1(runInfo.prevAllowStateChanges);
    $11a86e62e4f971e6$var$endBatch$$1();
    $11a86e62e4f971e6$var$untrackedEnd$$1(runInfo.prevDerivation);
    runInfo.notifySpy;
}
function $11a86e62e4f971e6$export$e510c5d1ea4358b1(allowStateChanges$$1, func) {
    var prev = $11a86e62e4f971e6$var$allowStateChangesStart$$1(allowStateChanges$$1);
    var res;
    try {
        res = func();
    } finally{
        $11a86e62e4f971e6$var$allowStateChangesEnd$$1(prev);
    }
    return res;
}
function $11a86e62e4f971e6$var$allowStateChangesStart$$1(allowStateChanges$$1) {
    var prev = $11a86e62e4f971e6$var$globalState$$1.allowStateChanges;
    $11a86e62e4f971e6$var$globalState$$1.allowStateChanges = allowStateChanges$$1;
    return prev;
}
function $11a86e62e4f971e6$var$allowStateChangesEnd$$1(prev) {
    $11a86e62e4f971e6$var$globalState$$1.allowStateChanges = prev;
}
function $11a86e62e4f971e6$export$832370e58be26204(func) {
    var prev = $11a86e62e4f971e6$var$globalState$$1.computationDepth;
    $11a86e62e4f971e6$var$globalState$$1.computationDepth = 0;
    var res;
    try {
        res = func();
    } finally{
        $11a86e62e4f971e6$var$globalState$$1.computationDepth = prev;
    }
    return res;
}
var $11a86e62e4f971e6$var$ObservableValue$$1 = /** @class */ function(_super) {
    $11a86e62e4f971e6$var$__extends(ObservableValue$$1, _super);
    function ObservableValue$$1(value, enhancer, name, notifySpy, equals) {
        if (name === void 0) name = "ObservableValue@" + $11a86e62e4f971e6$var$getNextId$$1();
        if (notifySpy === void 0) notifySpy = true;
        if (equals === void 0) equals = $11a86e62e4f971e6$export$d9328cbeeb64e882.default;
        var _this = _super.call(this, name) || this;
        _this.enhancer = enhancer;
        _this.name = name;
        _this.equals = equals;
        _this.hasUnreportedChange = false;
        _this.value = enhancer(value, undefined, name);
        notifySpy && $11a86e62e4f971e6$var$isSpyEnabled$$1();
        return _this;
    }
    ObservableValue$$1.prototype.dehanceValue = function(value) {
        if (this.dehancer !== undefined) return this.dehancer(value);
        return value;
    };
    ObservableValue$$1.prototype.set = function(newValue) {
        var oldValue = this.value;
        newValue = this.prepareNewValue(newValue);
        if (newValue !== $11a86e62e4f971e6$var$globalState$$1.UNCHANGED) {
            var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
            this.setNewValue(newValue);
        }
    };
    ObservableValue$$1.prototype.prepareNewValue = function(newValue) {
        $11a86e62e4f971e6$var$checkIfStateModificationsAreAllowed$$1(this);
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                object: this,
                type: "update",
                newValue: newValue
            });
            if (!change) return $11a86e62e4f971e6$var$globalState$$1.UNCHANGED;
            newValue = change.newValue;
        }
        // apply modifier
        newValue = this.enhancer(newValue, this.value, this.name);
        return this.equals(this.value, newValue) ? $11a86e62e4f971e6$var$globalState$$1.UNCHANGED : newValue;
    };
    ObservableValue$$1.prototype.setNewValue = function(newValue) {
        var oldValue = this.value;
        this.value = newValue;
        this.reportChanged();
        if ($11a86e62e4f971e6$var$hasListeners$$1(this)) $11a86e62e4f971e6$var$notifyListeners$$1(this, {
            type: "update",
            object: this,
            newValue: newValue,
            oldValue: oldValue
        });
    };
    ObservableValue$$1.prototype.get = function() {
        this.reportObserved();
        return this.dehanceValue(this.value);
    };
    ObservableValue$$1.prototype.intercept = function(handler) {
        return $11a86e62e4f971e6$var$registerInterceptor$$1(this, handler);
    };
    ObservableValue$$1.prototype.observe = function(listener, fireImmediately) {
        if (fireImmediately) listener({
            object: this,
            type: "update",
            newValue: this.value,
            oldValue: undefined
        });
        return $11a86e62e4f971e6$var$registerListener$$1(this, listener);
    };
    ObservableValue$$1.prototype.toJSON = function() {
        return this.get();
    };
    ObservableValue$$1.prototype.toString = function() {
        return this.name + "[" + this.value + "]";
    };
    ObservableValue$$1.prototype.valueOf = function() {
        return $11a86e62e4f971e6$var$toPrimitive$$1(this.get());
    };
    ObservableValue$$1.prototype[Symbol.toPrimitive] = function() {
        return this.valueOf();
    };
    return ObservableValue$$1;
}($11a86e62e4f971e6$var$Atom$$1);
var $11a86e62e4f971e6$export$fafbc00dbefd1aef = $11a86e62e4f971e6$var$createInstanceofPredicate$$1("ObservableValue", $11a86e62e4f971e6$var$ObservableValue$$1);
/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */ var $11a86e62e4f971e6$var$ComputedValue$$1 = /** @class */ function() {
    /**
     * Create a new computed value based on a function expression.
     *
     * The `name` property is for debug purposes only.
     *
     * The `equals` property specifies the comparer function to use to determine if a newly produced
     * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
     * compares based on identity comparison (===), and `structualComparer` deeply compares the structure.
     * Structural comparison can be convenient if you always produce a new aggregated object and
     * don't want to notify observers if it is structurally the same.
     * This is useful for working with vectors, mouse coordinates etc.
     */ function ComputedValue$$1(options) {
        this.dependenciesState = $11a86e62e4f971e6$export$7670cbf9718f5a36.NOT_TRACKING;
        this.observing = []; // nodes we are looking at. Our value depends on these nodes
        this.newObserving = null; // during tracking it's an array with new observed observers
        this.isBeingObserved = false;
        this.isPendingUnobservation = false;
        this.observers = new Set();
        this.diffValue = 0;
        this.runId = 0;
        this.lastAccessedBy = 0;
        this.lowestObserverState = $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE;
        this.unboundDepsCount = 0;
        this.__mapid = "#" + $11a86e62e4f971e6$var$getNextId$$1();
        this.value = new $11a86e62e4f971e6$var$CaughtException$$1(null);
        this.isComputing = false; // to check for cycles
        this.isRunningSetter = false;
        this.isTracing = $11a86e62e4f971e6$var$TraceMode$$1.NONE;
        this.derivation = options.get;
        this.name = options.name || "ComputedValue@" + $11a86e62e4f971e6$var$getNextId$$1();
        if (options.set) this.setter = $11a86e62e4f971e6$var$createAction$$1(this.name + "-setter", options.set);
        this.equals = options.equals || (options.compareStructural || options.struct ? $11a86e62e4f971e6$export$d9328cbeeb64e882.structural : $11a86e62e4f971e6$export$d9328cbeeb64e882.default);
        this.scope = options.context;
        this.requiresReaction = !!options.requiresReaction;
        this.keepAlive = !!options.keepAlive;
    }
    ComputedValue$$1.prototype.onBecomeStale = function() {
        $11a86e62e4f971e6$var$propagateMaybeChanged$$1(this);
    };
    ComputedValue$$1.prototype.onBecomeObserved = function() {
        if (this.onBecomeObservedListeners) this.onBecomeObservedListeners.forEach(function(listener) {
            return listener();
        });
    };
    ComputedValue$$1.prototype.onBecomeUnobserved = function() {
        if (this.onBecomeUnobservedListeners) this.onBecomeUnobservedListeners.forEach(function(listener) {
            return listener();
        });
    };
    /**
     * Returns the current value of this computed value.
     * Will evaluate its computation first if needed.
     */ ComputedValue$$1.prototype.get = function() {
        if (this.isComputing) $11a86e62e4f971e6$var$fail$$1("Cycle detected in computation " + this.name + ": " + this.derivation);
        if ($11a86e62e4f971e6$var$globalState$$1.inBatch === 0 && this.observers.size === 0 && !this.keepAlive) {
            if ($11a86e62e4f971e6$var$shouldCompute$$1(this)) {
                this.warnAboutUntrackedRead();
                $11a86e62e4f971e6$var$startBatch$$1(); // See perf test 'computed memoization'
                this.value = this.computeValue(false);
                $11a86e62e4f971e6$var$endBatch$$1();
            }
        } else {
            $11a86e62e4f971e6$var$reportObserved$$1(this);
            if ($11a86e62e4f971e6$var$shouldCompute$$1(this)) {
                if (this.trackAndCompute()) $11a86e62e4f971e6$var$propagateChangeConfirmed$$1(this);
            }
        }
        var result = this.value;
        if ($11a86e62e4f971e6$var$isCaughtException$$1(result)) throw result.cause;
        return result;
    };
    ComputedValue$$1.prototype.peek = function() {
        var res = this.computeValue(false);
        if ($11a86e62e4f971e6$var$isCaughtException$$1(res)) throw res.cause;
        return res;
    };
    ComputedValue$$1.prototype.set = function(value) {
        if (this.setter) {
            $11a86e62e4f971e6$var$invariant$$1(!this.isRunningSetter, "The setter of computed value '" + this.name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?");
            this.isRunningSetter = true;
            try {
                this.setter.call(this.scope, value);
            } finally{
                this.isRunningSetter = false;
            }
        } else $11a86e62e4f971e6$var$invariant$$1(false, false);
    };
    ComputedValue$$1.prototype.trackAndCompute = function() {
        $11a86e62e4f971e6$var$isSpyEnabled$$1();
        var oldValue = this.value;
        var wasSuspended = /* see #1208 */ this.dependenciesState === $11a86e62e4f971e6$export$7670cbf9718f5a36.NOT_TRACKING;
        var newValue = this.computeValue(true);
        var changed = wasSuspended || $11a86e62e4f971e6$var$isCaughtException$$1(oldValue) || $11a86e62e4f971e6$var$isCaughtException$$1(newValue) || !this.equals(oldValue, newValue);
        if (changed) this.value = newValue;
        return changed;
    };
    ComputedValue$$1.prototype.computeValue = function(track) {
        this.isComputing = true;
        $11a86e62e4f971e6$var$globalState$$1.computationDepth++;
        var res;
        if (track) res = $11a86e62e4f971e6$var$trackDerivedFunction$$1(this, this.derivation, this.scope);
        else {
            if ($11a86e62e4f971e6$var$globalState$$1.disableErrorBoundaries === true) res = this.derivation.call(this.scope);
            else try {
                res = this.derivation.call(this.scope);
            } catch (e) {
                res = new $11a86e62e4f971e6$var$CaughtException$$1(e);
            }
        }
        $11a86e62e4f971e6$var$globalState$$1.computationDepth--;
        this.isComputing = false;
        return res;
    };
    ComputedValue$$1.prototype.suspend = function() {
        if (!this.keepAlive) {
            $11a86e62e4f971e6$var$clearObserving$$1(this);
            this.value = undefined; // don't hold on to computed value!
        }
    };
    ComputedValue$$1.prototype.observe = function(listener, fireImmediately) {
        var _this = this;
        var firstTime = true;
        var prevValue = undefined;
        return $11a86e62e4f971e6$export$4abd31caebb0bb24(function() {
            var newValue = _this.get();
            if (!firstTime || fireImmediately) {
                var prevU = $11a86e62e4f971e6$var$untrackedStart$$1();
                listener({
                    type: "update",
                    object: _this,
                    newValue: newValue,
                    oldValue: prevValue
                });
                $11a86e62e4f971e6$var$untrackedEnd$$1(prevU);
            }
            firstTime = false;
            prevValue = newValue;
        });
    };
    ComputedValue$$1.prototype.warnAboutUntrackedRead = function() {
        return;
    };
    ComputedValue$$1.prototype.toJSON = function() {
        return this.get();
    };
    ComputedValue$$1.prototype.toString = function() {
        return this.name + "[" + this.derivation.toString() + "]";
    };
    ComputedValue$$1.prototype.valueOf = function() {
        return $11a86e62e4f971e6$var$toPrimitive$$1(this.get());
    };
    ComputedValue$$1.prototype[Symbol.toPrimitive] = function() {
        return this.valueOf();
    };
    return ComputedValue$$1;
}();
var $11a86e62e4f971e6$var$isComputedValue$$1 = $11a86e62e4f971e6$var$createInstanceofPredicate$$1("ComputedValue", $11a86e62e4f971e6$var$ComputedValue$$1);
var $11a86e62e4f971e6$export$7670cbf9718f5a36;
(function(IDerivationState$$1) {
    // before being run or (outside batch and not being observed)
    // at this point derivation is not holding any data about dependency tree
    IDerivationState$$1[IDerivationState$$1["NOT_TRACKING"] = -1] = "NOT_TRACKING";
    // no shallow dependency changed since last computation
    // won't recalculate derivation
    // this is what makes mobx fast
    IDerivationState$$1[IDerivationState$$1["UP_TO_DATE"] = 0] = "UP_TO_DATE";
    // some deep dependency changed, but don't know if shallow dependency changed
    // will require to check first if UP_TO_DATE or POSSIBLY_STALE
    // currently only ComputedValue will propagate POSSIBLY_STALE
    //
    // having this state is second big optimization:
    // don't have to recompute on every dependency change, but only when it's needed
    IDerivationState$$1[IDerivationState$$1["POSSIBLY_STALE"] = 1] = "POSSIBLY_STALE";
    // A shallow dependency has changed since last computation and the derivation
    // will need to recompute when it's needed next.
    IDerivationState$$1[IDerivationState$$1["STALE"] = 2] = "STALE";
})($11a86e62e4f971e6$export$7670cbf9718f5a36 || ($11a86e62e4f971e6$export$7670cbf9718f5a36 = {}));
var $11a86e62e4f971e6$var$TraceMode$$1;
(function(TraceMode$$1) {
    TraceMode$$1[TraceMode$$1["NONE"] = 0] = "NONE";
    TraceMode$$1[TraceMode$$1["LOG"] = 1] = "LOG";
    TraceMode$$1[TraceMode$$1["BREAK"] = 2] = "BREAK";
})($11a86e62e4f971e6$var$TraceMode$$1 || ($11a86e62e4f971e6$var$TraceMode$$1 = {}));
var $11a86e62e4f971e6$var$CaughtException$$1 = /** @class */ function() {
    function CaughtException$$1(cause) {
        this.cause = cause;
    // Empty
    }
    return CaughtException$$1;
}();
function $11a86e62e4f971e6$var$isCaughtException$$1(e) {
    return e instanceof $11a86e62e4f971e6$var$CaughtException$$1;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */ function $11a86e62e4f971e6$var$shouldCompute$$1(derivation) {
    switch(derivation.dependenciesState){
        case $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE:
            return false;
        case $11a86e62e4f971e6$export$7670cbf9718f5a36.NOT_TRACKING:
        case $11a86e62e4f971e6$export$7670cbf9718f5a36.STALE:
            return true;
        case $11a86e62e4f971e6$export$7670cbf9718f5a36.POSSIBLY_STALE:
            var prevUntracked = $11a86e62e4f971e6$var$untrackedStart$$1(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.
            var obs = derivation.observing, l = obs.length;
            for(var i = 0; i < l; i++){
                var obj = obs[i];
                if ($11a86e62e4f971e6$var$isComputedValue$$1(obj)) {
                    if ($11a86e62e4f971e6$var$globalState$$1.disableErrorBoundaries) obj.get();
                    else try {
                        obj.get();
                    } catch (e) {
                        // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                        $11a86e62e4f971e6$var$untrackedEnd$$1(prevUntracked);
                        return true;
                    }
                    // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
                    // and `derivation` is an observer of `obj`
                    // invariantShouldCompute(derivation)
                    if (derivation.dependenciesState === $11a86e62e4f971e6$export$7670cbf9718f5a36.STALE) {
                        $11a86e62e4f971e6$var$untrackedEnd$$1(prevUntracked);
                        return true;
                    }
                }
            }
            $11a86e62e4f971e6$var$changeDependenciesStateTo0$$1(derivation);
            $11a86e62e4f971e6$var$untrackedEnd$$1(prevUntracked);
            return false;
    }
}
// function invariantShouldCompute(derivation: IDerivation) {
//     const newDepState = (derivation as any).dependenciesState
//     if (
//         process.env.NODE_ENV === "production" &&
//         (newDepState === IDerivationState.POSSIBLY_STALE ||
//             newDepState === IDerivationState.NOT_TRACKING)
//     )
//         fail("Illegal dependency state")
// }
function $11a86e62e4f971e6$export$34c53f8cb85e26c1() {
    return $11a86e62e4f971e6$var$globalState$$1.trackingDerivation !== null; // filter out actions inside computations
}
function $11a86e62e4f971e6$var$checkIfStateModificationsAreAllowed$$1(atom) {
    var hasObservers$$1 = atom.observers.size > 0;
    // Should never be possible to change an observed observable from inside computed, see #798
    if ($11a86e62e4f971e6$var$globalState$$1.computationDepth > 0 && hasObservers$$1) $11a86e62e4f971e6$var$fail$$1(false);
    // Should not be possible to change observed state outside strict mode, except during initialization, see #563
    if (!$11a86e62e4f971e6$var$globalState$$1.allowStateChanges && (hasObservers$$1 || $11a86e62e4f971e6$var$globalState$$1.enforceActions === "strict")) $11a86e62e4f971e6$var$fail$$1(false);
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */ function $11a86e62e4f971e6$var$trackDerivedFunction$$1(derivation, f, context) {
    // pre allocate array allocation + room for variation in deps
    // array will be trimmed by bindDependencies
    $11a86e62e4f971e6$var$changeDependenciesStateTo0$$1(derivation);
    derivation.newObserving = new Array(derivation.observing.length + 100);
    derivation.unboundDepsCount = 0;
    derivation.runId = ++$11a86e62e4f971e6$var$globalState$$1.runId;
    var prevTracking = $11a86e62e4f971e6$var$globalState$$1.trackingDerivation;
    $11a86e62e4f971e6$var$globalState$$1.trackingDerivation = derivation;
    var result;
    if ($11a86e62e4f971e6$var$globalState$$1.disableErrorBoundaries === true) result = f.call(context);
    else try {
        result = f.call(context);
    } catch (e) {
        result = new $11a86e62e4f971e6$var$CaughtException$$1(e);
    }
    $11a86e62e4f971e6$var$globalState$$1.trackingDerivation = prevTracking;
    $11a86e62e4f971e6$var$bindDependencies(derivation);
    return result;
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */ function $11a86e62e4f971e6$var$bindDependencies(derivation) {
    // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
    var prevObserving = derivation.observing;
    var observing = derivation.observing = derivation.newObserving;
    var lowestNewObservingDerivationState = $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE;
    // Go through all new observables and check diffValue: (this list can contain duplicates):
    //   0: first occurrence, change to 1 and keep it
    //   1: extra occurrence, drop it
    var i0 = 0, l = derivation.unboundDepsCount;
    for(var i = 0; i < l; i++){
        var dep = observing[i];
        if (dep.diffValue === 0) {
            dep.diffValue = 1;
            if (i0 !== i) observing[i0] = dep;
            i0++;
        }
        // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
        // not hitting the condition
        if (dep.dependenciesState > lowestNewObservingDerivationState) lowestNewObservingDerivationState = dep.dependenciesState;
    }
    observing.length = i0;
    derivation.newObserving = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
    // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
    //   0: it's not in new observables, unobserve it
    //   1: it keeps being observed, don't want to notify it. change to 0
    l = prevObserving.length;
    while(l--){
        var dep = prevObserving[l];
        if (dep.diffValue === 0) $11a86e62e4f971e6$var$removeObserver$$1(dep, derivation);
        dep.diffValue = 0;
    }
    // Go through all new observables and check diffValue: (now it should be unique)
    //   0: it was set to 0 in last loop. don't need to do anything.
    //   1: it wasn't observed, let's observe it. set back to 0
    while(i0--){
        var dep = observing[i0];
        if (dep.diffValue === 1) {
            dep.diffValue = 0;
            $11a86e62e4f971e6$var$addObserver$$1(dep, derivation);
        }
    }
    // Some new observed derivations may become stale during this derivation computation
    // so they have had no chance to propagate staleness (#916)
    if (lowestNewObservingDerivationState !== $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE) {
        derivation.dependenciesState = lowestNewObservingDerivationState;
        derivation.onBecomeStale();
    }
}
function $11a86e62e4f971e6$var$clearObserving$$1(derivation) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
    var obs = derivation.observing;
    derivation.observing = [];
    var i = obs.length;
    while(i--)$11a86e62e4f971e6$var$removeObserver$$1(obs[i], derivation);
    derivation.dependenciesState = $11a86e62e4f971e6$export$7670cbf9718f5a36.NOT_TRACKING;
}
function $11a86e62e4f971e6$export$8c437e4d572e2f99(action$$1) {
    var prev = $11a86e62e4f971e6$var$untrackedStart$$1();
    try {
        return action$$1();
    } finally{
        $11a86e62e4f971e6$var$untrackedEnd$$1(prev);
    }
}
function $11a86e62e4f971e6$var$untrackedStart$$1() {
    var prev = $11a86e62e4f971e6$var$globalState$$1.trackingDerivation;
    $11a86e62e4f971e6$var$globalState$$1.trackingDerivation = null;
    return prev;
}
function $11a86e62e4f971e6$var$untrackedEnd$$1(prev) {
    $11a86e62e4f971e6$var$globalState$$1.trackingDerivation = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */ function $11a86e62e4f971e6$var$changeDependenciesStateTo0$$1(derivation) {
    if (derivation.dependenciesState === $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE) return;
    derivation.dependenciesState = $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE;
    var obs = derivation.observing;
    var i = obs.length;
    while(i--)obs[i].lowestObserverState = $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE;
}
/**
 * These values will persist if global state is reset
 */ var $11a86e62e4f971e6$var$persistentKeys = [
    "mobxGuid",
    "spyListeners",
    "enforceActions",
    "computedRequiresReaction",
    "disableErrorBoundaries",
    "runId",
    "UNCHANGED"
];
var $11a86e62e4f971e6$var$MobXGlobals$$1 = /** @class */ function() {
    function MobXGlobals$$1() {
        /**
         * MobXGlobals version.
         * MobX compatiblity with other versions loaded in memory as long as this version matches.
         * It indicates that the global state still stores similar information
         *
         * N.B: this version is unrelated to the package version of MobX, and is only the version of the
         * internal state storage of MobX, and can be the same across many different package versions
         */ this.version = 5;
        /**
         * globally unique token to signal unchanged
         */ this.UNCHANGED = {};
        /**
         * Currently running derivation
         */ this.trackingDerivation = null;
        /**
         * Are we running a computation currently? (not a reaction)
         */ this.computationDepth = 0;
        /**
         * Each time a derivation is tracked, it is assigned a unique run-id
         */ this.runId = 0;
        /**
         * 'guid' for general purpose. Will be persisted amongst resets.
         */ this.mobxGuid = 0;
        /**
         * Are we in a batch block? (and how many of them)
         */ this.inBatch = 0;
        /**
         * Observables that don't have observers anymore, and are about to be
         * suspended, unless somebody else accesses it in the same batch
         *
         * @type {IObservable[]}
         */ this.pendingUnobservations = [];
        /**
         * List of scheduled, not yet executed, reactions.
         */ this.pendingReactions = [];
        /**
         * Are we currently processing reactions?
         */ this.isRunningReactions = false;
        /**
         * Is it allowed to change observables at this point?
         * In general, MobX doesn't allow that when running computations and React.render.
         * To ensure that those functions stay pure.
         */ this.allowStateChanges = true;
        /**
         * If strict mode is enabled, state changes are by default not allowed
         */ this.enforceActions = false;
        /**
         * Spy callbacks
         */ this.spyListeners = [];
        /**
         * Globally attached error handlers that react specifically to errors in reactions
         */ this.globalReactionErrorHandlers = [];
        /**
         * Warn if computed values are accessed outside a reactive context
         */ this.computedRequiresReaction = false;
        /*
         * Don't catch and rethrow exceptions. This is useful for inspecting the state of
         * the stack when an exception occurs while debugging.
         */ this.disableErrorBoundaries = false;
        /*
         * If true, we are already handling an exception in an action. Any errors in reactions should be supressed, as
         * they are not the cause, see: https://github.com/mobxjs/mobx/issues/1836
         */ this.suppressReactionErrors = false;
    }
    return MobXGlobals$$1;
}();
var $11a86e62e4f971e6$var$canMergeGlobalState = true;
var $11a86e62e4f971e6$var$isolateCalled = false;
var $11a86e62e4f971e6$var$globalState$$1 = function() {
    var global1 = $11a86e62e4f971e6$var$getGlobal$$1();
    if (global1.__mobxInstanceCount > 0 && !global1.__mobxGlobals) $11a86e62e4f971e6$var$canMergeGlobalState = false;
    if (global1.__mobxGlobals && global1.__mobxGlobals.version !== new $11a86e62e4f971e6$var$MobXGlobals$$1().version) $11a86e62e4f971e6$var$canMergeGlobalState = false;
    if (!$11a86e62e4f971e6$var$canMergeGlobalState) {
        setTimeout(function() {
            if (!$11a86e62e4f971e6$var$isolateCalled) $11a86e62e4f971e6$var$fail$$1("There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`");
        }, 1);
        return new $11a86e62e4f971e6$var$MobXGlobals$$1();
    } else if (global1.__mobxGlobals) {
        global1.__mobxInstanceCount += 1;
        if (!global1.__mobxGlobals.UNCHANGED) global1.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible
        return global1.__mobxGlobals;
    } else {
        global1.__mobxInstanceCount = 1;
        return global1.__mobxGlobals = new $11a86e62e4f971e6$var$MobXGlobals$$1();
    }
}();
function $11a86e62e4f971e6$var$isolateGlobalState$$1() {
    if ($11a86e62e4f971e6$var$globalState$$1.pendingReactions.length || $11a86e62e4f971e6$var$globalState$$1.inBatch || $11a86e62e4f971e6$var$globalState$$1.isRunningReactions) $11a86e62e4f971e6$var$fail$$1("isolateGlobalState should be called before MobX is running any reactions");
    $11a86e62e4f971e6$var$isolateCalled = true;
    if ($11a86e62e4f971e6$var$canMergeGlobalState) {
        if (--$11a86e62e4f971e6$var$getGlobal$$1().__mobxInstanceCount === 0) $11a86e62e4f971e6$var$getGlobal$$1().__mobxGlobals = undefined;
        $11a86e62e4f971e6$var$globalState$$1 = new $11a86e62e4f971e6$var$MobXGlobals$$1();
    }
}
function $11a86e62e4f971e6$export$c78907783e606401() {
    return $11a86e62e4f971e6$var$globalState$$1;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */ function $11a86e62e4f971e6$export$5c18e491c80b9ab4() {
    var defaultGlobals = new $11a86e62e4f971e6$var$MobXGlobals$$1();
    for(var key in defaultGlobals)if ($11a86e62e4f971e6$var$persistentKeys.indexOf(key) === -1) $11a86e62e4f971e6$var$globalState$$1[key] = defaultGlobals[key];
    $11a86e62e4f971e6$var$globalState$$1.allowStateChanges = !$11a86e62e4f971e6$var$globalState$$1.enforceActions;
}
function $11a86e62e4f971e6$var$getGlobal$$1() {
    return typeof window !== "undefined" ? window : $parcel$global;
}
function $11a86e62e4f971e6$var$hasObservers$$1(observable$$1) {
    return observable$$1.observers && observable$$1.observers.size > 0;
}
function $11a86e62e4f971e6$var$getObservers$$1(observable$$1) {
    return observable$$1.observers;
}
// function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }
function $11a86e62e4f971e6$var$addObserver$$1(observable$$1, node) {
    // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
    // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
    // invariantObservers(observable);
    observable$$1.observers.add(node);
    if (observable$$1.lowestObserverState > node.dependenciesState) observable$$1.lowestObserverState = node.dependenciesState;
// invariantObservers(observable);
// invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function $11a86e62e4f971e6$var$removeObserver$$1(observable$$1, node) {
    // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
    // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
    // invariantObservers(observable);
    observable$$1.observers.delete(node);
    if (observable$$1.observers.size === 0) // deleting last observer
    $11a86e62e4f971e6$var$queueForUnobservation$$1(observable$$1);
// invariantObservers(observable);
// invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");
}
function $11a86e62e4f971e6$var$queueForUnobservation$$1(observable$$1) {
    if (observable$$1.isPendingUnobservation === false) {
        // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
        observable$$1.isPendingUnobservation = true;
        $11a86e62e4f971e6$var$globalState$$1.pendingUnobservations.push(observable$$1);
    }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */ function $11a86e62e4f971e6$var$startBatch$$1() {
    $11a86e62e4f971e6$var$globalState$$1.inBatch++;
}
function $11a86e62e4f971e6$var$endBatch$$1() {
    if (--$11a86e62e4f971e6$var$globalState$$1.inBatch === 0) {
        $11a86e62e4f971e6$var$runReactions$$1();
        // the batch is actually about to finish, all unobserving should happen here.
        var list = $11a86e62e4f971e6$var$globalState$$1.pendingUnobservations;
        for(var i = 0; i < list.length; i++){
            var observable$$1 = list[i];
            observable$$1.isPendingUnobservation = false;
            if (observable$$1.observers.size === 0) {
                if (observable$$1.isBeingObserved) {
                    // if this observable had reactive observers, trigger the hooks
                    observable$$1.isBeingObserved = false;
                    observable$$1.onBecomeUnobserved();
                }
                if (observable$$1 instanceof $11a86e62e4f971e6$var$ComputedValue$$1) // computed values are automatically teared down when the last observer leaves
                // this process happens recursively, this computed might be the last observabe of another, etc..
                observable$$1.suspend();
            }
        }
        $11a86e62e4f971e6$var$globalState$$1.pendingUnobservations = [];
    }
}
function $11a86e62e4f971e6$var$reportObserved$$1(observable$$1) {
    var derivation = $11a86e62e4f971e6$var$globalState$$1.trackingDerivation;
    if (derivation !== null) {
        /**
         * Simple optimization, give each derivation run an unique id (runId)
         * Check if last time this observable was accessed the same runId is used
         * if this is the case, the relation is already known
         */ if (derivation.runId !== observable$$1.lastAccessedBy) {
            observable$$1.lastAccessedBy = derivation.runId;
            // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...
            derivation.newObserving[derivation.unboundDepsCount++] = observable$$1;
            if (!observable$$1.isBeingObserved) {
                observable$$1.isBeingObserved = true;
                observable$$1.onBecomeObserved();
            }
        }
        return true;
    } else if (observable$$1.observers.size === 0 && $11a86e62e4f971e6$var$globalState$$1.inBatch > 0) $11a86e62e4f971e6$var$queueForUnobservation$$1(observable$$1);
    return false;
}
// function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }
/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */ // Called by Atom when its value changes
function $11a86e62e4f971e6$var$propagateChanged$$1(observable$$1) {
    // invariantLOS(observable, "changed start");
    if (observable$$1.lowestObserverState === $11a86e62e4f971e6$export$7670cbf9718f5a36.STALE) return;
    observable$$1.lowestObserverState = $11a86e62e4f971e6$export$7670cbf9718f5a36.STALE;
    // Ideally we use for..of here, but the downcompiled version is really slow...
    observable$$1.observers.forEach(function(d) {
        if (d.dependenciesState === $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE) {
            if (d.isTracing !== $11a86e62e4f971e6$var$TraceMode$$1.NONE) $11a86e62e4f971e6$var$logTraceInfo(d, observable$$1);
            d.onBecomeStale();
        }
        d.dependenciesState = $11a86e62e4f971e6$export$7670cbf9718f5a36.STALE;
    });
// invariantLOS(observable, "changed end");
}
// Called by ComputedValue when it recalculate and its value changed
function $11a86e62e4f971e6$var$propagateChangeConfirmed$$1(observable$$1) {
    // invariantLOS(observable, "confirmed start");
    if (observable$$1.lowestObserverState === $11a86e62e4f971e6$export$7670cbf9718f5a36.STALE) return;
    observable$$1.lowestObserverState = $11a86e62e4f971e6$export$7670cbf9718f5a36.STALE;
    observable$$1.observers.forEach(function(d) {
        if (d.dependenciesState === $11a86e62e4f971e6$export$7670cbf9718f5a36.POSSIBLY_STALE) d.dependenciesState = $11a86e62e4f971e6$export$7670cbf9718f5a36.STALE;
        else if (d.dependenciesState === $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE // this happens during computing of `d`, just keep lowestObserverState up to date.
        ) observable$$1.lowestObserverState = $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE;
    });
// invariantLOS(observable, "confirmed end");
}
// Used by computed when its dependency changed, but we don't wan't to immediately recompute.
function $11a86e62e4f971e6$var$propagateMaybeChanged$$1(observable$$1) {
    // invariantLOS(observable, "maybe start");
    if (observable$$1.lowestObserverState !== $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE) return;
    observable$$1.lowestObserverState = $11a86e62e4f971e6$export$7670cbf9718f5a36.POSSIBLY_STALE;
    observable$$1.observers.forEach(function(d) {
        if (d.dependenciesState === $11a86e62e4f971e6$export$7670cbf9718f5a36.UP_TO_DATE) {
            d.dependenciesState = $11a86e62e4f971e6$export$7670cbf9718f5a36.POSSIBLY_STALE;
            if (d.isTracing !== $11a86e62e4f971e6$var$TraceMode$$1.NONE) $11a86e62e4f971e6$var$logTraceInfo(d, observable$$1);
            d.onBecomeStale();
        }
    });
// invariantLOS(observable, "maybe end");
}
function $11a86e62e4f971e6$var$logTraceInfo(derivation, observable$$1) {
    console.log("[mobx.trace] '" + derivation.name + "' is invalidated due to a change in: '" + observable$$1.name + "'");
    if (derivation.isTracing === $11a86e62e4f971e6$var$TraceMode$$1.BREAK) {
        var lines = [];
        $11a86e62e4f971e6$var$printDepTree($11a86e62e4f971e6$export$23fbf90e5d80a5ee(derivation), lines, 1);
        // prettier-ignore
        new Function("debugger;\n/*\nTracing '" + derivation.name + "'\n\nYou are entering this break point because derivation '" + derivation.name + "' is being traced and '" + observable$$1.name + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof $11a86e62e4f971e6$var$ComputedValue$$1 ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
    }
}
function $11a86e62e4f971e6$var$printDepTree(tree, lines, depth) {
    if (lines.length >= 1000) {
        lines.push("(and many more)");
        return;
    }
    lines.push("" + new Array(depth).join("	") + tree.name); // MWE: not the fastest, but the easiest way :)
    if (tree.dependencies) tree.dependencies.forEach(function(child) {
        return $11a86e62e4f971e6$var$printDepTree(child, lines, depth + 1);
    });
}
var $11a86e62e4f971e6$export$d2ae4167a30cf6bb = /** @class */ function() {
    function Reaction$$1(name, onInvalidate, errorHandler) {
        if (name === void 0) name = "Reaction@" + $11a86e62e4f971e6$var$getNextId$$1();
        this.name = name;
        this.onInvalidate = onInvalidate;
        this.errorHandler = errorHandler;
        this.observing = []; // nodes we are looking at. Our value depends on these nodes
        this.newObserving = [];
        this.dependenciesState = $11a86e62e4f971e6$export$7670cbf9718f5a36.NOT_TRACKING;
        this.diffValue = 0;
        this.runId = 0;
        this.unboundDepsCount = 0;
        this.__mapid = "#" + $11a86e62e4f971e6$var$getNextId$$1();
        this.isDisposed = false;
        this._isScheduled = false;
        this._isTrackPending = false;
        this._isRunning = false;
        this.isTracing = $11a86e62e4f971e6$var$TraceMode$$1.NONE;
    }
    Reaction$$1.prototype.onBecomeStale = function() {
        this.schedule();
    };
    Reaction$$1.prototype.schedule = function() {
        if (!this._isScheduled) {
            this._isScheduled = true;
            $11a86e62e4f971e6$var$globalState$$1.pendingReactions.push(this);
            $11a86e62e4f971e6$var$runReactions$$1();
        }
    };
    Reaction$$1.prototype.isScheduled = function() {
        return this._isScheduled;
    };
    /**
     * internal, use schedule() if you intend to kick off a reaction
     */ Reaction$$1.prototype.runReaction = function() {
        if (!this.isDisposed) {
            $11a86e62e4f971e6$var$startBatch$$1();
            this._isScheduled = false;
            if ($11a86e62e4f971e6$var$shouldCompute$$1(this)) {
                this._isTrackPending = true;
                try {
                    this.onInvalidate();
                    this._isTrackPending && $11a86e62e4f971e6$var$isSpyEnabled$$1();
                } catch (e) {
                    this.reportExceptionInDerivation(e);
                }
            }
            $11a86e62e4f971e6$var$endBatch$$1();
        }
    };
    Reaction$$1.prototype.track = function(fn) {
        $11a86e62e4f971e6$var$startBatch$$1();
        var notify = $11a86e62e4f971e6$var$isSpyEnabled$$1();
        var startTime;
        this._isRunning = true;
        var result = $11a86e62e4f971e6$var$trackDerivedFunction$$1(this, fn, undefined);
        this._isRunning = false;
        this._isTrackPending = false;
        if (this.isDisposed) // disposed during last run. Clean up everything that was bound after the dispose call.
        $11a86e62e4f971e6$var$clearObserving$$1(this);
        if ($11a86e62e4f971e6$var$isCaughtException$$1(result)) this.reportExceptionInDerivation(result.cause);
        $11a86e62e4f971e6$var$endBatch$$1();
    };
    Reaction$$1.prototype.reportExceptionInDerivation = function(error) {
        var _this = this;
        if (this.errorHandler) {
            this.errorHandler(error, this);
            return;
        }
        if ($11a86e62e4f971e6$var$globalState$$1.disableErrorBoundaries) throw error;
        var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
        if ($11a86e62e4f971e6$var$globalState$$1.suppressReactionErrors) console.warn("[mobx] (error in reaction '" + this.name + "' suppressed, fix error of causing action below)"); // prettier-ignore
        else console.error(message, error);
        if ($11a86e62e4f971e6$var$isSpyEnabled$$1()) $11a86e62e4f971e6$var$spyReport$$1({
            type: "error",
            name: this.name,
            message: message,
            error: "" + error
        });
        $11a86e62e4f971e6$var$globalState$$1.globalReactionErrorHandlers.forEach(function(f) {
            return f(error, _this);
        });
    };
    Reaction$$1.prototype.dispose = function() {
        if (!this.isDisposed) {
            this.isDisposed = true;
            if (!this._isRunning) {
                // if disposed while running, clean up later. Maybe not optimal, but rare case
                $11a86e62e4f971e6$var$startBatch$$1();
                $11a86e62e4f971e6$var$clearObserving$$1(this);
                $11a86e62e4f971e6$var$endBatch$$1();
            }
        }
    };
    Reaction$$1.prototype.getDisposer = function() {
        var r = this.dispose.bind(this);
        r[$11a86e62e4f971e6$export$f246528900dd4467] = this;
        return r;
    };
    Reaction$$1.prototype.toString = function() {
        return "Reaction[" + this.name + "]";
    };
    Reaction$$1.prototype.trace = function(enterBreakPoint) {
        if (enterBreakPoint === void 0) enterBreakPoint = false;
        $11a86e62e4f971e6$export$357889f174732d38(this, enterBreakPoint);
    };
    return Reaction$$1;
}();
function $11a86e62e4f971e6$export$d7203a53b5e117e4(handler) {
    $11a86e62e4f971e6$var$globalState$$1.globalReactionErrorHandlers.push(handler);
    return function() {
        var idx = $11a86e62e4f971e6$var$globalState$$1.globalReactionErrorHandlers.indexOf(handler);
        if (idx >= 0) $11a86e62e4f971e6$var$globalState$$1.globalReactionErrorHandlers.splice(idx, 1);
    };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */ var $11a86e62e4f971e6$var$MAX_REACTION_ITERATIONS = 100;
var $11a86e62e4f971e6$var$reactionScheduler = function(f) {
    return f();
};
function $11a86e62e4f971e6$var$runReactions$$1() {
    // Trampolining, if runReactions are already running, new reactions will be picked up
    if ($11a86e62e4f971e6$var$globalState$$1.inBatch > 0 || $11a86e62e4f971e6$var$globalState$$1.isRunningReactions) return;
    $11a86e62e4f971e6$var$reactionScheduler($11a86e62e4f971e6$var$runReactionsHelper);
}
function $11a86e62e4f971e6$var$runReactionsHelper() {
    $11a86e62e4f971e6$var$globalState$$1.isRunningReactions = true;
    var allReactions = $11a86e62e4f971e6$var$globalState$$1.pendingReactions;
    var iterations = 0;
    // While running reactions, new reactions might be triggered.
    // Hence we work with two variables and check whether
    // we converge to no remaining reactions after a while.
    while(allReactions.length > 0){
        if (++iterations === $11a86e62e4f971e6$var$MAX_REACTION_ITERATIONS) {
            console.error("Reaction doesn't converge to a stable state after " + $11a86e62e4f971e6$var$MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]));
            allReactions.splice(0); // clear reactions
        }
        var remainingReactions = allReactions.splice(0);
        for(var i = 0, l = remainingReactions.length; i < l; i++)remainingReactions[i].runReaction();
    }
    $11a86e62e4f971e6$var$globalState$$1.isRunningReactions = false;
}
var $11a86e62e4f971e6$var$isReaction$$1 = $11a86e62e4f971e6$var$createInstanceofPredicate$$1("Reaction", $11a86e62e4f971e6$export$d2ae4167a30cf6bb);
function $11a86e62e4f971e6$var$setReactionScheduler$$1(fn) {
    var baseScheduler = $11a86e62e4f971e6$var$reactionScheduler;
    $11a86e62e4f971e6$var$reactionScheduler = function(f) {
        return fn(function() {
            return baseScheduler(f);
        });
    };
}
function $11a86e62e4f971e6$var$isSpyEnabled$$1() {
    return false;
}
function $11a86e62e4f971e6$var$spyReport$$1(event) {
    var listeners, i, l;
    return; // dead code elimination can do the rest
}
function $11a86e62e4f971e6$var$spyReportStart$$1(event) {
    var change;
    return;
}
var $11a86e62e4f971e6$var$END_EVENT = {
    spyReportEnd: true
};
function $11a86e62e4f971e6$var$spyReportEnd$$1(change) {
    return;
}
function $11a86e62e4f971e6$export$fcc0cd19e9fb2b4c(listener) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {};
}
function $11a86e62e4f971e6$var$dontReassignFields() {
    $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$var$namedActionDecorator$$1(name) {
    return function(target, prop, descriptor) {
        if (descriptor) {
            // babel / typescript
            // @action method() { }
            if (descriptor.value) // typescript
            return {
                value: $11a86e62e4f971e6$var$createAction$$1(name, descriptor.value),
                enumerable: false,
                configurable: true,
                writable: true // for typescript, this must be writable, otherwise it cannot inherit :/ (see inheritable actions test)
            };
            // babel only: @action method = () => {}
            var initializer_1 = descriptor.initializer;
            return {
                enumerable: false,
                configurable: true,
                writable: true,
                initializer: function() {
                    // N.B: we can't immediately invoke initializer; this would be wrong
                    return $11a86e62e4f971e6$var$createAction$$1(name, initializer_1.call(this));
                }
            };
        }
        // bound instance methods
        return $11a86e62e4f971e6$var$actionFieldDecorator$$1(name).apply(this, arguments);
    };
}
function $11a86e62e4f971e6$var$actionFieldDecorator$$1(name) {
    // Simple property that writes on first invocation to the current instance
    return function(target, prop, descriptor) {
        Object.defineProperty(target, prop, {
            configurable: true,
            enumerable: false,
            get: function() {
                return undefined;
            },
            set: function(value) {
                $11a86e62e4f971e6$var$addHiddenProp$$1(this, prop, $11a86e62e4f971e6$export$31eb53bd5b582a97(name, value));
            }
        });
    };
}
function $11a86e62e4f971e6$var$boundActionDecorator$$1(target, propertyName, descriptor, applyToInstance) {
    if (applyToInstance === true) {
        $11a86e62e4f971e6$var$defineBoundAction$$1(target, propertyName, descriptor.value);
        return null;
    }
    if (descriptor) // if (descriptor.value)
    // Typescript / Babel: @action.bound method() { }
    // also: babel @action.bound method = () => {}
    return {
        configurable: true,
        enumerable: false,
        get: function() {
            $11a86e62e4f971e6$var$defineBoundAction$$1(this, propertyName, descriptor.value || descriptor.initializer.call(this));
            return this[propertyName];
        },
        set: $11a86e62e4f971e6$var$dontReassignFields
    };
    // field decorator Typescript @action.bound method = () => {}
    return {
        enumerable: false,
        configurable: true,
        set: function(v) {
            $11a86e62e4f971e6$var$defineBoundAction$$1(this, propertyName, v);
        },
        get: function() {
            return undefined;
        }
    };
}
var $11a86e62e4f971e6$export$31eb53bd5b582a97 = function action$$1(arg1, arg2, arg3, arg4) {
    // action(fn() {})
    if (arguments.length === 1 && typeof arg1 === "function") return $11a86e62e4f971e6$var$createAction$$1(arg1.name || "<unnamed action>", arg1);
    // action("name", fn() {})
    if (arguments.length === 2 && typeof arg2 === "function") return $11a86e62e4f971e6$var$createAction$$1(arg1, arg2);
    // @action("name") fn() {}
    if (arguments.length === 1 && typeof arg1 === "string") return $11a86e62e4f971e6$var$namedActionDecorator$$1(arg1);
    // @action fn() {}
    if (arg4 === true) // apply to instance immediately
    $11a86e62e4f971e6$var$addHiddenProp$$1(arg1, arg2, $11a86e62e4f971e6$var$createAction$$1(arg1.name || arg2, arg3.value));
    else return $11a86e62e4f971e6$var$namedActionDecorator$$1(arg2).apply(null, arguments);
};
$11a86e62e4f971e6$export$31eb53bd5b582a97.bound = $11a86e62e4f971e6$var$boundActionDecorator$$1;
function $11a86e62e4f971e6$export$f443e47852576b4f(arg1, arg2) {
    var actionName = typeof arg1 === "string" ? arg1 : arg1.name || "<unnamed action>";
    var fn = typeof arg1 === "function" ? arg1 : arg2;
    return $11a86e62e4f971e6$var$executeAction$$1(actionName, fn, this, undefined);
}
function $11a86e62e4f971e6$export$b956e38827fca970(thing) {
    return typeof thing === "function" && thing.isMobxAction === true;
}
function $11a86e62e4f971e6$var$defineBoundAction$$1(target, propertyName, fn) {
    $11a86e62e4f971e6$var$addHiddenProp$$1(target, propertyName, $11a86e62e4f971e6$var$createAction$$1(propertyName, fn.bind(target)));
}
/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */ function $11a86e62e4f971e6$export$4abd31caebb0bb24(view, opts) {
    if (opts === void 0) opts = $11a86e62e4f971e6$var$EMPTY_OBJECT$$1;
    var name = opts && opts.name || view.name || "Autorun@" + $11a86e62e4f971e6$var$getNextId$$1();
    var runSync = !opts.scheduler && !opts.delay;
    var reaction$$1;
    if (runSync) // normal autorun
    reaction$$1 = new $11a86e62e4f971e6$export$d2ae4167a30cf6bb(name, function() {
        this.track(reactionRunner);
    }, opts.onError);
    else {
        var scheduler_1 = $11a86e62e4f971e6$var$createSchedulerFromOptions(opts);
        // debounced autorun
        var isScheduled_1 = false;
        reaction$$1 = new $11a86e62e4f971e6$export$d2ae4167a30cf6bb(name, function() {
            if (!isScheduled_1) {
                isScheduled_1 = true;
                scheduler_1(function() {
                    isScheduled_1 = false;
                    if (!reaction$$1.isDisposed) reaction$$1.track(reactionRunner);
                });
            }
        }, opts.onError);
    }
    function reactionRunner() {
        view(reaction$$1);
    }
    reaction$$1.schedule();
    return reaction$$1.getDisposer();
}
var $11a86e62e4f971e6$var$run = function(f) {
    return f();
};
function $11a86e62e4f971e6$var$createSchedulerFromOptions(opts) {
    return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {
        return setTimeout(f, opts.delay);
    } : $11a86e62e4f971e6$var$run;
}
function $11a86e62e4f971e6$export$7203b476385689ae(expression, effect, opts) {
    if (opts === void 0) opts = $11a86e62e4f971e6$var$EMPTY_OBJECT$$1;
    var name = opts.name || "Reaction@" + $11a86e62e4f971e6$var$getNextId$$1();
    var effectAction = $11a86e62e4f971e6$export$31eb53bd5b582a97(name, opts.onError ? $11a86e62e4f971e6$var$wrapErrorHandler(opts.onError, effect) : effect);
    var runSync = !opts.scheduler && !opts.delay;
    var scheduler = $11a86e62e4f971e6$var$createSchedulerFromOptions(opts);
    var firstTime = true;
    var isScheduled = false;
    var value;
    var equals = opts.compareStructural ? $11a86e62e4f971e6$export$d9328cbeeb64e882.structural : opts.equals || $11a86e62e4f971e6$export$d9328cbeeb64e882.default;
    var r = new $11a86e62e4f971e6$export$d2ae4167a30cf6bb(name, function() {
        if (firstTime || runSync) reactionRunner();
        else if (!isScheduled) {
            isScheduled = true;
            scheduler(reactionRunner);
        }
    }, opts.onError);
    function reactionRunner() {
        isScheduled = false; // Q: move into reaction runner?
        if (r.isDisposed) return;
        var changed = false;
        r.track(function() {
            var nextValue = expression(r);
            changed = firstTime || !equals(value, nextValue);
            value = nextValue;
        });
        if (firstTime && opts.fireImmediately) effectAction(value, r);
        if (!firstTime && changed === true) effectAction(value, r);
        if (firstTime) firstTime = false;
    }
    r.schedule();
    return r.getDisposer();
}
function $11a86e62e4f971e6$var$wrapErrorHandler(errorHandler, baseFn) {
    return function() {
        try {
            return baseFn.apply(this, arguments);
        } catch (e) {
            errorHandler.call(this, e);
        }
    };
}
function $11a86e62e4f971e6$export$24d7f9cdf0de2679(thing, arg2, arg3) {
    return $11a86e62e4f971e6$var$interceptHook("onBecomeObserved", thing, arg2, arg3);
}
function $11a86e62e4f971e6$export$f8586f6f22b9cba9(thing, arg2, arg3) {
    return $11a86e62e4f971e6$var$interceptHook("onBecomeUnobserved", thing, arg2, arg3);
}
function $11a86e62e4f971e6$var$interceptHook(hook, thing, arg2, arg3) {
    var atom = typeof arg2 === "string" ? $11a86e62e4f971e6$export$25fc416d10fa1afa(thing, arg2) : $11a86e62e4f971e6$export$25fc416d10fa1afa(thing);
    var cb = typeof arg2 === "string" ? arg3 : arg2;
    var listenersKey = hook + "Listeners";
    if (atom[listenersKey]) atom[listenersKey].add(cb);
    else atom[listenersKey] = new Set([
        cb
    ]);
    var orig = atom[hook];
    if (typeof orig !== "function") return $11a86e62e4f971e6$var$fail$$1(false);
    return function() {
        var hookListeners = atom[listenersKey];
        if (hookListeners) {
            hookListeners.delete(cb);
            if (hookListeners.size === 0) delete atom[listenersKey];
        }
    };
}
function $11a86e62e4f971e6$export$8d21e34596265fa2(options) {
    var enforceActions = options.enforceActions, computedRequiresReaction = options.computedRequiresReaction, disableErrorBoundaries = options.disableErrorBoundaries, reactionScheduler = options.reactionScheduler;
    if (options.isolateGlobalState === true) $11a86e62e4f971e6$var$isolateGlobalState$$1();
    if (enforceActions !== undefined) {
        if (typeof enforceActions === "boolean" || enforceActions === "strict") $11a86e62e4f971e6$var$deprecated$$1("Deprecated value for 'enforceActions', use 'false' => '\"never\"', 'true' => '\"observed\"', '\"strict\"' => \"'always'\" instead");
        var ea = void 0;
        switch(enforceActions){
            case true:
            case "observed":
                ea = true;
                break;
            case false:
            case "never":
                ea = false;
                break;
            case "strict":
            case "always":
                ea = "strict";
                break;
            default:
                $11a86e62e4f971e6$var$fail$$1("Invalid value for 'enforceActions': '" + enforceActions + "', expected 'never', 'always' or 'observed'");
        }
        $11a86e62e4f971e6$var$globalState$$1.enforceActions = ea;
        $11a86e62e4f971e6$var$globalState$$1.allowStateChanges = ea === true || ea === "strict" ? false : true;
    }
    if (computedRequiresReaction !== undefined) $11a86e62e4f971e6$var$globalState$$1.computedRequiresReaction = !!computedRequiresReaction;
    if (disableErrorBoundaries !== undefined) {
        if (disableErrorBoundaries === true) console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
        $11a86e62e4f971e6$var$globalState$$1.disableErrorBoundaries = !!disableErrorBoundaries;
    }
    if (reactionScheduler) $11a86e62e4f971e6$var$setReactionScheduler$$1(reactionScheduler);
}
function $11a86e62e4f971e6$export$c80826d3392ea781(thing, decorators) {
    var target = typeof thing === "function" ? thing.prototype : thing;
    var _loop_1 = function(prop) {
        var propertyDecorators = decorators[prop];
        if (!Array.isArray(propertyDecorators)) propertyDecorators = [
            propertyDecorators
        ];
        var descriptor = Object.getOwnPropertyDescriptor(target, prop);
        var newDescriptor = propertyDecorators.reduce(function(accDescriptor, decorator) {
            return decorator(target, prop, accDescriptor);
        }, descriptor);
        if (newDescriptor) Object.defineProperty(target, prop, newDescriptor);
    };
    for(var prop in decorators)_loop_1(prop);
    return thing;
}
function $11a86e62e4f971e6$export$59d8134e963031bd(target, properties, decorators, options) {
    options = $11a86e62e4f971e6$var$asCreateObservableOptions$$1(options);
    var defaultDecorator = $11a86e62e4f971e6$var$getDefaultDecoratorFromObjectOptions$$1(options);
    $11a86e62e4f971e6$var$initializeInstance$$1(target); // Fixes #1740
    $11a86e62e4f971e6$var$asObservableObject$$1(target, options.name, defaultDecorator.enhancer); // make sure object is observable, even without initial props
    if (properties) $11a86e62e4f971e6$var$extendObservableObjectWithProperties$$1(target, properties, decorators, defaultDecorator);
    return target;
}
function $11a86e62e4f971e6$var$getDefaultDecoratorFromObjectOptions$$1(options) {
    return options.defaultDecorator || (options.deep === false ? $11a86e62e4f971e6$var$refDecorator$$1 : $11a86e62e4f971e6$var$deepDecorator$$1);
}
function $11a86e62e4f971e6$var$extendObservableObjectWithProperties$$1(target, properties, decorators, defaultDecorator) {
    var key;
    $11a86e62e4f971e6$var$startBatch$$1();
    try {
        for(var key in properties){
            var descriptor = Object.getOwnPropertyDescriptor(properties, key);
            var decorator = decorators && key in decorators ? decorators[key] : descriptor.get ? $11a86e62e4f971e6$var$computedDecorator$$1 : defaultDecorator;
            var resultDescriptor = decorator(target, key, descriptor, true);
            if (resultDescriptor // otherwise, assume already applied, due to `applyToInstance`
            ) Object.defineProperty(target, key, resultDescriptor);
        }
    } finally{
        $11a86e62e4f971e6$var$endBatch$$1();
    }
}
function $11a86e62e4f971e6$export$23fbf90e5d80a5ee(thing, property) {
    return $11a86e62e4f971e6$var$nodeToDependencyTree($11a86e62e4f971e6$export$25fc416d10fa1afa(thing, property));
}
function $11a86e62e4f971e6$var$nodeToDependencyTree(node) {
    var result = {
        name: node.name
    };
    if (node.observing && node.observing.length > 0) result.dependencies = $11a86e62e4f971e6$var$unique$$1(node.observing).map($11a86e62e4f971e6$var$nodeToDependencyTree);
    return result;
}
function $11a86e62e4f971e6$export$3b1621dddf5aeacd(thing, property) {
    return $11a86e62e4f971e6$var$nodeToObserverTree($11a86e62e4f971e6$export$25fc416d10fa1afa(thing, property));
}
function $11a86e62e4f971e6$var$nodeToObserverTree(node) {
    var result = {
        name: node.name
    };
    if ($11a86e62e4f971e6$var$hasObservers$$1(node)) result.observers = Array.from($11a86e62e4f971e6$var$getObservers$$1(node)).map($11a86e62e4f971e6$var$nodeToObserverTree);
    return result;
}
var $11a86e62e4f971e6$var$generatorId = 0;
function $11a86e62e4f971e6$export$ccc7b0636abaffc3(generator) {
    if (arguments.length !== 1) $11a86e62e4f971e6$var$fail$$1("Flow expects one 1 argument and cannot be used as decorator");
    var name = generator.name || "<unnamed flow>";
    // Implementation based on https://github.com/tj/co/blob/master/index.js
    return function() {
        var ctx = this;
        var args = arguments;
        var runId = ++$11a86e62e4f971e6$var$generatorId;
        var gen = $11a86e62e4f971e6$export$31eb53bd5b582a97(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
        var rejector;
        var pendingPromise = undefined;
        var promise = new Promise(function(resolve, reject) {
            var stepId = 0;
            rejector = reject;
            function onFulfilled(res) {
                pendingPromise = undefined;
                var ret;
                try {
                    ret = $11a86e62e4f971e6$export$31eb53bd5b582a97(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
                } catch (e) {
                    return reject(e);
                }
                next(ret);
            }
            function onRejected(err) {
                pendingPromise = undefined;
                var ret;
                try {
                    ret = $11a86e62e4f971e6$export$31eb53bd5b582a97(name + " - runid: " + runId + " - yield " + stepId++, gen.throw).call(gen, err);
                } catch (e) {
                    return reject(e);
                }
                next(ret);
            }
            function next(ret) {
                if (ret && typeof ret.then === "function") {
                    // an async iterator
                    ret.then(next, reject);
                    return;
                }
                if (ret.done) return resolve(ret.value);
                pendingPromise = Promise.resolve(ret.value);
                return pendingPromise.then(onFulfilled, onRejected);
            }
            onFulfilled(undefined); // kick off the process
        });
        promise.cancel = $11a86e62e4f971e6$export$31eb53bd5b582a97(name + " - runid: " + runId + " - cancel", function() {
            try {
                if (pendingPromise) $11a86e62e4f971e6$var$cancelPromise(pendingPromise);
                // Finally block can return (or yield) stuff..
                var res = gen.return();
                // eat anything that promise would do, it's cancelled!
                var yieldedPromise = Promise.resolve(res.value);
                yieldedPromise.then($11a86e62e4f971e6$var$noop$$1, $11a86e62e4f971e6$var$noop$$1);
                $11a86e62e4f971e6$var$cancelPromise(yieldedPromise); // maybe it can be cancelled :)
                // reject our original promise
                rejector(new Error("FLOW_CANCELLED"));
            } catch (e) {
                rejector(e); // there could be a throwing finally block
            }
        });
        return promise;
    };
}
function $11a86e62e4f971e6$var$cancelPromise(promise) {
    if (typeof promise.cancel === "function") promise.cancel();
}
function $11a86e62e4f971e6$export$bf4da824ef9b40d0(thing, propOrHandler, handler) {
    var target;
    if ($11a86e62e4f971e6$export$27a7faddcfd44960(thing) || $11a86e62e4f971e6$export$f5afceff386badf9(thing) || $11a86e62e4f971e6$export$fafbc00dbefd1aef(thing)) target = $11a86e62e4f971e6$export$71ff639cb8b2a36e(thing);
    else if ($11a86e62e4f971e6$export$31960fb081a18155(thing)) {
        if (typeof propOrHandler !== "string") return $11a86e62e4f971e6$var$fail$$1(false);
        target = $11a86e62e4f971e6$export$71ff639cb8b2a36e(thing, propOrHandler);
    } else return $11a86e62e4f971e6$var$fail$$1(false);
    if (target.dehancer !== undefined) return $11a86e62e4f971e6$var$fail$$1(false);
    target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
    return function() {
        target.dehancer = undefined;
    };
}
function $11a86e62e4f971e6$export$ab0f802c05dd969b(thing, propOrHandler, handler) {
    if (typeof handler === "function") return $11a86e62e4f971e6$var$interceptProperty(thing, propOrHandler, handler);
    else return $11a86e62e4f971e6$var$interceptInterceptable(thing, propOrHandler);
}
function $11a86e62e4f971e6$var$interceptInterceptable(thing, handler) {
    return $11a86e62e4f971e6$export$71ff639cb8b2a36e(thing).intercept(handler);
}
function $11a86e62e4f971e6$var$interceptProperty(thing, property, handler) {
    return $11a86e62e4f971e6$export$71ff639cb8b2a36e(thing, property).intercept(handler);
}
function $11a86e62e4f971e6$var$_isComputed$$1(value, property) {
    if (value === null || value === undefined) return false;
    if (property !== undefined) {
        if ($11a86e62e4f971e6$export$31960fb081a18155(value) === false) return false;
        if (!value[$11a86e62e4f971e6$export$f246528900dd4467].values.has(property)) return false;
        var atom = $11a86e62e4f971e6$export$25fc416d10fa1afa(value, property);
        return $11a86e62e4f971e6$var$isComputedValue$$1(atom);
    }
    return $11a86e62e4f971e6$var$isComputedValue$$1(value);
}
function $11a86e62e4f971e6$export$21bb8b7af2417cc3(value) {
    if (arguments.length > 1) return $11a86e62e4f971e6$var$fail$$1(false);
    return $11a86e62e4f971e6$var$_isComputed$$1(value);
}
function $11a86e62e4f971e6$export$3cf701ab9f66d86a(value, propName) {
    if (typeof propName !== "string") return $11a86e62e4f971e6$var$fail$$1(false);
    return $11a86e62e4f971e6$var$_isComputed$$1(value, propName);
}
function $11a86e62e4f971e6$var$_isObservable(value, property) {
    if (value === null || value === undefined) return false;
    if (property !== undefined) {
        if ($11a86e62e4f971e6$export$31960fb081a18155(value)) return value[$11a86e62e4f971e6$export$f246528900dd4467].values.has(property);
        return false;
    }
    // For first check, see #701
    return $11a86e62e4f971e6$export$31960fb081a18155(value) || !!value[$11a86e62e4f971e6$export$f246528900dd4467] || $11a86e62e4f971e6$var$isAtom$$1(value) || $11a86e62e4f971e6$var$isReaction$$1(value) || $11a86e62e4f971e6$var$isComputedValue$$1(value);
}
function $11a86e62e4f971e6$export$5cd057a6046189f9(value) {
    if (arguments.length !== 1) $11a86e62e4f971e6$var$fail$$1(false);
    return $11a86e62e4f971e6$var$_isObservable(value);
}
function $11a86e62e4f971e6$export$7ad7acc949ba3cc7(value, propName) {
    if (typeof propName !== "string") return $11a86e62e4f971e6$var$fail$$1(false);
    return $11a86e62e4f971e6$var$_isObservable(value, propName);
}
function $11a86e62e4f971e6$export$ed97f33186d4b816(obj) {
    if ($11a86e62e4f971e6$export$31960fb081a18155(obj)) return obj[$11a86e62e4f971e6$export$f246528900dd4467].getKeys();
    if ($11a86e62e4f971e6$export$27a7faddcfd44960(obj)) return Array.from(obj.keys());
    if ($11a86e62e4f971e6$export$da6b063694cb52c1(obj)) return Array.from(obj.keys());
    if ($11a86e62e4f971e6$export$f5afceff386badf9(obj)) return obj.map(function(_, index) {
        return index;
    });
    return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$68c286be0e7e55b7(obj) {
    if ($11a86e62e4f971e6$export$31960fb081a18155(obj)) return $11a86e62e4f971e6$export$ed97f33186d4b816(obj).map(function(key) {
        return obj[key];
    });
    if ($11a86e62e4f971e6$export$27a7faddcfd44960(obj)) return $11a86e62e4f971e6$export$ed97f33186d4b816(obj).map(function(key) {
        return obj.get(key);
    });
    if ($11a86e62e4f971e6$export$da6b063694cb52c1(obj)) return Array.from(obj.values());
    if ($11a86e62e4f971e6$export$f5afceff386badf9(obj)) return obj.slice();
    return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$3e9f948b41964866(obj) {
    if ($11a86e62e4f971e6$export$31960fb081a18155(obj)) return $11a86e62e4f971e6$export$ed97f33186d4b816(obj).map(function(key) {
        return [
            key,
            obj[key]
        ];
    });
    if ($11a86e62e4f971e6$export$27a7faddcfd44960(obj)) return $11a86e62e4f971e6$export$ed97f33186d4b816(obj).map(function(key) {
        return [
            key,
            obj.get(key)
        ];
    });
    if ($11a86e62e4f971e6$export$da6b063694cb52c1(obj)) return Array.from(obj.entries());
    if ($11a86e62e4f971e6$export$f5afceff386badf9(obj)) return obj.map(function(key, index) {
        return [
            index,
            key
        ];
    });
    return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$adaa4cf7ef1b65be(obj, key, value) {
    if (arguments.length === 2) {
        $11a86e62e4f971e6$var$startBatch$$1();
        var values_1 = key;
        try {
            for(var key_1 in values_1)$11a86e62e4f971e6$export$adaa4cf7ef1b65be(obj, key_1, values_1[key_1]);
        } finally{
            $11a86e62e4f971e6$var$endBatch$$1();
        }
        return;
    }
    if ($11a86e62e4f971e6$export$31960fb081a18155(obj)) {
        var adm = obj[$11a86e62e4f971e6$export$f246528900dd4467];
        var existingObservable = adm.values.get(key);
        if (existingObservable) adm.write(key, value);
        else adm.addObservableProp(key, value, adm.defaultEnhancer);
    } else if ($11a86e62e4f971e6$export$27a7faddcfd44960(obj)) obj.set(key, value);
    else if ($11a86e62e4f971e6$export$f5afceff386badf9(obj)) {
        if (typeof key !== "number") key = parseInt(key, 10);
        $11a86e62e4f971e6$var$invariant$$1(key >= 0, "Not a valid index: '" + key + "'");
        $11a86e62e4f971e6$var$startBatch$$1();
        if (key >= obj.length) obj.length = key + 1;
        obj[key] = value;
        $11a86e62e4f971e6$var$endBatch$$1();
    } else return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$cd7f480d6b8286c3(obj, key) {
    if ($11a86e62e4f971e6$export$31960fb081a18155(obj)) obj[$11a86e62e4f971e6$export$f246528900dd4467].remove(key);
    else if ($11a86e62e4f971e6$export$27a7faddcfd44960(obj)) obj.delete(key);
    else if ($11a86e62e4f971e6$export$da6b063694cb52c1(obj)) obj.delete(key);
    else if ($11a86e62e4f971e6$export$f5afceff386badf9(obj)) {
        if (typeof key !== "number") key = parseInt(key, 10);
        $11a86e62e4f971e6$var$invariant$$1(key >= 0, "Not a valid index: '" + key + "'");
        obj.splice(key, 1);
    } else return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$a4f4bb6b1453fff5(obj, key) {
    if ($11a86e62e4f971e6$export$31960fb081a18155(obj)) {
        // return keys(obj).indexOf(key) >= 0
        var adm = $11a86e62e4f971e6$export$71ff639cb8b2a36e(obj);
        return adm.has(key);
    } else if ($11a86e62e4f971e6$export$27a7faddcfd44960(obj)) return obj.has(key);
    else if ($11a86e62e4f971e6$export$da6b063694cb52c1(obj)) return obj.has(key);
    else if ($11a86e62e4f971e6$export$f5afceff386badf9(obj)) return key >= 0 && key < obj.length;
    else return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$3988ae62b71be9a3(obj, key) {
    if (!$11a86e62e4f971e6$export$a4f4bb6b1453fff5(obj, key)) return undefined;
    if ($11a86e62e4f971e6$export$31960fb081a18155(obj)) return obj[key];
    else if ($11a86e62e4f971e6$export$27a7faddcfd44960(obj)) return obj.get(key);
    else if ($11a86e62e4f971e6$export$f5afceff386badf9(obj)) return obj[key];
    else return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$d1203567a167490e(thing, propOrCb, cbOrFire, fireImmediately) {
    if (typeof cbOrFire === "function") return $11a86e62e4f971e6$var$observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
    else return $11a86e62e4f971e6$var$observeObservable(thing, propOrCb, cbOrFire);
}
function $11a86e62e4f971e6$var$observeObservable(thing, listener, fireImmediately) {
    return $11a86e62e4f971e6$export$71ff639cb8b2a36e(thing).observe(listener, fireImmediately);
}
function $11a86e62e4f971e6$var$observeObservableProperty(thing, property, listener, fireImmediately) {
    return $11a86e62e4f971e6$export$71ff639cb8b2a36e(thing, property).observe(listener, fireImmediately);
}
var $11a86e62e4f971e6$var$defaultOptions = {
    detectCycles: true,
    exportMapsAsObjects: true,
    recurseEverything: false
};
function $11a86e62e4f971e6$var$cache(map, key, value, options) {
    if (options.detectCycles) map.set(key, value);
    return value;
}
function $11a86e62e4f971e6$var$toJSHelper(source, options, __alreadySeen) {
    if (!options.recurseEverything && !$11a86e62e4f971e6$export$5cd057a6046189f9(source)) return source;
    if (typeof source !== "object") return source;
    // Directly return null if source is null
    if (source === null) return null;
    // Directly return the Date object itself if contained in the observable
    if (source instanceof Date) return source;
    if ($11a86e62e4f971e6$export$fafbc00dbefd1aef(source)) return $11a86e62e4f971e6$var$toJSHelper(source.get(), options, __alreadySeen);
    // make sure we track the keys of the object
    if ($11a86e62e4f971e6$export$5cd057a6046189f9(source)) $11a86e62e4f971e6$export$ed97f33186d4b816(source);
    var detectCycles = options.detectCycles === true;
    if (detectCycles && source !== null && __alreadySeen.has(source)) return __alreadySeen.get(source);
    if ($11a86e62e4f971e6$export$f5afceff386badf9(source) || Array.isArray(source)) {
        var res_1 = $11a86e62e4f971e6$var$cache(__alreadySeen, source, [], options);
        var toAdd = source.map(function(value) {
            return $11a86e62e4f971e6$var$toJSHelper(value, options, __alreadySeen);
        });
        res_1.length = toAdd.length;
        for(var i = 0, l = toAdd.length; i < l; i++)res_1[i] = toAdd[i];
        return res_1;
    }
    if ($11a86e62e4f971e6$export$da6b063694cb52c1(source) || Object.getPrototypeOf(source) === Set.prototype) {
        if (options.exportMapsAsObjects === false) {
            var res_2 = $11a86e62e4f971e6$var$cache(__alreadySeen, source, new Set(), options);
            source.forEach(function(value) {
                res_2.add($11a86e62e4f971e6$var$toJSHelper(value, options, __alreadySeen));
            });
            return res_2;
        } else {
            var res_3 = $11a86e62e4f971e6$var$cache(__alreadySeen, source, [], options);
            source.forEach(function(value) {
                res_3.push($11a86e62e4f971e6$var$toJSHelper(value, options, __alreadySeen));
            });
            return res_3;
        }
    }
    if ($11a86e62e4f971e6$export$27a7faddcfd44960(source) || Object.getPrototypeOf(source) === Map.prototype) {
        if (options.exportMapsAsObjects === false) {
            var res_4 = $11a86e62e4f971e6$var$cache(__alreadySeen, source, new Map(), options);
            source.forEach(function(value, key) {
                res_4.set(key, $11a86e62e4f971e6$var$toJSHelper(value, options, __alreadySeen));
            });
            return res_4;
        } else {
            var res_5 = $11a86e62e4f971e6$var$cache(__alreadySeen, source, {}, options);
            source.forEach(function(value, key) {
                res_5[key] = $11a86e62e4f971e6$var$toJSHelper(value, options, __alreadySeen);
            });
            return res_5;
        }
    }
    // Fallback to the situation that source is an ObservableObject or a plain object
    var res = $11a86e62e4f971e6$var$cache(__alreadySeen, source, {}, options);
    for(var key in source)res[key] = $11a86e62e4f971e6$var$toJSHelper(source[key], options, __alreadySeen);
    return res;
}
function $11a86e62e4f971e6$export$f08965dd1304d490(source, options) {
    // backward compatibility
    if (typeof options === "boolean") options = {
        detectCycles: options
    };
    if (!options) options = $11a86e62e4f971e6$var$defaultOptions;
    options.detectCycles = options.detectCycles === undefined ? options.recurseEverything === true : options.detectCycles === true;
    var __alreadySeen;
    if (options.detectCycles) __alreadySeen = new Map();
    return $11a86e62e4f971e6$var$toJSHelper(source, options, __alreadySeen);
}
function $11a86e62e4f971e6$export$357889f174732d38() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var enterBreakPoint = false;
    if (typeof args[args.length - 1] === "boolean") enterBreakPoint = args.pop();
    var derivation = $11a86e62e4f971e6$var$getAtomFromArgs(args);
    if (!derivation) return $11a86e62e4f971e6$var$fail$$1(false);
    if (derivation.isTracing === $11a86e62e4f971e6$var$TraceMode$$1.NONE) console.log("[mobx.trace] '" + derivation.name + "' tracing enabled");
    derivation.isTracing = enterBreakPoint ? $11a86e62e4f971e6$var$TraceMode$$1.BREAK : $11a86e62e4f971e6$var$TraceMode$$1.LOG;
}
function $11a86e62e4f971e6$var$getAtomFromArgs(args) {
    switch(args.length){
        case 0:
            return $11a86e62e4f971e6$var$globalState$$1.trackingDerivation;
        case 1:
            return $11a86e62e4f971e6$export$25fc416d10fa1afa(args[0]);
        case 2:
            return $11a86e62e4f971e6$export$25fc416d10fa1afa(args[0], args[1]);
    }
}
/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */ function $11a86e62e4f971e6$export$2d62d2646dd2fb3c(action$$1, thisArg) {
    if (thisArg === void 0) thisArg = undefined;
    $11a86e62e4f971e6$var$startBatch$$1();
    try {
        return action$$1.apply(thisArg);
    } finally{
        $11a86e62e4f971e6$var$endBatch$$1();
    }
}
function $11a86e62e4f971e6$export$a55877ca9db47377(predicate, arg1, arg2) {
    if (arguments.length === 1 || arg1 && typeof arg1 === "object") return $11a86e62e4f971e6$var$whenPromise(predicate, arg1);
    return $11a86e62e4f971e6$var$_when(predicate, arg1, arg2 || {});
}
function $11a86e62e4f971e6$var$_when(predicate, effect, opts) {
    var timeoutHandle;
    if (typeof opts.timeout === "number") timeoutHandle = setTimeout(function() {
        if (!disposer[$11a86e62e4f971e6$export$f246528900dd4467].isDisposed) {
            disposer();
            var error = new Error("WHEN_TIMEOUT");
            if (opts.onError) opts.onError(error);
            else throw error;
        }
    }, opts.timeout);
    opts.name = opts.name || "When@" + $11a86e62e4f971e6$var$getNextId$$1();
    var effectAction = $11a86e62e4f971e6$var$createAction$$1(opts.name + "-effect", effect);
    var disposer = $11a86e62e4f971e6$export$4abd31caebb0bb24(function(r) {
        if (predicate()) {
            r.dispose();
            if (timeoutHandle) clearTimeout(timeoutHandle);
            effectAction();
        }
    }, opts);
    return disposer;
}
function $11a86e62e4f971e6$var$whenPromise(predicate, opts) {
    var cancel;
    var res = new Promise(function(resolve, reject) {
        var disposer = $11a86e62e4f971e6$var$_when(predicate, resolve, $11a86e62e4f971e6$var$__assign({}, opts, {
            onError: reject
        }));
        cancel = function() {
            disposer();
            reject("WHEN_CANCELLED");
        };
    });
    res.cancel = cancel;
    return res;
}
function $11a86e62e4f971e6$var$getAdm(target) {
    return target[$11a86e62e4f971e6$export$f246528900dd4467];
}
// Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
// and skip either the internal values map, or the base object with its property descriptors!
var $11a86e62e4f971e6$var$objectProxyTraps = {
    has: function(target, name) {
        if (name === $11a86e62e4f971e6$export$f246528900dd4467 || name === "constructor" || name === $11a86e62e4f971e6$var$mobxDidRunLazyInitializersSymbol$$1) return true;
        var adm = $11a86e62e4f971e6$var$getAdm(target);
        // MWE: should `in` operator be reactive? If not, below code path will be faster / more memory efficient
        // TODO: check performance stats!
        // if (adm.values.get(name as string)) return true
        if (typeof name === "string") return adm.has(name);
        return name in target;
    },
    get: function(target, name) {
        if (name === $11a86e62e4f971e6$export$f246528900dd4467 || name === "constructor" || name === $11a86e62e4f971e6$var$mobxDidRunLazyInitializersSymbol$$1) return target[name];
        var adm = $11a86e62e4f971e6$var$getAdm(target);
        var observable$$1 = adm.values.get(name);
        if (observable$$1 instanceof $11a86e62e4f971e6$var$Atom$$1) {
            var result = observable$$1.get();
            if (result === undefined) // This fixes #1796, because deleting a prop that has an
            // undefined value won't retrigger a observer (no visible effect),
            // the autorun wouldn't subscribe to future key changes (see also next comment)
            adm.has(name);
            return result;
        }
        // make sure we start listening to future keys
        // note that we only do this here for optimization
        if (typeof name === "string") adm.has(name);
        return target[name];
    },
    set: function(target, name, value) {
        if (typeof name !== "string") return false;
        $11a86e62e4f971e6$export$adaa4cf7ef1b65be(target, name, value);
        return true;
    },
    deleteProperty: function(target, name) {
        if (typeof name !== "string") return false;
        var adm = $11a86e62e4f971e6$var$getAdm(target);
        adm.remove(name);
        return true;
    },
    ownKeys: function(target) {
        var adm = $11a86e62e4f971e6$var$getAdm(target);
        adm.keysAtom.reportObserved();
        return Reflect.ownKeys(target);
    },
    preventExtensions: function(target) {
        $11a86e62e4f971e6$var$fail$$1("Dynamic observable objects cannot be frozen");
        return false;
    }
};
function $11a86e62e4f971e6$var$createDynamicObservableObject$$1(base) {
    var proxy = new Proxy(base, $11a86e62e4f971e6$var$objectProxyTraps);
    base[$11a86e62e4f971e6$export$f246528900dd4467].proxy = proxy;
    return proxy;
}
function $11a86e62e4f971e6$var$hasInterceptors$$1(interceptable) {
    return interceptable.interceptors !== undefined && interceptable.interceptors.length > 0;
}
function $11a86e62e4f971e6$var$registerInterceptor$$1(interceptable, handler) {
    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);
    interceptors.push(handler);
    return $11a86e62e4f971e6$var$once$$1(function() {
        var idx = interceptors.indexOf(handler);
        if (idx !== -1) interceptors.splice(idx, 1);
    });
}
function $11a86e62e4f971e6$var$interceptChange$$1(interceptable, change) {
    var prevU = $11a86e62e4f971e6$var$untrackedStart$$1();
    try {
        var interceptors = interceptable.interceptors;
        if (interceptors) for(var i = 0, l = interceptors.length; i < l; i++){
            change = interceptors[i](change);
            $11a86e62e4f971e6$var$invariant$$1(!change || change.type, "Intercept handlers should return nothing or a change object");
            if (!change) break;
        }
        return change;
    } finally{
        $11a86e62e4f971e6$var$untrackedEnd$$1(prevU);
    }
}
function $11a86e62e4f971e6$var$hasListeners$$1(listenable) {
    return listenable.changeListeners !== undefined && listenable.changeListeners.length > 0;
}
function $11a86e62e4f971e6$var$registerListener$$1(listenable, handler) {
    var listeners = listenable.changeListeners || (listenable.changeListeners = []);
    listeners.push(handler);
    return $11a86e62e4f971e6$var$once$$1(function() {
        var idx = listeners.indexOf(handler);
        if (idx !== -1) listeners.splice(idx, 1);
    });
}
function $11a86e62e4f971e6$var$notifyListeners$$1(listenable, change) {
    var prevU = $11a86e62e4f971e6$var$untrackedStart$$1();
    var listeners = listenable.changeListeners;
    if (!listeners) return;
    listeners = listeners.slice();
    for(var i = 0, l = listeners.length; i < l; i++)listeners[i](change);
    $11a86e62e4f971e6$var$untrackedEnd$$1(prevU);
}
var $11a86e62e4f971e6$var$MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859
var $11a86e62e4f971e6$var$arrayTraps = {
    get: function(target, name) {
        if (name === $11a86e62e4f971e6$export$f246528900dd4467) return target[$11a86e62e4f971e6$export$f246528900dd4467];
        if (name === "length") return target[$11a86e62e4f971e6$export$f246528900dd4467].getArrayLength();
        if (typeof name === "number") return $11a86e62e4f971e6$var$arrayExtensions.get.call(target, name);
        if (typeof name === "string" && !isNaN(name)) return $11a86e62e4f971e6$var$arrayExtensions.get.call(target, parseInt(name));
        if ($11a86e62e4f971e6$var$arrayExtensions.hasOwnProperty(name)) return $11a86e62e4f971e6$var$arrayExtensions[name];
        return target[name];
    },
    set: function(target, name, value) {
        if (name === "length") {
            target[$11a86e62e4f971e6$export$f246528900dd4467].setArrayLength(value);
            return true;
        }
        if (typeof name === "number") {
            $11a86e62e4f971e6$var$arrayExtensions.set.call(target, name, value);
            return true;
        }
        if (!isNaN(name)) {
            $11a86e62e4f971e6$var$arrayExtensions.set.call(target, parseInt(name), value);
            return true;
        }
        return false;
    },
    preventExtensions: function(target) {
        $11a86e62e4f971e6$var$fail$$1("Observable arrays cannot be frozen");
        return false;
    }
};
function $11a86e62e4f971e6$var$createObservableArray$$1(initialValues, enhancer, name, owned) {
    if (name === void 0) name = "ObservableArray@" + $11a86e62e4f971e6$var$getNextId$$1();
    if (owned === void 0) owned = false;
    var adm = new $11a86e62e4f971e6$var$ObservableArrayAdministration(name, enhancer, owned);
    $11a86e62e4f971e6$var$addHiddenFinalProp$$1(adm.values, $11a86e62e4f971e6$export$f246528900dd4467, adm);
    var proxy = new Proxy(adm.values, $11a86e62e4f971e6$var$arrayTraps);
    adm.proxy = proxy;
    if (initialValues && initialValues.length) {
        var prev = $11a86e62e4f971e6$var$allowStateChangesStart$$1(true);
        adm.spliceWithArray(0, 0, initialValues);
        $11a86e62e4f971e6$var$allowStateChangesEnd$$1(prev);
    }
    return proxy;
}
var $11a86e62e4f971e6$var$ObservableArrayAdministration = /** @class */ function() {
    function ObservableArrayAdministration(name, enhancer, owned) {
        this.owned = owned;
        this.values = [];
        this.proxy = undefined;
        this.lastKnownLength = 0;
        this.atom = new $11a86e62e4f971e6$var$Atom$$1(name || "ObservableArray@" + $11a86e62e4f971e6$var$getNextId$$1());
        this.enhancer = function(newV, oldV) {
            return enhancer(newV, oldV, name + "[..]");
        };
    }
    ObservableArrayAdministration.prototype.dehanceValue = function(value) {
        if (this.dehancer !== undefined) return this.dehancer(value);
        return value;
    };
    ObservableArrayAdministration.prototype.dehanceValues = function(values$$1) {
        if (this.dehancer !== undefined && values$$1.length > 0) return values$$1.map(this.dehancer);
        return values$$1;
    };
    ObservableArrayAdministration.prototype.intercept = function(handler) {
        return $11a86e62e4f971e6$var$registerInterceptor$$1(this, handler);
    };
    ObservableArrayAdministration.prototype.observe = function(listener, fireImmediately) {
        if (fireImmediately === void 0) fireImmediately = false;
        if (fireImmediately) listener({
            object: this.proxy,
            type: "splice",
            index: 0,
            added: this.values.slice(),
            addedCount: this.values.length,
            removed: [],
            removedCount: 0
        });
        return $11a86e62e4f971e6$var$registerListener$$1(this, listener);
    };
    ObservableArrayAdministration.prototype.getArrayLength = function() {
        this.atom.reportObserved();
        return this.values.length;
    };
    ObservableArrayAdministration.prototype.setArrayLength = function(newLength) {
        if (typeof newLength !== "number" || newLength < 0) throw new Error("[mobx.array] Out of range: " + newLength);
        var currentLength = this.values.length;
        if (newLength === currentLength) return;
        else if (newLength > currentLength) {
            var newItems = new Array(newLength - currentLength);
            for(var i = 0; i < newLength - currentLength; i++)newItems[i] = undefined; // No Array.fill everywhere...
            this.spliceWithArray(currentLength, 0, newItems);
        } else this.spliceWithArray(newLength, currentLength - newLength);
    };
    ObservableArrayAdministration.prototype.updateArrayLength = function(oldLength, delta) {
        if (oldLength !== this.lastKnownLength) throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed.");
        this.lastKnownLength += delta;
    };
    ObservableArrayAdministration.prototype.spliceWithArray = function(index, deleteCount, newItems) {
        var _this = this;
        $11a86e62e4f971e6$var$checkIfStateModificationsAreAllowed$$1(this.atom);
        var length = this.values.length;
        if (index === undefined) index = 0;
        else if (index > length) index = length;
        else if (index < 0) index = Math.max(0, length + index);
        if (arguments.length === 1) deleteCount = length - index;
        else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;
        else deleteCount = Math.max(0, Math.min(deleteCount, length - index));
        if (newItems === undefined) newItems = $11a86e62e4f971e6$var$EMPTY_ARRAY$$1;
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                object: this.proxy,
                type: "splice",
                index: index,
                removedCount: deleteCount,
                added: newItems
            });
            if (!change) return $11a86e62e4f971e6$var$EMPTY_ARRAY$$1;
            deleteCount = change.removedCount;
            newItems = change.added;
        }
        newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {
            return _this.enhancer(v, undefined);
        });
        var lengthDelta;
        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);
        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);
        return this.dehanceValues(res);
    };
    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function(index, deleteCount, newItems) {
        var _a;
        if (newItems.length < $11a86e62e4f971e6$var$MAX_SPLICE_SIZE) return (_a = this.values).splice.apply(_a, $11a86e62e4f971e6$var$__spread([
            index,
            deleteCount
        ], newItems));
        else {
            var res = this.values.slice(index, index + deleteCount);
            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));
            return res;
        }
    };
    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function(index, newValue, oldValue) {
        var notifySpy = !this.owned && $11a86e62e4f971e6$var$isSpyEnabled$$1();
        var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
        var change = notify || notifySpy ? {
            object: this.proxy,
            type: "update",
            index: index,
            newValue: newValue,
            oldValue: oldValue
        } : null;
        this.atom.reportChanged();
        if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
    };
    ObservableArrayAdministration.prototype.notifyArraySplice = function(index, added, removed) {
        var notifySpy = !this.owned && $11a86e62e4f971e6$var$isSpyEnabled$$1();
        var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
        var change = notify || notifySpy ? {
            object: this.proxy,
            type: "splice",
            index: index,
            removed: removed,
            added: added,
            removedCount: removed.length,
            addedCount: added.length
        } : null;
        this.atom.reportChanged();
        // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe
        if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
    };
    return ObservableArrayAdministration;
}();
var $11a86e62e4f971e6$var$arrayExtensions = {
    intercept: function(handler) {
        return this[$11a86e62e4f971e6$export$f246528900dd4467].intercept(handler);
    },
    observe: function(listener, fireImmediately) {
        if (fireImmediately === void 0) fireImmediately = false;
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        return adm.observe(listener, fireImmediately);
    },
    clear: function() {
        return this.splice(0);
    },
    replace: function(newItems) {
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        return adm.spliceWithArray(0, adm.values.length, newItems);
    },
    /**
     * Converts this array back to a (shallow) javascript structure.
     * For a deep clone use mobx.toJS
     */ toJS: function() {
        return this.slice();
    },
    toJSON: function() {
        // Used by JSON.stringify
        return this.toJS();
    },
    /*
     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
     * since these functions alter the inner structure of the array, the have side effects.
     * Because the have side effects, they should not be used in computed function,
     * and for that reason the do not call dependencyState.notifyObserved
     */ splice: function(index, deleteCount) {
        var newItems = [];
        for(var _i = 2; _i < arguments.length; _i++)newItems[_i - 2] = arguments[_i];
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        switch(arguments.length){
            case 0:
                return [];
            case 1:
                return adm.spliceWithArray(index);
            case 2:
                return adm.spliceWithArray(index, deleteCount);
        }
        return adm.spliceWithArray(index, deleteCount, newItems);
    },
    spliceWithArray: function(index, deleteCount, newItems) {
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        return adm.spliceWithArray(index, deleteCount, newItems);
    },
    push: function() {
        var items = [];
        for(var _i = 0; _i < arguments.length; _i++)items[_i] = arguments[_i];
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        adm.spliceWithArray(adm.values.length, 0, items);
        return adm.values.length;
    },
    pop: function() {
        return this.splice(Math.max(this[$11a86e62e4f971e6$export$f246528900dd4467].values.length - 1, 0), 1)[0];
    },
    shift: function() {
        return this.splice(0, 1)[0];
    },
    unshift: function() {
        var items = [];
        for(var _i = 0; _i < arguments.length; _i++)items[_i] = arguments[_i];
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        adm.spliceWithArray(0, 0, items);
        return adm.values.length;
    },
    reverse: function() {
        var clone = this.slice();
        return clone.reverse.apply(clone, arguments);
    },
    sort: function(compareFn) {
        var clone = this.slice();
        return clone.sort.apply(clone, arguments);
    },
    remove: function(value) {
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        var idx = adm.dehanceValues(adm.values).indexOf(value);
        if (idx > -1) {
            this.splice(idx, 1);
            return true;
        }
        return false;
    },
    get: function(index) {
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        if (adm) {
            if (index < adm.values.length) {
                adm.atom.reportObserved();
                return adm.dehanceValue(adm.values[index]);
            }
            console.warn("[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + adm.values.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
        }
        return undefined;
    },
    set: function(index, newValue) {
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        var values$$1 = adm.values;
        if (index < values$$1.length) {
            // update at index in range
            $11a86e62e4f971e6$var$checkIfStateModificationsAreAllowed$$1(adm.atom);
            var oldValue = values$$1[index];
            if ($11a86e62e4f971e6$var$hasInterceptors$$1(adm)) {
                var change = $11a86e62e4f971e6$var$interceptChange$$1(adm, {
                    type: "update",
                    object: this,
                    index: index,
                    newValue: newValue
                });
                if (!change) return;
                newValue = change.newValue;
            }
            newValue = adm.enhancer(newValue, oldValue);
            var changed = newValue !== oldValue;
            if (changed) {
                values$$1[index] = newValue;
                adm.notifyArrayChildUpdate(index, newValue, oldValue);
            }
        } else if (index === values$$1.length) // add a new item
        adm.spliceWithArray(index, 0, [
            newValue
        ]);
        else // out of bounds
        throw new Error("[mobx.array] Index out of bounds, " + index + " is larger than " + values$$1.length);
    }
};
[
    "concat",
    "every",
    "filter",
    "forEach",
    "indexOf",
    "join",
    "lastIndexOf",
    "map",
    "reduce",
    "reduceRight",
    "slice",
    "some",
    "toString",
    "toLocaleString"
].forEach(function(funcName) {
    $11a86e62e4f971e6$var$arrayExtensions[funcName] = function() {
        var adm = this[$11a86e62e4f971e6$export$f246528900dd4467];
        adm.atom.reportObserved();
        var res = adm.dehanceValues(adm.values);
        return res[funcName].apply(res, arguments);
    };
});
var $11a86e62e4f971e6$var$isObservableArrayAdministration = $11a86e62e4f971e6$var$createInstanceofPredicate$$1("ObservableArrayAdministration", $11a86e62e4f971e6$var$ObservableArrayAdministration);
function $11a86e62e4f971e6$export$f5afceff386badf9(thing) {
    return $11a86e62e4f971e6$var$isObject$$1(thing) && $11a86e62e4f971e6$var$isObservableArrayAdministration(thing[$11a86e62e4f971e6$export$f246528900dd4467]);
}
var $11a86e62e4f971e6$var$_a;
var $11a86e62e4f971e6$var$ObservableMapMarker = {};
// just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
// But: https://github.com/mobxjs/mobx/issues/1556
var $11a86e62e4f971e6$export$db1c0901f08fc6fd = /** @class */ function() {
    function ObservableMap$$1(initialData, enhancer, name) {
        if (enhancer === void 0) enhancer = $11a86e62e4f971e6$var$deepEnhancer$$1;
        if (name === void 0) name = "ObservableMap@" + $11a86e62e4f971e6$var$getNextId$$1();
        this.enhancer = enhancer;
        this.name = name;
        this[$11a86e62e4f971e6$var$_a] = $11a86e62e4f971e6$var$ObservableMapMarker;
        this._keysAtom = $11a86e62e4f971e6$export$2e17fe64ec9a826e(this.name + ".keys()");
        this[Symbol.toStringTag] = "Map";
        if (typeof Map !== "function") throw new Error("mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js");
        this._data = new Map();
        this._hasMap = new Map();
        this.merge(initialData);
    }
    ObservableMap$$1.prototype._has = function(key) {
        return this._data.has(key);
    };
    ObservableMap$$1.prototype.has = function(key) {
        if (this._hasMap.has(key)) return this._hasMap.get(key).get();
        return this._updateHasMapEntry(key, false).get();
    };
    ObservableMap$$1.prototype.set = function(key, value) {
        var hasKey = this._has(key);
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                type: hasKey ? "update" : "add",
                object: this,
                newValue: value,
                name: key
            });
            if (!change) return this;
            value = change.newValue;
        }
        if (hasKey) this._updateValue(key, value);
        else this._addValue(key, value);
        return this;
    };
    ObservableMap$$1.prototype.delete = function(key) {
        var _this = this;
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                type: "delete",
                object: this,
                name: key
            });
            if (!change) return false;
        }
        if (this._has(key)) {
            var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
            var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
            var change = notify || notifySpy ? {
                type: "delete",
                object: this,
                oldValue: this._data.get(key).value,
                name: key
            } : null;
            $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
                _this._keysAtom.reportChanged();
                _this._updateHasMapEntry(key, false);
                var observable$$1 = _this._data.get(key);
                observable$$1.setNewValue(undefined);
                _this._data.delete(key);
            });
            if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
            return true;
        }
        return false;
    };
    ObservableMap$$1.prototype._updateHasMapEntry = function(key, value) {
        // optimization; don't fill the hasMap if we are not observing, or remove entry if there are no observers anymore
        var entry = this._hasMap.get(key);
        if (entry) entry.setNewValue(value);
        else {
            entry = new $11a86e62e4f971e6$var$ObservableValue$$1(value, $11a86e62e4f971e6$var$referenceEnhancer$$1, this.name + "." + key + "?", false);
            this._hasMap.set(key, entry);
        }
        return entry;
    };
    ObservableMap$$1.prototype._updateValue = function(key, newValue) {
        var observable$$1 = this._data.get(key);
        newValue = observable$$1.prepareNewValue(newValue);
        if (newValue !== $11a86e62e4f971e6$var$globalState$$1.UNCHANGED) {
            var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
            var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
            var change = notify || notifySpy ? {
                type: "update",
                object: this,
                oldValue: observable$$1.value,
                name: key,
                newValue: newValue
            } : null;
            observable$$1.setNewValue(newValue);
            if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
        }
    };
    ObservableMap$$1.prototype._addValue = function(key, newValue) {
        var _this = this;
        $11a86e62e4f971e6$var$checkIfStateModificationsAreAllowed$$1(this._keysAtom);
        $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
            var observable$$1 = new $11a86e62e4f971e6$var$ObservableValue$$1(newValue, _this.enhancer, _this.name + "." + key, false);
            _this._data.set(key, observable$$1);
            newValue = observable$$1.value; // value might have been changed
            _this._updateHasMapEntry(key, true);
            _this._keysAtom.reportChanged();
        });
        var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
        var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
        var change = notify || notifySpy ? {
            type: "add",
            object: this,
            name: key,
            newValue: newValue
        } : null;
        if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
    };
    ObservableMap$$1.prototype.get = function(key) {
        if (this.has(key)) return this.dehanceValue(this._data.get(key).get());
        return this.dehanceValue(undefined);
    };
    ObservableMap$$1.prototype.dehanceValue = function(value) {
        if (this.dehancer !== undefined) return this.dehancer(value);
        return value;
    };
    ObservableMap$$1.prototype.keys = function() {
        this._keysAtom.reportObserved();
        return this._data.keys();
    };
    ObservableMap$$1.prototype.values = function() {
        var self = this;
        var nextIndex = 0;
        var keys$$1 = Array.from(this.keys());
        return $11a86e62e4f971e6$var$makeIterable({
            next: function() {
                return nextIndex < keys$$1.length ? {
                    value: self.get(keys$$1[nextIndex++]),
                    done: false
                } : {
                    done: true
                };
            }
        });
    };
    ObservableMap$$1.prototype.entries = function() {
        var self = this;
        var nextIndex = 0;
        var keys$$1 = Array.from(this.keys());
        return $11a86e62e4f971e6$var$makeIterable({
            next: function() {
                if (nextIndex < keys$$1.length) {
                    var key = keys$$1[nextIndex++];
                    return {
                        value: [
                            key,
                            self.get(key)
                        ],
                        done: false
                    };
                }
                return {
                    done: true
                };
            }
        });
    };
    ObservableMap$$1.prototype[$11a86e62e4f971e6$var$_a = $11a86e62e4f971e6$export$f246528900dd4467, Symbol.iterator] = function() {
        return this.entries();
    };
    ObservableMap$$1.prototype.forEach = function(callback, thisArg) {
        var e_1, _a;
        try {
            for(var _b = $11a86e62e4f971e6$var$__values(this), _c = _b.next(); !_c.done; _c = _b.next()){
                var _d = $11a86e62e4f971e6$var$__read(_c.value, 2), key = _d[0], value = _d[1];
                callback.call(thisArg, value, key, this);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    };
    /** Merge another object into this object, returns this. */ ObservableMap$$1.prototype.merge = function(other) {
        var _this = this;
        if ($11a86e62e4f971e6$export$27a7faddcfd44960(other)) other = other.toJS();
        $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
            if ($11a86e62e4f971e6$var$isPlainObject$$1(other)) Object.keys(other).forEach(function(key) {
                return _this.set(key, other[key]);
            });
            else if (Array.isArray(other)) other.forEach(function(_a) {
                var _b = $11a86e62e4f971e6$var$__read(_a, 2), key = _b[0], value = _b[1];
                return _this.set(key, value);
            });
            else if ($11a86e62e4f971e6$var$isES6Map$$1(other)) {
                if (other.constructor !== Map) return $11a86e62e4f971e6$var$fail$$1("Cannot initialize from classes that inherit from Map: " + other.constructor.name); // prettier-ignore
                other.forEach(function(value, key) {
                    return _this.set(key, value);
                });
            } else if (other !== null && other !== undefined) $11a86e62e4f971e6$var$fail$$1("Cannot initialize map from " + other);
        });
        return this;
    };
    ObservableMap$$1.prototype.clear = function() {
        var _this = this;
        $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
            $11a86e62e4f971e6$export$8c437e4d572e2f99(function() {
                var e_2, _a;
                try {
                    for(var _b = $11a86e62e4f971e6$var$__values(_this.keys()), _c = _b.next(); !_c.done; _c = _b.next()){
                        var key = _c.value;
                        _this.delete(key);
                    }
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally{
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally{
                        if (e_2) throw e_2.error;
                    }
                }
            });
        });
    };
    ObservableMap$$1.prototype.replace = function(values$$1) {
        var _this = this;
        $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
            // grab all the keys that are present in the new map but not present in the current map
            // and delete them from the map, then merge the new map
            // this will cause reactions only on changed values
            var newKeys = $11a86e62e4f971e6$var$getMapLikeKeys$$1(values$$1);
            var oldKeys = Array.from(_this.keys());
            var missingKeys = oldKeys.filter(function(k) {
                return newKeys.indexOf(k) === -1;
            });
            missingKeys.forEach(function(k) {
                return _this.delete(k);
            });
            _this.merge(values$$1);
        });
        return this;
    };
    Object.defineProperty(ObservableMap$$1.prototype, "size", {
        get: function() {
            this._keysAtom.reportObserved();
            return this._data.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a plain object that represents this map.
     * Note that all the keys being stringified.
     * If there are duplicating keys after converting them to strings, behaviour is undetermined.
     */ ObservableMap$$1.prototype.toPOJO = function() {
        var e_3, _a;
        var res = {};
        try {
            for(var _b = $11a86e62e4f971e6$var$__values(this), _c = _b.next(); !_c.done; _c = _b.next()){
                var _d = $11a86e62e4f971e6$var$__read(_c.value, 2), key = _d[0], value = _d[1];
                res["" + key] = value;
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        return res;
    };
    /**
     * Returns a shallow non observable object clone of this map.
     * Note that the values migth still be observable. For a deep clone use mobx.toJS.
     */ ObservableMap$$1.prototype.toJS = function() {
        return new Map(this);
    };
    ObservableMap$$1.prototype.toJSON = function() {
        // Used by JSON.stringify
        return this.toPOJO();
    };
    ObservableMap$$1.prototype.toString = function() {
        var _this = this;
        return this.name + "[{ " + Array.from(this.keys()).map(function(key) {
            return key + ": " + ("" + _this.get(key));
        }).join(", ") + " }]";
    };
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */ ObservableMap$$1.prototype.observe = function(listener, fireImmediately) {
        return $11a86e62e4f971e6$var$registerListener$$1(this, listener);
    };
    ObservableMap$$1.prototype.intercept = function(handler) {
        return $11a86e62e4f971e6$var$registerInterceptor$$1(this, handler);
    };
    return ObservableMap$$1;
}();
/* 'var' fixes small-build issue */ var $11a86e62e4f971e6$export$27a7faddcfd44960 = $11a86e62e4f971e6$var$createInstanceofPredicate$$1("ObservableMap", $11a86e62e4f971e6$export$db1c0901f08fc6fd);
var $11a86e62e4f971e6$var$_a$1;
var $11a86e62e4f971e6$var$ObservableSetMarker = {};
var $11a86e62e4f971e6$export$2235f602a7a77c81 = /** @class */ function() {
    function ObservableSet$$1(initialData, enhancer, name) {
        if (enhancer === void 0) enhancer = $11a86e62e4f971e6$var$deepEnhancer$$1;
        if (name === void 0) name = "ObservableSet@" + $11a86e62e4f971e6$var$getNextId$$1();
        this.name = name;
        this[$11a86e62e4f971e6$var$_a$1] = $11a86e62e4f971e6$var$ObservableSetMarker;
        this._data = new Set();
        this._atom = $11a86e62e4f971e6$export$2e17fe64ec9a826e(this.name);
        this[Symbol.toStringTag] = "Set";
        if (typeof Set !== "function") throw new Error("mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js");
        this.enhancer = function(newV, oldV) {
            return enhancer(newV, oldV, name);
        };
        if (initialData) this.replace(initialData);
    }
    ObservableSet$$1.prototype.dehanceValue = function(value) {
        if (this.dehancer !== undefined) return this.dehancer(value);
        return value;
    };
    ObservableSet$$1.prototype.clear = function() {
        var _this = this;
        $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
            $11a86e62e4f971e6$export$8c437e4d572e2f99(function() {
                var e_1, _a;
                try {
                    for(var _b = $11a86e62e4f971e6$var$__values(_this._data.values()), _c = _b.next(); !_c.done; _c = _b.next()){
                        var value = _c.value;
                        _this.delete(value);
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
            });
        });
    };
    ObservableSet$$1.prototype.forEach = function(callbackFn, thisArg) {
        var e_2, _a;
        try {
            for(var _b = $11a86e62e4f971e6$var$__values(this), _c = _b.next(); !_c.done; _c = _b.next()){
                var value = _c.value;
                callbackFn.call(thisArg, value, value, this);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    };
    Object.defineProperty(ObservableSet$$1.prototype, "size", {
        get: function() {
            this._atom.reportObserved();
            return this._data.size;
        },
        enumerable: true,
        configurable: true
    });
    ObservableSet$$1.prototype.add = function(value) {
        var _this = this;
        $11a86e62e4f971e6$var$checkIfStateModificationsAreAllowed$$1(this._atom);
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                type: "add",
                object: this,
                newValue: value
            });
            if (!change) return this;
        // TODO: ideally, value = change.value would be done here, so that values can be
        // changed by interceptor. Same applies for other Set and Map api's.
        }
        if (!this.has(value)) {
            $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
                _this._data.add(_this.enhancer(value, undefined));
                _this._atom.reportChanged();
            });
            var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
            var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
            var change = notify || notifySpy ? {
                type: "add",
                object: this,
                newValue: value
            } : null;
            if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
        }
        return this;
    };
    ObservableSet$$1.prototype.delete = function(value) {
        var _this = this;
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                type: "delete",
                object: this,
                oldValue: value
            });
            if (!change) return false;
        }
        if (this.has(value)) {
            var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
            var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
            var change = notify || notifySpy ? {
                type: "delete",
                object: this,
                oldValue: value
            } : null;
            $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
                _this._atom.reportChanged();
                _this._data.delete(value);
            });
            if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
            return true;
        }
        return false;
    };
    ObservableSet$$1.prototype.has = function(value) {
        this._atom.reportObserved();
        return this._data.has(this.dehanceValue(value));
    };
    ObservableSet$$1.prototype.entries = function() {
        var nextIndex = 0;
        var keys$$1 = Array.from(this.keys());
        var values$$1 = Array.from(this.values());
        return $11a86e62e4f971e6$var$makeIterable({
            next: function() {
                var index = nextIndex;
                nextIndex += 1;
                return index < values$$1.length ? {
                    value: [
                        keys$$1[index],
                        values$$1[index]
                    ],
                    done: false
                } : {
                    done: true
                };
            }
        });
    };
    ObservableSet$$1.prototype.keys = function() {
        return this.values();
    };
    ObservableSet$$1.prototype.values = function() {
        this._atom.reportObserved();
        var self = this;
        var nextIndex = 0;
        var observableValues = Array.from(this._data.values());
        return $11a86e62e4f971e6$var$makeIterable({
            next: function() {
                return nextIndex < observableValues.length ? {
                    value: self.dehanceValue(observableValues[nextIndex++]),
                    done: false
                } : {
                    done: true
                };
            }
        });
    };
    ObservableSet$$1.prototype.replace = function(other) {
        var _this = this;
        if ($11a86e62e4f971e6$export$da6b063694cb52c1(other)) other = other.toJS();
        $11a86e62e4f971e6$export$2d62d2646dd2fb3c(function() {
            if (Array.isArray(other)) {
                _this.clear();
                other.forEach(function(value) {
                    return _this.add(value);
                });
            } else if ($11a86e62e4f971e6$var$isES6Set$$1(other)) {
                _this.clear();
                other.forEach(function(value) {
                    return _this.add(value);
                });
            } else if (other !== null && other !== undefined) $11a86e62e4f971e6$var$fail$$1("Cannot initialize set from " + other);
        });
        return this;
    };
    ObservableSet$$1.prototype.observe = function(listener, fireImmediately) {
        return $11a86e62e4f971e6$var$registerListener$$1(this, listener);
    };
    ObservableSet$$1.prototype.intercept = function(handler) {
        return $11a86e62e4f971e6$var$registerInterceptor$$1(this, handler);
    };
    ObservableSet$$1.prototype.toJS = function() {
        return new Set(this);
    };
    ObservableSet$$1.prototype.toString = function() {
        return this.name + "[ " + Array.from(this).join(", ") + " ]";
    };
    ObservableSet$$1.prototype[$11a86e62e4f971e6$var$_a$1 = $11a86e62e4f971e6$export$f246528900dd4467, Symbol.iterator] = function() {
        return this.values();
    };
    return ObservableSet$$1;
}();
var $11a86e62e4f971e6$export$da6b063694cb52c1 = $11a86e62e4f971e6$var$createInstanceofPredicate$$1("ObservableSet", $11a86e62e4f971e6$export$2235f602a7a77c81);
var $11a86e62e4f971e6$var$ObservableObjectAdministration$$1 = /** @class */ function() {
    function ObservableObjectAdministration$$1(target, values$$1, name, defaultEnhancer) {
        if (values$$1 === void 0) values$$1 = new Map();
        this.target = target;
        this.values = values$$1;
        this.name = name;
        this.defaultEnhancer = defaultEnhancer;
        this.keysAtom = new $11a86e62e4f971e6$var$Atom$$1(name + ".keys");
    }
    ObservableObjectAdministration$$1.prototype.read = function(key) {
        return this.values.get(key).get();
    };
    ObservableObjectAdministration$$1.prototype.write = function(key, newValue) {
        var instance = this.target;
        var observable$$1 = this.values.get(key);
        if (observable$$1 instanceof $11a86e62e4f971e6$var$ComputedValue$$1) {
            observable$$1.set(newValue);
            return;
        }
        // intercept
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                type: "update",
                object: this.proxy || instance,
                name: key,
                newValue: newValue
            });
            if (!change) return;
            newValue = change.newValue;
        }
        newValue = observable$$1.prepareNewValue(newValue);
        // notify spy & observers
        if (newValue !== $11a86e62e4f971e6$var$globalState$$1.UNCHANGED) {
            var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
            var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
            var change = notify || notifySpy ? {
                type: "update",
                object: this.proxy || instance,
                oldValue: observable$$1.value,
                name: key,
                newValue: newValue
            } : null;
            observable$$1.setNewValue(newValue);
            if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
        }
    };
    ObservableObjectAdministration$$1.prototype.has = function(key) {
        var map = this.pendingKeys || (this.pendingKeys = new Map());
        var entry = map.get(key);
        if (entry) return entry.get();
        else {
            var exists = !!this.values.get(key);
            // Possible optimization: Don't have a separate map for non existing keys,
            // but store them in the values map instead, using a special symbol to denote "not existing"
            entry = new $11a86e62e4f971e6$var$ObservableValue$$1(exists, $11a86e62e4f971e6$var$referenceEnhancer$$1, this.name + "." + key.toString() + "?", false);
            map.set(key, entry);
            return entry.get(); // read to subscribe
        }
    };
    ObservableObjectAdministration$$1.prototype.addObservableProp = function(propName, newValue, enhancer) {
        if (enhancer === void 0) enhancer = this.defaultEnhancer;
        var target = this.target;
        $11a86e62e4f971e6$var$assertPropertyConfigurable$$1(target, propName);
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                object: this.proxy || target,
                name: propName,
                type: "add",
                newValue: newValue
            });
            if (!change) return;
            newValue = change.newValue;
        }
        var observable$$1 = new $11a86e62e4f971e6$var$ObservableValue$$1(newValue, enhancer, this.name + "." + propName, false);
        this.values.set(propName, observable$$1);
        newValue = observable$$1.value; // observableValue might have changed it
        Object.defineProperty(target, propName, $11a86e62e4f971e6$var$generateObservablePropConfig$$1(propName));
        this.notifyPropertyAddition(propName, newValue);
    };
    ObservableObjectAdministration$$1.prototype.addComputedProp = function(propertyOwner, propName, options) {
        var target = this.target;
        options.name = options.name || this.name + "." + propName;
        this.values.set(propName, new $11a86e62e4f971e6$var$ComputedValue$$1(options));
        if (propertyOwner === target || $11a86e62e4f971e6$var$isPropertyConfigurable$$1(propertyOwner, propName)) Object.defineProperty(propertyOwner, propName, $11a86e62e4f971e6$var$generateComputedPropConfig$$1(propName));
    };
    ObservableObjectAdministration$$1.prototype.remove = function(key) {
        if (!this.values.has(key)) return;
        var target = this.target;
        if ($11a86e62e4f971e6$var$hasInterceptors$$1(this)) {
            var change = $11a86e62e4f971e6$var$interceptChange$$1(this, {
                object: this.proxy || target,
                name: key,
                type: "remove"
            });
            if (!change) return;
        }
        try {
            $11a86e62e4f971e6$var$startBatch$$1();
            var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
            var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
            var oldObservable = this.values.get(key);
            var oldValue = oldObservable && oldObservable.get();
            oldObservable && oldObservable.set(undefined);
            // notify key and keyset listeners
            this.keysAtom.reportChanged();
            this.values.delete(key);
            if (this.pendingKeys) {
                var entry = this.pendingKeys.get(key);
                if (entry) entry.set(false);
            }
            // delete the prop
            delete this.target[key];
            var change = notify || notifySpy ? {
                type: "remove",
                object: this.proxy || target,
                oldValue: oldValue,
                name: key
            } : null;
            if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
        } finally{
            $11a86e62e4f971e6$var$endBatch$$1();
        }
    };
    ObservableObjectAdministration$$1.prototype.illegalAccess = function(owner, propName) {
        /**
         * This happens if a property is accessed through the prototype chain, but the property was
         * declared directly as own property on the prototype.
         *
         * E.g.:
         * class A {
         * }
         * extendObservable(A.prototype, { x: 1 })
         *
         * classB extens A {
         * }
         * console.log(new B().x)
         *
         * It is unclear whether the property should be considered 'static' or inherited.
         * Either use `console.log(A.x)`
         * or: decorate(A, { x: observable })
         *
         * When using decorate, the property will always be redeclared as own property on the actual instance
         */ console.warn("Property '" + propName + "' of '" + owner + "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner");
    };
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */ ObservableObjectAdministration$$1.prototype.observe = function(callback, fireImmediately) {
        return $11a86e62e4f971e6$var$registerListener$$1(this, callback);
    };
    ObservableObjectAdministration$$1.prototype.intercept = function(handler) {
        return $11a86e62e4f971e6$var$registerInterceptor$$1(this, handler);
    };
    ObservableObjectAdministration$$1.prototype.notifyPropertyAddition = function(key, newValue) {
        var notify = $11a86e62e4f971e6$var$hasListeners$$1(this);
        var notifySpy = $11a86e62e4f971e6$var$isSpyEnabled$$1();
        var change = notify || notifySpy ? {
            type: "add",
            object: this.proxy || this.target,
            name: key,
            newValue: newValue
        } : null;
        if (notify) $11a86e62e4f971e6$var$notifyListeners$$1(this, change);
        if (this.pendingKeys) {
            var entry = this.pendingKeys.get(key);
            if (entry) entry.set(true);
        }
        this.keysAtom.reportChanged();
    };
    ObservableObjectAdministration$$1.prototype.getKeys = function() {
        var e_1, _a;
        this.keysAtom.reportObserved();
        // return Reflect.ownKeys(this.values) as any
        var res = [];
        try {
            for(var _b = $11a86e62e4f971e6$var$__values(this.values), _c = _b.next(); !_c.done; _c = _b.next()){
                var _d = $11a86e62e4f971e6$var$__read(_c.value, 2), key = _d[0], value = _d[1];
                if (value instanceof $11a86e62e4f971e6$var$ObservableValue$$1) res.push(key);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return res;
    };
    return ObservableObjectAdministration$$1;
}();
function $11a86e62e4f971e6$var$asObservableObject$$1(target, name, defaultEnhancer) {
    if (name === void 0) name = "";
    if (defaultEnhancer === void 0) defaultEnhancer = $11a86e62e4f971e6$var$deepEnhancer$$1;
    if (Object.prototype.hasOwnProperty.call(target, $11a86e62e4f971e6$export$f246528900dd4467)) return target[$11a86e62e4f971e6$export$f246528900dd4467];
    if (!$11a86e62e4f971e6$var$isPlainObject$$1(target)) name = (target.constructor.name || "ObservableObject") + "@" + $11a86e62e4f971e6$var$getNextId$$1();
    if (!name) name = "ObservableObject@" + $11a86e62e4f971e6$var$getNextId$$1();
    var adm = new $11a86e62e4f971e6$var$ObservableObjectAdministration$$1(target, new Map(), name, defaultEnhancer);
    $11a86e62e4f971e6$var$addHiddenProp$$1(target, $11a86e62e4f971e6$export$f246528900dd4467, adm);
    return adm;
}
var $11a86e62e4f971e6$var$observablePropertyConfigs = Object.create(null);
var $11a86e62e4f971e6$var$computedPropertyConfigs = Object.create(null);
function $11a86e62e4f971e6$var$generateObservablePropConfig$$1(propName) {
    return $11a86e62e4f971e6$var$observablePropertyConfigs[propName] || ($11a86e62e4f971e6$var$observablePropertyConfigs[propName] = {
        configurable: true,
        enumerable: true,
        get: function() {
            return this[$11a86e62e4f971e6$export$f246528900dd4467].read(propName);
        },
        set: function(v) {
            this[$11a86e62e4f971e6$export$f246528900dd4467].write(propName, v);
        }
    });
}
function $11a86e62e4f971e6$var$getAdministrationForComputedPropOwner(owner) {
    var adm = owner[$11a86e62e4f971e6$export$f246528900dd4467];
    if (!adm) {
        // because computed props are declared on proty,
        // the current instance might not have been initialized yet
        $11a86e62e4f971e6$var$initializeInstance$$1(owner);
        return owner[$11a86e62e4f971e6$export$f246528900dd4467];
    }
    return adm;
}
function $11a86e62e4f971e6$var$generateComputedPropConfig$$1(propName) {
    return $11a86e62e4f971e6$var$computedPropertyConfigs[propName] || ($11a86e62e4f971e6$var$computedPropertyConfigs[propName] = {
        configurable: false,
        enumerable: false,
        get: function() {
            return $11a86e62e4f971e6$var$getAdministrationForComputedPropOwner(this).read(propName);
        },
        set: function(v) {
            $11a86e62e4f971e6$var$getAdministrationForComputedPropOwner(this).write(propName, v);
        }
    });
}
var $11a86e62e4f971e6$var$isObservableObjectAdministration = $11a86e62e4f971e6$var$createInstanceofPredicate$$1("ObservableObjectAdministration", $11a86e62e4f971e6$var$ObservableObjectAdministration$$1);
function $11a86e62e4f971e6$export$31960fb081a18155(thing) {
    if ($11a86e62e4f971e6$var$isObject$$1(thing)) {
        // Initializers run lazily when transpiling to babel, so make sure they are run...
        $11a86e62e4f971e6$var$initializeInstance$$1(thing);
        return $11a86e62e4f971e6$var$isObservableObjectAdministration(thing[$11a86e62e4f971e6$export$f246528900dd4467]);
    }
    return false;
}
function $11a86e62e4f971e6$export$25fc416d10fa1afa(thing, property) {
    if (typeof thing === "object" && thing !== null) {
        if ($11a86e62e4f971e6$export$f5afceff386badf9(thing)) {
            if (property !== undefined) $11a86e62e4f971e6$var$fail$$1(false);
            return thing[$11a86e62e4f971e6$export$f246528900dd4467].atom;
        }
        if ($11a86e62e4f971e6$export$da6b063694cb52c1(thing)) return thing[$11a86e62e4f971e6$export$f246528900dd4467];
        if ($11a86e62e4f971e6$export$27a7faddcfd44960(thing)) {
            var anyThing = thing;
            if (property === undefined) return anyThing._keysAtom;
            var observable$$1 = anyThing._data.get(property) || anyThing._hasMap.get(property);
            if (!observable$$1) $11a86e62e4f971e6$var$fail$$1(false);
            return observable$$1;
        }
        // Initializers run lazily when transpiling to babel, so make sure they are run...
        $11a86e62e4f971e6$var$initializeInstance$$1(thing);
        if (property && !thing[$11a86e62e4f971e6$export$f246528900dd4467]) thing[property]; // See #1072
        if ($11a86e62e4f971e6$export$31960fb081a18155(thing)) {
            if (!property) return $11a86e62e4f971e6$var$fail$$1(false);
            var observable$$1 = thing[$11a86e62e4f971e6$export$f246528900dd4467].values.get(property);
            if (!observable$$1) $11a86e62e4f971e6$var$fail$$1(false);
            return observable$$1;
        }
        if ($11a86e62e4f971e6$var$isAtom$$1(thing) || $11a86e62e4f971e6$var$isComputedValue$$1(thing) || $11a86e62e4f971e6$var$isReaction$$1(thing)) return thing;
    } else if (typeof thing === "function") {
        if ($11a86e62e4f971e6$var$isReaction$$1(thing[$11a86e62e4f971e6$export$f246528900dd4467])) // disposer function
        return thing[$11a86e62e4f971e6$export$f246528900dd4467];
    }
    return $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$71ff639cb8b2a36e(thing, property) {
    if (!thing) $11a86e62e4f971e6$var$fail$$1("Expecting some object");
    if (property !== undefined) return $11a86e62e4f971e6$export$71ff639cb8b2a36e($11a86e62e4f971e6$export$25fc416d10fa1afa(thing, property));
    if ($11a86e62e4f971e6$var$isAtom$$1(thing) || $11a86e62e4f971e6$var$isComputedValue$$1(thing) || $11a86e62e4f971e6$var$isReaction$$1(thing)) return thing;
    if ($11a86e62e4f971e6$export$27a7faddcfd44960(thing) || $11a86e62e4f971e6$export$da6b063694cb52c1(thing)) return thing;
    // Initializers run lazily when transpiling to babel, so make sure they are run...
    $11a86e62e4f971e6$var$initializeInstance$$1(thing);
    if (thing[$11a86e62e4f971e6$export$f246528900dd4467]) return thing[$11a86e62e4f971e6$export$f246528900dd4467];
    $11a86e62e4f971e6$var$fail$$1(false);
}
function $11a86e62e4f971e6$export$c48237bbccf30144(thing, property) {
    var named;
    if (property !== undefined) named = $11a86e62e4f971e6$export$25fc416d10fa1afa(thing, property);
    else if ($11a86e62e4f971e6$export$31960fb081a18155(thing) || $11a86e62e4f971e6$export$27a7faddcfd44960(thing) || $11a86e62e4f971e6$export$da6b063694cb52c1(thing)) named = $11a86e62e4f971e6$export$71ff639cb8b2a36e(thing);
    else named = $11a86e62e4f971e6$export$25fc416d10fa1afa(thing); // valid for arrays as well
    return named.name;
}
var $11a86e62e4f971e6$var$toString = Object.prototype.toString;
function $11a86e62e4f971e6$var$deepEqual$$1(a, b) {
    return $11a86e62e4f971e6$var$eq(a, b);
}
// Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.
function $11a86e62e4f971e6$var$eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== "function" && type !== "object" && typeof b != "object") return false;
    return $11a86e62e4f971e6$var$deepEq(a, b, aStack, bStack);
}
// Internal recursive comparison function for `isEqual`.
function $11a86e62e4f971e6$var$deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    a = $11a86e62e4f971e6$var$unwrap(a);
    b = $11a86e62e4f971e6$var$unwrap(b);
    // Compare `[[Class]]` names.
    var className = $11a86e62e4f971e6$var$toString.call(a);
    if (className !== $11a86e62e4f971e6$var$toString.call(b)) return false;
    switch(className){
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case "[object RegExp]":
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case "[object String]":
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return "" + a === "" + b;
        case "[object Number]":
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a) return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case "[object Date]":
        case "[object Boolean]":
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        case "[object Symbol]":
            return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
    }
    var areArrays = className === "[object Array]";
    if (!areArrays) {
        if (typeof a != "object" || typeof b != "object") return false;
        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(typeof aCtor === "function" && aCtor instanceof aCtor && typeof bCtor === "function" && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) return false;
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while(length--){
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while(length--){
            if (!$11a86e62e4f971e6$var$eq(a[length], b[length], aStack, bStack)) return false;
        }
    } else {
        // Deep compare objects.
        var keys$$1 = Object.keys(a), key;
        length = keys$$1.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (Object.keys(b).length !== length) return false;
        while(length--){
            // Deep compare each member
            key = keys$$1[length];
            if (!($11a86e62e4f971e6$var$has$1(b, key) && $11a86e62e4f971e6$var$eq(a[key], b[key], aStack, bStack))) return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
}
function $11a86e62e4f971e6$var$unwrap(a) {
    if ($11a86e62e4f971e6$export$f5afceff386badf9(a)) return a.slice();
    if ($11a86e62e4f971e6$var$isES6Map$$1(a) || $11a86e62e4f971e6$export$27a7faddcfd44960(a)) return Array.from(a.entries());
    if ($11a86e62e4f971e6$var$isES6Set$$1(a) || $11a86e62e4f971e6$export$da6b063694cb52c1(a)) return Array.from(a.entries());
    return a;
}
function $11a86e62e4f971e6$var$has$1(a, key) {
    return Object.prototype.hasOwnProperty.call(a, key);
}
function $11a86e62e4f971e6$var$makeIterable(iterator) {
    iterator[Symbol.iterator] = $11a86e62e4f971e6$var$self;
    return iterator;
}
function $11a86e62e4f971e6$var$self() {
    return this;
}
/*
The only reason for this file to exist is pure horror:
Without it rollup can make the bundling fail at any point in time; when it rolls up the files in the wrong order
it will cause undefined errors (for example because super classes or local variables not being hosted).
With this file that will still happen,
but at least in this file we can magically reorder the imports with trial and error until the build succeeds again.
*/ /**
 * (c) Michel Weststrate 2015 - 2018
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */ if (typeof Proxy === "undefined" || typeof Symbol === "undefined") throw new Error("[mobx] MobX 5+ requires Proxy and Symbol objects. If your environment doesn't support Proxy objects, please downgrade to MobX 4. For React Native Android, consider upgrading JSCore.");
try {
    "production";
} catch (e) {
    var $11a86e62e4f971e6$var$g = typeof window !== "undefined" ? window : $parcel$global;
    if (typeof $361a76e6ea33591f$exports === "undefined") $11a86e62e4f971e6$var$g.process = {};
    $11a86e62e4f971e6$var$g.process.env = {};
}
(function() {
    function testCodeMinification() {}
    testCodeMinification.name;
})();
// Devtools support
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") // See: https://github.com/andykog/mobx-devtools/
__MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: $11a86e62e4f971e6$export$fcc0cd19e9fb2b4c,
    extras: {
        getDebugName: $11a86e62e4f971e6$export$c48237bbccf30144
    },
    $mobx: $11a86e62e4f971e6$export$f246528900dd4467
});



var $aaLBe = parcelRequire("aaLBe");

function $89be00fd7ffd1d5f$var$_typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") $89be00fd7ffd1d5f$var$_typeof = function(obj) {
        return typeof obj;
    };
    else $89be00fd7ffd1d5f$var$_typeof = function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    return $89be00fd7ffd1d5f$var$_typeof(obj);
}
function $89be00fd7ffd1d5f$var$_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function $89be00fd7ffd1d5f$var$_defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function $89be00fd7ffd1d5f$var$_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) $89be00fd7ffd1d5f$var$_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) $89be00fd7ffd1d5f$var$_defineProperties(Constructor, staticProps);
    return Constructor;
}
function $89be00fd7ffd1d5f$var$_defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function $89be00fd7ffd1d5f$var$_inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) $89be00fd7ffd1d5f$var$_setPrototypeOf(subClass, superClass);
}
function $89be00fd7ffd1d5f$var$_getPrototypeOf(o) {
    $89be00fd7ffd1d5f$var$_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return $89be00fd7ffd1d5f$var$_getPrototypeOf(o);
}
function $89be00fd7ffd1d5f$var$_setPrototypeOf(o, p) {
    $89be00fd7ffd1d5f$var$_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return $89be00fd7ffd1d5f$var$_setPrototypeOf(o, p);
}
function $89be00fd7ffd1d5f$var$_assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function $89be00fd7ffd1d5f$var$_possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) return call;
    return $89be00fd7ffd1d5f$var$_assertThisInitialized(self);
}
// These functions can be stubbed out in specific environments
function $89be00fd7ffd1d5f$var$unwrapExports(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
function $89be00fd7ffd1d5f$var$createCommonjsModule(fn, module) {
    return module = {
        exports: {}
    }, fn(module, module.exports), module.exports;
}
var $89be00fd7ffd1d5f$var$reactIs_production_min = $89be00fd7ffd1d5f$var$createCommonjsModule(function(module, exports) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116;
    function u(a) {
        if ("object" === typeof a && null !== a) {
            var q = a.$$typeof;
            switch(q){
                case c:
                    switch(a = a.type, a){
                        case l:
                        case m:
                        case e:
                        case g:
                        case f:
                            return a;
                        default:
                            switch(a = a && a.$$typeof, a){
                                case k:
                                case n:
                                case h:
                                    return a;
                                default:
                                    return q;
                            }
                    }
                case d:
                    return q;
            }
        }
    }
    function v(a) {
        return u(a) === m;
    }
    exports.typeOf = u;
    exports.AsyncMode = l;
    exports.ConcurrentMode = m;
    exports.ContextConsumer = k;
    exports.ContextProvider = h;
    exports.Element = c;
    exports.ForwardRef = n;
    exports.Fragment = e;
    exports.Profiler = g;
    exports.Portal = d;
    exports.StrictMode = f;
    exports.isValidElementType = function(a) {
        return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n);
    };
    exports.isAsyncMode = function(a) {
        return v(a) || u(a) === l;
    };
    exports.isConcurrentMode = v;
    exports.isContextConsumer = function(a) {
        return u(a) === k;
    };
    exports.isContextProvider = function(a) {
        return u(a) === h;
    };
    exports.isElement = function(a) {
        return "object" === typeof a && null !== a && a.$$typeof === c;
    };
    exports.isForwardRef = function(a) {
        return u(a) === n;
    };
    exports.isFragment = function(a) {
        return u(a) === e;
    };
    exports.isProfiler = function(a) {
        return u(a) === g;
    };
    exports.isPortal = function(a) {
        return u(a) === d;
    };
    exports.isStrictMode = function(a) {
        return u(a) === f;
    };
});
$89be00fd7ffd1d5f$var$unwrapExports($89be00fd7ffd1d5f$var$reactIs_production_min);
var $89be00fd7ffd1d5f$var$reactIs_production_min_1 = $89be00fd7ffd1d5f$var$reactIs_production_min.typeOf;
var $89be00fd7ffd1d5f$var$reactIs_production_min_2 = $89be00fd7ffd1d5f$var$reactIs_production_min.AsyncMode;
var $89be00fd7ffd1d5f$var$reactIs_production_min_3 = $89be00fd7ffd1d5f$var$reactIs_production_min.ConcurrentMode;
var $89be00fd7ffd1d5f$var$reactIs_production_min_4 = $89be00fd7ffd1d5f$var$reactIs_production_min.ContextConsumer;
var $89be00fd7ffd1d5f$var$reactIs_production_min_5 = $89be00fd7ffd1d5f$var$reactIs_production_min.ContextProvider;
var $89be00fd7ffd1d5f$var$reactIs_production_min_6 = $89be00fd7ffd1d5f$var$reactIs_production_min.Element;
var $89be00fd7ffd1d5f$var$reactIs_production_min_7 = $89be00fd7ffd1d5f$var$reactIs_production_min.ForwardRef;
var $89be00fd7ffd1d5f$var$reactIs_production_min_8 = $89be00fd7ffd1d5f$var$reactIs_production_min.Fragment;
var $89be00fd7ffd1d5f$var$reactIs_production_min_9 = $89be00fd7ffd1d5f$var$reactIs_production_min.Profiler;
var $89be00fd7ffd1d5f$var$reactIs_production_min_10 = $89be00fd7ffd1d5f$var$reactIs_production_min.Portal;
var $89be00fd7ffd1d5f$var$reactIs_production_min_11 = $89be00fd7ffd1d5f$var$reactIs_production_min.StrictMode;
var $89be00fd7ffd1d5f$var$reactIs_production_min_12 = $89be00fd7ffd1d5f$var$reactIs_production_min.isValidElementType;
var $89be00fd7ffd1d5f$var$reactIs_production_min_13 = $89be00fd7ffd1d5f$var$reactIs_production_min.isAsyncMode;
var $89be00fd7ffd1d5f$var$reactIs_production_min_14 = $89be00fd7ffd1d5f$var$reactIs_production_min.isConcurrentMode;
var $89be00fd7ffd1d5f$var$reactIs_production_min_15 = $89be00fd7ffd1d5f$var$reactIs_production_min.isContextConsumer;
var $89be00fd7ffd1d5f$var$reactIs_production_min_16 = $89be00fd7ffd1d5f$var$reactIs_production_min.isContextProvider;
var $89be00fd7ffd1d5f$var$reactIs_production_min_17 = $89be00fd7ffd1d5f$var$reactIs_production_min.isElement;
var $89be00fd7ffd1d5f$var$reactIs_production_min_18 = $89be00fd7ffd1d5f$var$reactIs_production_min.isForwardRef;
var $89be00fd7ffd1d5f$var$reactIs_production_min_19 = $89be00fd7ffd1d5f$var$reactIs_production_min.isFragment;
var $89be00fd7ffd1d5f$var$reactIs_production_min_20 = $89be00fd7ffd1d5f$var$reactIs_production_min.isProfiler;
var $89be00fd7ffd1d5f$var$reactIs_production_min_21 = $89be00fd7ffd1d5f$var$reactIs_production_min.isPortal;
var $89be00fd7ffd1d5f$var$reactIs_production_min_22 = $89be00fd7ffd1d5f$var$reactIs_production_min.isStrictMode;
var $89be00fd7ffd1d5f$var$reactIs = $89be00fd7ffd1d5f$var$createCommonjsModule(function(module) {
    module.exports = $89be00fd7ffd1d5f$var$reactIs_production_min;
});
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */ var $89be00fd7ffd1d5f$var$REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};
var $89be00fd7ffd1d5f$var$KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};
var $89be00fd7ffd1d5f$var$FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};
var $89be00fd7ffd1d5f$var$TYPE_STATICS = {};
$89be00fd7ffd1d5f$var$TYPE_STATICS[$89be00fd7ffd1d5f$var$reactIs.ForwardRef] = $89be00fd7ffd1d5f$var$FORWARD_REF_STATICS;
var $89be00fd7ffd1d5f$var$defineProperty = Object.defineProperty;
var $89be00fd7ffd1d5f$var$getOwnPropertyNames = Object.getOwnPropertyNames;
var $89be00fd7ffd1d5f$var$getOwnPropertySymbols = Object.getOwnPropertySymbols;
var $89be00fd7ffd1d5f$var$getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var $89be00fd7ffd1d5f$var$getPrototypeOf = Object.getPrototypeOf;
var $89be00fd7ffd1d5f$var$objectPrototype = Object.prototype;
function $89be00fd7ffd1d5f$var$hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
        // don't hoist over string (html) components
        if ($89be00fd7ffd1d5f$var$objectPrototype) {
            var inheritedComponent = $89be00fd7ffd1d5f$var$getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== $89be00fd7ffd1d5f$var$objectPrototype) $89be00fd7ffd1d5f$var$hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
        var keys = $89be00fd7ffd1d5f$var$getOwnPropertyNames(sourceComponent);
        if ($89be00fd7ffd1d5f$var$getOwnPropertySymbols) keys = keys.concat($89be00fd7ffd1d5f$var$getOwnPropertySymbols(sourceComponent));
        var targetStatics = $89be00fd7ffd1d5f$var$TYPE_STATICS[targetComponent["$$typeof"]] || $89be00fd7ffd1d5f$var$REACT_STATICS;
        var sourceStatics = $89be00fd7ffd1d5f$var$TYPE_STATICS[sourceComponent["$$typeof"]] || $89be00fd7ffd1d5f$var$REACT_STATICS;
        for(var i = 0; i < keys.length; ++i){
            var key = keys[i];
            if (!$89be00fd7ffd1d5f$var$KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = $89be00fd7ffd1d5f$var$getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    $89be00fd7ffd1d5f$var$defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }
        return targetComponent;
    }
    return targetComponent;
}
var $89be00fd7ffd1d5f$var$hoistNonReactStatics_cjs = $89be00fd7ffd1d5f$var$hoistNonReactStatics;
var $89be00fd7ffd1d5f$var$EventEmitter = /*#__PURE__*/ function() {
    function EventEmitter() {
        $89be00fd7ffd1d5f$var$_classCallCheck(this, EventEmitter);
        this.listeners = [];
    }
    $89be00fd7ffd1d5f$var$_createClass(EventEmitter, [
        {
            key: "on",
            value: function on(cb) {
                var _this = this;
                this.listeners.push(cb);
                return function() {
                    var index = _this.listeners.indexOf(cb);
                    if (index !== -1) _this.listeners.splice(index, 1);
                };
            }
        },
        {
            key: "emit",
            value: function emit(data) {
                this.listeners.forEach(function(fn) {
                    return fn(data);
                });
            }
        }
    ]);
    return EventEmitter;
}();
function $89be00fd7ffd1d5f$var$createChainableTypeChecker(validate) {
    function checkType(isRequired, props, propName, componentName, location, propFullName) {
        for(var _len = arguments.length, rest = new Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++)rest[_key - 6] = arguments[_key];
        return (0, $11a86e62e4f971e6$export$8c437e4d572e2f99)(function() {
            componentName = componentName || "<<anonymous>>";
            propFullName = propFullName || propName;
            if (props[propName] == null) {
                if (isRequired) {
                    var actual = props[propName] === null ? "null" : "undefined";
                    return new Error("The " + location + " `" + propFullName + "` is marked as required " + "in `" + componentName + "`, but its value is `" + actual + "`.");
                }
                return null;
            } else return validate.apply(void 0, [
                props,
                propName,
                componentName,
                location,
                propFullName
            ].concat(rest));
        });
    }
    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);
    return chainedCheckType;
} // Copied from React.PropTypes
function $89be00fd7ffd1d5f$var$isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === "symbol") return true;
     // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue["@@toStringTag"] === "Symbol") return true;
     // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === "function" && propValue instanceof Symbol) return true;
    return false;
} // Copied from React.PropTypes
function $89be00fd7ffd1d5f$var$getPropType(propValue) {
    var propType = $89be00fd7ffd1d5f$var$_typeof(propValue);
    if (Array.isArray(propValue)) return "array";
    if (propValue instanceof RegExp) // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return "object";
    if ($89be00fd7ffd1d5f$var$isSymbol(propType, propValue)) return "symbol";
    return propType;
} // This handles more types than `getPropType`. Only used for error messages.
// Copied from React.PropTypes
function $89be00fd7ffd1d5f$var$getPreciseType(propValue) {
    var propType = $89be00fd7ffd1d5f$var$getPropType(propValue);
    if (propType === "object") {
        if (propValue instanceof Date) return "date";
        else if (propValue instanceof RegExp) return "regexp";
    }
    return propType;
}
function $89be00fd7ffd1d5f$var$createObservableTypeCheckerCreator(allowNativeType, mobxType) {
    return $89be00fd7ffd1d5f$var$createChainableTypeChecker(function(props, propName, componentName, location, propFullName) {
        return (0, $11a86e62e4f971e6$export$8c437e4d572e2f99)(function() {
            if (allowNativeType) {
                if ($89be00fd7ffd1d5f$var$getPropType(props[propName]) === mobxType.toLowerCase()) return null;
            }
            var mobxChecker;
            switch(mobxType){
                case "Array":
                    mobxChecker = (0, $11a86e62e4f971e6$export$f5afceff386badf9);
                    break;
                case "Object":
                    mobxChecker = (0, $11a86e62e4f971e6$export$31960fb081a18155);
                    break;
                case "Map":
                    mobxChecker = (0, $11a86e62e4f971e6$export$27a7faddcfd44960);
                    break;
                default:
                    throw new Error("Unexpected mobxType: ".concat(mobxType));
            }
            var propValue = props[propName];
            if (!mobxChecker(propValue)) {
                var preciseType = $89be00fd7ffd1d5f$var$getPreciseType(propValue);
                var nativeTypeExpectationMessage = allowNativeType ? " or javascript `" + mobxType.toLowerCase() + "`" : "";
                return new Error("Invalid prop `" + propFullName + "` of type `" + preciseType + "` supplied to" + " `" + componentName + "`, expected `mobx.Observable" + mobxType + "`" + nativeTypeExpectationMessage + ".");
            }
            return null;
        });
    });
}
function $89be00fd7ffd1d5f$var$createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {
    return $89be00fd7ffd1d5f$var$createChainableTypeChecker(function(props, propName, componentName, location, propFullName) {
        for(var _len2 = arguments.length, rest = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++)rest[_key2 - 5] = arguments[_key2];
        return (0, $11a86e62e4f971e6$export$8c437e4d572e2f99)(function() {
            if (typeof typeChecker !== "function") return new Error("Property `" + propFullName + "` of component `" + componentName + "` has " + "invalid PropType notation.");
            var error = $89be00fd7ffd1d5f$var$createObservableTypeCheckerCreator(allowNativeType, "Array")(props, propName, componentName);
            if (error instanceof Error) return error;
            var propValue = props[propName];
            for(var i = 0; i < propValue.length; i++){
                error = typeChecker.apply(void 0, [
                    propValue,
                    i,
                    componentName,
                    location,
                    propFullName + "[" + i + "]"
                ].concat(rest));
                if (error instanceof Error) return error;
            }
            return null;
        });
    });
}
var $89be00fd7ffd1d5f$var$observableArray = $89be00fd7ffd1d5f$var$createObservableTypeCheckerCreator(false, "Array");
var $89be00fd7ffd1d5f$var$observableArrayOf = $89be00fd7ffd1d5f$var$createObservableArrayOfTypeChecker.bind(null, false);
var $89be00fd7ffd1d5f$var$observableMap = $89be00fd7ffd1d5f$var$createObservableTypeCheckerCreator(false, "Map");
var $89be00fd7ffd1d5f$var$observableObject = $89be00fd7ffd1d5f$var$createObservableTypeCheckerCreator(false, "Object");
var $89be00fd7ffd1d5f$var$arrayOrObservableArray = $89be00fd7ffd1d5f$var$createObservableTypeCheckerCreator(true, "Array");
var $89be00fd7ffd1d5f$var$arrayOrObservableArrayOf = $89be00fd7ffd1d5f$var$createObservableArrayOfTypeChecker.bind(null, true);
var $89be00fd7ffd1d5f$var$objectOrObservableObject = $89be00fd7ffd1d5f$var$createObservableTypeCheckerCreator(true, "Object");
var $89be00fd7ffd1d5f$export$513805011eaa4892 = /*#__PURE__*/ Object.freeze({
    observableArray: $89be00fd7ffd1d5f$var$observableArray,
    observableArrayOf: $89be00fd7ffd1d5f$var$observableArrayOf,
    observableMap: $89be00fd7ffd1d5f$var$observableMap,
    observableObject: $89be00fd7ffd1d5f$var$observableObject,
    arrayOrObservableArray: $89be00fd7ffd1d5f$var$arrayOrObservableArray,
    arrayOrObservableArrayOf: $89be00fd7ffd1d5f$var$arrayOrObservableArrayOf,
    objectOrObservableObject: $89be00fd7ffd1d5f$var$objectOrObservableObject
});
function $89be00fd7ffd1d5f$var$isStateless(component) {
    // `function() {}` has prototype, but `() => {}` doesn't
    // `() => {}` via Babel has prototype too.
    return !(component.prototype && component.prototype.render);
}
var $89be00fd7ffd1d5f$var$symbolId = 0;
function $89be00fd7ffd1d5f$var$newSymbol(name) {
    if (typeof Symbol === "function") return Symbol(name);
    var symbol = "__$mobx-react ".concat(name, " (").concat($89be00fd7ffd1d5f$var$symbolId, ")");
    $89be00fd7ffd1d5f$var$symbolId++;
    return symbol;
}
var $89be00fd7ffd1d5f$var$mobxMixins = $89be00fd7ffd1d5f$var$newSymbol("patchMixins");
var $89be00fd7ffd1d5f$var$mobxPatchedDefinition = $89be00fd7ffd1d5f$var$newSymbol("patchedDefinition");
function $89be00fd7ffd1d5f$var$getMixins(target, methodName) {
    var mixins = target[$89be00fd7ffd1d5f$var$mobxMixins] = target[$89be00fd7ffd1d5f$var$mobxMixins] || {};
    var methodMixins = mixins[methodName] = mixins[methodName] || {};
    methodMixins.locks = methodMixins.locks || 0;
    methodMixins.methods = methodMixins.methods || [];
    return methodMixins;
}
function $89be00fd7ffd1d5f$var$wrapper(realMethod, mixins) {
    var _this = this;
    for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)args[_key - 2] = arguments[_key];
    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls
    mixins.locks++;
    try {
        var retVal;
        if (realMethod !== undefined && realMethod !== null) retVal = realMethod.apply(this, args);
        return retVal;
    } finally{
        mixins.locks--;
        if (mixins.locks === 0) mixins.methods.forEach(function(mx) {
            mx.apply(_this, args);
        });
    }
}
function $89be00fd7ffd1d5f$var$wrapFunction(realMethod, mixins) {
    var fn = function fn() {
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
        $89be00fd7ffd1d5f$var$wrapper.call.apply($89be00fd7ffd1d5f$var$wrapper, [
            this,
            realMethod,
            mixins
        ].concat(args));
    };
    return fn;
}
function $89be00fd7ffd1d5f$var$patch(target, methodName) {
    var mixins = $89be00fd7ffd1d5f$var$getMixins(target, methodName);
    for(var _len3 = arguments.length, mixinMethods = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++)mixinMethods[_key3 - 2] = arguments[_key3];
    for(var _i = 0; _i < mixinMethods.length; _i++){
        var mixinMethod = mixinMethods[_i];
        if (mixins.methods.indexOf(mixinMethod) < 0) mixins.methods.push(mixinMethod);
    }
    var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);
    if (oldDefinition && oldDefinition[$89be00fd7ffd1d5f$var$mobxPatchedDefinition]) // already patched definition, do not repatch
    return;
    var originalMethod = target[methodName];
    var newDefinition = $89be00fd7ffd1d5f$var$createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);
    Object.defineProperty(target, methodName, newDefinition);
}
function $89be00fd7ffd1d5f$var$createDefinition(target, methodName, enumerable, mixins, originalMethod) {
    var _ref;
    var wrappedFunc = $89be00fd7ffd1d5f$var$wrapFunction(originalMethod, mixins);
    return _ref = {}, $89be00fd7ffd1d5f$var$_defineProperty(_ref, $89be00fd7ffd1d5f$var$mobxPatchedDefinition, true), $89be00fd7ffd1d5f$var$_defineProperty(_ref, "get", function get() {
        return wrappedFunc;
    }), $89be00fd7ffd1d5f$var$_defineProperty(_ref, "set", function set(value) {
        if (this === target) wrappedFunc = $89be00fd7ffd1d5f$var$wrapFunction(value, mixins);
        else {
            // when it is an instance of the prototype/a child prototype patch that particular case again separately
            // since we need to store separate values depending on wether it is the actual instance, the prototype, etc
            // e.g. the method for super might not be the same as the method for the prototype which might be not the same
            // as the method for the instance
            var newDefinition = $89be00fd7ffd1d5f$var$createDefinition(this, methodName, enumerable, mixins, value);
            Object.defineProperty(this, methodName, newDefinition);
        }
    }), $89be00fd7ffd1d5f$var$_defineProperty(_ref, "configurable", true), $89be00fd7ffd1d5f$var$_defineProperty(_ref, "enumerable", enumerable), _ref;
}
var $89be00fd7ffd1d5f$var$injectorContextTypes = {
    mobxStores: $89be00fd7ffd1d5f$var$objectOrObservableObject
};
Object.seal($89be00fd7ffd1d5f$var$injectorContextTypes);
var $89be00fd7ffd1d5f$var$proxiedInjectorProps = {
    contextTypes: {
        get: function get() {
            return $89be00fd7ffd1d5f$var$injectorContextTypes;
        },
        set: function set(_) {
            console.warn("Mobx Injector: you are trying to attach `contextTypes` on an component decorated with `inject` (or `observer`) HOC. Please specify the contextTypes on the wrapped component instead. It is accessible through the `wrappedComponent`");
        },
        configurable: true,
        enumerable: false
    },
    isMobxInjector: {
        value: true,
        writable: true,
        configurable: true,
        enumerable: true
    }
};
function $89be00fd7ffd1d5f$var$createStoreInjector(grabStoresFn, component, injectNames) {
    var displayName = "inject-" + (component.displayName || component.name || component.constructor && component.constructor.name || "Unknown");
    if (injectNames) displayName += "-with-" + injectNames;
    var Injector = /*#__PURE__*/ function(_Component) {
        $89be00fd7ffd1d5f$var$_inherits(Injector, _Component);
        function Injector() {
            var _getPrototypeOf2;
            var _this;
            $89be00fd7ffd1d5f$var$_classCallCheck(this, Injector);
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
            _this = $89be00fd7ffd1d5f$var$_possibleConstructorReturn(this, (_getPrototypeOf2 = $89be00fd7ffd1d5f$var$_getPrototypeOf(Injector)).call.apply(_getPrototypeOf2, [
                this
            ].concat(args)));
            _this.storeRef = function(instance) {
                _this.wrappedInstance = instance;
            };
            return _this;
        }
        $89be00fd7ffd1d5f$var$_createClass(Injector, [
            {
                key: "render",
                value: function render() {
                    // Optimization: it might be more efficient to apply the mapper function *outside* the render method
                    // (if the mapper is a function), that could avoid expensive(?) re-rendering of the injector component
                    // See this test: 'using a custom injector is not too reactive' in inject.js
                    var newProps = {};
                    for(var key in this.props)if (this.props.hasOwnProperty(key)) newProps[key] = this.props[key];
                    var additionalProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context) || {};
                    for(var _key2 in additionalProps)newProps[_key2] = additionalProps[_key2];
                    if (!$89be00fd7ffd1d5f$var$isStateless(component)) newProps.ref = this.storeRef;
                    return (0, $aaLBe.createElement)(component, newProps);
                }
            }
        ]);
        return Injector;
    }((0, $aaLBe.Component)); // Static fields from component should be visible on the generated Injector
    Injector.displayName = displayName;
    $89be00fd7ffd1d5f$var$hoistNonReactStatics_cjs(Injector, component);
    Injector.wrappedComponent = component;
    Object.defineProperties(Injector, $89be00fd7ffd1d5f$var$proxiedInjectorProps);
    return Injector;
}
function $89be00fd7ffd1d5f$var$grabStoresByName(storeNames) {
    return function(baseStores, nextProps) {
        storeNames.forEach(function(storeName) {
            if (storeName in nextProps // prefer props over stores
            ) return;
            if (!(storeName in baseStores)) throw new Error("MobX injector: Store '" + storeName + "' is not available! Make sure it is provided by some Provider");
            nextProps[storeName] = baseStores[storeName];
        });
        return nextProps;
    };
}
/**
 * higher order component that injects stores to a child.
 * takes either a varargs list of strings, which are stores read from the context,
 * or a function that manually maps the available stores from the context to props:
 * storesToProps(mobxStores, props, context) => newProps
 */ function $89be00fd7ffd1d5f$export$a976684a0efeb93f() /* fn(stores, nextProps) or ...storeNames */ {
    var grabStoresFn;
    if (typeof arguments[0] === "function") {
        grabStoresFn = arguments[0];
        return function(componentClass) {
            var injected = $89be00fd7ffd1d5f$var$createStoreInjector(grabStoresFn, componentClass);
            injected.isMobxInjector = false; // supress warning
            // mark the Injector as observer, to make it react to expressions in `grabStoresFn`,
            // see #111
            injected = $89be00fd7ffd1d5f$export$b6ae1bc530f4c149(injected);
            injected.isMobxInjector = true; // restore warning
            return injected;
        };
    } else {
        var storeNames = [];
        for(var i = 0; i < arguments.length; i++)storeNames[i] = arguments[i];
        grabStoresFn = $89be00fd7ffd1d5f$var$grabStoresByName(storeNames);
        return function(componentClass) {
            return $89be00fd7ffd1d5f$var$createStoreInjector(grabStoresFn, componentClass, storeNames.join("-"));
        };
    }
}
var $89be00fd7ffd1d5f$var$mobxAdminProperty = (0, $11a86e62e4f971e6$export$f246528900dd4467) || "$mobx";
var $89be00fd7ffd1d5f$var$mobxIsUnmounted = $89be00fd7ffd1d5f$var$newSymbol("isUnmounted");
/**
 * dev tool support
 */ var $89be00fd7ffd1d5f$var$isDevtoolsEnabled = false;
var $89be00fd7ffd1d5f$var$isUsingStaticRendering = false;
var $89be00fd7ffd1d5f$var$warnedAboutObserverInjectDeprecation = false; // WeakMap<Node, Object>;
var $89be00fd7ffd1d5f$export$47b2ca1072935aee = typeof WeakMap !== "undefined" ? new WeakMap() : undefined;
var $89be00fd7ffd1d5f$export$4e5e4824fdee985b = new $89be00fd7ffd1d5f$var$EventEmitter();
var $89be00fd7ffd1d5f$var$skipRenderKey = $89be00fd7ffd1d5f$var$newSymbol("skipRender");
var $89be00fd7ffd1d5f$var$isForcingUpdateKey = $89be00fd7ffd1d5f$var$newSymbol("isForcingUpdate"); // Using react-is had some issues (and operates on elements, not on types), see #608 / #609
var $89be00fd7ffd1d5f$var$ReactForwardRefSymbol = typeof (0, $aaLBe.forwardRef) === "function" && (0, $aaLBe.forwardRef)(function(_props, _ref) {})["$$typeof"];
/**
 * Helper to set `prop` to `this` as non-enumerable (hidden prop)
 * @param target
 * @param prop
 * @param value
 */ function $89be00fd7ffd1d5f$var$setHiddenProp(target, prop, value) {
    if (!Object.hasOwnProperty.call(target, prop)) Object.defineProperty(target, prop, {
        enumerable: false,
        configurable: true,
        writable: true,
        value: value
    });
    else target[prop] = value;
}
function $89be00fd7ffd1d5f$var$findDOMNode$2(component) {
    if (0, $ba021dca0cbd5bec$exports.findDOMNode) try {
        return (0, $ba021dca0cbd5bec$exports.findDOMNode)(component);
    } catch (e) {
        // findDOMNode will throw in react-test-renderer, see:
        // See https://github.com/mobxjs/mobx-react/issues/216
        // Is there a better heuristic?
        return null;
    }
    return null;
}
function $89be00fd7ffd1d5f$var$reportRendering(component) {
    var node = $89be00fd7ffd1d5f$var$findDOMNode$2(component);
    if (node && $89be00fd7ffd1d5f$export$47b2ca1072935aee) $89be00fd7ffd1d5f$export$47b2ca1072935aee.set(node, component);
    $89be00fd7ffd1d5f$export$4e5e4824fdee985b.emit({
        event: "render",
        renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,
        totalTime: Date.now() - component.__$mobRenderStart,
        component: component,
        node: node
    });
}
function $89be00fd7ffd1d5f$export$69b2aa3117973c0f() {
    if (typeof WeakMap === "undefined") throw new Error("[mobx-react] tracking components is not supported in this browser.");
    if (!$89be00fd7ffd1d5f$var$isDevtoolsEnabled) $89be00fd7ffd1d5f$var$isDevtoolsEnabled = true;
}
function $89be00fd7ffd1d5f$export$7613124ee4202834(useStaticRendering) {
    $89be00fd7ffd1d5f$var$isUsingStaticRendering = useStaticRendering;
}
/**
 * Errors reporter
 */ var $89be00fd7ffd1d5f$var$errorsReporter = new $89be00fd7ffd1d5f$var$EventEmitter();
/**
 * Utilities
 */ function $89be00fd7ffd1d5f$var$patch$1(target, funcName) {
    $89be00fd7ffd1d5f$var$patch(target, funcName, $89be00fd7ffd1d5f$var$reactiveMixin[funcName]);
}
function $89be00fd7ffd1d5f$var$shallowEqual(objA, objB) {
    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if ($89be00fd7ffd1d5f$var$is(objA, objB)) return true;
    if ($89be00fd7ffd1d5f$var$_typeof(objA) !== "object" || objA === null || $89be00fd7ffd1d5f$var$_typeof(objB) !== "object" || objB === null) return false;
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for(var i = 0; i < keysA.length; i++){
        if (!hasOwnProperty.call(objB, keysA[i]) || !$89be00fd7ffd1d5f$var$is(objA[keysA[i]], objB[keysA[i]])) return false;
    }
    return true;
}
function $89be00fd7ffd1d5f$var$is(x, y) {
    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if (x === y) return x !== 0 || 1 / x === 1 / y;
    else return x !== x && y !== y;
}
function $89be00fd7ffd1d5f$var$makeComponentReactive(render) {
    var _this2 = this;
    if ($89be00fd7ffd1d5f$var$isUsingStaticRendering === true) return render.call(this);
    function reactiveRender() {
        var _this = this;
        isRenderingPending = false;
        var exception = undefined;
        var rendering = undefined;
        reaction.track(function() {
            if ($89be00fd7ffd1d5f$var$isDevtoolsEnabled) _this.__$mobRenderStart = Date.now();
            try {
                rendering = (0, $11a86e62e4f971e6$export$e510c5d1ea4358b1)(false, baseRender);
            } catch (e) {
                exception = e;
            }
            if ($89be00fd7ffd1d5f$var$isDevtoolsEnabled) _this.__$mobRenderEnd = Date.now();
        });
        if (exception) {
            $89be00fd7ffd1d5f$var$errorsReporter.emit(exception);
            throw exception;
        }
        return rendering;
    } // Generate friendly name for debugging
    var initialName = this.displayName || this.name || this.constructor && (this.constructor.displayName || this.constructor.name) || "<component>";
    var rootNodeID = this._reactInternalInstance && this._reactInternalInstance._rootNodeID || this._reactInternalInstance && this._reactInternalInstance._debugID || this._reactInternalFiber && this._reactInternalFiber._debugID;
    /**
   * If props are shallowly modified, react will render anyway,
   * so atom.reportChanged() should not result in yet another re-render
   */ $89be00fd7ffd1d5f$var$setHiddenProp(this, $89be00fd7ffd1d5f$var$skipRenderKey, false);
    /**
   * forceUpdate will re-assign this.props. We don't want that to cause a loop,
   * so detect these changes
   */ $89be00fd7ffd1d5f$var$setHiddenProp(this, $89be00fd7ffd1d5f$var$isForcingUpdateKey, false); // wire up reactive render
    var baseRender = render.bind(this);
    var isRenderingPending = false;
    var reaction = new (0, $11a86e62e4f971e6$export$d2ae4167a30cf6bb)("".concat(initialName, "#").concat(rootNodeID, ".render()"), function() {
        if (!isRenderingPending) {
            // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)
            // This unidiomatic React usage but React will correctly warn about this so we continue as usual
            // See #85 / Pull #44
            isRenderingPending = true;
            if (typeof _this2.componentWillReact === "function") _this2.componentWillReact(); // TODO: wrap in action?
            if (_this2[$89be00fd7ffd1d5f$var$mobxIsUnmounted] !== true) {
                // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted
                // TODO: remove this check? Then react will properly warn about the fact that this should not happen? See #73
                // However, people also claim this might happen during unit tests..
                var hasError = true;
                try {
                    $89be00fd7ffd1d5f$var$setHiddenProp(_this2, $89be00fd7ffd1d5f$var$isForcingUpdateKey, true);
                    if (!_this2[$89be00fd7ffd1d5f$var$skipRenderKey]) (0, $aaLBe.Component).prototype.forceUpdate.call(_this2);
                    hasError = false;
                } finally{
                    $89be00fd7ffd1d5f$var$setHiddenProp(_this2, $89be00fd7ffd1d5f$var$isForcingUpdateKey, false);
                    if (hasError) reaction.dispose();
                }
            }
        }
    });
    reaction.reactComponent = this;
    reactiveRender[$89be00fd7ffd1d5f$var$mobxAdminProperty] = reaction;
    this.render = reactiveRender;
    return reactiveRender.call(this);
}
/**
 * ReactiveMixin
 */ var $89be00fd7ffd1d5f$var$reactiveMixin = {
    componentWillUnmount: function componentWillUnmount() {
        if ($89be00fd7ffd1d5f$var$isUsingStaticRendering === true) return;
        this.render[$89be00fd7ffd1d5f$var$mobxAdminProperty] && this.render[$89be00fd7ffd1d5f$var$mobxAdminProperty].dispose();
        this[$89be00fd7ffd1d5f$var$mobxIsUnmounted] = true;
        if ($89be00fd7ffd1d5f$var$isDevtoolsEnabled) {
            var node = $89be00fd7ffd1d5f$var$findDOMNode$2(this);
            if (node && $89be00fd7ffd1d5f$export$47b2ca1072935aee) $89be00fd7ffd1d5f$export$47b2ca1072935aee.delete(node);
            $89be00fd7ffd1d5f$export$4e5e4824fdee985b.emit({
                event: "destroy",
                component: this,
                node: node
            });
        }
    },
    componentDidMount: function componentDidMount() {
        if ($89be00fd7ffd1d5f$var$isDevtoolsEnabled) $89be00fd7ffd1d5f$var$reportRendering(this);
    },
    componentDidUpdate: function componentDidUpdate() {
        if ($89be00fd7ffd1d5f$var$isDevtoolsEnabled) $89be00fd7ffd1d5f$var$reportRendering(this);
    },
    shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
        if ($89be00fd7ffd1d5f$var$isUsingStaticRendering) console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");
         // update on any state changes (as is the default)
        if (this.state !== nextState) return true;
         // update if props are shallowly not equal, inspired by PureRenderMixin
        // we could return just 'false' here, and avoid the `skipRender` checks etc
        // however, it is nicer if lifecycle events are triggered like usually,
        // so we return true here if props are shallowly modified.
        return !$89be00fd7ffd1d5f$var$shallowEqual(this.props, nextProps);
    }
};
function $89be00fd7ffd1d5f$var$makeObservableProp(target, propName) {
    var valueHolderKey = $89be00fd7ffd1d5f$var$newSymbol("reactProp_".concat(propName, "_valueHolder"));
    var atomHolderKey = $89be00fd7ffd1d5f$var$newSymbol("reactProp_".concat(propName, "_atomHolder"));
    function getAtom() {
        if (!this[atomHolderKey]) $89be00fd7ffd1d5f$var$setHiddenProp(this, atomHolderKey, (0, $11a86e62e4f971e6$export$2e17fe64ec9a826e)("reactive " + propName));
        return this[atomHolderKey];
    }
    Object.defineProperty(target, propName, {
        configurable: true,
        enumerable: true,
        get: function get() {
            getAtom.call(this).reportObserved();
            return this[valueHolderKey];
        },
        set: function set(v) {
            if (!this[$89be00fd7ffd1d5f$var$isForcingUpdateKey] && !$89be00fd7ffd1d5f$var$shallowEqual(this[valueHolderKey], v)) {
                $89be00fd7ffd1d5f$var$setHiddenProp(this, valueHolderKey, v);
                $89be00fd7ffd1d5f$var$setHiddenProp(this, $89be00fd7ffd1d5f$var$skipRenderKey, true);
                getAtom.call(this).reportChanged();
                $89be00fd7ffd1d5f$var$setHiddenProp(this, $89be00fd7ffd1d5f$var$skipRenderKey, false);
            } else $89be00fd7ffd1d5f$var$setHiddenProp(this, valueHolderKey, v);
        }
    });
}
/**
 * Observer function / decorator
 */ function $89be00fd7ffd1d5f$export$b6ae1bc530f4c149(arg1, arg2) {
    if (typeof arg1 === "string") throw new Error("Store names should be provided as array");
    if (Array.isArray(arg1)) {
        // TODO: remove in next major
        // component needs stores
        if (!$89be00fd7ffd1d5f$var$warnedAboutObserverInjectDeprecation) {
            $89be00fd7ffd1d5f$var$warnedAboutObserverInjectDeprecation = true;
            console.warn('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject("store1", "store2") @observer ComponentClass` or `inject("store1", "store2")(observer(componentClass))` instead of `@observer(["store1", "store2"]) ComponentClass`');
        }
        if (!arg2) // invoked as decorator
        return function(componentClass) {
            return $89be00fd7ffd1d5f$export$b6ae1bc530f4c149(arg1, componentClass);
        };
        else return $89be00fd7ffd1d5f$export$a976684a0efeb93f.apply(null, arg1)($89be00fd7ffd1d5f$export$b6ae1bc530f4c149(arg2));
    }
    var componentClass = arg1;
    if (componentClass.isMobxInjector === true) console.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'");
    if (componentClass.__proto__ === (0, $aaLBe.PureComponent)) console.warn("Mobx observer: You are using 'observer' on React.PureComponent. These two achieve two opposite goals and should not be used together");
     // Unwrap forward refs into `<Observer>` component
    // we need to unwrap the render, because it is the inner render that needs to be tracked,
    // not the ForwardRef HoC
    if ($89be00fd7ffd1d5f$var$ReactForwardRefSymbol && componentClass["$$typeof"] === $89be00fd7ffd1d5f$var$ReactForwardRefSymbol) {
        var _baseRender = componentClass.render;
        if (typeof _baseRender !== "function") throw new Error("render property of ForwardRef was not a function"); // TODO: do we need to hoist statics from baseRender to the forward ref?
        return (0, $aaLBe.forwardRef)(function ObserverForwardRef() {
            var _arguments = arguments;
            return (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89be00fd7ffd1d5f$export$c1cbdee04e18ea8b, null, function() {
                return _baseRender.apply(undefined, _arguments);
            });
        });
    } // Stateless function component:
    // If it is function but doesn't seem to be a react class constructor,
    // wrap it to a react class automatically
    if (typeof componentClass === "function" && (!componentClass.prototype || !componentClass.prototype.render) && !componentClass.isReactClass && !(0, $aaLBe.Component).isPrototypeOf(componentClass)) {
        var _class, _temp;
        var observerComponent = $89be00fd7ffd1d5f$export$b6ae1bc530f4c149((_temp = _class = /*#__PURE__*/ function(_Component) {
            $89be00fd7ffd1d5f$var$_inherits(_class, _Component);
            function _class() {
                $89be00fd7ffd1d5f$var$_classCallCheck(this, _class);
                return $89be00fd7ffd1d5f$var$_possibleConstructorReturn(this, $89be00fd7ffd1d5f$var$_getPrototypeOf(_class).apply(this, arguments));
            }
            $89be00fd7ffd1d5f$var$_createClass(_class, [
                {
                    key: "render",
                    value: function render() {
                        return componentClass.call(this, this.props, this.context);
                    }
                }
            ]);
            return _class;
        }((0, $aaLBe.Component)), _class.displayName = componentClass.displayName || componentClass.name, _class.contextTypes = componentClass.contextTypes, _class.propTypes = componentClass.propTypes, _class.defaultProps = componentClass.defaultProps, _temp));
        $89be00fd7ffd1d5f$var$hoistNonReactStatics_cjs(observerComponent, componentClass);
        return observerComponent;
    }
    if (!componentClass) throw new Error("Please pass a valid component to 'observer'");
    var target = componentClass.prototype || componentClass;
    $89be00fd7ffd1d5f$var$mixinLifecycleEvents(target);
    componentClass.isMobXReactObserver = true;
    $89be00fd7ffd1d5f$var$makeObservableProp(target, "props");
    $89be00fd7ffd1d5f$var$makeObservableProp(target, "state");
    var baseRender = target.render;
    target.render = function() {
        return $89be00fd7ffd1d5f$var$makeComponentReactive.call(this, baseRender);
    };
    return componentClass;
}
function $89be00fd7ffd1d5f$var$mixinLifecycleEvents(target) {
    [
        "componentDidMount",
        "componentWillUnmount",
        "componentDidUpdate"
    ].forEach(function(funcName) {
        $89be00fd7ffd1d5f$var$patch$1(target, funcName);
    });
    if (!target.shouldComponentUpdate) target.shouldComponentUpdate = $89be00fd7ffd1d5f$var$reactiveMixin.shouldComponentUpdate;
    else if (target.shouldComponentUpdate !== $89be00fd7ffd1d5f$var$reactiveMixin.shouldComponentUpdate) // TODO: make throw in next major
    console.warn("Use `shouldComponentUpdate` in an `observer` based component breaks the behavior of `observer` and might lead to unexpected results. Manually implementing `sCU` should not be needed when using mobx-react.");
}
var $89be00fd7ffd1d5f$export$c1cbdee04e18ea8b = $89be00fd7ffd1d5f$export$b6ae1bc530f4c149(function(_ref2) {
    var children = _ref2.children, observerInject = _ref2.inject, render = _ref2.render;
    var component = children || render;
    if (typeof component === "undefined") return null;
    if (!observerInject) return component();
     // TODO: remove in next major
    console.warn("<Observer inject=.../> is no longer supported. Please use inject on the enclosing component instead");
    var InjectComponent = $89be00fd7ffd1d5f$export$a976684a0efeb93f(observerInject)(component);
    return (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(InjectComponent, null);
});
$89be00fd7ffd1d5f$export$c1cbdee04e18ea8b.displayName = "Observer";
var $89be00fd7ffd1d5f$var$ObserverPropsCheck = function ObserverPropsCheck(props, key, componentName, location, propFullName) {
    var extraKey = key === "children" ? "render" : "children";
    if (typeof props[key] === "function" && typeof props[extraKey] === "function") return new Error("Invalid prop,do not use children and render in the same time in`" + componentName);
    if (typeof props[key] === "function" || typeof props[extraKey] === "function") return;
    return new Error("Invalid prop `" + propFullName + "` of type `" + $89be00fd7ffd1d5f$var$_typeof(props[key]) + "` supplied to" + " `" + componentName + "`, expected `function`.");
};
$89be00fd7ffd1d5f$export$c1cbdee04e18ea8b.propTypes = {
    render: $89be00fd7ffd1d5f$var$ObserverPropsCheck,
    children: $89be00fd7ffd1d5f$var$ObserverPropsCheck
};
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function $89be00fd7ffd1d5f$var$componentWillMount() {
    // Call this.constructor.gDSFP to support sub-classes.
    var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
    if (state !== null && state !== undefined) this.setState(state);
}
function $89be00fd7ffd1d5f$var$componentWillReceiveProps(nextProps) {
    // Call this.constructor.gDSFP to support sub-classes.
    // Use the setState() updater to ensure state isn't stale in certain edge cases.
    function updater(prevState) {
        var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
        return state !== null && state !== undefined ? state : null;
    }
    // Binding "this" is important for shallow renderer support.
    this.setState(updater.bind(this));
}
function $89be00fd7ffd1d5f$var$componentWillUpdate(nextProps, nextState) {
    try {
        var prevProps = this.props;
        var prevState = this.state;
        this.props = nextProps;
        this.state = nextState;
        this.__reactInternalSnapshotFlag = true;
        this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
    } finally{
        this.props = prevProps;
        this.state = prevState;
    }
}
// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
$89be00fd7ffd1d5f$var$componentWillMount.__suppressDeprecationWarning = true;
$89be00fd7ffd1d5f$var$componentWillReceiveProps.__suppressDeprecationWarning = true;
$89be00fd7ffd1d5f$var$componentWillUpdate.__suppressDeprecationWarning = true;
function $89be00fd7ffd1d5f$var$polyfill(Component$$1) {
    var prototype = Component$$1.prototype;
    if (!prototype || !prototype.isReactComponent) throw new Error("Can only polyfill class components");
    if (typeof Component$$1.getDerivedStateFromProps !== "function" && typeof prototype.getSnapshotBeforeUpdate !== "function") return Component$$1;
    // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Error if any of these lifecycles are present,
    // Because they would work differently between older and newer (16.3+) versions of React.
    var foundWillMountName = null;
    var foundWillReceivePropsName = null;
    var foundWillUpdateName = null;
    if (typeof prototype.componentWillMount === "function") foundWillMountName = "componentWillMount";
    else if (typeof prototype.UNSAFE_componentWillMount === "function") foundWillMountName = "UNSAFE_componentWillMount";
    if (typeof prototype.componentWillReceiveProps === "function") foundWillReceivePropsName = "componentWillReceiveProps";
    else if (typeof prototype.UNSAFE_componentWillReceiveProps === "function") foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
    if (typeof prototype.componentWillUpdate === "function") foundWillUpdateName = "componentWillUpdate";
    else if (typeof prototype.UNSAFE_componentWillUpdate === "function") foundWillUpdateName = "UNSAFE_componentWillUpdate";
    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var componentName = Component$$1.displayName || Component$$1.name;
        var newApiName = typeof Component$$1.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
        throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (foundWillMountName !== null ? "\n  " + foundWillMountName : "") + (foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "") + (foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\n" + "https://fb.me/react-async-component-lifecycle-hooks");
    }
    // React <= 16.2 does not support static getDerivedStateFromProps.
    // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
    // Newer versions of React will ignore these lifecycles if gDSFP exists.
    if (typeof Component$$1.getDerivedStateFromProps === "function") {
        prototype.componentWillMount = $89be00fd7ffd1d5f$var$componentWillMount;
        prototype.componentWillReceiveProps = $89be00fd7ffd1d5f$var$componentWillReceiveProps;
    }
    // React <= 16.2 does not support getSnapshotBeforeUpdate.
    // As a workaround, use cWU to invoke the new lifecycle.
    // Newer versions of React will ignore that lifecycle if gSBU exists.
    if (typeof prototype.getSnapshotBeforeUpdate === "function") {
        if (typeof prototype.componentDidUpdate !== "function") throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
        prototype.componentWillUpdate = $89be00fd7ffd1d5f$var$componentWillUpdate;
        var componentDidUpdate = prototype.componentDidUpdate;
        prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
            // 16.3+ will not execute our will-update method;
            // It will pass a snapshot value to did-update though.
            // Older versions will require our polyfilled will-update value.
            // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
            // Because for <= 15.x versions this might be a "prevContext" object.
            // We also can't just check "__reactInternalSnapshot",
            // Because get-snapshot might return a falsy value.
            // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
            var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
            componentDidUpdate.call(this, prevProps, prevState, snapshot);
        };
    }
    return Component$$1;
}
var $89be00fd7ffd1d5f$var$specialReactKeys = {
    children: true,
    key: true,
    ref: true
};
var $89be00fd7ffd1d5f$export$2881499e37b75b9a = /*#__PURE__*/ function(_Component) {
    $89be00fd7ffd1d5f$var$_inherits(Provider, _Component);
    function Provider(props, context) {
        var _this;
        $89be00fd7ffd1d5f$var$_classCallCheck(this, Provider);
        _this = $89be00fd7ffd1d5f$var$_possibleConstructorReturn(this, $89be00fd7ffd1d5f$var$_getPrototypeOf(Provider).call(this, props, context));
        _this.state = {};
        $89be00fd7ffd1d5f$var$copyStores(props, _this.state);
        return _this;
    }
    $89be00fd7ffd1d5f$var$_createClass(Provider, [
        {
            key: "render",
            value: function render() {
                return (0, $aaLBe.Children).only(this.props.children);
            }
        },
        {
            key: "getChildContext",
            value: function getChildContext() {
                var stores = {}; // inherit stores
                $89be00fd7ffd1d5f$var$copyStores(this.context.mobxStores, stores); // add own stores
                $89be00fd7ffd1d5f$var$copyStores(this.props, stores);
                return {
                    mobxStores: stores
                };
            }
        }
    ], [
        {
            key: "getDerivedStateFromProps",
            value: function getDerivedStateFromProps(nextProps, prevState) {
                if (!nextProps) return null;
                if (!prevState) return nextProps; // Maybe this warning is too aggressive?
                if (Object.keys(nextProps).filter($89be00fd7ffd1d5f$var$validStoreName).length !== Object.keys(prevState).filter($89be00fd7ffd1d5f$var$validStoreName).length) console.warn("MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children");
                if (!nextProps.suppressChangedStoreWarning) {
                    for(var key in nextProps)if ($89be00fd7ffd1d5f$var$validStoreName(key) && prevState[key] !== nextProps[key]) console.warn("MobX Provider: Provided store '" + key + "' has changed. Please avoid replacing stores as the change might not propagate to all children");
                }
                return nextProps;
            }
        }
    ]);
    return Provider;
}((0, $aaLBe.Component));
$89be00fd7ffd1d5f$export$2881499e37b75b9a.contextTypes = {
    mobxStores: $89be00fd7ffd1d5f$var$objectOrObservableObject
};
$89be00fd7ffd1d5f$export$2881499e37b75b9a.childContextTypes = {
    mobxStores: $89be00fd7ffd1d5f$var$objectOrObservableObject.isRequired
};
function $89be00fd7ffd1d5f$var$copyStores(from, to) {
    if (!from) return;
    for(var key in from)if ($89be00fd7ffd1d5f$var$validStoreName(key)) to[key] = from[key];
}
function $89be00fd7ffd1d5f$var$validStoreName(key) {
    return !$89be00fd7ffd1d5f$var$specialReactKeys[key] && key !== "suppressChangedStoreWarning";
} // TODO: kill in next major
$89be00fd7ffd1d5f$var$polyfill($89be00fd7ffd1d5f$export$2881499e37b75b9a);
var $89be00fd7ffd1d5f$var$storeKey = $89be00fd7ffd1d5f$var$newSymbol("disposeOnUnmount");
function $89be00fd7ffd1d5f$var$runDisposersOnWillUnmount() {
    var _this = this;
    if (!this[$89be00fd7ffd1d5f$var$storeKey]) // when disposeOnUnmount is only set to some instances of a component it will still patch the prototype
    return;
    this[$89be00fd7ffd1d5f$var$storeKey].forEach(function(propKeyOrFunction) {
        var prop = typeof propKeyOrFunction === "string" ? _this[propKeyOrFunction] : propKeyOrFunction;
        if (prop !== undefined && prop !== null) {
            if (typeof prop !== "function") throw new Error("[mobx-react] disposeOnUnmount only works on functions such as disposers returned by reactions, autorun, etc.");
            prop();
        }
    });
    this[$89be00fd7ffd1d5f$var$storeKey] = [];
}
function $89be00fd7ffd1d5f$export$4e749cb731da87a9(target, propertyKeyOrFunction) {
    if (Array.isArray(propertyKeyOrFunction)) return propertyKeyOrFunction.map(function(fn) {
        return $89be00fd7ffd1d5f$export$4e749cb731da87a9(target, fn);
    });
    if (!target instanceof (0, $aaLBe.Component)) throw new Error("[mobx-react] disposeOnUnmount only works on class based React components.");
    if (typeof propertyKeyOrFunction !== "string" && typeof propertyKeyOrFunction !== "function") throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");
     // add property key / function we want run (disposed) to the store
    var componentWasAlreadyModified = !!target[$89be00fd7ffd1d5f$var$storeKey];
    var store = target[$89be00fd7ffd1d5f$var$storeKey] || (target[$89be00fd7ffd1d5f$var$storeKey] = []);
    store.push(propertyKeyOrFunction); // tweak the component class componentWillUnmount if not done already
    if (!componentWasAlreadyModified) $89be00fd7ffd1d5f$var$patch(target, "componentWillUnmount", $89be00fd7ffd1d5f$var$runDisposersOnWillUnmount);
     // return the disposer as is if invoked as a non decorator
    if (typeof propertyKeyOrFunction !== "string") return propertyKeyOrFunction;
}
if (!(0, $aaLBe.Component)) throw new Error("mobx-react requires React to be available");
if (!(0, $11a86e62e4f971e6$export$fcc0cd19e9fb2b4c)) throw new Error("mobx-react requires mobx to be available");
if (typeof (0, $ba021dca0cbd5bec$exports.unstable_batchedUpdates) === "function") (0, $11a86e62e4f971e6$export$8d21e34596265fa2)({
    reactionScheduler: (0, $ba021dca0cbd5bec$exports.unstable_batchedUpdates)
});
var $89be00fd7ffd1d5f$export$2288787135a8f66e = function onError(fn) {
    return $89be00fd7ffd1d5f$var$errorsReporter.on(fn);
};
if ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "undefined" ? "undefined" : $89be00fd7ffd1d5f$var$_typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === "object") {
    var $89be00fd7ffd1d5f$var$mobx = {
        spy: (0, $11a86e62e4f971e6$export$fcc0cd19e9fb2b4c),
        extras: {
            getDebugName: (0, $11a86e62e4f971e6$export$c48237bbccf30144)
        }
    };
    var $89be00fd7ffd1d5f$var$mobxReact = {
        renderReporter: $89be00fd7ffd1d5f$export$4e5e4824fdee985b,
        componentByNodeRegistry: $89be00fd7ffd1d5f$export$47b2ca1072935aee,
        componentByNodeRegistery: $89be00fd7ffd1d5f$export$47b2ca1072935aee,
        trackComponents: $89be00fd7ffd1d5f$export$69b2aa3117973c0f
    };
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobxReact($89be00fd7ffd1d5f$var$mobxReact, $89be00fd7ffd1d5f$var$mobx);
}



var $aaLBe = parcelRequire("aaLBe");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

"use strict";
function $9793d8a71e8d5ff2$export$2e2bcd8739ae039(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}


"use strict";
// utils is a library of generic helper functions non-specific to axios
const { toString: $6c358707ac100c0e$var$toString  } = Object.prototype;
const { getPrototypeOf: $6c358707ac100c0e$var$getPrototypeOf  } = Object;
const $6c358707ac100c0e$var$kindOf = ((cache)=>(thing)=>{
        const str = $6c358707ac100c0e$var$toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));
const $6c358707ac100c0e$var$kindOfTest = (type)=>{
    type = type.toLowerCase();
    return (thing)=>$6c358707ac100c0e$var$kindOf(thing) === type;
};
const $6c358707ac100c0e$var$typeOfTest = (type)=>(thing)=>typeof thing === type;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ const { isArray: $6c358707ac100c0e$var$isArray  } = Array;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ const $6c358707ac100c0e$var$isUndefined = $6c358707ac100c0e$var$typeOfTest("undefined");
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function $6c358707ac100c0e$var$isBuffer(val) {
    return val !== null && !$6c358707ac100c0e$var$isUndefined(val) && val.constructor !== null && !$6c358707ac100c0e$var$isUndefined(val.constructor) && $6c358707ac100c0e$var$isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ const $6c358707ac100c0e$var$isArrayBuffer = $6c358707ac100c0e$var$kindOfTest("ArrayBuffer");
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function $6c358707ac100c0e$var$isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && $6c358707ac100c0e$var$isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ const $6c358707ac100c0e$var$isString = $6c358707ac100c0e$var$typeOfTest("string");
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ const $6c358707ac100c0e$var$isFunction = $6c358707ac100c0e$var$typeOfTest("function");
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ const $6c358707ac100c0e$var$isNumber = $6c358707ac100c0e$var$typeOfTest("number");
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ const $6c358707ac100c0e$var$isObject = (thing)=>thing !== null && typeof thing === "object";
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ const $6c358707ac100c0e$var$isBoolean = (thing)=>thing === true || thing === false;
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ const $6c358707ac100c0e$var$isPlainObject = (val)=>{
    if ($6c358707ac100c0e$var$kindOf(val) !== "object") return false;
    const prototype = $6c358707ac100c0e$var$getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ const $6c358707ac100c0e$var$isDate = $6c358707ac100c0e$var$kindOfTest("Date");
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const $6c358707ac100c0e$var$isFile = $6c358707ac100c0e$var$kindOfTest("File");
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ const $6c358707ac100c0e$var$isBlob = $6c358707ac100c0e$var$kindOfTest("Blob");
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const $6c358707ac100c0e$var$isFileList = $6c358707ac100c0e$var$kindOfTest("FileList");
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ const $6c358707ac100c0e$var$isStream = (val)=>$6c358707ac100c0e$var$isObject(val) && $6c358707ac100c0e$var$isFunction(val.pipe);
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ const $6c358707ac100c0e$var$isFormData = (thing)=>{
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || $6c358707ac100c0e$var$isFunction(thing.append) && ((kind = $6c358707ac100c0e$var$kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && $6c358707ac100c0e$var$isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ const $6c358707ac100c0e$var$isURLSearchParams = $6c358707ac100c0e$var$kindOfTest("URLSearchParams");
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ const $6c358707ac100c0e$var$trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function $6c358707ac100c0e$var$forEach(obj, fn, { allOwnKeys: allOwnKeys = false  } = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") return;
    let i;
    let l;
    // Force an array if not already something iterable
    if (typeof obj !== "object") /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if ($6c358707ac100c0e$var$isArray(obj)) // Iterate over array values
    for(i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function $6c358707ac100c0e$var$findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) return _key;
    }
    return null;
}
const $6c358707ac100c0e$var$_global = (()=>{
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : $parcel$global;
})();
const $6c358707ac100c0e$var$isContextDefined = (context)=>!$6c358707ac100c0e$var$isUndefined(context) && context !== $6c358707ac100c0e$var$_global;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function $6c358707ac100c0e$var$merge() {
    const { caseless: caseless  } = $6c358707ac100c0e$var$isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key)=>{
        const targetKey = caseless && $6c358707ac100c0e$var$findKey(result, key) || key;
        if ($6c358707ac100c0e$var$isPlainObject(result[targetKey]) && $6c358707ac100c0e$var$isPlainObject(val)) result[targetKey] = $6c358707ac100c0e$var$merge(result[targetKey], val);
        else if ($6c358707ac100c0e$var$isPlainObject(val)) result[targetKey] = $6c358707ac100c0e$var$merge({}, val);
        else if ($6c358707ac100c0e$var$isArray(val)) result[targetKey] = val.slice();
        else result[targetKey] = val;
    };
    for(let i = 0, l = arguments.length; i < l; i++)arguments[i] && $6c358707ac100c0e$var$forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ const $6c358707ac100c0e$var$extend = (a, b, thisArg, { allOwnKeys: allOwnKeys  } = {})=>{
    $6c358707ac100c0e$var$forEach(b, (val, key)=>{
        if (thisArg && $6c358707ac100c0e$var$isFunction(val)) a[key] = (0, $9793d8a71e8d5ff2$export$2e2bcd8739ae039)(val, thisArg);
        else a[key] = val;
    }, {
        allOwnKeys: allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ const $6c358707ac100c0e$var$stripBOM = (content)=>{
    if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ const $6c358707ac100c0e$var$inherits = (constructor, superConstructor, props, descriptors)=>{
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ const $6c358707ac100c0e$var$toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && $6c358707ac100c0e$var$getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ const $6c358707ac100c0e$var$endsWith = (str, searchString, position)=>{
    str = String(str);
    if (position === undefined || position > str.length) position = str.length;
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ const $6c358707ac100c0e$var$toArray = (thing)=>{
    if (!thing) return null;
    if ($6c358707ac100c0e$var$isArray(thing)) return thing;
    let i = thing.length;
    if (!$6c358707ac100c0e$var$isNumber(i)) return null;
    const arr = new Array(i);
    while(i-- > 0)arr[i] = thing[i];
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
const $6c358707ac100c0e$var$isTypedArray = ((TypedArray)=>{
    // eslint-disable-next-line func-names
    return (thing)=>{
        return TypedArray && thing instanceof TypedArray;
    };
})(typeof Uint8Array !== "undefined" && $6c358707ac100c0e$var$getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ const $6c358707ac100c0e$var$forEachEntry = (obj, fn)=>{
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while((result = iterator.next()) && !result.done){
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ const $6c358707ac100c0e$var$matchAll = (regExp, str)=>{
    let matches;
    const arr = [];
    while((matches = regExp.exec(str)) !== null)arr.push(matches);
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const $6c358707ac100c0e$var$isHTMLForm = $6c358707ac100c0e$var$kindOfTest("HTMLFormElement");
const $6c358707ac100c0e$var$toCamelCase = (str)=>{
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ const $6c358707ac100c0e$var$hasOwnProperty = (({ hasOwnProperty: hasOwnProperty  })=>(obj, prop)=>hasOwnProperty.call(obj, prop))(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ const $6c358707ac100c0e$var$isRegExp = $6c358707ac100c0e$var$kindOfTest("RegExp");
const $6c358707ac100c0e$var$reduceDescriptors = (obj, reducer)=>{
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    $6c358707ac100c0e$var$forEach(descriptors, (descriptor, name)=>{
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ const $6c358707ac100c0e$var$freezeMethods = (obj)=>{
    $6c358707ac100c0e$var$reduceDescriptors(obj, (descriptor, name)=>{
        // skip restricted props in strict mode
        if ($6c358707ac100c0e$var$isFunction(obj) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(name) !== -1) return false;
        const value = obj[name];
        if (!$6c358707ac100c0e$var$isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) descriptor.set = ()=>{
            throw Error("Can not rewrite read-only method '" + name + "'");
        };
    });
};
const $6c358707ac100c0e$var$toObjectSet = (arrayOrString, delimiter)=>{
    const obj = {};
    const define = (arr)=>{
        arr.forEach((value)=>{
            obj[value] = true;
        });
    };
    $6c358707ac100c0e$var$isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
const $6c358707ac100c0e$var$noop = ()=>{};
const $6c358707ac100c0e$var$toFiniteNumber = (value, defaultValue)=>{
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
};
const $6c358707ac100c0e$var$ALPHA = "abcdefghijklmnopqrstuvwxyz";
const $6c358707ac100c0e$var$DIGIT = "0123456789";
const $6c358707ac100c0e$var$ALPHABET = {
    DIGIT: $6c358707ac100c0e$var$DIGIT,
    ALPHA: $6c358707ac100c0e$var$ALPHA,
    ALPHA_DIGIT: $6c358707ac100c0e$var$ALPHA + $6c358707ac100c0e$var$ALPHA.toUpperCase() + $6c358707ac100c0e$var$DIGIT
};
const $6c358707ac100c0e$var$generateString = (size = 16, alphabet = $6c358707ac100c0e$var$ALPHABET.ALPHA_DIGIT)=>{
    let str = "";
    const { length: length  } = alphabet;
    while(size--)str += alphabet[Math.random() * length | 0];
    return str;
};
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function $6c358707ac100c0e$var$isSpecCompliantForm(thing) {
    return !!(thing && $6c358707ac100c0e$var$isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const $6c358707ac100c0e$var$toJSONObject = (obj)=>{
    const stack = new Array(10);
    const visit = (source, i)=>{
        if ($6c358707ac100c0e$var$isObject(source)) {
            if (stack.indexOf(source) >= 0) return;
            if (!("toJSON" in source)) {
                stack[i] = source;
                const target = $6c358707ac100c0e$var$isArray(source) ? [] : {};
                $6c358707ac100c0e$var$forEach(source, (value, key)=>{
                    const reducedValue = visit(value, i + 1);
                    !$6c358707ac100c0e$var$isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
const $6c358707ac100c0e$var$isAsyncFn = $6c358707ac100c0e$var$kindOfTest("AsyncFunction");
const $6c358707ac100c0e$var$isThenable = (thing)=>thing && ($6c358707ac100c0e$var$isObject(thing) || $6c358707ac100c0e$var$isFunction(thing)) && $6c358707ac100c0e$var$isFunction(thing.then) && $6c358707ac100c0e$var$isFunction(thing.catch);
var $6c358707ac100c0e$export$2e2bcd8739ae039 = {
    isArray: $6c358707ac100c0e$var$isArray,
    isArrayBuffer: $6c358707ac100c0e$var$isArrayBuffer,
    isBuffer: $6c358707ac100c0e$var$isBuffer,
    isFormData: $6c358707ac100c0e$var$isFormData,
    isArrayBufferView: $6c358707ac100c0e$var$isArrayBufferView,
    isString: $6c358707ac100c0e$var$isString,
    isNumber: $6c358707ac100c0e$var$isNumber,
    isBoolean: $6c358707ac100c0e$var$isBoolean,
    isObject: $6c358707ac100c0e$var$isObject,
    isPlainObject: $6c358707ac100c0e$var$isPlainObject,
    isUndefined: $6c358707ac100c0e$var$isUndefined,
    isDate: $6c358707ac100c0e$var$isDate,
    isFile: $6c358707ac100c0e$var$isFile,
    isBlob: $6c358707ac100c0e$var$isBlob,
    isRegExp: $6c358707ac100c0e$var$isRegExp,
    isFunction: $6c358707ac100c0e$var$isFunction,
    isStream: $6c358707ac100c0e$var$isStream,
    isURLSearchParams: $6c358707ac100c0e$var$isURLSearchParams,
    isTypedArray: $6c358707ac100c0e$var$isTypedArray,
    isFileList: $6c358707ac100c0e$var$isFileList,
    forEach: $6c358707ac100c0e$var$forEach,
    merge: $6c358707ac100c0e$var$merge,
    extend: $6c358707ac100c0e$var$extend,
    trim: $6c358707ac100c0e$var$trim,
    stripBOM: $6c358707ac100c0e$var$stripBOM,
    inherits: $6c358707ac100c0e$var$inherits,
    toFlatObject: $6c358707ac100c0e$var$toFlatObject,
    kindOf: $6c358707ac100c0e$var$kindOf,
    kindOfTest: $6c358707ac100c0e$var$kindOfTest,
    endsWith: $6c358707ac100c0e$var$endsWith,
    toArray: $6c358707ac100c0e$var$toArray,
    forEachEntry: $6c358707ac100c0e$var$forEachEntry,
    matchAll: $6c358707ac100c0e$var$matchAll,
    isHTMLForm: $6c358707ac100c0e$var$isHTMLForm,
    hasOwnProperty: $6c358707ac100c0e$var$hasOwnProperty,
    hasOwnProp: $6c358707ac100c0e$var$hasOwnProperty,
    reduceDescriptors: $6c358707ac100c0e$var$reduceDescriptors,
    freezeMethods: $6c358707ac100c0e$var$freezeMethods,
    toObjectSet: $6c358707ac100c0e$var$toObjectSet,
    toCamelCase: $6c358707ac100c0e$var$toCamelCase,
    noop: $6c358707ac100c0e$var$noop,
    toFiniteNumber: $6c358707ac100c0e$var$toFiniteNumber,
    findKey: $6c358707ac100c0e$var$findKey,
    global: $6c358707ac100c0e$var$_global,
    isContextDefined: $6c358707ac100c0e$var$isContextDefined,
    ALPHABET: $6c358707ac100c0e$var$ALPHABET,
    generateString: $6c358707ac100c0e$var$generateString,
    isSpecCompliantForm: $6c358707ac100c0e$var$isSpecCompliantForm,
    toJSONObject: $6c358707ac100c0e$var$toJSONObject,
    isAsyncFn: $6c358707ac100c0e$var$isAsyncFn,
    isThenable: $6c358707ac100c0e$var$isThenable
};







"use strict";
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function $39018d9e9893716d$var$AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = new Error().stack;
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
}
(0, $6c358707ac100c0e$export$2e2bcd8739ae039).inherits($39018d9e9893716d$var$AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: (0, $6c358707ac100c0e$export$2e2bcd8739ae039).toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    }
});
const $39018d9e9893716d$var$prototype = $39018d9e9893716d$var$AxiosError.prototype;
const $39018d9e9893716d$var$descriptors = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((code)=>{
    $39018d9e9893716d$var$descriptors[code] = {
        value: code
    };
});
Object.defineProperties($39018d9e9893716d$var$AxiosError, $39018d9e9893716d$var$descriptors);
Object.defineProperty($39018d9e9893716d$var$prototype, "isAxiosError", {
    value: true
});
// eslint-disable-next-line func-names
$39018d9e9893716d$var$AxiosError.from = (error, code, config, request, response, customProps)=>{
    const axiosError = Object.create($39018d9e9893716d$var$prototype);
    (0, $6c358707ac100c0e$export$2e2bcd8739ae039).toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, (prop)=>{
        return prop !== "isAxiosError";
    });
    $39018d9e9893716d$var$AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
var $39018d9e9893716d$export$2e2bcd8739ae039 = $39018d9e9893716d$var$AxiosError;


// eslint-disable-next-line strict
var $d4a60d549108ae8b$export$2e2bcd8739ae039 = null;


/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ var $7aaf889172aa0226$export$a143d493d941bafc;
var $7aaf889172aa0226$export$e4cf37d7f6fb9e0a;
var $7aaf889172aa0226$export$f99ded8fe4b79145;
var $7aaf889172aa0226$export$599f31c3813fae4d;
"use strict";
var $023dfcfbcb75732a$export$a48f0734ac7c2329;
var $023dfcfbcb75732a$export$d622b2ad8d90c771;
var $023dfcfbcb75732a$export$6100ba28696e12de;
"use strict";
$023dfcfbcb75732a$export$a48f0734ac7c2329 = $023dfcfbcb75732a$var$byteLength;
$023dfcfbcb75732a$export$d622b2ad8d90c771 = $023dfcfbcb75732a$var$toByteArray;
$023dfcfbcb75732a$export$6100ba28696e12de = $023dfcfbcb75732a$var$fromByteArray;
var $023dfcfbcb75732a$var$lookup = [];
var $023dfcfbcb75732a$var$revLookup = [];
var $023dfcfbcb75732a$var$Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var $023dfcfbcb75732a$var$code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var $023dfcfbcb75732a$var$i = 0, $023dfcfbcb75732a$var$len = $023dfcfbcb75732a$var$code.length; $023dfcfbcb75732a$var$i < $023dfcfbcb75732a$var$len; ++$023dfcfbcb75732a$var$i){
    $023dfcfbcb75732a$var$lookup[$023dfcfbcb75732a$var$i] = $023dfcfbcb75732a$var$code[$023dfcfbcb75732a$var$i];
    $023dfcfbcb75732a$var$revLookup[$023dfcfbcb75732a$var$code.charCodeAt($023dfcfbcb75732a$var$i)] = $023dfcfbcb75732a$var$i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
$023dfcfbcb75732a$var$revLookup["-".charCodeAt(0)] = 62;
$023dfcfbcb75732a$var$revLookup["_".charCodeAt(0)] = 63;
function $023dfcfbcb75732a$var$getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function $023dfcfbcb75732a$var$byteLength(b64) {
    var lens = $023dfcfbcb75732a$var$getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function $023dfcfbcb75732a$var$_byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function $023dfcfbcb75732a$var$toByteArray(b64) {
    var tmp;
    var lens = $023dfcfbcb75732a$var$getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new $023dfcfbcb75732a$var$Arr($023dfcfbcb75732a$var$_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i)] << 18 | $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i)] << 2 | $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i)] << 10 | $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $023dfcfbcb75732a$var$revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function $023dfcfbcb75732a$var$tripletToBase64(num) {
    return $023dfcfbcb75732a$var$lookup[num >> 18 & 0x3F] + $023dfcfbcb75732a$var$lookup[num >> 12 & 0x3F] + $023dfcfbcb75732a$var$lookup[num >> 6 & 0x3F] + $023dfcfbcb75732a$var$lookup[num & 0x3F];
}
function $023dfcfbcb75732a$var$encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push($023dfcfbcb75732a$var$tripletToBase64(tmp));
    }
    return output.join("");
}
function $023dfcfbcb75732a$var$fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($023dfcfbcb75732a$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push($023dfcfbcb75732a$var$lookup[tmp >> 2] + $023dfcfbcb75732a$var$lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push($023dfcfbcb75732a$var$lookup[tmp >> 10] + $023dfcfbcb75732a$var$lookup[tmp >> 4 & 0x3F] + $023dfcfbcb75732a$var$lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}


/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $b38ea80d59ab0cdb$export$aafa59e2e03f2942;
var $b38ea80d59ab0cdb$export$68d8715fc104d294;
$b38ea80d59ab0cdb$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
$b38ea80d59ab0cdb$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};


var $7aaf889172aa0226$var$customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
$7aaf889172aa0226$export$a143d493d941bafc = $7aaf889172aa0226$var$Buffer;
$7aaf889172aa0226$export$e4cf37d7f6fb9e0a = $7aaf889172aa0226$var$SlowBuffer;
$7aaf889172aa0226$export$f99ded8fe4b79145 = 50;
var $7aaf889172aa0226$var$K_MAX_LENGTH = 0x7fffffff;
$7aaf889172aa0226$export$599f31c3813fae4d = $7aaf889172aa0226$var$K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ $7aaf889172aa0226$var$Buffer.TYPED_ARRAY_SUPPORT = $7aaf889172aa0226$var$typedArraySupport();
if (!$7aaf889172aa0226$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function $7aaf889172aa0226$var$typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty($7aaf889172aa0226$var$Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!$7aaf889172aa0226$var$Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty($7aaf889172aa0226$var$Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!$7aaf889172aa0226$var$Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function $7aaf889172aa0226$var$createBuffer(length) {
    if (length > $7aaf889172aa0226$var$K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, $7aaf889172aa0226$var$Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function $7aaf889172aa0226$var$Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return $7aaf889172aa0226$var$allocUnsafe(arg);
    }
    return $7aaf889172aa0226$var$from(arg, encodingOrOffset, length);
}
$7aaf889172aa0226$var$Buffer.poolSize = 8192 // not used by this implementation
;
function $7aaf889172aa0226$var$from(value, encodingOrOffset, length) {
    if (typeof value === "string") return $7aaf889172aa0226$var$fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return $7aaf889172aa0226$var$fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if ($7aaf889172aa0226$var$isInstance(value, ArrayBuffer) || value && $7aaf889172aa0226$var$isInstance(value.buffer, ArrayBuffer)) return $7aaf889172aa0226$var$fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && ($7aaf889172aa0226$var$isInstance(value, SharedArrayBuffer) || value && $7aaf889172aa0226$var$isInstance(value.buffer, SharedArrayBuffer))) return $7aaf889172aa0226$var$fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return $7aaf889172aa0226$var$Buffer.from(valueOf, encodingOrOffset, length);
    var b = $7aaf889172aa0226$var$fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return $7aaf889172aa0226$var$Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ $7aaf889172aa0226$var$Buffer.from = function(value, encodingOrOffset, length) {
    return $7aaf889172aa0226$var$from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf($7aaf889172aa0226$var$Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf($7aaf889172aa0226$var$Buffer, Uint8Array);
function $7aaf889172aa0226$var$assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function $7aaf889172aa0226$var$alloc(size, fill, encoding) {
    $7aaf889172aa0226$var$assertSize(size);
    if (size <= 0) return $7aaf889172aa0226$var$createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? $7aaf889172aa0226$var$createBuffer(size).fill(fill, encoding) : $7aaf889172aa0226$var$createBuffer(size).fill(fill);
    return $7aaf889172aa0226$var$createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ $7aaf889172aa0226$var$Buffer.alloc = function(size, fill, encoding) {
    return $7aaf889172aa0226$var$alloc(size, fill, encoding);
};
function $7aaf889172aa0226$var$allocUnsafe(size) {
    $7aaf889172aa0226$var$assertSize(size);
    return $7aaf889172aa0226$var$createBuffer(size < 0 ? 0 : $7aaf889172aa0226$var$checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ $7aaf889172aa0226$var$Buffer.allocUnsafe = function(size) {
    return $7aaf889172aa0226$var$allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ $7aaf889172aa0226$var$Buffer.allocUnsafeSlow = function(size) {
    return $7aaf889172aa0226$var$allocUnsafe(size);
};
function $7aaf889172aa0226$var$fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!$7aaf889172aa0226$var$Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    var length = $7aaf889172aa0226$var$byteLength(string, encoding) | 0;
    var buf = $7aaf889172aa0226$var$createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function $7aaf889172aa0226$var$fromArrayLike(array) {
    var length = array.length < 0 ? 0 : $7aaf889172aa0226$var$checked(array.length) | 0;
    var buf = $7aaf889172aa0226$var$createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function $7aaf889172aa0226$var$fromArrayView(arrayView) {
    if ($7aaf889172aa0226$var$isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return $7aaf889172aa0226$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return $7aaf889172aa0226$var$fromArrayLike(arrayView);
}
function $7aaf889172aa0226$var$fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, $7aaf889172aa0226$var$Buffer.prototype);
    return buf;
}
function $7aaf889172aa0226$var$fromObject(obj) {
    if ($7aaf889172aa0226$var$Buffer.isBuffer(obj)) {
        var len = $7aaf889172aa0226$var$checked(obj.length) | 0;
        var buf = $7aaf889172aa0226$var$createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || $7aaf889172aa0226$var$numberIsNaN(obj.length)) return $7aaf889172aa0226$var$createBuffer(0);
        return $7aaf889172aa0226$var$fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return $7aaf889172aa0226$var$fromArrayLike(obj.data);
}
function $7aaf889172aa0226$var$checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= $7aaf889172aa0226$var$K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + $7aaf889172aa0226$var$K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function $7aaf889172aa0226$var$SlowBuffer(length) {
    if (+length != length) length = 0;
    return $7aaf889172aa0226$var$Buffer.alloc(+length);
}
$7aaf889172aa0226$var$Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== $7aaf889172aa0226$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
$7aaf889172aa0226$var$Buffer.compare = function compare(a, b) {
    if ($7aaf889172aa0226$var$isInstance(a, Uint8Array)) a = $7aaf889172aa0226$var$Buffer.from(a, a.offset, a.byteLength);
    if ($7aaf889172aa0226$var$isInstance(b, Uint8Array)) b = $7aaf889172aa0226$var$Buffer.from(b, b.offset, b.byteLength);
    if (!$7aaf889172aa0226$var$Buffer.isBuffer(a) || !$7aaf889172aa0226$var$Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
$7aaf889172aa0226$var$Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
$7aaf889172aa0226$var$Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return $7aaf889172aa0226$var$Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = $7aaf889172aa0226$var$Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if ($7aaf889172aa0226$var$isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) $7aaf889172aa0226$var$Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!$7aaf889172aa0226$var$Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function $7aaf889172aa0226$var$byteLength(string, encoding) {
    if ($7aaf889172aa0226$var$Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || $7aaf889172aa0226$var$isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return $7aaf889172aa0226$var$utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return $7aaf889172aa0226$var$base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : $7aaf889172aa0226$var$utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
$7aaf889172aa0226$var$Buffer.byteLength = $7aaf889172aa0226$var$byteLength;
function $7aaf889172aa0226$var$slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return $7aaf889172aa0226$var$hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return $7aaf889172aa0226$var$utf8Slice(this, start, end);
        case "ascii":
            return $7aaf889172aa0226$var$asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return $7aaf889172aa0226$var$latin1Slice(this, start, end);
        case "base64":
            return $7aaf889172aa0226$var$base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return $7aaf889172aa0226$var$utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
$7aaf889172aa0226$var$Buffer.prototype._isBuffer = true;
function $7aaf889172aa0226$var$swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
$7aaf889172aa0226$var$Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(var i = 0; i < len; i += 2)$7aaf889172aa0226$var$swap(this, i, i + 1);
    return this;
};
$7aaf889172aa0226$var$Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(var i = 0; i < len; i += 4){
        $7aaf889172aa0226$var$swap(this, i, i + 3);
        $7aaf889172aa0226$var$swap(this, i + 1, i + 2);
    }
    return this;
};
$7aaf889172aa0226$var$Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(var i = 0; i < len; i += 8){
        $7aaf889172aa0226$var$swap(this, i, i + 7);
        $7aaf889172aa0226$var$swap(this, i + 1, i + 6);
        $7aaf889172aa0226$var$swap(this, i + 2, i + 5);
        $7aaf889172aa0226$var$swap(this, i + 3, i + 4);
    }
    return this;
};
$7aaf889172aa0226$var$Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return $7aaf889172aa0226$var$utf8Slice(this, 0, length);
    return $7aaf889172aa0226$var$slowToString.apply(this, arguments);
};
$7aaf889172aa0226$var$Buffer.prototype.toLocaleString = $7aaf889172aa0226$var$Buffer.prototype.toString;
$7aaf889172aa0226$var$Buffer.prototype.equals = function equals(b) {
    if (!$7aaf889172aa0226$var$Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return $7aaf889172aa0226$var$Buffer.compare(this, b) === 0;
};
$7aaf889172aa0226$var$Buffer.prototype.inspect = function inspect() {
    var str = "";
    var max = $7aaf889172aa0226$export$f99ded8fe4b79145;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if ($7aaf889172aa0226$var$customInspectSymbol) $7aaf889172aa0226$var$Buffer.prototype[$7aaf889172aa0226$var$customInspectSymbol] = $7aaf889172aa0226$var$Buffer.prototype.inspect;
$7aaf889172aa0226$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if ($7aaf889172aa0226$var$isInstance(target, Uint8Array)) target = $7aaf889172aa0226$var$Buffer.from(target, target.offset, target.byteLength);
    if (!$7aaf889172aa0226$var$Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function $7aaf889172aa0226$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if ($7aaf889172aa0226$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = $7aaf889172aa0226$var$Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if ($7aaf889172aa0226$var$Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return $7aaf889172aa0226$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return $7aaf889172aa0226$var$arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function $7aaf889172aa0226$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
$7aaf889172aa0226$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
$7aaf889172aa0226$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return $7aaf889172aa0226$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
$7aaf889172aa0226$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return $7aaf889172aa0226$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function $7aaf889172aa0226$var$hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if ($7aaf889172aa0226$var$numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function $7aaf889172aa0226$var$utf8Write(buf, string, offset, length) {
    return $7aaf889172aa0226$var$blitBuffer($7aaf889172aa0226$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function $7aaf889172aa0226$var$asciiWrite(buf, string, offset, length) {
    return $7aaf889172aa0226$var$blitBuffer($7aaf889172aa0226$var$asciiToBytes(string), buf, offset, length);
}
function $7aaf889172aa0226$var$base64Write(buf, string, offset, length) {
    return $7aaf889172aa0226$var$blitBuffer($7aaf889172aa0226$var$base64ToBytes(string), buf, offset, length);
}
function $7aaf889172aa0226$var$ucs2Write(buf, string, offset, length) {
    return $7aaf889172aa0226$var$blitBuffer($7aaf889172aa0226$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
$7aaf889172aa0226$var$Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    var loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return $7aaf889172aa0226$var$hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return $7aaf889172aa0226$var$utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return $7aaf889172aa0226$var$asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return $7aaf889172aa0226$var$base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return $7aaf889172aa0226$var$ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
$7aaf889172aa0226$var$Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function $7aaf889172aa0226$var$base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return $023dfcfbcb75732a$export$6100ba28696e12de(buf);
    else return $023dfcfbcb75732a$export$6100ba28696e12de(buf.slice(start, end));
}
function $7aaf889172aa0226$var$utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return $7aaf889172aa0226$var$decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var $7aaf889172aa0226$var$MAX_ARGUMENTS_LENGTH = 0x1000;
function $7aaf889172aa0226$var$decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= $7aaf889172aa0226$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = "";
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $7aaf889172aa0226$var$MAX_ARGUMENTS_LENGTH));
    return res;
}
function $7aaf889172aa0226$var$asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function $7aaf889172aa0226$var$latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function $7aaf889172aa0226$var$hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = "";
    for(var i = start; i < end; ++i)out += $7aaf889172aa0226$var$hexSliceLookupTable[buf[i]];
    return out;
}
function $7aaf889172aa0226$var$utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
$7aaf889172aa0226$var$Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, $7aaf889172aa0226$var$Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function $7aaf889172aa0226$var$checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
$7aaf889172aa0226$var$Buffer.prototype.readUintLE = $7aaf889172aa0226$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
$7aaf889172aa0226$var$Buffer.prototype.readUintBE = $7aaf889172aa0226$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
$7aaf889172aa0226$var$Buffer.prototype.readUint8 = $7aaf889172aa0226$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 1, this.length);
    return this[offset];
};
$7aaf889172aa0226$var$Buffer.prototype.readUint16LE = $7aaf889172aa0226$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
$7aaf889172aa0226$var$Buffer.prototype.readUint16BE = $7aaf889172aa0226$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
$7aaf889172aa0226$var$Buffer.prototype.readUint32LE = $7aaf889172aa0226$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
$7aaf889172aa0226$var$Buffer.prototype.readUint32BE = $7aaf889172aa0226$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
$7aaf889172aa0226$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
$7aaf889172aa0226$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
$7aaf889172aa0226$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
$7aaf889172aa0226$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
$7aaf889172aa0226$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
$7aaf889172aa0226$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
$7aaf889172aa0226$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
$7aaf889172aa0226$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 4, this.length);
    return $b38ea80d59ab0cdb$export$aafa59e2e03f2942(this, offset, true, 23, 4);
};
$7aaf889172aa0226$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 4, this.length);
    return $b38ea80d59ab0cdb$export$aafa59e2e03f2942(this, offset, false, 23, 4);
};
$7aaf889172aa0226$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 8, this.length);
    return $b38ea80d59ab0cdb$export$aafa59e2e03f2942(this, offset, true, 52, 8);
};
$7aaf889172aa0226$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkOffset(offset, 8, this.length);
    return $b38ea80d59ab0cdb$export$aafa59e2e03f2942(this, offset, false, 52, 8);
};
function $7aaf889172aa0226$var$checkInt(buf, value, offset, ext, max, min) {
    if (!$7aaf889172aa0226$var$Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
$7aaf889172aa0226$var$Buffer.prototype.writeUintLE = $7aaf889172aa0226$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        $7aaf889172aa0226$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
$7aaf889172aa0226$var$Buffer.prototype.writeUintBE = $7aaf889172aa0226$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        $7aaf889172aa0226$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
$7aaf889172aa0226$var$Buffer.prototype.writeUint8 = $7aaf889172aa0226$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
$7aaf889172aa0226$var$Buffer.prototype.writeUint16LE = $7aaf889172aa0226$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
$7aaf889172aa0226$var$Buffer.prototype.writeUint16BE = $7aaf889172aa0226$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
$7aaf889172aa0226$var$Buffer.prototype.writeUint32LE = $7aaf889172aa0226$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
$7aaf889172aa0226$var$Buffer.prototype.writeUint32BE = $7aaf889172aa0226$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
$7aaf889172aa0226$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        $7aaf889172aa0226$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
$7aaf889172aa0226$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        $7aaf889172aa0226$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
$7aaf889172aa0226$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
$7aaf889172aa0226$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
$7aaf889172aa0226$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
$7aaf889172aa0226$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
$7aaf889172aa0226$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function $7aaf889172aa0226$var$checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function $7aaf889172aa0226$var$writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    $b38ea80d59ab0cdb$export$68d8715fc104d294(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
$7aaf889172aa0226$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return $7aaf889172aa0226$var$writeFloat(this, value, offset, true, noAssert);
};
$7aaf889172aa0226$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return $7aaf889172aa0226$var$writeFloat(this, value, offset, false, noAssert);
};
function $7aaf889172aa0226$var$writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $7aaf889172aa0226$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    $b38ea80d59ab0cdb$export$68d8715fc104d294(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
$7aaf889172aa0226$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return $7aaf889172aa0226$var$writeDouble(this, value, offset, true, noAssert);
};
$7aaf889172aa0226$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return $7aaf889172aa0226$var$writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
$7aaf889172aa0226$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!$7aaf889172aa0226$var$Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
$7aaf889172aa0226$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !$7aaf889172aa0226$var$Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = $7aaf889172aa0226$var$Buffer.isBuffer(val) ? val : $7aaf889172aa0226$var$Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var $7aaf889172aa0226$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function $7aaf889172aa0226$var$base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace($7aaf889172aa0226$var$INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function $7aaf889172aa0226$var$utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function $7aaf889172aa0226$var$asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function $7aaf889172aa0226$var$utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function $7aaf889172aa0226$var$base64ToBytes(str) {
    return $023dfcfbcb75732a$export$d622b2ad8d90c771($7aaf889172aa0226$var$base64clean(str));
}
function $7aaf889172aa0226$var$blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function $7aaf889172aa0226$var$isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function $7aaf889172aa0226$var$numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var $7aaf889172aa0226$var$hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();


var $df9a38a07be5d4e8$require$Buffer = $7aaf889172aa0226$export$a143d493d941bafc;
"use strict";
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function $df9a38a07be5d4e8$var$isVisitable(thing) {
    return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isPlainObject(thing) || (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function $df9a38a07be5d4e8$var$removeBrackets(key) {
    return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function $df9a38a07be5d4e8$var$renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = $df9a38a07be5d4e8$var$removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function $df9a38a07be5d4e8$var$isFlatArray(arr) {
    return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(arr) && !arr.some($df9a38a07be5d4e8$var$isVisitable);
}
const $df9a38a07be5d4e8$var$predicates = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).toFlatObject((0, $6c358707ac100c0e$export$2e2bcd8739ae039), {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function $df9a38a07be5d4e8$var$toFormData(obj, formData, options) {
    if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isObject(obj)) throw new TypeError("target must be an object");
    // eslint-disable-next-line no-param-reassign
    formData = formData || new ((0, $d4a60d549108ae8b$export$2e2bcd8739ae039) || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isSpecCompliantForm(formData);
    if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFunction(visitor)) throw new TypeError("visitor must be a function");
    function convertValue(value) {
        if (value === null) return "";
        if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isDate(value)) return value.toISOString();
        if (!useBlob && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isBlob(value)) throw new (0, $39018d9e9893716d$export$2e2bcd8739ae039)("Blob is not supported. Use a Buffer instead.");
        if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArrayBuffer(value) || (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([
            value
        ]) : $df9a38a07be5d4e8$require$Buffer.from(value);
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).endsWith(key, "{}")) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(value) && $df9a38a07be5d4e8$var$isFlatArray(value) || ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFileList(value) || (0, $6c358707ac100c0e$export$2e2bcd8739ae039).endsWith(key, "[]")) && (arr = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = $df9a38a07be5d4e8$var$removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? $df9a38a07be5d4e8$var$renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                });
                return false;
            }
        }
        if ($df9a38a07be5d4e8$var$isVisitable(value)) return true;
        formData.append($df9a38a07be5d4e8$var$renderKey(path, key, dots), convertValue(value));
        return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign($df9a38a07be5d4e8$var$predicates, {
        defaultVisitor: defaultVisitor,
        convertValue: convertValue,
        isVisitable: $df9a38a07be5d4e8$var$isVisitable
    });
    function build(value, path) {
        if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path.join("."));
        stack.push(value);
        (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach(value, function each(el, key) {
            const result = !((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(el) || el === null) && visitor.call(formData, el, (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) build(el, path ? path.concat(key) : [
                key
            ]);
        });
        stack.pop();
    }
    if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isObject(obj)) throw new TypeError("data must be an object");
    build(obj);
    return formData;
}
var $df9a38a07be5d4e8$export$2e2bcd8739ae039 = $df9a38a07be5d4e8$var$toFormData;


"use strict";
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function $cfa3e15841aae5b8$var$encode(str) {
    const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function $cfa3e15841aae5b8$var$AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && (0, $df9a38a07be5d4e8$export$2e2bcd8739ae039)(params, this, options);
}
const $cfa3e15841aae5b8$var$prototype = $cfa3e15841aae5b8$var$AxiosURLSearchParams.prototype;
$cfa3e15841aae5b8$var$prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
$cfa3e15841aae5b8$var$prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
        return encoder.call(this, value, $cfa3e15841aae5b8$var$encode);
    } : $cfa3e15841aae5b8$var$encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
};
var $cfa3e15841aae5b8$export$2e2bcd8739ae039 = $cfa3e15841aae5b8$var$AxiosURLSearchParams;


"use strict";
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function $1ee14c8c458684a0$var$encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function $1ee14c8c458684a0$export$2e2bcd8739ae039(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    const _encode = options && options.encode || $1ee14c8c458684a0$var$encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) serializedParams = serializeFn(params, options);
    else serializedParams = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isURLSearchParams(params) ? params.toString() : new (0, $cfa3e15841aae5b8$export$2e2bcd8739ae039)(params, options).toString(_encode);
    if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
}



"use strict";
class $e0cc20f5b823c3f0$var$InterceptorManager {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(fulfilled, rejected, options) {
        this.handlers.push({
            fulfilled: fulfilled,
            rejected: rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(id) {
        if (this.handlers[id]) this.handlers[id] = null;
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        if (this.handlers) this.handlers = [];
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(fn) {
        (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) fn(h);
        });
    }
}
var $e0cc20f5b823c3f0$export$2e2bcd8739ae039 = $e0cc20f5b823c3f0$var$InterceptorManager;





"use strict";
var $ecf06bfe9ff67c7f$export$2e2bcd8739ae039 = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};






"use strict";
var $21f94769e18c573b$export$2e2bcd8739ae039 = typeof URLSearchParams !== "undefined" ? URLSearchParams : (0, $cfa3e15841aae5b8$export$2e2bcd8739ae039);


"use strict";
var $9fd86673bdb5ec06$export$2e2bcd8739ae039 = typeof FormData !== "undefined" ? FormData : null;


"use strict";
var $d2c096e20c6ee8a6$export$2e2bcd8739ae039 = typeof Blob !== "undefined" ? Blob : null;


/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ const $9a3320105857c8bd$var$isStandardBrowserEnv = (()=>{
    let product;
    if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) return false;
    return typeof window !== "undefined" && typeof document !== "undefined";
})();
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ const $9a3320105857c8bd$var$isStandardBrowserWebWorkerEnv = (()=>{
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var $9a3320105857c8bd$export$2e2bcd8739ae039 = {
    isBrowser: true,
    classes: {
        URLSearchParams: $21f94769e18c573b$export$2e2bcd8739ae039,
        FormData: $9fd86673bdb5ec06$export$2e2bcd8739ae039,
        Blob: $d2c096e20c6ee8a6$export$2e2bcd8739ae039
    },
    isStandardBrowserEnv: $9a3320105857c8bd$var$isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv: $9a3320105857c8bd$var$isStandardBrowserWebWorkerEnv,
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
};


"use strict";
function $afd3cc622a70c947$export$2e2bcd8739ae039(data, options) {
    return (0, $df9a38a07be5d4e8$export$2e2bcd8739ae039)(data, new (0, $9a3320105857c8bd$export$2e2bcd8739ae039).classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
            if ((0, $9a3320105857c8bd$export$2e2bcd8739ae039).isNode && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isBuffer(value)) {
                this.append(key, value.toString("base64"));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}




"use strict";
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function $85cee280f0a85293$var$parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
        return match[0] === "[]" ? "" : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function $85cee280f0a85293$var$arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function $85cee280f0a85293$var$formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        let name = path[index++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(target) ? target.length : name;
        if (isLast) {
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).hasOwnProp(target, name)) target[name] = [
                target[name],
                value
            ];
            else target[name] = value;
            return !isNumericKey;
        }
        if (!target[name] || !(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isObject(target[name])) target[name] = [];
        const result = buildPath(path, value, target[name], index);
        if (result && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(target[name])) target[name] = $85cee280f0a85293$var$arrayToObject(target[name]);
        return !isNumericKey;
    }
    if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFormData(formData) && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFunction(formData.entries)) {
        const obj = {};
        (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEachEntry(formData, (name, value)=>{
            buildPath($85cee280f0a85293$var$parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
var $85cee280f0a85293$export$2e2bcd8739ae039 = $85cee280f0a85293$var$formDataToJSON;


"use strict";
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function $b4d55bc52e11a350$var$stringifySafely(rawValue, parser, encoder) {
    if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).trim(rawValue);
    } catch (e) {
        if (e.name !== "SyntaxError") throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
const $b4d55bc52e11a350$var$defaults = {
    transitional: (0, $ecf06bfe9ff67c7f$export$2e2bcd8739ae039),
    adapter: [
        "xhr",
        "http"
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            const contentType = headers.getContentType() || "";
            const hasJSONContentType = contentType.indexOf("application/json") > -1;
            const isObjectPayload = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isObject(data);
            if (isObjectPayload && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isHTMLForm(data)) data = new FormData(data);
            const isFormData = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFormData(data);
            if (isFormData) {
                if (!hasJSONContentType) return data;
                return hasJSONContentType ? JSON.stringify((0, $85cee280f0a85293$export$2e2bcd8739ae039)(data)) : data;
            }
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArrayBuffer(data) || (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isBuffer(data) || (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isStream(data) || (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFile(data) || (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isBlob(data)) return data;
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArrayBufferView(data)) return data.buffer;
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isURLSearchParams(data)) {
                headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                return data.toString();
            }
            let isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf("application/x-www-form-urlencoded") > -1) return (0, $afd3cc622a70c947$export$2e2bcd8739ae039)(data, this.formSerializer).toString();
                if ((isFileList = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                    const _FormData = this.env && this.env.FormData;
                    return (0, $df9a38a07be5d4e8$export$2e2bcd8739ae039)(isFileList ? {
                        "files[]": data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return $b4d55bc52e11a350$var$stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            const transitional = this.transitional || $b4d55bc52e11a350$var$defaults.transitional;
            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            const JSONRequested = this.responseType === "json";
            if (data && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                const silentJSONParsing = transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") throw (0, $39018d9e9893716d$export$2e2bcd8739ae039).from(e, (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_BAD_RESPONSE, this, null, this.response);
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: (0, $9a3320105857c8bd$export$2e2bcd8739ae039).classes.FormData,
        Blob: (0, $9a3320105857c8bd$export$2e2bcd8739ae039).classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": undefined
        }
    }
};
(0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (method)=>{
    $b4d55bc52e11a350$var$defaults.headers[method] = {};
});
var $b4d55bc52e11a350$export$2e2bcd8739ae039 = $b4d55bc52e11a350$var$defaults;




"use strict";
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const $84b34a0b5539e40b$var$ignoreDuplicateOf = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]);
var /**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */ $84b34a0b5539e40b$export$2e2bcd8739ae039 = (rawHeaders)=>{
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && $84b34a0b5539e40b$var$ignoreDuplicateOf[key]) return;
        if (key === "set-cookie") {
            if (parsed[key]) parsed[key].push(val);
            else parsed[key] = [
                val
            ];
        } else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    });
    return parsed;
};


"use strict";
const $6c55e0db0b3245e3$var$$internals = Symbol("internals");
function $6c55e0db0b3245e3$var$normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function $6c55e0db0b3245e3$var$normalizeValue(value) {
    if (value === false || value == null) return value;
    return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(value) ? value.map($6c55e0db0b3245e3$var$normalizeValue) : String(value);
}
function $6c55e0db0b3245e3$var$parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while(match = tokensRE.exec(str))tokens[match[1]] = match[2];
    return tokens;
}
const $6c55e0db0b3245e3$var$isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function $6c55e0db0b3245e3$var$matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFunction(filter)) return filter.call(this, value, header);
    if (isHeaderNameFilter) value = header;
    if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(value)) return;
    if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(filter)) return value.indexOf(filter) !== -1;
    if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isRegExp(filter)) return filter.test(value);
}
function $6c55e0db0b3245e3$var$formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str)=>{
        return char.toUpperCase() + str;
    });
}
function $6c55e0db0b3245e3$var$buildAccessors(obj, header) {
    const accessorName = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).toCamelCase(" " + header);
    [
        "get",
        "set",
        "has"
    ].forEach((methodName)=>{
        Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
class $6c55e0db0b3245e3$var$AxiosHeaders {
    constructor(headers){
        headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
        const self = this;
        function setHeader(_value, _header, _rewrite) {
            const lHeader = $6c55e0db0b3245e3$var$normalizeHeader(_header);
            if (!lHeader) throw new Error("header name must be a non-empty string");
            const key = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).findKey(self, lHeader);
            if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) self[key || _header] = $6c55e0db0b3245e3$var$normalizeValue(_value);
        }
        const setHeaders = (headers, _rewrite)=>(0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));
        if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
        else if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(header) && (header = header.trim()) && !$6c55e0db0b3245e3$var$isValidHeaderName(header)) setHeaders((0, $84b34a0b5539e40b$export$2e2bcd8739ae039)(header), valueOrRewrite);
        else header != null && setHeader(valueOrRewrite, header, rewrite);
        return this;
    }
    get(header, parser) {
        header = $6c55e0db0b3245e3$var$normalizeHeader(header);
        if (header) {
            const key = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).findKey(this, header);
            if (key) {
                const value = this[key];
                if (!parser) return value;
                if (parser === true) return $6c55e0db0b3245e3$var$parseTokens(value);
                if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFunction(parser)) return parser.call(this, value, key);
                if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isRegExp(parser)) return parser.exec(value);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(header, matcher) {
        header = $6c55e0db0b3245e3$var$normalizeHeader(header);
        if (header) {
            const key = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).findKey(this, header);
            return !!(key && this[key] !== undefined && (!matcher || $6c55e0db0b3245e3$var$matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
    }
    delete(header, matcher) {
        const self = this;
        let deleted = false;
        function deleteHeader(_header) {
            _header = $6c55e0db0b3245e3$var$normalizeHeader(_header);
            if (_header) {
                const key = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).findKey(self, _header);
                if (key && (!matcher || $6c55e0db0b3245e3$var$matchHeaderValue(self, self[key], key, matcher))) {
                    delete self[key];
                    deleted = true;
                }
            }
        }
        if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(header)) header.forEach(deleteHeader);
        else deleteHeader(header);
        return deleted;
    }
    clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while(i--){
            const key = keys[i];
            if (!matcher || $6c55e0db0b3245e3$var$matchHeaderValue(this, this[key], key, matcher, true)) {
                delete this[key];
                deleted = true;
            }
        }
        return deleted;
    }
    normalize(format) {
        const self = this;
        const headers = {};
        (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach(this, (value, header)=>{
            const key = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).findKey(headers, header);
            if (key) {
                self[key] = $6c55e0db0b3245e3$var$normalizeValue(value);
                delete self[header];
                return;
            }
            const normalized = format ? $6c55e0db0b3245e3$var$formatHeader(header) : String(header).trim();
            if (normalized !== header) delete self[header];
            self[normalized] = $6c55e0db0b3245e3$var$normalizeValue(value);
            headers[normalized] = true;
        });
        return this;
    }
    concat(...targets) {
        return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
        const obj = Object.create(null);
        (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach(this, (value, header)=>{
            value != null && value !== false && (obj[header] = asStrings && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(value) ? value.join(", ") : value);
        });
        return obj;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([header, value])=>header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(thing) {
        return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target)=>computed.set(target));
        return computed;
    }
    static accessor(header) {
        const internals = this[$6c55e0db0b3245e3$var$$internals] = this[$6c55e0db0b3245e3$var$$internals] = {
            accessors: {}
        };
        const accessors = internals.accessors;
        const prototype = this.prototype;
        function defineAccessor(_header) {
            const lHeader = $6c55e0db0b3245e3$var$normalizeHeader(_header);
            if (!accessors[lHeader]) {
                $6c55e0db0b3245e3$var$buildAccessors(prototype, _header);
                accessors[lHeader] = true;
            }
        }
        (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
    }
}
$6c55e0db0b3245e3$var$AxiosHeaders.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
// reserved names hotfix
(0, $6c358707ac100c0e$export$2e2bcd8739ae039).reduceDescriptors($6c55e0db0b3245e3$var$AxiosHeaders.prototype, ({ value: value  }, key)=>{
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
        get: ()=>value,
        set (headerValue) {
            this[mapped] = headerValue;
        }
    };
});
(0, $6c358707ac100c0e$export$2e2bcd8739ae039).freezeMethods($6c55e0db0b3245e3$var$AxiosHeaders);
var $6c55e0db0b3245e3$export$2e2bcd8739ae039 = $6c55e0db0b3245e3$var$AxiosHeaders;


"use strict";
function $7343c2f4b703b2ba$export$2e2bcd8739ae039(fns, response) {
    const config = this || (0, $b4d55bc52e11a350$export$2e2bcd8739ae039);
    const context = response || config;
    const headers = (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039).from(context.headers);
    let data = context.data;
    (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}


"use strict";
function $e63b86be51b94285$export$2e2bcd8739ae039(value) {
    return !!(value && value.__CANCEL__);
}





"use strict";
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function $43dc33230b98b12a$var$CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    (0, $39018d9e9893716d$export$2e2bcd8739ae039).call(this, message == null ? "canceled" : message, (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_CANCELED, config, request);
    this.name = "CanceledError";
}
(0, $6c358707ac100c0e$export$2e2bcd8739ae039).inherits($43dc33230b98b12a$var$CanceledError, (0, $39018d9e9893716d$export$2e2bcd8739ae039), {
    __CANCEL__: true
});
var $43dc33230b98b12a$export$2e2bcd8739ae039 = $43dc33230b98b12a$var$CanceledError;







"use strict";
function $25fae190cd2ded42$export$2e2bcd8739ae039(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(new (0, $39018d9e9893716d$export$2e2bcd8739ae039)("Request failed with status code " + response.status, [
        (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_BAD_REQUEST,
        (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_BAD_RESPONSE
    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}




"use strict";
var $86c078ac0564e94e$export$2e2bcd8739ae039 = (0, $9a3320105857c8bd$export$2e2bcd8739ae039).isStandardBrowserEnv ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
    return {
        write: function write(name, value, expires, path, domain, secure) {
            const cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isNumber(expires)) cookie.push("expires=" + new Date(expires).toGMTString());
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(path)) cookie.push("path=" + path);
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(domain)) cookie.push("domain=" + domain);
            if (secure === true) cookie.push("secure");
            document.cookie = cookie.join("; ");
        },
        read: function read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
            this.write(name, "", Date.now() - 86400000);
        }
    };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return {
        write: function write() {},
        read: function read() {
            return null;
        },
        remove: function remove() {}
    };
}();



"use strict";
function $03766157726c79e4$export$2e2bcd8739ae039(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}


"use strict";
function $040e916410a945da$export$2e2bcd8739ae039(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}


"use strict";
function $21e9db8e91102907$export$2e2bcd8739ae039(baseURL, requestedURL) {
    if (baseURL && !(0, $03766157726c79e4$export$2e2bcd8739ae039)(requestedURL)) return (0, $040e916410a945da$export$2e2bcd8739ae039)(baseURL, requestedURL);
    return requestedURL;
}




"use strict";
var $62702a31e29ab496$export$2e2bcd8739ae039 = (0, $9a3320105857c8bd$export$2e2bcd8739ae039).isStandardBrowserEnv ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        let href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        const parsed = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();





"use strict";
function $db68a9ee7f5708f2$export$2e2bcd8739ae039(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
}




"use strict";
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function $4586f5ceb7de10e0$var$speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) firstSampleTS = now;
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) tail = (tail + 1) % samplesCount;
        if (now - firstSampleTS < min) return;
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
var $4586f5ceb7de10e0$export$2e2bcd8739ae039 = $4586f5ceb7de10e0$var$speedometer;


"use strict";
function $75deb55110043b1d$var$progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = (0, $4586f5ceb7de10e0$export$2e2bcd8739ae039)(50, 250);
    return (e)=>{
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
            loaded: loaded,
            total: total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
    };
}
const $75deb55110043b1d$var$isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var $75deb55110043b1d$export$2e2bcd8739ae039 = $75deb55110043b1d$var$isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039).from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
            if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
            if (config.signal) config.signal.removeEventListener("abort", onCanceled);
        }
        let contentType;
        if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFormData(requestData)) {
            if ((0, $9a3320105857c8bd$export$2e2bcd8739ae039).isStandardBrowserEnv || (0, $9a3320105857c8bd$export$2e2bcd8739ae039).isStandardBrowserWebWorkerEnv) requestHeaders.setContentType(false); // Let the browser set it
            else if (!requestHeaders.getContentType(/^\s*multipart\/form-data/)) requestHeaders.setContentType("multipart/form-data"); // mobile/desktop app frameworks
            else if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isString(contentType = requestHeaders.getContentType())) // fix semicolon duplication issue for ReactNative FormData implementation
            requestHeaders.setContentType(contentType.replace(/^\s*(multipart\/form-data);+/, "$1"));
        }
        let request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = (0, $21e9db8e91102907$export$2e2bcd8739ae039)(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), (0, $1ee14c8c458684a0$export$2e2bcd8739ae039)(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            const responseHeaders = (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039).from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
            };
            (0, $25fae190cd2ded42$export$2e2bcd8739ae039)(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(new (0, $39018d9e9893716d$export$2e2bcd8739ae039)("Request aborted", (0, $39018d9e9893716d$export$2e2bcd8739ae039).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new (0, $39018d9e9893716d$export$2e2bcd8739ae039)("Network Error", (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_NETWORK, config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || (0, $ecf06bfe9ff67c7f$export$2e2bcd8739ae039);
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(new (0, $39018d9e9893716d$export$2e2bcd8739ae039)(timeoutErrorMessage, transitional.clarifyTimeoutError ? (0, $39018d9e9893716d$export$2e2bcd8739ae039).ETIMEDOUT : (0, $39018d9e9893716d$export$2e2bcd8739ae039).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if ((0, $9a3320105857c8bd$export$2e2bcd8739ae039).isStandardBrowserEnv) {
            // Add xsrf header
            // regarding CVE-2023-45857 config.withCredentials condition was removed temporarily
            const xsrfValue = (0, $62702a31e29ab496$export$2e2bcd8739ae039)(fullPath) && config.xsrfCookieName && (0, $86c078ac0564e94e$export$2e2bcd8739ae039).read(config.xsrfCookieName);
            if (xsrfValue) requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ("setRequestHeader" in request) (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== "json") request.responseType = config.responseType;
        // Handle progress if needed
        if (typeof config.onDownloadProgress === "function") request.addEventListener("progress", $75deb55110043b1d$var$progressEventReducer(config.onDownloadProgress, true));
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === "function" && request.upload) request.upload.addEventListener("progress", $75deb55110043b1d$var$progressEventReducer(config.onUploadProgress));
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = (cancel)=>{
                if (!request) return;
                reject(!cancel || cancel.type ? new (0, $43dc33230b98b12a$export$2e2bcd8739ae039)(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
        const protocol = (0, $db68a9ee7f5708f2$export$2e2bcd8739ae039)(fullPath);
        if (protocol && (0, $9a3320105857c8bd$export$2e2bcd8739ae039).protocols.indexOf(protocol) === -1) {
            reject(new (0, $39018d9e9893716d$export$2e2bcd8739ae039)("Unsupported protocol " + protocol + ":", (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};



const $70f1d4bc773f007e$var$knownAdapters = {
    http: (0, $d4a60d549108ae8b$export$2e2bcd8739ae039),
    xhr: (0, $75deb55110043b1d$export$2e2bcd8739ae039)
};
(0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach($70f1d4bc773f007e$var$knownAdapters, (fn, value)=>{
    if (fn) {
        try {
            Object.defineProperty(fn, "name", {
                value: value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, "adapterName", {
            value: value
        });
    }
});
const $70f1d4bc773f007e$var$renderReason = (reason)=>`- ${reason}`;
const $70f1d4bc773f007e$var$isResolvedHandle = (adapter)=>(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFunction(adapter) || adapter === null || adapter === false;
var $70f1d4bc773f007e$export$2e2bcd8739ae039 = {
    getAdapter: (adapters)=>{
        adapters = (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(adapters) ? adapters : [
            adapters
        ];
        const { length: length  } = adapters;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for(let i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            let id;
            adapter = nameOrAdapter;
            if (!$70f1d4bc773f007e$var$isResolvedHandle(nameOrAdapter)) {
                adapter = $70f1d4bc773f007e$var$knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === undefined) throw new (0, $39018d9e9893716d$export$2e2bcd8739ae039)(`Unknown adapter '${id}'`);
            }
            if (adapter) break;
            rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(([id, state])=>`adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map($70f1d4bc773f007e$var$renderReason).join("\n") : " " + $70f1d4bc773f007e$var$renderReason(reasons[0]) : "as no adapter specified";
            throw new (0, $39018d9e9893716d$export$2e2bcd8739ae039)(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
        }
        return adapter;
    },
    adapters: $70f1d4bc773f007e$var$knownAdapters
};


"use strict";
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function $73212b91920630b3$var$throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new (0, $43dc33230b98b12a$export$2e2bcd8739ae039)(null, config);
}
function $73212b91920630b3$export$2e2bcd8739ae039(config) {
    $73212b91920630b3$var$throwIfCancellationRequested(config);
    config.headers = (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039).from(config.headers);
    // Transform request data
    config.data = (0, $7343c2f4b703b2ba$export$2e2bcd8739ae039).call(config, config.transformRequest);
    if ([
        "post",
        "put",
        "patch"
    ].indexOf(config.method) !== -1) config.headers.setContentType("application/x-www-form-urlencoded", false);
    const adapter = (0, $70f1d4bc773f007e$export$2e2bcd8739ae039).getAdapter(config.adapter || (0, $b4d55bc52e11a350$export$2e2bcd8739ae039).adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        $73212b91920630b3$var$throwIfCancellationRequested(config);
        // Transform response data
        response.data = (0, $7343c2f4b703b2ba$export$2e2bcd8739ae039).call(config, config.transformResponse, response);
        response.headers = (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039).from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!(0, $e63b86be51b94285$export$2e2bcd8739ae039)(reason)) {
            $73212b91920630b3$var$throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = (0, $7343c2f4b703b2ba$export$2e2bcd8739ae039).call(config, config.transformResponse, reason.response);
                reason.response.headers = (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039).from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}




"use strict";
const $018b5e1fb5ffc975$var$headersToObject = (thing)=>thing instanceof (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039) ? thing.toJSON() : thing;
function $018b5e1fb5ffc975$export$2e2bcd8739ae039(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
        if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isPlainObject(target) && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isPlainObject(source)) return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).merge.call({
            caseless: caseless
        }, target, source);
        else if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isPlainObject(source)) return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).merge({}, source);
        else if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
        if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(b)) return getMergedValue(a, b, caseless);
        else if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(a)) return getMergedValue(undefined, a, caseless);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(b)) return getMergedValue(undefined, b);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(b)) return getMergedValue(undefined, b);
        else if (!(0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(a)) return getMergedValue(undefined, a);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) return getMergedValue(a, b);
        else if (prop in config1) return getMergedValue(undefined, a);
    }
    const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b)=>mergeDeepProperties($018b5e1fb5ffc975$var$headersToObject(a), $018b5e1fb5ffc975$var$headersToObject(b), true)
    };
    (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}



const $ea551752e35e8692$export$a4ad2735b021c132 = "1.6.0";



"use strict";
const $06d775c5bf264279$var$validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((type, i)=>{
    $06d775c5bf264279$var$validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
const $06d775c5bf264279$var$deprecatedWarnings = {};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ $06d775c5bf264279$var$validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + (0, $ea551752e35e8692$export$a4ad2735b021c132) + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return (value, opt, opts)=>{
        if (validator === false) throw new (0, $39018d9e9893716d$export$2e2bcd8739ae039)(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_DEPRECATED);
        if (version && !$06d775c5bf264279$var$deprecatedWarnings[opt]) {
            $06d775c5bf264279$var$deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function $06d775c5bf264279$var$assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") throw new (0, $39018d9e9893716d$export$2e2bcd8739ae039)("options must be an object", (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_BAD_OPTION_VALUE);
    const keys = Object.keys(options);
    let i = keys.length;
    while(i-- > 0){
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
            const value = options[opt];
            const result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new (0, $39018d9e9893716d$export$2e2bcd8739ae039)("option " + opt + " must be " + result, (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (allowUnknown !== true) throw new (0, $39018d9e9893716d$export$2e2bcd8739ae039)("Unknown option " + opt, (0, $39018d9e9893716d$export$2e2bcd8739ae039).ERR_BAD_OPTION);
    }
}
var $06d775c5bf264279$export$2e2bcd8739ae039 = {
    assertOptions: $06d775c5bf264279$var$assertOptions,
    validators: $06d775c5bf264279$var$validators
};



"use strict";
const $65f086b5f8306d11$var$validators = (0, $06d775c5bf264279$export$2e2bcd8739ae039).validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ class $65f086b5f8306d11$var$Axios {
    constructor(instanceConfig){
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new (0, $e0cc20f5b823c3f0$export$2e2bcd8739ae039)(),
            response: new (0, $e0cc20f5b823c3f0$export$2e2bcd8739ae039)()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
        } else config = configOrUrl || {};
        config = (0, $018b5e1fb5ffc975$export$2e2bcd8739ae039)(this.defaults, config);
        const { transitional: transitional , paramsSerializer: paramsSerializer , headers: headers  } = config;
        if (transitional !== undefined) (0, $06d775c5bf264279$export$2e2bcd8739ae039).assertOptions(transitional, {
            silentJSONParsing: $65f086b5f8306d11$var$validators.transitional($65f086b5f8306d11$var$validators.boolean),
            forcedJSONParsing: $65f086b5f8306d11$var$validators.transitional($65f086b5f8306d11$var$validators.boolean),
            clarifyTimeoutError: $65f086b5f8306d11$var$validators.transitional($65f086b5f8306d11$var$validators.boolean)
        }, false);
        if (paramsSerializer != null) {
            if ((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isFunction(paramsSerializer)) config.paramsSerializer = {
                serialize: paramsSerializer
            };
            else (0, $06d775c5bf264279$export$2e2bcd8739ae039).assertOptions(paramsSerializer, {
                encode: $65f086b5f8306d11$var$validators.function,
                serialize: $65f086b5f8306d11$var$validators.function
            }, true);
        }
        // Set config.method
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        // Flatten headers
        let contextHeaders = headers && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).merge(headers.common, headers[config.method]);
        headers && (0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (method)=>{
            delete headers[method];
        });
        config.headers = (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039).concat(contextHeaders, headers);
        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
            const chain = [
                (0, $73212b91920630b3$export$2e2bcd8739ae039).bind(this),
                undefined
            ];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while(i < len)promise = promise.then(chain[i++], chain[i++]);
            return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while(i < len){
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
                newConfig = onFulfilled(newConfig);
            } catch (error) {
                onRejected.call(this, error);
                break;
            }
        }
        try {
            promise = (0, $73212b91920630b3$export$2e2bcd8739ae039).call(this, newConfig);
        } catch (error) {
            return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while(i < len)promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        return promise;
    }
    getUri(config) {
        config = (0, $018b5e1fb5ffc975$export$2e2bcd8739ae039)(this.defaults, config);
        const fullPath = (0, $21e9db8e91102907$export$2e2bcd8739ae039)(config.baseURL, config.url);
        return (0, $1ee14c8c458684a0$export$2e2bcd8739ae039)(fullPath, config.params, config.paramsSerializer);
    }
}
// Provide aliases for supported request methods
(0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ $65f086b5f8306d11$var$Axios.prototype[method] = function(url, config) {
        return this.request((0, $018b5e1fb5ffc975$export$2e2bcd8739ae039)(config || {}, {
            method: method,
            url: url,
            data: (config || {}).data
        }));
    };
});
(0, $6c358707ac100c0e$export$2e2bcd8739ae039).forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request((0, $018b5e1fb5ffc975$export$2e2bcd8739ae039)(config || {}, {
                method: method,
                headers: isForm ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: url,
                data: data
            }));
        };
    }
    $65f086b5f8306d11$var$Axios.prototype[method] = generateHTTPMethod();
    $65f086b5f8306d11$var$Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var $65f086b5f8306d11$export$2e2bcd8739ae039 = $65f086b5f8306d11$var$Axios;







"use strict";
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ class $8a96f4dfaaed1253$var$CancelToken {
    constructor(executor){
        if (typeof executor !== "function") throw new TypeError("executor must be a function.");
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        const token = this;
        // eslint-disable-next-line func-names
        this.promise.then((cancel)=>{
            if (!token._listeners) return;
            let i = token._listeners.length;
            while(i-- > 0)token._listeners[i](cancel);
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = (onfulfilled)=>{
            let _resolve;
            // eslint-disable-next-line func-names
            const promise = new Promise((resolve)=>{
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) // Cancellation has already been requested
            return;
            token.reason = new (0, $43dc33230b98b12a$export$2e2bcd8739ae039)(message, config, request);
            resolvePromise(token.reason);
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(listener) {
        if (this.reason) {
            listener(this.reason);
            return;
        }
        if (this._listeners) this._listeners.push(listener);
        else this._listeners = [
            listener
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(listener) {
        if (!this._listeners) return;
        const index = this._listeners.indexOf(listener);
        if (index !== -1) this._listeners.splice(index, 1);
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let cancel;
        const token = new $8a96f4dfaaed1253$var$CancelToken(function executor(c) {
            cancel = c;
        });
        return {
            token: token,
            cancel: cancel
        };
    }
}
var $8a96f4dfaaed1253$export$2e2bcd8739ae039 = $8a96f4dfaaed1253$var$CancelToken;






"use strict";
function $6252a06555621505$export$2e2bcd8739ae039(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}



"use strict";
function $8354989b4dcd6e4e$export$2e2bcd8739ae039(payload) {
    return (0, $6c358707ac100c0e$export$2e2bcd8739ae039).isObject(payload) && payload.isAxiosError === true;
}




const $a0cb09b1f0f101bc$var$HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries($a0cb09b1f0f101bc$var$HttpStatusCode).forEach(([key, value])=>{
    $a0cb09b1f0f101bc$var$HttpStatusCode[value] = key;
});
var $a0cb09b1f0f101bc$export$2e2bcd8739ae039 = $a0cb09b1f0f101bc$var$HttpStatusCode;


"use strict";
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function $18783bca1921ec86$var$createInstance(defaultConfig) {
    const context = new (0, $65f086b5f8306d11$export$2e2bcd8739ae039)(defaultConfig);
    const instance = (0, $9793d8a71e8d5ff2$export$2e2bcd8739ae039)((0, $65f086b5f8306d11$export$2e2bcd8739ae039).prototype.request, context);
    // Copy axios.prototype to instance
    (0, $6c358707ac100c0e$export$2e2bcd8739ae039).extend(instance, (0, $65f086b5f8306d11$export$2e2bcd8739ae039).prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    (0, $6c358707ac100c0e$export$2e2bcd8739ae039).extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return $18783bca1921ec86$var$createInstance((0, $018b5e1fb5ffc975$export$2e2bcd8739ae039)(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
const $18783bca1921ec86$var$axios = $18783bca1921ec86$var$createInstance((0, $b4d55bc52e11a350$export$2e2bcd8739ae039));
// Expose Axios class to allow class inheritance
$18783bca1921ec86$var$axios.Axios = (0, $65f086b5f8306d11$export$2e2bcd8739ae039);
// Expose Cancel & CancelToken
$18783bca1921ec86$var$axios.CanceledError = (0, $43dc33230b98b12a$export$2e2bcd8739ae039);
$18783bca1921ec86$var$axios.CancelToken = (0, $8a96f4dfaaed1253$export$2e2bcd8739ae039);
$18783bca1921ec86$var$axios.isCancel = (0, $e63b86be51b94285$export$2e2bcd8739ae039);
$18783bca1921ec86$var$axios.VERSION = (0, $ea551752e35e8692$export$a4ad2735b021c132);
$18783bca1921ec86$var$axios.toFormData = (0, $df9a38a07be5d4e8$export$2e2bcd8739ae039);
// Expose AxiosError class
$18783bca1921ec86$var$axios.AxiosError = (0, $39018d9e9893716d$export$2e2bcd8739ae039);
// alias for CanceledError for backward compatibility
$18783bca1921ec86$var$axios.Cancel = $18783bca1921ec86$var$axios.CanceledError;
// Expose all/spread
$18783bca1921ec86$var$axios.all = function all(promises) {
    return Promise.all(promises);
};
$18783bca1921ec86$var$axios.spread = (0, $6252a06555621505$export$2e2bcd8739ae039);
// Expose isAxiosError
$18783bca1921ec86$var$axios.isAxiosError = (0, $8354989b4dcd6e4e$export$2e2bcd8739ae039);
// Expose mergeConfig
$18783bca1921ec86$var$axios.mergeConfig = (0, $018b5e1fb5ffc975$export$2e2bcd8739ae039);
$18783bca1921ec86$var$axios.AxiosHeaders = (0, $6c55e0db0b3245e3$export$2e2bcd8739ae039);
$18783bca1921ec86$var$axios.formToJSON = (thing)=>(0, $85cee280f0a85293$export$2e2bcd8739ae039)((0, $6c358707ac100c0e$export$2e2bcd8739ae039).isHTMLForm(thing) ? new FormData(thing) : thing);
$18783bca1921ec86$var$axios.getAdapter = (0, $70f1d4bc773f007e$export$2e2bcd8739ae039).getAdapter;
$18783bca1921ec86$var$axios.HttpStatusCode = (0, $a0cb09b1f0f101bc$export$2e2bcd8739ae039);
$18783bca1921ec86$var$axios.default = $18783bca1921ec86$var$axios;
var // this module should only have a default export
$18783bca1921ec86$export$2e2bcd8739ae039 = $18783bca1921ec86$var$axios;


// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const { Axios: $d18973b05b104eb4$export$1c00760e9e5a4e95 , AxiosError: $d18973b05b104eb4$export$c1fbed17c2f6a328 , CanceledError: $d18973b05b104eb4$export$1ab0c6b20d94fa14 , isCancel: $d18973b05b104eb4$export$3b22524397b493c6 , CancelToken: $d18973b05b104eb4$export$fd08e3cb425f0d61 , VERSION: $d18973b05b104eb4$export$a4ad2735b021c132 , all: $d18973b05b104eb4$export$84bf76cd7afc7469 , Cancel: $d18973b05b104eb4$export$848c9b7ead0df967 , isAxiosError: $d18973b05b104eb4$export$fbafdbe06a5b5a9a , spread: $d18973b05b104eb4$export$3ae0fd4797ed47c8 , toFormData: $d18973b05b104eb4$export$10ae0d317ea97f8b , AxiosHeaders: $d18973b05b104eb4$export$4e7d6ff0f3e6520 , HttpStatusCode: $d18973b05b104eb4$export$a972f69c851492b3 , formToJSON: $d18973b05b104eb4$export$86d7c59254d6a2c9 , getAdapter: $d18973b05b104eb4$export$17ddc20a97d669e2 , mergeConfig: $d18973b05b104eb4$export$7ec1ebcfa9d8bd6a  } = (0, $18783bca1921ec86$export$2e2bcd8739ae039);


function $8afa7834ebc28caa$export$2e2bcd8739ae039(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}



function $049294e5ba29a0f0$export$2e2bcd8739ae039(compare) {
    if (compare.length === 1) compare = $049294e5ba29a0f0$var$ascendingComparator(compare);
    return {
        left: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while(lo < hi){
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        },
        right: function(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while(lo < hi){
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) > 0) hi = mid;
                else lo = mid + 1;
            }
            return lo;
        }
    };
}
function $049294e5ba29a0f0$var$ascendingComparator(f) {
    return function(d, x) {
        return (0, $8afa7834ebc28caa$export$2e2bcd8739ae039)(f(d), x);
    };
}


var $96bc67fdfc1bb15b$var$ascendingBisect = (0, $049294e5ba29a0f0$export$2e2bcd8739ae039)((0, $8afa7834ebc28caa$export$2e2bcd8739ae039));
var $96bc67fdfc1bb15b$export$4d945ad3ad5751b0 = $96bc67fdfc1bb15b$var$ascendingBisect.right;
var $96bc67fdfc1bb15b$export$df7d25c84ebd12a5 = $96bc67fdfc1bb15b$var$ascendingBisect.left;
var $96bc67fdfc1bb15b$export$2e2bcd8739ae039 = $96bc67fdfc1bb15b$export$4d945ad3ad5751b0;




function $d23e7aa5e3d2ce3d$var$length(array) {
    return array.length | 0;
}
function $d23e7aa5e3d2ce3d$var$empty(length) {
    return !(length > 0);
}
function $d23e7aa5e3d2ce3d$var$arrayify(values) {
    return typeof values !== "object" || "length" in values ? values : Array.from(values);
}
function $d23e7aa5e3d2ce3d$var$reducer(reduce) {
    return (values)=>reduce(...values);
}
function $d23e7aa5e3d2ce3d$export$2e2bcd8739ae039(...values) {
    const reduce = typeof values[values.length - 1] === "function" && $d23e7aa5e3d2ce3d$var$reducer(values.pop());
    values = values.map($d23e7aa5e3d2ce3d$var$arrayify);
    const lengths = values.map($d23e7aa5e3d2ce3d$var$length);
    const j = values.length - 1;
    const index = new Array(j + 1).fill(0);
    const product = [];
    if (j < 0 || lengths.some($d23e7aa5e3d2ce3d$var$empty)) return product;
    while(true){
        product.push(index.map((j, i)=>values[i][j]));
        let i = j;
        while(++index[i] === lengths[i]){
            if (i === 0) return reduce ? product.map(reduce) : product;
            index[i--] = 0;
        }
    }
}


function $fd670c0f0109e50d$export$2e2bcd8739ae039(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


function $5003d507cd1bc621$export$2e2bcd8739ae039(values, valueof) {
    let count = 0;
    let delta;
    let mean = 0;
    let sum = 0;
    if (valueof === undefined) {
        for (let value of values)if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
        }
    } else {
        let index = -1;
        for (let value of values)if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
        }
    }
    if (count > 1) return sum / (count - 1);
}


function $fc7530dfb9f60d2b$export$2e2bcd8739ae039(values, valueof) {
    const v = (0, $5003d507cd1bc621$export$2e2bcd8739ae039)(values, valueof);
    return v ? Math.sqrt(v) : v;
}


function $719ebe1dfe21c6ae$export$2e2bcd8739ae039(values, valueof) {
    let min;
    let max;
    if (valueof === undefined) {
        for (let value of values)if (value != null && value >= value) {
            if (min === undefined) min = max = value;
            else {
                if (min > value) min = value;
                if (max < value) max = value;
            }
        }
    } else {
        let index = -1;
        for (let value of values)if ((value = valueof(value, ++index, values)) != null && value >= value) {
            if (min === undefined) min = max = value;
            else {
                if (min > value) min = value;
                if (max < value) max = value;
            }
        }
    }
    return [
        min,
        max
    ];
}


function $976bcfabbad0d313$export$2e2bcd8739ae039(x) {
    return x;
}


function $b760e5245204e129$var$dogroup(values, keyof) {
    const map = new Map();
    let index = -1;
    for (const value of values){
        const key = keyof(value, ++index, values);
        const group = map.get(key);
        if (group) group.push(value);
        else map.set(key, [
            value
        ]);
    }
    return map;
}
function $b760e5245204e129$export$2e2bcd8739ae039(values, reduce, ...keys) {
    return function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const map = $b760e5245204e129$var$dogroup(values, keys[i]);
        return new Map(Array.from(map, ([k, v])=>[
                k,
                regroup(v, i + 1)
            ]));
    }(values, 0);
}


function $470d9af02fc95cef$export$2e2bcd8739ae039(values, ...keys) {
    return (0, $b760e5245204e129$export$2e2bcd8739ae039)(values, (0, $976bcfabbad0d313$export$2e2bcd8739ae039), ...keys);
}


var $3d8f608bdb61ceb4$var$array = Array.prototype;
var $3d8f608bdb61ceb4$export$58adb3bec8346d0f = $3d8f608bdb61ceb4$var$array.slice;
var $3d8f608bdb61ceb4$export$871de8747c9eaa88 = $3d8f608bdb61ceb4$var$array.map;



function $4a3ab71a94d30669$export$2e2bcd8739ae039(x) {
    return function() {
        return x;
    };
}




function $55c1484467247d76$export$2e2bcd8739ae039(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
    while(++i < n)range[i] = start + i * step;
    return range;
}


var $35bc5adaf50b7e77$var$e10 = Math.sqrt(50), $35bc5adaf50b7e77$var$e5 = Math.sqrt(10), $35bc5adaf50b7e77$var$e2 = Math.sqrt(2);
function $35bc5adaf50b7e77$export$2e2bcd8739ae039(start, stop, count) {
    var reverse, i = -1, n, ticks, step;
    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [
        start
    ];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = $35bc5adaf50b7e77$export$bc64d00cc98e7e95(start, stop, count)) === 0 || !isFinite(step)) return [];
    if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while(++i < n)ticks[i] = (start + i) * step;
    } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while(++i < n)ticks[i] = (start - i) / step;
    }
    if (reverse) ticks.reverse();
    return ticks;
}
function $35bc5adaf50b7e77$export$bc64d00cc98e7e95(start, stop, count) {
    var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
    return power >= 0 ? (error >= $35bc5adaf50b7e77$var$e10 ? 10 : error >= $35bc5adaf50b7e77$var$e5 ? 5 : error >= $35bc5adaf50b7e77$var$e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= $35bc5adaf50b7e77$var$e10 ? 10 : error >= $35bc5adaf50b7e77$var$e5 ? 5 : error >= $35bc5adaf50b7e77$var$e2 ? 2 : 1);
}
function $35bc5adaf50b7e77$export$81087d9b915d4ede(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
    if (error >= $35bc5adaf50b7e77$var$e10) step1 *= 10;
    else if (error >= $35bc5adaf50b7e77$var$e5) step1 *= 5;
    else if (error >= $35bc5adaf50b7e77$var$e2) step1 *= 2;
    return stop < start ? -step1 : step1;
}


function $c18b5cfad88fa2be$export$2e2bcd8739ae039(values) {
    return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}


function $2e5a6772496690f7$export$2e2bcd8739ae039() {
    var value = (0, $976bcfabbad0d313$export$2e2bcd8739ae039), domain = (0, $719ebe1dfe21c6ae$export$2e2bcd8739ae039), threshold = (0, $c18b5cfad88fa2be$export$2e2bcd8739ae039);
    function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);
        var i, n = data.length, x, values = new Array(n);
        for(i = 0; i < n; ++i)values[i] = value(data[i], i, data);
        var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
            tz = (0, $35bc5adaf50b7e77$export$81087d9b915d4ede)(x0, x1, tz);
            tz = (0, $55c1484467247d76$export$2e2bcd8739ae039)(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
        }
        // Remove any thresholds outside the domain.
        var m = tz.length;
        while(tz[0] <= x0)tz.shift(), --m;
        while(tz[m - 1] > x1)tz.pop(), --m;
        var bins = new Array(m + 1), bin;
        // Initialize bins.
        for(i = 0; i <= m; ++i){
            bin = bins[i] = [];
            bin.x0 = i > 0 ? tz[i - 1] : x0;
            bin.x1 = i < m ? tz[i] : x1;
        }
        // Assign data to bins by value, ignoring any outside the domain.
        for(i = 0; i < n; ++i){
            x = values[i];
            if (x0 <= x && x <= x1) bins[(0, $96bc67fdfc1bb15b$export$2e2bcd8739ae039)(tz, x, 0, m)].push(data[i]);
        }
        return bins;
    }
    histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : (0, $4a3ab71a94d30669$export$2e2bcd8739ae039)(_), histogram) : value;
    };
    histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : (0, $4a3ab71a94d30669$export$2e2bcd8739ae039)([
            _[0],
            _[1]
        ]), histogram) : domain;
    };
    histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? (0, $4a3ab71a94d30669$export$2e2bcd8739ae039)((0, $3d8f608bdb61ceb4$export$58adb3bec8346d0f).call(_)) : (0, $4a3ab71a94d30669$export$2e2bcd8739ae039)(_), histogram) : threshold;
    };
    return histogram;
}




function $fabf5a01287a32b6$export$2e2bcd8739ae039(x) {
    return x === null ? NaN : +x;
}



function $267b55e11281d34c$export$2e2bcd8739ae039(values, p, valueof = (0, $fabf5a01287a32b6$export$2e2bcd8739ae039)) {
    if (!(n = values.length)) return;
    if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
    if (p >= 1) return +valueof(values[n - 1], n - 1, values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
}


function $f05eebc60cdd7ac1$export$2e2bcd8739ae039(values, min, max) {
    values = (0, $3d8f608bdb61ceb4$export$871de8747c9eaa88).call(values, (0, $fabf5a01287a32b6$export$2e2bcd8739ae039)).sort((0, $8afa7834ebc28caa$export$2e2bcd8739ae039));
    return Math.ceil((max - min) / (2 * ((0, $267b55e11281d34c$export$2e2bcd8739ae039)(values, 0.75) - (0, $267b55e11281d34c$export$2e2bcd8739ae039)(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}



function $597ed8bbc2f52a87$export$2e2bcd8739ae039(values, min, max) {
    return Math.ceil((max - min) / (3.5 * (0, $fc7530dfb9f60d2b$export$2e2bcd8739ae039)(values) * Math.pow(values.length, -1 / 3)));
}



function $3c6663a447dc3064$export$2e2bcd8739ae039(values, valueof) {
    let max;
    if (valueof === undefined) {
        for (let value of values)if (value != null && value >= value && (max === undefined || max < value)) max = value;
    } else {
        let index = -1;
        for (let value of values)if ((value = valueof(value, ++index, values)) != null && value >= value && (max === undefined || max < value)) max = value;
    }
    return max;
}


function $de5e85a4aa287bbd$export$2e2bcd8739ae039(values, valueof) {
    let count = 0;
    let sum = 0;
    if (valueof === undefined) {
        for (let value of values)if (value != null && (value = +value) >= value) ++count, sum += value;
    } else {
        let index = -1;
        for (let value of values)if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) ++count, sum += value;
    }
    if (count) return sum / count;
}




function $35dc57ffe7f35304$export$2e2bcd8739ae039(array, k, left = 0, right = array.length - 1, compare = (0, $8afa7834ebc28caa$export$2e2bcd8739ae039)) {
    while(right > left){
        if (right - left > 600) {
            const n = right - left + 1;
            const m = k - left + 1;
            const z = Math.log(n);
            const s = 0.5 * Math.exp(2 * z / 3);
            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            $35dc57ffe7f35304$export$2e2bcd8739ae039(array, k, newLeft, newRight, compare);
        }
        const t = array[k];
        let i = left;
        let j = right;
        $35dc57ffe7f35304$var$swap(array, left, k);
        if (compare(array[right], t) > 0) $35dc57ffe7f35304$var$swap(array, left, right);
        while(i < j){
            $35dc57ffe7f35304$var$swap(array, i, j), ++i, --j;
            while(compare(array[i], t) < 0)++i;
            while(compare(array[j], t) > 0)--j;
        }
        if (compare(array[left], t) === 0) $35dc57ffe7f35304$var$swap(array, left, j);
        else ++j, $35dc57ffe7f35304$var$swap(array, j, right);
        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
    return array;
}
function $35dc57ffe7f35304$var$swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
}


function* $7ebb0e4e23363f23$var$numbers(values, valueof) {
    if (valueof === undefined) {
        for (let value of values)if (value != null && (value = +value) >= value) yield value;
    } else {
        let index = -1;
        for (let value of values)if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) yield value;
    }
}
function $7ebb0e4e23363f23$export$2e2bcd8739ae039(values, valueof) {
    values = Float64Array.from($7ebb0e4e23363f23$var$numbers(values, valueof));
    if (!values.length) return;
    const n = values.length;
    const i = n >> 1;
    (0, $35dc57ffe7f35304$export$2e2bcd8739ae039)(values, i - 1, 0);
    if ((n & 1) === 0) (0, $35dc57ffe7f35304$export$2e2bcd8739ae039)(values, i, i);
    return (0, $267b55e11281d34c$export$2e2bcd8739ae039)(values, 0.5);
}


function* $5cd8852784c64684$var$flatten(arrays) {
    for (const array of arrays)yield* array;
}
function $5cd8852784c64684$export$2e2bcd8739ae039(arrays) {
    return Array.from($5cd8852784c64684$var$flatten(arrays));
}


function $a9fca0efc4cc4e3d$export$2e2bcd8739ae039(values, valueof) {
    let min;
    if (valueof === undefined) {
        for (let value of values)if (value != null && value >= value && (min === undefined || min > value)) min = value;
    } else {
        let index = -1;
        for (let value of values)if ((value = valueof(value, ++index, values)) != null && value >= value && (min === undefined || min > value)) min = value;
    }
    return min;
}


function $7ad8a107ac351c3a$export$2e2bcd8739ae039(values, pairof = $7ad8a107ac351c3a$export$a04cb3fe8b81dd) {
    const pairs = [];
    let previous;
    let first = false;
    for (const value of values){
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
    }
    return pairs;
}
function $7ad8a107ac351c3a$export$a04cb3fe8b81dd(a, b) {
    return [
        a,
        b
    ];
}


function $aa8a3ac165746b6a$export$2e2bcd8739ae039(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while(i--)permutes[i] = array[indexes[i]];
    return permutes;
}







function $97a8a22b403544d3$export$2e2bcd8739ae039(values, compare = (0, $8afa7834ebc28caa$export$2e2bcd8739ae039)) {
    let min;
    let minIndex;
    let index = -1;
    for (const value of values){
        ++index;
        if (minIndex === undefined ? compare(value, value) === 0 : compare(value, min) < 0) {
            min = value;
            minIndex = index;
        }
    }
    return minIndex;
}


function $5eb4d186477b965c$export$2e2bcd8739ae039(array, i0 = 0, i1 = array.length) {
    var m = i1 - (i0 = +i0), t, i;
    while(m){
        i = Math.random() * m-- | 0;
        t = array[m + i0];
        array[m + i0] = array[i + i0];
        array[i + i0] = t;
    }
    return array;
}


function $a382cf9932ea2443$export$2e2bcd8739ae039(values, valueof) {
    let sum = 0;
    if (valueof === undefined) {
        for (let value of values)if (value = +value) sum += value;
    } else {
        let index = -1;
        for (let value of values)if (value = +valueof(value, ++index, values)) sum += value;
    }
    return sum;
}




function $79e7c3447479c11e$export$2e2bcd8739ae039(matrix) {
    if (!(n = matrix.length)) return [];
    for(var i = -1, m = (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)(matrix, $79e7c3447479c11e$var$length), transpose = new Array(m); ++i < m;)for(var j = -1, n, row = transpose[i] = new Array(n); ++j < n;)row[j] = matrix[j][i];
    return transpose;
}
function $79e7c3447479c11e$var$length(d) {
    return d.length;
}




function $a6b22fb684d85c42$export$2e2bcd8739ae039() {
    return (0, $79e7c3447479c11e$export$2e2bcd8739ae039)(arguments);
}





// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function $7e34f0090ff041ad$export$2e2bcd8739ae039(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
    while(++i < n)range[i] = start + i * step;
    return range;
}


function $a672075a618c81db$export$23c7bb9e6558da2a(domain, range) {
    switch(arguments.length){
        case 0:
            break;
        case 1:
            this.range(domain);
            break;
        default:
            this.range(range).domain(domain);
            break;
    }
    return this;
}
function $a672075a618c81db$export$7d6b419e59e83f3d(domain, interpolator) {
    switch(arguments.length){
        case 0:
            break;
        case 1:
            if (typeof domain === "function") this.interpolator(domain);
            else this.range(domain);
            break;
        default:
            this.domain(domain);
            if (typeof interpolator === "function") this.interpolator(interpolator);
            else this.range(interpolator);
            break;
    }
    return this;
}


class $c0b82574205cc832$export$dcc6fb7d82b5bc7b extends Map {
    constructor(entries, key = $c0b82574205cc832$var$keyof){
        super();
        Object.defineProperties(this, {
            _intern: {
                value: new Map()
            },
            _key: {
                value: key
            }
        });
        if (entries != null) for (const [key, value] of entries)this.set(key, value);
    }
    get(key) {
        return super.get($c0b82574205cc832$var$intern_get(this, key));
    }
    has(key) {
        return super.has($c0b82574205cc832$var$intern_get(this, key));
    }
    set(key, value) {
        return super.set($c0b82574205cc832$var$intern_set(this, key), value);
    }
    delete(key) {
        return super.delete($c0b82574205cc832$var$intern_delete(this, key));
    }
}
class $c0b82574205cc832$export$55278c3294239828 extends Set {
    constructor(values, key = $c0b82574205cc832$var$keyof){
        super();
        Object.defineProperties(this, {
            _intern: {
                value: new Map()
            },
            _key: {
                value: key
            }
        });
        if (values != null) for (const value of values)this.add(value);
    }
    has(value) {
        return super.has($c0b82574205cc832$var$intern_get(this, value));
    }
    add(value) {
        return super.add($c0b82574205cc832$var$intern_set(this, value));
    }
    delete(value) {
        return super.delete($c0b82574205cc832$var$intern_delete(this, value));
    }
}
function $c0b82574205cc832$var$intern_get({ _intern: _intern , _key: _key  }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
}
function $c0b82574205cc832$var$intern_set({ _intern: _intern , _key: _key  }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
}
function $c0b82574205cc832$var$intern_delete({ _intern: _intern , _key: _key  }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
    }
    return value;
}
function $c0b82574205cc832$var$keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
}



const $76f520e6ef852424$export$e4f898ab14d9d460 = Symbol("implicit");
function $76f520e6ef852424$export$2e2bcd8739ae039() {
    var index = new (0, $c0b82574205cc832$export$dcc6fb7d82b5bc7b)(), domain = [], range = [], unknown = $76f520e6ef852424$export$e4f898ab14d9d460;
    function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
            if (unknown !== $76f520e6ef852424$export$e4f898ab14d9d460) return unknown;
            index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
    }
    scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new (0, $c0b82574205cc832$export$dcc6fb7d82b5bc7b)();
        for (const value of _){
            if (index.has(value)) continue;
            index.set(value, domain.push(value) - 1);
        }
        return scale;
    };
    scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
        return $76f520e6ef852424$export$2e2bcd8739ae039(domain, range).unknown(unknown);
    };
    (0, $a672075a618c81db$export$23c7bb9e6558da2a).apply(scale, arguments);
    return scale;
}


function $1c006476403aa8e7$export$2e2bcd8739ae039() {
    var scale = (0, $76f520e6ef852424$export$2e2bcd8739ae039)().unknown(undefined), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
        var n = domain().length, reverse = r1 < r0, start = reverse ? r1 : r0, stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = (0, $7e34f0090ff041ad$export$2e2bcd8739ae039)(n).map(function(i) {
            return start + step * i;
        });
        return ordinalRange(reverse ? values.reverse() : values);
    }
    scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [
            r0,
            r1
        ];
    };
    scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
    };
    scale.bandwidth = function() {
        return bandwidth;
    };
    scale.step = function() {
        return step;
    };
    scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
    };
    scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale.copy = function() {
        return $1c006476403aa8e7$export$2e2bcd8739ae039(domain(), [
            r0,
            r1
        ]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return (0, $a672075a618c81db$export$23c7bb9e6558da2a).apply(rescale(), arguments);
}
function $1c006476403aa8e7$var$pointish(scale) {
    var copy = scale.copy;
    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;
    scale.copy = function() {
        return $1c006476403aa8e7$var$pointish(copy());
    };
    return scale;
}
function $1c006476403aa8e7$export$105684a3041cb6f3() {
    return $1c006476403aa8e7$var$pointish($1c006476403aa8e7$export$2e2bcd8739ae039.apply(null, arguments).paddingInner(1));
}

const $13e83a9ae37bfd32$var$e10 = Math.sqrt(50), $13e83a9ae37bfd32$var$e5 = Math.sqrt(10), $13e83a9ae37bfd32$var$e2 = Math.sqrt(2);
function $13e83a9ae37bfd32$var$tickSpec(start, stop, count) {
    const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= $13e83a9ae37bfd32$var$e10 ? 10 : error >= $13e83a9ae37bfd32$var$e5 ? 5 : error >= $13e83a9ae37bfd32$var$e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start) ++i1;
        if (i2 / inc > stop) --i2;
        inc = -inc;
    } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start) ++i1;
        if (i2 * inc > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2) return $13e83a9ae37bfd32$var$tickSpec(start, stop, count * 2);
    return [
        i1,
        i2,
        inc
    ];
}
function $13e83a9ae37bfd32$export$2e2bcd8739ae039(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    if (!(count > 0)) return [];
    if (start === stop) return [
        start
    ];
    const reverse = stop < start, [i1, i2, inc] = reverse ? $13e83a9ae37bfd32$var$tickSpec(stop, start, count) : $13e83a9ae37bfd32$var$tickSpec(start, stop, count);
    if (!(i2 >= i1)) return [];
    const n = i2 - i1 + 1, ticks = new Array(n);
    if (reverse) {
        if (inc < 0) for(let i = 0; i < n; ++i)ticks[i] = (i2 - i) / -inc;
        else for(let i = 0; i < n; ++i)ticks[i] = (i2 - i) * inc;
    } else {
        if (inc < 0) for(let i = 0; i < n; ++i)ticks[i] = (i1 + i) / -inc;
        else for(let i = 0; i < n; ++i)ticks[i] = (i1 + i) * inc;
    }
    return ticks;
}
function $13e83a9ae37bfd32$export$bc64d00cc98e7e95(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    return $13e83a9ae37bfd32$var$tickSpec(start, stop, count)[2];
}
function $13e83a9ae37bfd32$export$81087d9b915d4ede(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    const reverse = stop < start, inc = reverse ? $13e83a9ae37bfd32$export$bc64d00cc98e7e95(stop, start, count) : $13e83a9ae37bfd32$export$bc64d00cc98e7e95(start, stop, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}


function $82853b02e4a3c56f$export$2e2bcd8739ae039(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}



function $c160560ea2400d04$export$2e2bcd8739ae039(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


function $fec511e1556f8cf9$export$2e2bcd8739ae039(f) {
    let compare1, compare2, delta;
    // If an accessor is specified, promote it to a comparator. In this case we
    // can test whether the search value is (self-) comparable. We can’t do this
    // for a comparator (except for specific, known comparators) because we can’t
    // tell if the comparator is symmetric, and an asymmetric comparator can’t be
    // used to test whether a single value is comparable.
    if (f.length !== 2) {
        compare1 = (0, $82853b02e4a3c56f$export$2e2bcd8739ae039);
        compare2 = (d, x)=>(0, $82853b02e4a3c56f$export$2e2bcd8739ae039)(f(d), x);
        delta = (d, x)=>f(d) - x;
    } else {
        compare1 = f === (0, $82853b02e4a3c56f$export$2e2bcd8739ae039) || f === (0, $c160560ea2400d04$export$2e2bcd8739ae039) ? f : $fec511e1556f8cf9$var$zero;
        compare2 = f;
        delta = f;
    }
    function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
            if (compare1(x, x) !== 0) return hi;
            do {
                const mid = lo + hi >>> 1;
                if (compare2(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
            }while (lo < hi);
        }
        return lo;
    }
    function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
            if (compare1(x, x) !== 0) return hi;
            do {
                const mid = lo + hi >>> 1;
                if (compare2(a[mid], x) <= 0) lo = mid + 1;
                else hi = mid;
            }while (lo < hi);
        }
        return lo;
    }
    function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return {
        left: left,
        center: center,
        right: right
    };
}
function $fec511e1556f8cf9$var$zero() {
    return 0;
}


function $34b142bf1d14ade3$export$2e2bcd8739ae039(x) {
    return x === null ? NaN : +x;
}
function* $34b142bf1d14ade3$export$1f6c9cc012ebacae(values, valueof) {
    if (valueof === undefined) {
        for (let value of values)if (value != null && (value = +value) >= value) yield value;
    } else {
        let index = -1;
        for (let value of values)if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) yield value;
    }
}


const $3a7b979758621c37$var$ascendingBisect = (0, $fec511e1556f8cf9$export$2e2bcd8739ae039)((0, $82853b02e4a3c56f$export$2e2bcd8739ae039));
const $3a7b979758621c37$export$4d945ad3ad5751b0 = $3a7b979758621c37$var$ascendingBisect.right;
const $3a7b979758621c37$export$df7d25c84ebd12a5 = $3a7b979758621c37$var$ascendingBisect.left;
const $3a7b979758621c37$export$c1cb828b1117c77b = (0, $fec511e1556f8cf9$export$2e2bcd8739ae039)((0, $34b142bf1d14ade3$export$2e2bcd8739ae039)).center;
var $3a7b979758621c37$export$2e2bcd8739ae039 = $3a7b979758621c37$export$4d945ad3ad5751b0;


function $901f80c70ca6856e$export$2e2bcd8739ae039(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
}
function $901f80c70ca6856e$export$8b58be045bf06082(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for(var key in definition)prototype[key] = definition[key];
    return prototype;
}


function $cf694006e2c2e1e2$export$892596cec99bc70e() {}
var $cf694006e2c2e1e2$export$4adafc6ed0600c10 = 0.7;
var $cf694006e2c2e1e2$export$9eace2cc0d12c98d = 1 / $cf694006e2c2e1e2$export$4adafc6ed0600c10;
var $cf694006e2c2e1e2$var$reI = "\\s*([+-]?\\d+)\\s*", $cf694006e2c2e1e2$var$reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", $cf694006e2c2e1e2$var$reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", $cf694006e2c2e1e2$var$reHex = /^#([0-9a-f]{3,8})$/, $cf694006e2c2e1e2$var$reRgbInteger = new RegExp(`^rgb\\(${$cf694006e2c2e1e2$var$reI},${$cf694006e2c2e1e2$var$reI},${$cf694006e2c2e1e2$var$reI}\\)$`), $cf694006e2c2e1e2$var$reRgbPercent = new RegExp(`^rgb\\(${$cf694006e2c2e1e2$var$reP},${$cf694006e2c2e1e2$var$reP},${$cf694006e2c2e1e2$var$reP}\\)$`), $cf694006e2c2e1e2$var$reRgbaInteger = new RegExp(`^rgba\\(${$cf694006e2c2e1e2$var$reI},${$cf694006e2c2e1e2$var$reI},${$cf694006e2c2e1e2$var$reI},${$cf694006e2c2e1e2$var$reN}\\)$`), $cf694006e2c2e1e2$var$reRgbaPercent = new RegExp(`^rgba\\(${$cf694006e2c2e1e2$var$reP},${$cf694006e2c2e1e2$var$reP},${$cf694006e2c2e1e2$var$reP},${$cf694006e2c2e1e2$var$reN}\\)$`), $cf694006e2c2e1e2$var$reHslPercent = new RegExp(`^hsl\\(${$cf694006e2c2e1e2$var$reN},${$cf694006e2c2e1e2$var$reP},${$cf694006e2c2e1e2$var$reP}\\)$`), $cf694006e2c2e1e2$var$reHslaPercent = new RegExp(`^hsla\\(${$cf694006e2c2e1e2$var$reN},${$cf694006e2c2e1e2$var$reP},${$cf694006e2c2e1e2$var$reP},${$cf694006e2c2e1e2$var$reN}\\)$`);
var $cf694006e2c2e1e2$var$named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
};
(0, $901f80c70ca6856e$export$2e2bcd8739ae039)($cf694006e2c2e1e2$export$892596cec99bc70e, $cf694006e2c2e1e2$export$2e2bcd8739ae039, {
    copy (channels) {
        return Object.assign(new this.constructor, this, channels);
    },
    displayable () {
        return this.rgb().displayable();
    },
    hex: $cf694006e2c2e1e2$var$color_formatHex,
    formatHex: $cf694006e2c2e1e2$var$color_formatHex,
    formatHex8: $cf694006e2c2e1e2$var$color_formatHex8,
    formatHsl: $cf694006e2c2e1e2$var$color_formatHsl,
    formatRgb: $cf694006e2c2e1e2$var$color_formatRgb,
    toString: $cf694006e2c2e1e2$var$color_formatRgb
});
function $cf694006e2c2e1e2$var$color_formatHex() {
    return this.rgb().formatHex();
}
function $cf694006e2c2e1e2$var$color_formatHex8() {
    return this.rgb().formatHex8();
}
function $cf694006e2c2e1e2$var$color_formatHsl() {
    return $cf694006e2c2e1e2$export$8133dc3fa904d6d1(this).formatHsl();
}
function $cf694006e2c2e1e2$var$color_formatRgb() {
    return this.rgb().formatRgb();
}
function $cf694006e2c2e1e2$export$2e2bcd8739ae039(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = $cf694006e2c2e1e2$var$reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? $cf694006e2c2e1e2$var$rgbn(m) // #ff0000
     : l === 3 ? new $cf694006e2c2e1e2$export$5e05a94393ac29e3(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
     : l === 8 ? $cf694006e2c2e1e2$var$rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
     : l === 4 ? $cf694006e2c2e1e2$var$rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
     : null // invalid hex
    ) : (m = $cf694006e2c2e1e2$var$reRgbInteger.exec(format)) ? new $cf694006e2c2e1e2$export$5e05a94393ac29e3(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
     : (m = $cf694006e2c2e1e2$var$reRgbPercent.exec(format)) ? new $cf694006e2c2e1e2$export$5e05a94393ac29e3(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
     : (m = $cf694006e2c2e1e2$var$reRgbaInteger.exec(format)) ? $cf694006e2c2e1e2$var$rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
     : (m = $cf694006e2c2e1e2$var$reRgbaPercent.exec(format)) ? $cf694006e2c2e1e2$var$rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
     : (m = $cf694006e2c2e1e2$var$reHslPercent.exec(format)) ? $cf694006e2c2e1e2$var$hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
     : (m = $cf694006e2c2e1e2$var$reHslaPercent.exec(format)) ? $cf694006e2c2e1e2$var$hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
     : $cf694006e2c2e1e2$var$named.hasOwnProperty(format) ? $cf694006e2c2e1e2$var$rgbn($cf694006e2c2e1e2$var$named[format]) // eslint-disable-line no-prototype-builtins
     : format === "transparent" ? new $cf694006e2c2e1e2$export$5e05a94393ac29e3(NaN, NaN, NaN, 0) : null;
}
function $cf694006e2c2e1e2$var$rgbn(n) {
    return new $cf694006e2c2e1e2$export$5e05a94393ac29e3(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}
function $cf694006e2c2e1e2$var$rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new $cf694006e2c2e1e2$export$5e05a94393ac29e3(r, g, b, a);
}
function $cf694006e2c2e1e2$export$42da0a331c2802f5(o) {
    if (!(o instanceof $cf694006e2c2e1e2$export$892596cec99bc70e)) o = $cf694006e2c2e1e2$export$2e2bcd8739ae039(o);
    if (!o) return new $cf694006e2c2e1e2$export$5e05a94393ac29e3;
    o = o.rgb();
    return new $cf694006e2c2e1e2$export$5e05a94393ac29e3(o.r, o.g, o.b, o.opacity);
}
function $cf694006e2c2e1e2$export$8972dc0e6ad9238f(r, g, b, opacity) {
    return arguments.length === 1 ? $cf694006e2c2e1e2$export$42da0a331c2802f5(r) : new $cf694006e2c2e1e2$export$5e05a94393ac29e3(r, g, b, opacity == null ? 1 : opacity);
}
function $cf694006e2c2e1e2$export$5e05a94393ac29e3(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
}
(0, $901f80c70ca6856e$export$2e2bcd8739ae039)($cf694006e2c2e1e2$export$5e05a94393ac29e3, $cf694006e2c2e1e2$export$8972dc0e6ad9238f, (0, $901f80c70ca6856e$export$8b58be045bf06082)($cf694006e2c2e1e2$export$892596cec99bc70e, {
    brighter (k) {
        k = k == null ? $cf694006e2c2e1e2$export$9eace2cc0d12c98d : Math.pow($cf694006e2c2e1e2$export$9eace2cc0d12c98d, k);
        return new $cf694006e2c2e1e2$export$5e05a94393ac29e3(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker (k) {
        k = k == null ? $cf694006e2c2e1e2$export$4adafc6ed0600c10 : Math.pow($cf694006e2c2e1e2$export$4adafc6ed0600c10, k);
        return new $cf694006e2c2e1e2$export$5e05a94393ac29e3(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb () {
        return this;
    },
    clamp () {
        return new $cf694006e2c2e1e2$export$5e05a94393ac29e3($cf694006e2c2e1e2$var$clampi(this.r), $cf694006e2c2e1e2$var$clampi(this.g), $cf694006e2c2e1e2$var$clampi(this.b), $cf694006e2c2e1e2$var$clampa(this.opacity));
    },
    displayable () {
        return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: $cf694006e2c2e1e2$var$rgb_formatHex,
    formatHex: $cf694006e2c2e1e2$var$rgb_formatHex,
    formatHex8: $cf694006e2c2e1e2$var$rgb_formatHex8,
    formatRgb: $cf694006e2c2e1e2$var$rgb_formatRgb,
    toString: $cf694006e2c2e1e2$var$rgb_formatRgb
}));
function $cf694006e2c2e1e2$var$rgb_formatHex() {
    return `#${$cf694006e2c2e1e2$var$hex(this.r)}${$cf694006e2c2e1e2$var$hex(this.g)}${$cf694006e2c2e1e2$var$hex(this.b)}`;
}
function $cf694006e2c2e1e2$var$rgb_formatHex8() {
    return `#${$cf694006e2c2e1e2$var$hex(this.r)}${$cf694006e2c2e1e2$var$hex(this.g)}${$cf694006e2c2e1e2$var$hex(this.b)}${$cf694006e2c2e1e2$var$hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function $cf694006e2c2e1e2$var$rgb_formatRgb() {
    const a = $cf694006e2c2e1e2$var$clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${$cf694006e2c2e1e2$var$clampi(this.r)}, ${$cf694006e2c2e1e2$var$clampi(this.g)}, ${$cf694006e2c2e1e2$var$clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function $cf694006e2c2e1e2$var$clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function $cf694006e2c2e1e2$var$clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function $cf694006e2c2e1e2$var$hex(value) {
    value = $cf694006e2c2e1e2$var$clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
}
function $cf694006e2c2e1e2$var$hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new $cf694006e2c2e1e2$var$Hsl(h, s, l, a);
}
function $cf694006e2c2e1e2$export$8133dc3fa904d6d1(o) {
    if (o instanceof $cf694006e2c2e1e2$var$Hsl) return new $cf694006e2c2e1e2$var$Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof $cf694006e2c2e1e2$export$892596cec99bc70e)) o = $cf694006e2c2e1e2$export$2e2bcd8739ae039(o);
    if (!o) return new $cf694006e2c2e1e2$var$Hsl;
    if (o instanceof $cf694006e2c2e1e2$var$Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
    if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
    } else s = l > 0 && l < 1 ? 0 : h;
    return new $cf694006e2c2e1e2$var$Hsl(h, s, l, o.opacity);
}
function $cf694006e2c2e1e2$export$8f4a7c0bb78e6ea8(h, s, l, opacity) {
    return arguments.length === 1 ? $cf694006e2c2e1e2$export$8133dc3fa904d6d1(h) : new $cf694006e2c2e1e2$var$Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function $cf694006e2c2e1e2$var$Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
}
(0, $901f80c70ca6856e$export$2e2bcd8739ae039)($cf694006e2c2e1e2$var$Hsl, $cf694006e2c2e1e2$export$8f4a7c0bb78e6ea8, (0, $901f80c70ca6856e$export$8b58be045bf06082)($cf694006e2c2e1e2$export$892596cec99bc70e, {
    brighter (k) {
        k = k == null ? $cf694006e2c2e1e2$export$9eace2cc0d12c98d : Math.pow($cf694006e2c2e1e2$export$9eace2cc0d12c98d, k);
        return new $cf694006e2c2e1e2$var$Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker (k) {
        k = k == null ? $cf694006e2c2e1e2$export$4adafc6ed0600c10 : Math.pow($cf694006e2c2e1e2$export$4adafc6ed0600c10, k);
        return new $cf694006e2c2e1e2$var$Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb () {
        var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new $cf694006e2c2e1e2$export$5e05a94393ac29e3($cf694006e2c2e1e2$var$hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), $cf694006e2c2e1e2$var$hsl2rgb(h, m1, m2), $cf694006e2c2e1e2$var$hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    clamp () {
        return new $cf694006e2c2e1e2$var$Hsl($cf694006e2c2e1e2$var$clamph(this.h), $cf694006e2c2e1e2$var$clampt(this.s), $cf694006e2c2e1e2$var$clampt(this.l), $cf694006e2c2e1e2$var$clampa(this.opacity));
    },
    displayable () {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl () {
        const a = $cf694006e2c2e1e2$var$clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${$cf694006e2c2e1e2$var$clamph(this.h)}, ${$cf694006e2c2e1e2$var$clampt(this.s) * 100}%, ${$cf694006e2c2e1e2$var$clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
}));
function $cf694006e2c2e1e2$var$clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
}
function $cf694006e2c2e1e2$var$clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
}
/* From FvD 13.37, CSS Color Module Level 3 */ function $cf694006e2c2e1e2$var$hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}



function $aa6dd7d72504a24e$export$4e41033bfeec1a4c(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function $aa6dd7d72504a24e$export$2e2bcd8739ae039(values) {
    var n = values.length - 1;
    return function(t) {
        var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return $aa6dd7d72504a24e$export$4e41033bfeec1a4c((t - i / n) * n, v0, v1, v2, v3);
    };
}



function $fa6b9ba791d053a6$export$2e2bcd8739ae039(values) {
    var n = values.length;
    return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
        return (0, $aa6dd7d72504a24e$export$4e41033bfeec1a4c)((t - i / n) * n, v0, v1, v2, v3);
    };
}


var $663e255a175cfb78$export$2e2bcd8739ae039 = (x)=>()=>x;


function $129eda5b6d4cb725$var$linear(a, d) {
    return function(t) {
        return a + t * d;
    };
}
function $129eda5b6d4cb725$var$exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
    };
}
function $129eda5b6d4cb725$export$97d7b0c7ddb78dcf(a, b) {
    var d = b - a;
    return d ? $129eda5b6d4cb725$var$linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0, $663e255a175cfb78$export$2e2bcd8739ae039)(isNaN(a) ? b : a);
}
function $129eda5b6d4cb725$export$a7ebe8cc6aaf8d37(y) {
    return (y = +y) === 1 ? $129eda5b6d4cb725$export$2e2bcd8739ae039 : function(a, b) {
        return b - a ? $129eda5b6d4cb725$var$exponential(a, b, y) : (0, $663e255a175cfb78$export$2e2bcd8739ae039)(isNaN(a) ? b : a);
    };
}
function $129eda5b6d4cb725$export$2e2bcd8739ae039(a, b) {
    var d = b - a;
    return d ? $129eda5b6d4cb725$var$linear(a, d) : (0, $663e255a175cfb78$export$2e2bcd8739ae039)(isNaN(a) ? b : a);
}


var $dee4c3745eb459e0$export$2e2bcd8739ae039 = function rgbGamma(y) {
    var color = (0, $129eda5b6d4cb725$export$a7ebe8cc6aaf8d37)(y);
    function rgb(start, end) {
        var r = color((start = (0, $cf694006e2c2e1e2$export$8972dc0e6ad9238f)(start)).r, (end = (0, $cf694006e2c2e1e2$export$8972dc0e6ad9238f)(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = (0, $129eda5b6d4cb725$export$2e2bcd8739ae039)(start.opacity, end.opacity);
        return function(t) {
            start.r = r(t);
            start.g = g(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
        };
    }
    rgb.gamma = rgbGamma;
    return rgb;
}(1);
function $dee4c3745eb459e0$var$rgbSpline(spline) {
    return function(colors) {
        var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color;
        for(i = 0; i < n; ++i){
            color = (0, $cf694006e2c2e1e2$export$8972dc0e6ad9238f)(colors[i]);
            r[i] = color.r || 0;
            g[i] = color.g || 0;
            b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
            color.r = r(t);
            color.g = g(t);
            color.b = b(t);
            return color + "";
        };
    };
}
var $dee4c3745eb459e0$export$2c0e28f2e2852d3f = $dee4c3745eb459e0$var$rgbSpline((0, $aa6dd7d72504a24e$export$2e2bcd8739ae039));
var $dee4c3745eb459e0$export$53d5214f625ccd4c = $dee4c3745eb459e0$var$rgbSpline((0, $fa6b9ba791d053a6$export$2e2bcd8739ae039));



function $d9fa745bef89a63f$export$2e2bcd8739ae039(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
        for(i = 0; i < n; ++i)c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
    };
}
function $d9fa745bef89a63f$export$5cd576d1827d40c8(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


function $94122849d0a1bd4f$export$2e2bcd8739ae039(a, b) {
    return ((0, $d9fa745bef89a63f$export$5cd576d1827d40c8)(b) ? (0, $d9fa745bef89a63f$export$2e2bcd8739ae039) : $94122849d0a1bd4f$export$15d09067c6a5ee49)(a, b);
}
function $94122849d0a1bd4f$export$15d09067c6a5ee49(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for(i = 0; i < na; ++i)x[i] = (0, $d6f598373d8c7921$export$2e2bcd8739ae039)(a[i], b[i]);
    for(; i < nb; ++i)c[i] = b[i];
    return function(t) {
        for(i = 0; i < na; ++i)c[i] = x[i](t);
        return c;
    };
}


function $fa99a6cf855593c6$export$2e2bcd8739ae039(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
    };
}


function $c81b71dd671221b9$export$2e2bcd8739ae039(a, b) {
    return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
    };
}



function $4351e7982219ccb5$export$2e2bcd8739ae039(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};
    for(k in b)if (k in a) i[k] = (0, $d6f598373d8c7921$export$2e2bcd8739ae039)(a[k], b[k]);
    else c[k] = b[k];
    return function(t) {
        for(k in i)c[k] = i[k](t);
        return c;
    };
}



var $2857a0a753f53698$var$reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, $2857a0a753f53698$var$reB = new RegExp($2857a0a753f53698$var$reA.source, "g");
function $2857a0a753f53698$var$zero(b) {
    return function() {
        return b;
    };
}
function $2857a0a753f53698$var$one(b) {
    return function(t) {
        return b(t) + "";
    };
}
function $2857a0a753f53698$export$2e2bcd8739ae039(a, b) {
    var bi = $2857a0a753f53698$var$reA.lastIndex = $2857a0a753f53698$var$reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = []; // number interpolators
    // Coerce inputs to strings.
    a = a + "", b = b + "";
    // Interpolate pairs of numbers in a & b.
    while((am = $2857a0a753f53698$var$reA.exec(a)) && (bm = $2857a0a753f53698$var$reB.exec(b))){
        if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i]) s[i] += bs; // coalesce with previous string
            else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
            if (s[i]) s[i] += bm; // coalesce with previous string
            else s[++i] = bm;
        } else {
            s[++i] = null;
            q.push({
                i: i,
                x: (0, $c81b71dd671221b9$export$2e2bcd8739ae039)(am, bm)
            });
        }
        bi = $2857a0a753f53698$var$reB.lastIndex;
    }
    // Add remains of b.
    if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
    }
    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? q[0] ? $2857a0a753f53698$var$one(q[0].x) : $2857a0a753f53698$var$zero(b) : (b = q.length, function(t) {
        for(var i = 0, o; i < b; ++i)s[(o = q[i]).i] = o.x(t);
        return s.join("");
    });
}




function $d6f598373d8c7921$export$2e2bcd8739ae039(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? (0, $663e255a175cfb78$export$2e2bcd8739ae039)(b) : (t === "number" ? (0, $c81b71dd671221b9$export$2e2bcd8739ae039) : t === "string" ? (c = (0, $cf694006e2c2e1e2$export$2e2bcd8739ae039)(b)) ? (b = c, $dee4c3745eb459e0$export$2e2bcd8739ae039) : (0, $2857a0a753f53698$export$2e2bcd8739ae039) : b instanceof (0, $cf694006e2c2e1e2$export$2e2bcd8739ae039) ? (0, $dee4c3745eb459e0$export$2e2bcd8739ae039) : b instanceof Date ? (0, $fa99a6cf855593c6$export$2e2bcd8739ae039) : (0, $d9fa745bef89a63f$export$5cd576d1827d40c8)(b) ? (0, $d9fa745bef89a63f$export$2e2bcd8739ae039) : Array.isArray(b) ? (0, $94122849d0a1bd4f$export$15d09067c6a5ee49) : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? (0, $4351e7982219ccb5$export$2e2bcd8739ae039) : (0, $c81b71dd671221b9$export$2e2bcd8739ae039))(a, b);
}

function $17ba21bccb8f8ee4$export$2e2bcd8739ae039(a, b) {
    return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
    };
}


function $934e9e7f5b67cfca$export$2e2bcd8739ae039(x) {
    return function() {
        return x;
    };
}


function $28eff86d82a0d9a8$export$2e2bcd8739ae039(x) {
    return +x;
}


var $d1720577d8838e88$var$unit = [
    0,
    1
];
function $d1720577d8838e88$export$f0954fd7d5368655(x) {
    return x;
}
function $d1720577d8838e88$var$normalize(a, b) {
    return (b -= a = +a) ? function(x) {
        return (x - a) / b;
    } : (0, $934e9e7f5b67cfca$export$2e2bcd8739ae039)(isNaN(b) ? NaN : 0.5);
}
function $d1720577d8838e88$var$clamper(a, b) {
    var t;
    if (a > b) t = a, a = b, b = t;
    return function(x) {
        return Math.max(a, Math.min(b, x));
    };
}
// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function $d1720577d8838e88$var$bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = $d1720577d8838e88$var$normalize(d1, d0), r0 = interpolate(r1, r0);
    else d0 = $d1720577d8838e88$var$normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x) {
        return r0(d0(x));
    };
}
function $d1720577d8838e88$var$polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    // Reverse descending domains.
    if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
    }
    while(++i < j){
        d[i] = $d1720577d8838e88$var$normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
    }
    return function(x) {
        var i = (0, $3a7b979758621c37$export$2e2bcd8739ae039)(domain, x, 1, j) - 1;
        return r[i](d[i](x));
    };
}
function $d1720577d8838e88$export$784d13d8ee351f07(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function $d1720577d8838e88$export$6b468dcfb64c653c() {
    var domain = $d1720577d8838e88$var$unit, range = $d1720577d8838e88$var$unit, interpolate = (0, $d6f598373d8c7921$export$2e2bcd8739ae039), transform, untransform, unknown, clamp = $d1720577d8838e88$export$f0954fd7d5368655, piecewise, output, input;
    function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== $d1720577d8838e88$export$f0954fd7d5368655) clamp = $d1720577d8838e88$var$clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? $d1720577d8838e88$var$polymap : $d1720577d8838e88$var$bimap;
        output = input = null;
        return scale;
    }
    function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
    }
    scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), (0, $c81b71dd671221b9$export$2e2bcd8739ae039))))(y)));
    };
    scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, (0, $28eff86d82a0d9a8$export$2e2bcd8739ae039)), rescale()) : domain.slice();
    };
    scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };
    scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = (0, $17ba21bccb8f8ee4$export$2e2bcd8739ae039), rescale();
    };
    scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : $d1720577d8838e88$export$f0954fd7d5368655, rescale()) : clamp !== $d1720577d8838e88$export$f0954fd7d5368655;
    };
    scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t, u) {
        transform = t, untransform = u;
        return rescale();
    };
}
function $d1720577d8838e88$export$2e2bcd8739ae039() {
    return $d1720577d8838e88$export$6b468dcfb64c653c()($d1720577d8838e88$export$f0954fd7d5368655, $d1720577d8838e88$export$f0954fd7d5368655);
}




// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function $8759ab15297a2b56$export$2e2bcd8739ae039(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);
    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
    ];
}


function $6dd8f871b985337d$export$2e2bcd8739ae039(x) {
    return x = (0, $8759ab15297a2b56$export$2e2bcd8739ae039)(Math.abs(x)), x ? x[1] : NaN;
}


function $f7ff9787fda96f8f$export$2e2bcd8739ae039(grouping, thousands) {
    return function(value, width) {
        var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
        while(i > 0 && g > 0){
            if (length + g + 1 > width) g = Math.max(1, width - length);
            t.push(value.substring(i -= g, i + g));
            if ((length += g + 1) > width) break;
            g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
    };
}


function $338e6057aae25f4e$export$2e2bcd8739ae039(numerals) {
    return function(value) {
        return value.replace(/[0-9]/g, function(i) {
            return numerals[+i];
        });
    };
}


// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var $babd3c0ee933dbfb$var$re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function $babd3c0ee933dbfb$export$2e2bcd8739ae039(specifier) {
    return new $babd3c0ee933dbfb$var$FormatSpecifier(specifier);
}
$babd3c0ee933dbfb$export$2e2bcd8739ae039.prototype = $babd3c0ee933dbfb$var$FormatSpecifier.prototype; // instanceof
function $babd3c0ee933dbfb$var$FormatSpecifier(specifier) {
    if (!(match = $babd3c0ee933dbfb$var$re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    this.fill = match[1] || " ";
    this.align = match[2] || ">";
    this.sign = match[3] || "-";
    this.symbol = match[4] || "";
    this.zero = !!match[5];
    this.width = match[6] && +match[6];
    this.comma = !!match[7];
    this.precision = match[8] && +match[8].slice(1);
    this.trim = !!match[9];
    this.type = match[10] || "";
}
$babd3c0ee933dbfb$var$FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};


// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function $014a99823dff2a6c$export$2e2bcd8739ae039(s) {
    out: for(var n = s.length, i = 1, i0 = -1, i1; i < n; ++i)switch(s[i]){
        case ".":
            i0 = i1 = i;
            break;
        case "0":
            if (i0 === 0) i0 = i;
            i1 = i;
            break;
        default:
            if (i0 > 0) {
                if (!+s[i]) break out;
                i0 = 0;
            }
            break;
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}



var $dba29f01eef201fc$export$6863724d9a42263;
function $dba29f01eef201fc$export$2e2bcd8739ae039(x, p) {
    var d = (0, $8759ab15297a2b56$export$2e2bcd8739ae039)(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - ($dba29f01eef201fc$export$6863724d9a42263 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + (0, $8759ab15297a2b56$export$2e2bcd8739ae039)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}



function $96057359aae7caa5$export$2e2bcd8739ae039(x, p) {
    var d = (0, $8759ab15297a2b56$export$2e2bcd8739ae039)(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


var $a7a5368c26bb49b2$export$2e2bcd8739ae039 = {
    "%": function(x, p) {
        return (x * 100).toFixed(p);
    },
    "b": function(x) {
        return Math.round(x).toString(2);
    },
    "c": function(x) {
        return x + "";
    },
    "d": function(x) {
        return Math.round(x).toString(10);
    },
    "e": function(x, p) {
        return x.toExponential(p);
    },
    "f": function(x, p) {
        return x.toFixed(p);
    },
    "g": function(x, p) {
        return x.toPrecision(p);
    },
    "o": function(x) {
        return Math.round(x).toString(8);
    },
    "p": function(x, p) {
        return (0, $96057359aae7caa5$export$2e2bcd8739ae039)(x * 100, p);
    },
    "r": (0, $96057359aae7caa5$export$2e2bcd8739ae039),
    "s": (0, $dba29f01eef201fc$export$2e2bcd8739ae039),
    "X": function(x) {
        return Math.round(x).toString(16).toUpperCase();
    },
    "x": function(x) {
        return Math.round(x).toString(16);
    }
};



function $3719f021b54a9028$export$2e2bcd8739ae039(x) {
    return x;
}


var $a0c09c68c1f49473$var$prefixes = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "\xb5",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
];
function $a0c09c68c1f49473$export$2e2bcd8739ae039(locale) {
    var group = locale.grouping && locale.thousands ? (0, $f7ff9787fda96f8f$export$2e2bcd8739ae039)(locale.grouping, locale.thousands) : (0, $3719f021b54a9028$export$2e2bcd8739ae039), currency = locale.currency, decimal = locale.decimal, numerals = locale.numerals ? (0, $338e6057aae25f4e$export$2e2bcd8739ae039)(locale.numerals) : (0, $3719f021b54a9028$export$2e2bcd8739ae039), percent = locale.percent || "%";
    function newFormat(specifier) {
        specifier = (0, $babd3c0ee933dbfb$export$2e2bcd8739ae039)(specifier);
        var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";
        else if (!(0, $a7a5368c26bb49b2$export$2e2bcd8739ae039)[type]) precision == null && (precision = 12), trim = true, type = "g";
        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";
        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = (0, $a7a5368c26bb49b2$export$2e2bcd8739ae039)[type], maybeSuffix = /[defgprs%]/.test(type);
        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision == null ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format(value) {
            var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
            if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
            } else {
                value = +value;
                // Perform the initial formatting.
                var valueNegative = value < 0;
                value = formatType(Math.abs(value), precision);
                // Trim insignificant zeros.
                if (trim) value = (0, $014a99823dff2a6c$export$2e2bcd8739ae039)(value);
                // If a negative value rounds to zero during formatting, treat as positive.
                if (valueNegative && +value === 0) valueNegative = false;
                // Compute the prefix and suffix.
                valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? $a0c09c68c1f49473$var$prefixes[8 + (0, $dba29f01eef201fc$export$6863724d9a42263) / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                // Break the formatted value into the integer “value” part that can be
                // grouped, and fractional or exponential “suffix” part that is not.
                if (maybeSuffix) {
                    i = -1, n = value.length;
                    while(++i < n)if (c = value.charCodeAt(i), 48 > c || c > 57) {
                        valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                        value = value.slice(0, i);
                        break;
                    }
                }
            }
            // If the fill character is not "0", grouping is applied before padding.
            if (comma && !zero) value = group(value, Infinity);
            // Compute the padding.
            var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
            // If the fill character is "0", grouping is applied after padding.
            if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
            // Reconstruct the final output based on the desired alignment.
            switch(align){
                case "<":
                    value = valuePrefix + value + valueSuffix + padding;
                    break;
                case "=":
                    value = valuePrefix + padding + value + valueSuffix;
                    break;
                case "^":
                    value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                    break;
                default:
                    value = padding + valuePrefix + value + valueSuffix;
                    break;
            }
            return numerals(value);
        }
        format.toString = function() {
            return specifier + "";
        };
        return format;
    }
    function formatPrefix(specifier, value) {
        var f = newFormat((specifier = (0, $babd3c0ee933dbfb$export$2e2bcd8739ae039)(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor((0, $6dd8f871b985337d$export$2e2bcd8739ae039)(value) / 3))) * 3, k = Math.pow(10, -e), prefix = $a0c09c68c1f49473$var$prefixes[8 + e / 3];
        return function(value) {
            return f(k * value) + prefix;
        };
    }
    return {
        format: newFormat,
        formatPrefix: formatPrefix
    };
}


var $23de77130e6fabd5$var$locale;
var $23de77130e6fabd5$export$d9468344d3651243;
var $23de77130e6fabd5$export$8d85692a469dde6f;
$23de77130e6fabd5$export$2e2bcd8739ae039({
    decimal: ".",
    thousands: ",",
    grouping: [
        3
    ],
    currency: [
        "$",
        ""
    ]
});
function $23de77130e6fabd5$export$2e2bcd8739ae039(definition) {
    $23de77130e6fabd5$var$locale = (0, $a0c09c68c1f49473$export$2e2bcd8739ae039)(definition);
    $23de77130e6fabd5$export$d9468344d3651243 = $23de77130e6fabd5$var$locale.format;
    $23de77130e6fabd5$export$8d85692a469dde6f = $23de77130e6fabd5$var$locale.formatPrefix;
    return $23de77130e6fabd5$var$locale;
}





function $e542643fa01a3586$export$2e2bcd8739ae039(step) {
    return Math.max(0, -(0, $6dd8f871b985337d$export$2e2bcd8739ae039)(Math.abs(step)));
}



function $70c7673fef1d9274$export$2e2bcd8739ae039(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0, $6dd8f871b985337d$export$2e2bcd8739ae039)(value) / 3))) * 3 - (0, $6dd8f871b985337d$export$2e2bcd8739ae039)(Math.abs(step)));
}



function $36636254076a5075$export$2e2bcd8739ae039(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, (0, $6dd8f871b985337d$export$2e2bcd8739ae039)(max) - (0, $6dd8f871b985337d$export$2e2bcd8739ae039)(step)) + 1;
}




function $9de36082a50c02ba$export$2e2bcd8739ae039(start, stop, count, specifier) {
    var step = (0, $13e83a9ae37bfd32$export$81087d9b915d4ede)(start, stop, count), precision;
    specifier = (0, $babd3c0ee933dbfb$export$2e2bcd8739ae039)(specifier == null ? ",f" : specifier);
    switch(specifier.type){
        case "s":
            var value = Math.max(Math.abs(start), Math.abs(stop));
            if (specifier.precision == null && !isNaN(precision = (0, $70c7673fef1d9274$export$2e2bcd8739ae039)(step, value))) specifier.precision = precision;
            return (0, $23de77130e6fabd5$export$8d85692a469dde6f)(specifier, value);
        case "":
        case "e":
        case "g":
        case "p":
        case "r":
            if (specifier.precision == null && !isNaN(precision = (0, $36636254076a5075$export$2e2bcd8739ae039)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
            break;
        case "f":
        case "%":
            if (specifier.precision == null && !isNaN(precision = (0, $e542643fa01a3586$export$2e2bcd8739ae039)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
            break;
    }
    return (0, $23de77130e6fabd5$export$d9468344d3651243)(specifier);
}


function $46dd7dd0ac807af9$export$16a5d4b4a61a274d(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
        var d = domain();
        return (0, $13e83a9ae37bfd32$export$2e2bcd8739ae039)(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
        var d = domain();
        return (0, $9de36082a50c02ba$export$2e2bcd8739ae039)(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
        if (count == null) count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop < start) {
            step = start, start = stop, stop = step;
            step = i0, i0 = i1, i1 = step;
        }
        while(maxIter-- > 0){
            step = (0, $13e83a9ae37bfd32$export$bc64d00cc98e7e95)(start, stop, count);
            if (step === prestep) {
                d[i0] = start;
                d[i1] = stop;
                return domain(d);
            } else if (step > 0) {
                start = Math.floor(start / step) * step;
                stop = Math.ceil(stop / step) * step;
            } else if (step < 0) {
                start = Math.ceil(start * step) / step;
                stop = Math.floor(stop * step) / step;
            } else break;
            prestep = step;
        }
        return scale;
    };
    return scale;
}
function $46dd7dd0ac807af9$export$2e2bcd8739ae039() {
    var scale = (0, $d1720577d8838e88$export$2e2bcd8739ae039)();
    scale.copy = function() {
        return (0, $d1720577d8838e88$export$784d13d8ee351f07)(scale, $46dd7dd0ac807af9$export$2e2bcd8739ae039());
    };
    (0, $a672075a618c81db$export$23c7bb9e6558da2a).apply(scale, arguments);
    return $46dd7dd0ac807af9$export$16a5d4b4a61a274d(scale);
}


let $bbdd41951bc984bf$export$c40deacab7e2491c;
(function(FeatureType) {
    FeatureType["Numerical"] = "numerical";
    FeatureType["Categorical"] = "categorical";
    FeatureType["Unused"] = "unused";
})($bbdd41951bc984bf$export$c40deacab7e2491c || ($bbdd41951bc984bf$export$c40deacab7e2491c = {}));
class $bbdd41951bc984bf$export$e26c98255b26aeaf {
    constructor(bins){
        this.bins = bins;
        this.isPiecewiseConstant = true;
    }
    getScale(width) {
        return (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().rangeRound([
            0,
            width
        ]).domain((0, $719ebe1dfe21c6ae$export$2e2bcd8739ae039)(this.bins.map((d)=>d.x)));
    }
    getPrediction(x) {
        for(let b = 0; b < this.bins.length - 1; b++){
            if (this.bins[b].x <= x && x < this.bins[b + 1].x) return this.bins[b].pdep;
        }
        return NaN;
    }
    get pdep() {
        return this.bins.map((b)=>({
                x: b.x,
                y: b.pdep
            }));
    }
    get lowerConf() {
        return this.bins.map((b)=>({
                x: b.x,
                y: b.pdep - b.sd
            }));
    }
    get upperConf() {
        return this.bins.map((b)=>({
                x: b.x,
                y: b.pdep + b.sd
            }));
    }
}
class $bbdd41951bc984bf$export$f9f2b84b3d833d93 {
    constructor(data){
        this.data = data;
        this.isPiecewiseConstant = false;
        this.segments = data.slice(1).map((d, i)=>new $bbdd41951bc984bf$var$LineSegment(data[i].X, data[i].pdep_X, d.X, d.pdep_X));
    }
    get pdep() {
        return this.data.map((d)=>({
                x: d.X,
                y: d.pdep_X
            }));
    }
    get lowerConf() {
        return this.data.map((d)=>({
                x: d.X,
                y: d.confi_l_X
            }));
    }
    get upperConf() {
        return this.data.map((d)=>({
                x: d.X,
                y: d.confi_u_X
            }));
    }
    getScale(width) {
        return (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().clamp(true).rangeRound([
            0,
            width
        ]).domain((0, $719ebe1dfe21c6ae$export$2e2bcd8739ae039)(this.data.map((d)=>d.X)));
    }
    getPrediction(x) {
        const segs = this.segments;
        let left = 0, right = segs.length - 1;
        if (segs[left].tooSmall(x) || segs[right].tooBig(x)) return NaN;
        do {
            const middle = Math.floor(0.5 * (left + right));
            const seg = segs[middle];
            if (seg.containsX(x)) return segs[middle].y(x);
            else if (seg.tooSmall(x)) right = middle - 1;
            else left = middle + 1;
        }while (left <= right && left >= 0 && right < segs.length);
        return NaN;
    }
}
class $bbdd41951bc984bf$export$221d31c781f75234 {
    constructor(data){
        this.data = data;
        this.isPiecewiseConstant = true;
        this.valueMap = data.reduce((map, val)=>{
            if (!map[val.X]) map[val.X.toString()] = val;
            return map;
        }, {});
        this.cleanedData = Object.getOwnPropertyNames(this.valueMap).sort().map((n)=>this.valueMap[n]);
    }
    get pdep() {
        return this.cleanedData.map((d)=>({
                x: d.X,
                y: d.pdep_X
            }));
    }
    get lowerConf() {
        return this.cleanedData.map((d)=>({
                x: d.X,
                y: d.confi_l_X
            }));
    }
    get upperConf() {
        return this.cleanedData.map((d)=>({
                x: d.X,
                y: d.confi_u_X
            }));
    }
    getScale(width) {
        return (0, $1c006476403aa8e7$export$2e2bcd8739ae039)().range([
            0,
            width
        ]).domain(this.cleanedData.map((d)=>d.X)).padding(0.1).align(0.5);
    }
    getPrediction(x) {
        return this.valueMap[x] ? this.valueMap[x].pdep_X : NaN;
    }
    get histogram() {
        return this.data.map((d)=>d.X.toString()).reduce((map, val)=>{
            if (!map[val]) map[val] = 1;
            else map[val]++;
            return map;
        }, {});
    }
}
class $bbdd41951bc984bf$export$6e91cf7616333d5 {
    constructor(name, description, shape, valueType){
        this.name = name;
        this.description = description;
        this.shape = shape;
        this.valueType = valueType;
        const ys = shape.pdep.map((d)=>d.y).concat(shape.lowerConf.map((d)=>d.y)).concat(shape.upperConf.map((d)=>d.y));
        this.minY = (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)(ys);
        this.maxY = (0, $3c6663a447dc3064$export$2e2bcd8739ae039)(ys);
    }
    // get the model's predicted value for an arbitrary value in the feature's domain
    getPrediction(x) {
        if (isNaN(x)) return NaN;
        return this.shape.getPrediction(x);
    }
}
class $bbdd41951bc984bf$var$LineSegment {
    constructor(x0, y0, x1, y1){
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
    }
    tooSmall(x) {
        return x < this.x0;
    }
    tooBig(x) {
        return x > this.x1;
    }
    containsX(x) {
        return this.x0 <= x && x <= this.x1;
    }
    y(x) {
        const frac = (x - this.x0) / (this.x1 - this.x0);
        return this.y0 + frac * (this.y1 - this.y0);
    }
}


class $841120e180d215c5$export$a1edc412be3e1841 {
    instanceStats = {};
    constructor(gamJson, instanceData, descriptions){
        this.gam = gamJson;
        const isGaam = this.gam.name.indexOf("gaam") >= 0;
        this.instanceData = instanceData || [];
        let features = this.gam.features;
        if (!features || features.length === 0) return;
        this.attributes = features.map((feature)=>feature.name);
        if (features[0].influence) features = features.sort((x, y)=>(0, $fd670c0f0109e50d$export$2e2bcd8739ae039)(x.influence.diff, y.influence.diff));
        this.features = features.filter((f)=>f.name !== "intercept").map((feat)=>new (0, $bbdd41951bc984bf$export$6e91cf7616333d5)(feat.name, descriptions ? descriptions[feat.name] : undefined, isGaam ? feat.dtype === "continuous" ? new (0, $bbdd41951bc984bf$export$e26c98255b26aeaf)(feat.shape) : new (0, $bbdd41951bc984bf$export$221d31c781f75234)(feat.shape.map((b)=>({
                    X: b.x,
                    pdep_X: b.pdep,
                    confi_l_X: b.pdep - b.sd,
                    confi_u_X: b.pdep + b.sd
                }))) : feat.dtype === "numerical" ? new (0, $bbdd41951bc984bf$export$f9f2b84b3d833d93)(feat.data) : new (0, $bbdd41951bc984bf$export$221d31c781f75234)(feat.data), feat.dtype === "numerical" || feat.dtype === "continuous" ? (0, $bbdd41951bc984bf$export$c40deacab7e2491c).Numerical : feat.dtype === "unused" ? (0, $bbdd41951bc984bf$export$c40deacab7e2491c).Unused : (0, $bbdd41951bc984bf$export$c40deacab7e2491c).Categorical));
        this.globalMinY = (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)(this.features.map((f)=>f.minY));
        this.globalMaxY = (0, $3c6663a447dc3064$export$2e2bcd8739ae039)(this.features.map((f)=>f.maxY));
        this.instances = this.instanceData.map((inst)=>{
            const row = {
                id: inst.id,
                y: inst.y,
                prediction: this.getPrediction(inst)
            };
            inst.data.forEach((d)=>row[d.name] = d.X);
            return row;
        });
        this.calculateStats();
    }
    get name() {
        return this.gam.name;
    }
    get rms() {
        return this.gam.rms;
    }
    get intercept() {
        const intercept = this.gam.features.find((feature)=>feature.name === "intercept");
        return intercept ? intercept.value : 0;
    }
    getPrediction(instance) {
        return instance.data.reduce((sum, item)=>sum + item.pdep, this.intercept);
    }
    getNeighbors(instance, vectorSpaceString, numOfNeighbors = 16) {
        const normalize = (instance)=>instance.data.map((data)=>{
                const stats = this.instanceStats[data.name];
                if (!stats) return 0; // WHY DOES THIS HAPPEN? :angry:
                return (data.X - stats.mean) / stats.max;
            });
        const pdep = (instance)=>instance.data.map((data)=>data.pdep);
        const euclidean = (vec1, vec2)=>Math.sqrt($841120e180d215c5$var$zip(vec1, vec2).reduce((sum, [x, y])=>sum + Math.pow(x - y, 2), 0));
        const measures = vectorSpaceString === "feature" ? normalize : pdep;
        const selectedInstanceArray = measures(instance);
        return this.instanceData.slice().filter(({ id: id  })=>id !== instance.id).map((inst)=>({
                ...inst,
                distance: euclidean(selectedInstanceArray, measures(inst))
            })).sort((x, y)=>(0, $8afa7834ebc28caa$export$2e2bcd8739ae039)(x.distance, y.distance)).slice(0, numOfNeighbors);
    }
    gethistogram(featureName) {
        return this.instances.map((d)=>d[featureName]).reduce((map, val)=>{
            if (!map[val]) map[val] = 1;
            else map[val]++;
            return map;
        }, {});
    }
    calculateStats() {
        const instances = this.instanceData;
        if (!instances || !instances.length || !instances[0].data) return;
        const features = this.gam.features;
        for(let f = 0; f < features.length - 1; f++)this.instanceStats[features[f].name] = {
            max: (0, $3c6663a447dc3064$export$2e2bcd8739ae039)(instances, (d)=>d.data[f].X),
            min: (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)(instances, (d)=>d.data[f].X),
            mean: (0, $de5e85a4aa287bbd$export$2e2bcd8739ae039)(instances, (d)=>d.data[f].X)
        };
    }
    getType(featureName) {
        const theFeature = this.features.find((afeat)=>afeat.name == featureName);
        if (theFeature != null) return theFeature.valueType;
        else return null;
    }
}
class $841120e180d215c5$export$986181c251d527c3 {
    constructor(){
        this.datasets = [];
        this.datasetName = undefined;
        this.ready = false // use this lightweigh value to signal when model is ready
        ;
        // view state
        this.sidebarOpen = false;
        this.showHistograms = true;
        this.featureSpace = "feature";
        this.featureVisible = {};
        this.hoverFeature = undefined;
        this.normalizeAxes = true;
        this.focusedFeature = undefined;
    }
    // dataset state
    model = undefined;
    loadManifest(manifestUrl, dataDir, defaultDataset) {
        this.dataDir = dataDir;
        (0, $18783bca1921ec86$export$2e2bcd8739ae039).get(manifestUrl).then((resp)=>{
            const datasetResponse = resp.data;
            this.datasets = datasetResponse.datasets;
            this.loadDataset(defaultDataset || datasetResponse.default);
        });
    }
    get datasetNames() {
        return this.datasets.map((ds)=>ds.name);
    }
    isFeatureVisible(featureName) {
        return this.featureVisible[featureName];
    }
    setFeatureVisibility(featureName, visible) {
        this.featureVisible[featureName] = visible;
    }
    toggleFeatureVisibility(featureName) {
        this.featureVisible[featureName] = !this.featureVisible[featureName];
    }
    toggleAllFeatureVisbility(onOff) {
        for(const fname in this.featureVisible)this.featureVisible[fname] = onOff;
    }
    loadDataset(datasetName) {
        let dataset = this.datasets.find((ds)=>ds.name === datasetName);
        if (!dataset) //console.log("BAD DATASET " + datasetName);
        dataset = this.datasets[0];
        this.datasetName = dataset.name;
        this.ready = false;
        this.model = undefined;
        const fetches = [
            dataset.model,
            dataset.instances,
            dataset.descriptions
        ].map((url)=>{
            if (url) {
                //look for parcel'ed data if local
                const a = document.querySelector(`a.gamut-app-content-bundled#${url.replace(/\/|\./g, "_")}`);
                if (a) url = a.href;
                else //look for location of data
                url = `${this.dataDir}${url}`;
                return (0, $18783bca1921ec86$export$2e2bcd8739ae039).get(url);
            } else return Promise.resolve(undefined);
        });
        (0, $18783bca1921ec86$export$2e2bcd8739ae039).all(fetches).then((responses)=>{
            (0, $11a86e62e4f971e6$export$f443e47852576b4f)(()=>{
                const gamJson = $841120e180d215c5$var$dataFrom(responses[0]);
                if (!gamJson) {
                    this.ready = true;
                    return;
                }
                this.createModel(gamJson, $841120e180d215c5$var$dataFrom(responses[1]), $841120e180d215c5$var$dataFrom(responses[2]));
            });
        });
    }
    createModel(gamJson, instanceData, descriptions) {
        this.model = new $841120e180d215c5$export$a1edc412be3e1841(gamJson, instanceData, descriptions);
        if (this.model.instanceData.length) this.updateSelection(this.model.instanceData[0].id);
        // Show all features by default.
        this.model.features.filter((f)=>f.name !== "intercept").forEach((f)=>this.featureVisible[f.name] = true);
        this.ready = true;
    }
    updateSelection(id) {
        const item = this.model.instanceData.find((d)=>d.id === id);
        if (item) {
            this.selectedInstance = item;
            this.neighborsOfSelection = this.model.getNeighbors(item, this.featureSpace);
            this.selectedInstance2 = null;
        }
    }
    updateSelection2(id) {
        const item = this.model.instanceData.find((d)=>d.id === id);
        if (item) this.selectedInstance2 = item;
    }
    setFeatureSpace(value) {
        if (value !== "feature" && value !== "gam") throw "bad feature space";
        this.featureSpace = value;
        this.updateSelection(this.selectedInstance.id);
    }
    setFocusedFeature(value) {
        this.focusedFeature = value;
    }
}
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "datasets", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "datasetName", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "ready", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "selectedInstance", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "selectedInstance2", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "neighborsOfSelection", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "sidebarOpen", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "showHistograms", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "featureSpace", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "featureVisible", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "hoverFeature", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "normalizeAxes", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $841120e180d215c5$export$986181c251d527c3.prototype, "focusedFeature", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$31eb53bd5b582a97)
], $841120e180d215c5$export$986181c251d527c3.prototype, "loadManifest", null);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$2983e091f1a1e8e2)
], $841120e180d215c5$export$986181c251d527c3.prototype, "datasetNames", null);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$31eb53bd5b582a97)
], $841120e180d215c5$export$986181c251d527c3.prototype, "loadDataset", null);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$31eb53bd5b582a97)
], $841120e180d215c5$export$986181c251d527c3.prototype, "createModel", null);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$31eb53bd5b582a97)
], $841120e180d215c5$export$986181c251d527c3.prototype, "updateSelection", null);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$31eb53bd5b582a97)
], $841120e180d215c5$export$986181c251d527c3.prototype, "updateSelection2", null);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$31eb53bd5b582a97)
], $841120e180d215c5$export$986181c251d527c3.prototype, "setFeatureSpace", null);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$31eb53bd5b582a97)
], $841120e180d215c5$export$986181c251d527c3.prototype, "setFocusedFeature", null);
function $841120e180d215c5$var$zip(vec1, vec2) {
    return vec1.map((x, i)=>[
            x,
            vec2[i]
        ]);
}
function $841120e180d215c5$var$dataFrom(resp) {
    return resp ? resp.data : undefined;
}
const $841120e180d215c5$export$a510af025ac2bbc1 = new $841120e180d215c5$export$986181c251d527c3();
if (location.search.substring(1) === "embed") window.addEventListener("message", (e)=>{
    if (e && e.origin !== "https://microsoft.github.io" && e.data) {
        const { gamJson: gamJson , instanceData: instanceData , descriptions: descriptions  } = e.data;
        if (gamJson && instanceData) $841120e180d215c5$export$a510af025ac2bbc1.createModel(gamJson, instanceData, descriptions);
    }
});
else {
    const dataDirAnchor = document.querySelector("a.gamut-app-content#datadir");
    const dataDir = dataDirAnchor ? dataDirAnchor.href : "";
    const manifestAnchor = document.querySelector("a.gamut-app-content-bundled#manifest");
    const manifestUrl = manifestAnchor ? manifestAnchor.href : `${dataDir}-manifest.json`;
    $841120e180d215c5$export$a510af025ac2bbc1.loadManifest(manifestUrl, dataDir);
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");

var $gqsD7 = parcelRequire("gqsD7");

var $kqze3 = parcelRequire("kqze3");

var $29rXr = parcelRequire("29rXr");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");


var $2LmR0 = parcelRequire("2LmR0");
var $1d208f46a78f549a$export$9dd6ff9ea0189349 = function styles(theme) {
    var elevations = {};
    theme.shadows.forEach(function(shadow, index) {
        elevations["elevation".concat(index)] = {
            boxShadow: shadow
        };
    });
    return (0, $29rXr.default)({
        /* Styles applied to the root element. */ root: {
            backgroundColor: theme.palette.background.paper,
            color: theme.palette.text.primary,
            transition: theme.transitions.create("box-shadow")
        },
        /* Styles applied to the root element if `square={false}`. */ rounded: {
            borderRadius: theme.shape.borderRadius
        },
        /* Styles applied to the root element if `variant="outlined"`. */ outlined: {
            border: "1px solid ".concat(theme.palette.divider)
        }
    }, elevations);
};
var $1d208f46a78f549a$var$Paper = /*#__PURE__*/ $aaLBe.forwardRef(function Paper(props, ref) {
    var classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _props$square = props.square, square = _props$square === void 0 ? false : _props$square, _props$elevation = props.elevation, elevation = _props$elevation === void 0 ? 1 : _props$elevation, _props$variant = props.variant, variant = _props$variant === void 0 ? "elevation" : _props$variant, other = (0, $kqze3.default)(props, [
        "classes",
        "className",
        "component",
        "square",
        "elevation",
        "variant"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, variant === "outlined" ? classes.outlined : classes["elevation".concat(elevation)], !square && classes.rounded),
        ref: ref
    }, other));
});
var $1d208f46a78f549a$export$2e2bcd8739ae039 = (0, $2LmR0.default)($1d208f46a78f549a$export$9dd6ff9ea0189349, {
    name: "MuiPaper"
})($1d208f46a78f549a$var$Paper);


var $918dca7716ce40a7$export$9dd6ff9ea0189349 = function styles(theme) {
    var backgroundColorDefault = theme.palette.type === "light" ? theme.palette.grey[100] : theme.palette.grey[900];
    return {
        /* Styles applied to the root element. */ root: {
            display: "flex",
            flexDirection: "column",
            width: "100%",
            boxSizing: "border-box",
            // Prevent padding issue with the Modal and fixed positioned AppBar.
            zIndex: theme.zIndex.appBar,
            flexShrink: 0
        },
        /* Styles applied to the root element if `position="fixed"`. */ positionFixed: {
            position: "fixed",
            top: 0,
            left: "auto",
            right: 0,
            "@media print": {
                // Prevent the app bar to be visible on each printed page.
                position: "absolute"
            }
        },
        /* Styles applied to the root element if `position="absolute"`. */ positionAbsolute: {
            position: "absolute",
            top: 0,
            left: "auto",
            right: 0
        },
        /* Styles applied to the root element if `position="sticky"`. */ positionSticky: {
            // ⚠️ sticky is not supported by IE 11.
            position: "sticky",
            top: 0,
            left: "auto",
            right: 0
        },
        /* Styles applied to the root element if `position="static"`. */ positionStatic: {
            position: "static"
        },
        /* Styles applied to the root element if `position="relative"`. */ positionRelative: {
            position: "relative"
        },
        /* Styles applied to the root element if `color="default"`. */ colorDefault: {
            backgroundColor: backgroundColorDefault,
            color: theme.palette.getContrastText(backgroundColorDefault)
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            backgroundColor: theme.palette.primary.main,
            color: theme.palette.primary.contrastText
        },
        /* Styles applied to the root element if `color="secondary"`. */ colorSecondary: {
            backgroundColor: theme.palette.secondary.main,
            color: theme.palette.secondary.contrastText
        },
        /* Styles applied to the root element if `color="inherit"`. */ colorInherit: {
            color: "inherit"
        },
        /* Styles applied to the root element if `color="transparent"`. */ colorTransparent: {
            backgroundColor: "transparent",
            color: "inherit"
        }
    };
};
var $918dca7716ce40a7$var$AppBar = /*#__PURE__*/ $aaLBe.forwardRef(function AppBar(props, ref) {
    var classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "primary" : _props$color, _props$position = props.position, position = _props$position === void 0 ? "fixed" : _props$position, other = (0, $kqze3.default)(props, [
        "classes",
        "className",
        "color",
        "position"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement((0, $1d208f46a78f549a$export$2e2bcd8739ae039), (0, $29rXr.default)({
        square: true,
        component: "header",
        elevation: 4,
        className: (0, $h0TGs.default)(classes.root, classes["position".concat((0, $gqsD7.default)(position))], classes["color".concat((0, $gqsD7.default)(color))], className, position === "fixed" && "mui-fixed"),
        ref: ref
    }, other));
});
var $918dca7716ce40a7$export$2e2bcd8739ae039 = (0, $2LmR0.default)($918dca7716ce40a7$export$9dd6ff9ea0189349, {
    name: "MuiAppBar"
})($918dca7716ce40a7$var$AppBar);



var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $gzGrO = parcelRequire("gzGrO");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");
var $125e0e14f9b60abb$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            position: "relative",
            display: "flex",
            alignItems: "center"
        },
        /* Styles applied to the root element if `disableGutters={false}`. */ gutters: (0, $gzGrO.default)({
            paddingLeft: theme.spacing(2),
            paddingRight: theme.spacing(2)
        }, theme.breakpoints.up("sm"), {
            paddingLeft: theme.spacing(3),
            paddingRight: theme.spacing(3)
        }),
        /* Styles applied to the root element if `variant="regular"`. */ regular: theme.mixins.toolbar,
        /* Styles applied to the root element if `variant="dense"`. */ dense: {
            minHeight: 48
        }
    };
};
var $125e0e14f9b60abb$var$Toolbar = /*#__PURE__*/ $aaLBe.forwardRef(function Toolbar(props, ref) {
    var classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _props$disableGutters = props.disableGutters, disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters, _props$variant = props.variant, variant = _props$variant === void 0 ? "regular" : _props$variant, other = (0, $kqze3.default)(props, [
        "classes",
        "className",
        "component",
        "disableGutters",
        "variant"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, classes[variant], className, !disableGutters && classes.gutters),
        ref: ref
    }, other));
});
var $125e0e14f9b60abb$export$2e2bcd8739ae039 = (0, $2LmR0.default)($125e0e14f9b60abb$export$9dd6ff9ea0189349, {
    name: "MuiToolbar"
})($125e0e14f9b60abb$var$Toolbar);



var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");

var $gqsD7 = parcelRequire("gqsD7");
var $372cadd18a544d36$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            margin: 0
        },
        /* Styles applied to the root element if `variant="body2"`. */ body2: theme.typography.body2,
        /* Styles applied to the root element if `variant="body1"`. */ body1: theme.typography.body1,
        /* Styles applied to the root element if `variant="caption"`. */ caption: theme.typography.caption,
        /* Styles applied to the root element if `variant="button"`. */ button: theme.typography.button,
        /* Styles applied to the root element if `variant="h1"`. */ h1: theme.typography.h1,
        /* Styles applied to the root element if `variant="h2"`. */ h2: theme.typography.h2,
        /* Styles applied to the root element if `variant="h3"`. */ h3: theme.typography.h3,
        /* Styles applied to the root element if `variant="h4"`. */ h4: theme.typography.h4,
        /* Styles applied to the root element if `variant="h5"`. */ h5: theme.typography.h5,
        /* Styles applied to the root element if `variant="h6"`. */ h6: theme.typography.h6,
        /* Styles applied to the root element if `variant="subtitle1"`. */ subtitle1: theme.typography.subtitle1,
        /* Styles applied to the root element if `variant="subtitle2"`. */ subtitle2: theme.typography.subtitle2,
        /* Styles applied to the root element if `variant="overline"`. */ overline: theme.typography.overline,
        /* Styles applied to the root element if `variant="srOnly"`. Only accessible to screen readers. */ srOnly: {
            position: "absolute",
            height: 1,
            width: 1,
            overflow: "hidden"
        },
        /* Styles applied to the root element if `align="left"`. */ alignLeft: {
            textAlign: "left"
        },
        /* Styles applied to the root element if `align="center"`. */ alignCenter: {
            textAlign: "center"
        },
        /* Styles applied to the root element if `align="right"`. */ alignRight: {
            textAlign: "right"
        },
        /* Styles applied to the root element if `align="justify"`. */ alignJustify: {
            textAlign: "justify"
        },
        /* Styles applied to the root element if `nowrap={true}`. */ noWrap: {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
        },
        /* Styles applied to the root element if `gutterBottom={true}`. */ gutterBottom: {
            marginBottom: "0.35em"
        },
        /* Styles applied to the root element if `paragraph={true}`. */ paragraph: {
            marginBottom: 16
        },
        /* Styles applied to the root element if `color="inherit"`. */ colorInherit: {
            color: "inherit"
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            color: theme.palette.primary.main
        },
        /* Styles applied to the root element if `color="secondary"`. */ colorSecondary: {
            color: theme.palette.secondary.main
        },
        /* Styles applied to the root element if `color="textPrimary"`. */ colorTextPrimary: {
            color: theme.palette.text.primary
        },
        /* Styles applied to the root element if `color="textSecondary"`. */ colorTextSecondary: {
            color: theme.palette.text.secondary
        },
        /* Styles applied to the root element if `color="error"`. */ colorError: {
            color: theme.palette.error.main
        },
        /* Styles applied to the root element if `display="inline"`. */ displayInline: {
            display: "inline"
        },
        /* Styles applied to the root element if `display="block"`. */ displayBlock: {
            display: "block"
        }
    };
};
var $372cadd18a544d36$var$defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p"
};
var $372cadd18a544d36$var$Typography = /*#__PURE__*/ $aaLBe.forwardRef(function Typography(props, ref) {
    var _props$align = props.align, align = _props$align === void 0 ? "inherit" : _props$align, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "initial" : _props$color, component = props.component, _props$display = props.display, display = _props$display === void 0 ? "initial" : _props$display, _props$gutterBottom = props.gutterBottom, gutterBottom = _props$gutterBottom === void 0 ? false : _props$gutterBottom, _props$noWrap = props.noWrap, noWrap = _props$noWrap === void 0 ? false : _props$noWrap, _props$paragraph = props.paragraph, paragraph = _props$paragraph === void 0 ? false : _props$paragraph, _props$variant = props.variant, variant = _props$variant === void 0 ? "body1" : _props$variant, _props$variantMapping = props.variantMapping, variantMapping = _props$variantMapping === void 0 ? $372cadd18a544d36$var$defaultVariantMapping : _props$variantMapping, other = (0, $kqze3.default)(props, [
        "align",
        "classes",
        "className",
        "color",
        "component",
        "display",
        "gutterBottom",
        "noWrap",
        "paragraph",
        "variant",
        "variantMapping"
    ]);
    var Component = component || (paragraph ? "p" : variantMapping[variant] || $372cadd18a544d36$var$defaultVariantMapping[variant]) || "span";
    return /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, variant !== "inherit" && classes[variant], color !== "initial" && classes["color".concat((0, $gqsD7.default)(color))], noWrap && classes.noWrap, gutterBottom && classes.gutterBottom, paragraph && classes.paragraph, align !== "inherit" && classes["align".concat((0, $gqsD7.default)(align))], display !== "initial" && classes["display".concat((0, $gqsD7.default)(display))]),
        ref: ref
    }, other));
});
var $372cadd18a544d36$export$2e2bcd8739ae039 = (0, $2LmR0.default)($372cadd18a544d36$export$9dd6ff9ea0189349, {
    name: "MuiTypography"
})($372cadd18a544d36$var$Typography);


var $39d00819b5e2256c$exports = {};
"use strict";
var $69f4ded615f6c2c8$exports = {};
function $69f4ded615f6c2c8$var$_interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
$69f4ded615f6c2c8$exports = $69f4ded615f6c2c8$var$_interopRequireDefault, $69f4ded615f6c2c8$exports.__esModule = true, $69f4ded615f6c2c8$exports["default"] = $69f4ded615f6c2c8$exports;


var $80a9c2f6d1811a06$exports = {};
var $9ec40e8a6809e691$exports = {};
function $9ec40e8a6809e691$var$_typeof(obj) {
    "@babel/helpers - typeof";
    return $9ec40e8a6809e691$exports = $9ec40e8a6809e691$var$_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, $9ec40e8a6809e691$exports.__esModule = true, $9ec40e8a6809e691$exports["default"] = $9ec40e8a6809e691$exports, $9ec40e8a6809e691$var$_typeof(obj);
}
$9ec40e8a6809e691$exports = $9ec40e8a6809e691$var$_typeof, $9ec40e8a6809e691$exports.__esModule = true, $9ec40e8a6809e691$exports["default"] = $9ec40e8a6809e691$exports;


var $80a9c2f6d1811a06$var$_typeof = $9ec40e8a6809e691$exports.default;
function $80a9c2f6d1811a06$var$_getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return ($80a9c2f6d1811a06$var$_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function $80a9c2f6d1811a06$var$_interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;
    if (obj === null || $80a9c2f6d1811a06$var$_typeof(obj) !== "object" && typeof obj !== "function") return {
        "default": obj
    };
    var cache = $80a9c2f6d1811a06$var$_getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj)if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
        else newObj[key] = obj[key];
    }
    newObj["default"] = obj;
    if (cache) cache.set(obj, newObj);
    return newObj;
}
$80a9c2f6d1811a06$exports = $80a9c2f6d1811a06$var$_interopRequireWildcard, $80a9c2f6d1811a06$exports.__esModule = true, $80a9c2f6d1811a06$exports["default"] = $80a9c2f6d1811a06$exports;


Object.defineProperty($39d00819b5e2256c$exports, "__esModule", {
    value: true
});
$39d00819b5e2256c$exports.default = void 0;

var $39d00819b5e2256c$var$React = $80a9c2f6d1811a06$exports((parcelRequire("aaLBe")));

var $39d00819b5e2256c$var$_createSvgIcon = $69f4ded615f6c2c8$exports((parcelRequire("jxmMp")));
var $39d00819b5e2256c$var$_default = (0, $39d00819b5e2256c$var$_createSvgIcon.default)(/*#__PURE__*/ $39d00819b5e2256c$var$React.createElement("path", {
    d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
}), "Menu");
$39d00819b5e2256c$exports.default = $39d00819b5e2256c$var$_default;





var $aaLBe = parcelRequire("aaLBe");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


var $aaLBe = parcelRequire("aaLBe");
/**
 * The unique id is used for unique hashes.
 */ let $bb5666e07862b1ef$var$uniqueId = 0;
/**
 * Quick dictionary lookup for unit-less numbers.
 */ const $bb5666e07862b1ef$var$CSS_NUMBER = Object.create(null);
/**
 * CSS properties that are valid unit-less numbers.
 *
 * Ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/shared/CSSProperty.js
 */ const $bb5666e07862b1ef$var$CSS_NUMBER_KEYS = [
    "animation-iteration-count",
    "border-image-outset",
    "border-image-slice",
    "border-image-width",
    "box-flex",
    "box-flex-group",
    "box-ordinal-group",
    "column-count",
    "columns",
    "counter-increment",
    "counter-reset",
    "flex",
    "flex-grow",
    "flex-positive",
    "flex-shrink",
    "flex-negative",
    "flex-order",
    "font-weight",
    "grid-area",
    "grid-column",
    "grid-column-end",
    "grid-column-span",
    "grid-column-start",
    "grid-row",
    "grid-row-end",
    "grid-row-span",
    "grid-row-start",
    "line-clamp",
    "line-height",
    "opacity",
    "order",
    "orphans",
    "tab-size",
    "widows",
    "z-index",
    "zoom",
    // SVG properties.
    "fill-opacity",
    "flood-opacity",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width"
];
// Add vendor prefixes to all unit-less properties.
for (const property of $bb5666e07862b1ef$var$CSS_NUMBER_KEYS)for (const prefix of [
    "-webkit-",
    "-ms-",
    "-moz-",
    "-o-",
    ""
])$bb5666e07862b1ef$var$CSS_NUMBER[prefix + property] = true;
/**
 * Escape a CSS class name.
 */ function $bb5666e07862b1ef$var$escape(str) {
    return str.replace(/[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g, "\\$&");
}
/**
 * Transform a JavaScript property into a CSS property.
 */ function $bb5666e07862b1ef$var$hyphenate(propertyName) {
    return propertyName.replace(/[A-Z]/g, (m)=>`-${m.toLowerCase()}`).replace(/^ms-/, "-ms-"); // Internet Explorer vendor prefix.
}
/**
 * Generate a hash value from a string.
 */ function $bb5666e07862b1ef$var$stringHash(str) {
    let value = 5381;
    let len = str.length;
    while(len--)value = value * 33 ^ str.charCodeAt(len);
    return (value >>> 0).toString(36);
}
/**
 * Transform a style string to a CSS string.
 */ function $bb5666e07862b1ef$var$styleToString(key, value) {
    if (value && typeof value === "number" && !$bb5666e07862b1ef$var$CSS_NUMBER[key]) return `${key}:${value}px`;
    return `${key}:${value}`;
}
/**
 * Sort an array of tuples by first value.
 */ function $bb5666e07862b1ef$var$sortTuples(value) {
    return value.sort((a, b)=>a[0] > b[0] ? 1 : -1);
}
/**
 * Categorize user styles.
 */ function $bb5666e07862b1ef$var$parseStyles(styles, hasNestedStyles) {
    const properties = [];
    const nestedStyles = [];
    // Sort keys before adding to styles.
    for (const key of Object.keys(styles)){
        const name = key.trim();
        const value = styles[key];
        if (name.charCodeAt(0) !== 36 /* $ */  && value != null) {
            if (typeof value === "object" && !Array.isArray(value)) nestedStyles.push([
                name,
                value
            ]);
            else properties.push([
                $bb5666e07862b1ef$var$hyphenate(name),
                value
            ]);
        }
    }
    return {
        style: $bb5666e07862b1ef$var$stringifyProperties($bb5666e07862b1ef$var$sortTuples(properties)),
        nested: hasNestedStyles ? nestedStyles : $bb5666e07862b1ef$var$sortTuples(nestedStyles),
        isUnique: !!styles.$unique
    };
}
/**
 * Stringify an array of property tuples.
 */ function $bb5666e07862b1ef$var$stringifyProperties(properties) {
    return properties.map(([name, value])=>{
        if (!Array.isArray(value)) return $bb5666e07862b1ef$var$styleToString(name, value);
        return value.map((x)=>$bb5666e07862b1ef$var$styleToString(name, x)).join(";");
    }).join(";");
}
/**
 * Interpolate CSS selectors.
 */ function $bb5666e07862b1ef$var$interpolate(selector, parent) {
    if (selector.indexOf("&") === -1) return `${parent} ${selector}`;
    return selector.replace(/&/g, parent);
}
/**
 * Recursive loop building styles with deferred selectors.
 */ function $bb5666e07862b1ef$var$stylize(selector, styles, rulesList, stylesList, parent) {
    const { style: style , nested: nested , isUnique: isUnique  } = $bb5666e07862b1ef$var$parseStyles(styles, selector !== "");
    let pid = style;
    if (selector.charCodeAt(0) === 64 /* @ */ ) {
        const child = {
            selector: selector,
            styles: [],
            rules: [],
            style: parent ? "" : style
        };
        rulesList.push(child);
        // Nested styles support (e.g. `.foo > @media > .bar`).
        if (style && parent) child.styles.push({
            selector: parent,
            style: style,
            isUnique: isUnique
        });
        for (const [name, value] of nested)pid += name + $bb5666e07862b1ef$var$stylize(name, value, child.rules, child.styles, parent);
    } else {
        const key = parent ? $bb5666e07862b1ef$var$interpolate(selector, parent) : selector;
        if (style) stylesList.push({
            selector: key,
            style: style,
            isUnique: isUnique
        });
        for (const [name, value] of nested)pid += name + $bb5666e07862b1ef$var$stylize(name, value, rulesList, stylesList, key);
    }
    return pid;
}
/**
 * Transform `stylize` tree into style objects.
 */ function $bb5666e07862b1ef$var$composeStylize(cache, pid, rulesList, stylesList, className, isStyle) {
    for (const { selector: selector , style: style , isUnique: isUnique  } of stylesList){
        const key = isStyle ? $bb5666e07862b1ef$var$interpolate(selector, className) : selector;
        const id = isUnique ? `u\0${(++$bb5666e07862b1ef$var$uniqueId).toString(36)}` : `s\0${pid}\0${style}`;
        const item = new $bb5666e07862b1ef$export$d9e45bc13d335801(style, id);
        item.add(new $bb5666e07862b1ef$export$d15f4cd5286f9b1e(key, `k\0${pid}\0${key}`));
        cache.add(item);
    }
    for (const { selector: selector , style: style , rules: rules , styles: styles  } of rulesList){
        const item = new $bb5666e07862b1ef$export$f1ff2a90c38ff669(selector, style, `r\0${pid}\0${selector}\0${style}`);
        $bb5666e07862b1ef$var$composeStylize(item, pid, rules, styles, className, isStyle);
        cache.add(item);
    }
}
/**
 * Cache to list to styles.
 */ function $bb5666e07862b1ef$var$join(arr) {
    let res = "";
    for(let i = 0; i < arr.length; i++)res += arr[i];
    return res;
}
/**
 * Noop changes.
 */ const $bb5666e07862b1ef$var$noopChanges = {
    add: ()=>undefined,
    change: ()=>undefined,
    remove: ()=>undefined
};
class $bb5666e07862b1ef$export$94affb487e701bf2 {
    constructor(changes = $bb5666e07862b1ef$var$noopChanges){
        this.changes = changes;
        this.sheet = [];
        this.changeId = 0;
        this._keys = [];
        this._children = Object.create(null);
        this._counters = Object.create(null);
    }
    add(style) {
        const count = this._counters[style.id] || 0;
        const item = this._children[style.id] || style.clone();
        this._counters[style.id] = count + 1;
        if (count === 0) {
            this._children[item.id] = item;
            this._keys.push(item.id);
            this.sheet.push(item.getStyles());
            this.changeId++;
            this.changes.add(item, this._keys.length - 1);
        } else if (item instanceof $bb5666e07862b1ef$export$94affb487e701bf2 && style instanceof $bb5666e07862b1ef$export$94affb487e701bf2) {
            const curIndex = this._keys.indexOf(style.id);
            const prevItemChangeId = item.changeId;
            item.merge(style);
            if (item.changeId !== prevItemChangeId) {
                this.sheet.splice(curIndex, 1, item.getStyles());
                this.changeId++;
                this.changes.change(item, curIndex, curIndex);
            }
        }
    }
    remove(style) {
        const count = this._counters[style.id];
        if (count) {
            this._counters[style.id] = count - 1;
            const item = this._children[style.id];
            const index = this._keys.indexOf(item.id);
            if (count === 1) {
                delete this._counters[style.id];
                delete this._children[style.id];
                this._keys.splice(index, 1);
                this.sheet.splice(index, 1);
                this.changeId++;
                this.changes.remove(item, index);
            } else if (item instanceof $bb5666e07862b1ef$export$94affb487e701bf2 && style instanceof $bb5666e07862b1ef$export$94affb487e701bf2) {
                const prevChangeId = item.changeId;
                item.unmerge(style);
                if (item.changeId !== prevChangeId) {
                    this.sheet.splice(index, 1, item.getStyles());
                    this.changeId++;
                    this.changes.change(item, index, index);
                }
            }
        }
    }
    values() {
        return this._keys.map((key)=>this._children[key]);
    }
    merge(cache) {
        for (const item of cache.values())this.add(item);
        return this;
    }
    unmerge(cache) {
        for (const item of cache.values())this.remove(item);
        return this;
    }
    clone() {
        return new $bb5666e07862b1ef$export$94affb487e701bf2().merge(this);
    }
}
class $bb5666e07862b1ef$export$d15f4cd5286f9b1e {
    constructor(selector, id){
        this.selector = selector;
        this.id = id;
    }
    getStyles() {
        return this.selector;
    }
    clone() {
        return this;
    }
}
class $bb5666e07862b1ef$export$d9e45bc13d335801 extends $bb5666e07862b1ef$export$94affb487e701bf2 {
    constructor(style, id){
        super();
        this.style = style;
        this.id = id;
    }
    getStyles() {
        return `${this.sheet.join(",")}{${this.style}}`;
    }
    clone() {
        return new $bb5666e07862b1ef$export$d9e45bc13d335801(this.style, this.id).merge(this);
    }
}
class $bb5666e07862b1ef$export$f1ff2a90c38ff669 extends $bb5666e07862b1ef$export$94affb487e701bf2 {
    constructor(rule, style, id){
        super();
        this.rule = rule;
        this.style = style;
        this.id = id;
    }
    getStyles() {
        return `${this.rule}{${this.style}${$bb5666e07862b1ef$var$join(this.sheet)}}`;
    }
    clone() {
        return new $bb5666e07862b1ef$export$f1ff2a90c38ff669(this.rule, this.style, this.id).merge(this);
    }
}
function $bb5666e07862b1ef$var$key(pid, styles) {
    const key = `f${$bb5666e07862b1ef$var$stringHash(pid)}`;
    return key;
}
class $bb5666e07862b1ef$export$cb2cd1474b7aa70 extends $bb5666e07862b1ef$export$94affb487e701bf2 {
    constructor(id, changes){
        super(changes);
        this.id = id;
    }
    registerStyle(styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = $bb5666e07862b1ef$var$stylize("&", styles, rulesList, stylesList);
        const id = $bb5666e07862b1ef$var$key(pid, styles);
        const selector = `.${id}`;
        $bb5666e07862b1ef$var$composeStylize(this, pid, rulesList, stylesList, selector, true);
        return id;
    }
    registerKeyframes(keyframes) {
        return this.registerHashRule("@keyframes", keyframes);
    }
    registerHashRule(prefix, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = $bb5666e07862b1ef$var$stylize("", styles, rulesList, stylesList);
        const id = $bb5666e07862b1ef$var$key(pid, styles);
        const selector = `${prefix} ${id}`;
        const rule = new $bb5666e07862b1ef$export$f1ff2a90c38ff669(selector, "", `h\0${pid}\0${prefix}`);
        $bb5666e07862b1ef$var$composeStylize(rule, pid, rulesList, stylesList, "", false);
        this.add(rule);
        return id;
    }
    registerRule(rule, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = $bb5666e07862b1ef$var$stylize(rule, styles, rulesList, stylesList);
        $bb5666e07862b1ef$var$composeStylize(this, pid, rulesList, stylesList, "", false);
    }
    registerCss(styles) {
        return this.registerRule("", styles);
    }
    getStyles() {
        return $bb5666e07862b1ef$var$join(this.sheet);
    }
    clone() {
        return new $bb5666e07862b1ef$export$cb2cd1474b7aa70(this.id, this.changes).merge(this);
    }
}
function $bb5666e07862b1ef$export$185802fd694ee1f5(changes) {
    return new $bb5666e07862b1ef$export$cb2cd1474b7aa70(`f${(++$bb5666e07862b1ef$var$uniqueId).toString(36)}`, changes);
}


/**
 * We need to do the following to *our* objects before passing to freestyle:
 * - For any `$nest` directive move up to FreeStyle style nesting
 * - For any `$unique` directive map to FreeStyle Unique
 * - For any `$debugName` directive return the debug name
 */ function $951acce1b360d836$export$6e907e5026f5a8f3(object) {
    /** The final result we will return */ var styles = {};
    for(var key in object){
        /** Grab the value upfront */ var val = object[key];
        /** TypeStyle configuration options */ if (key === "$nest") {
            var nested = val;
            for(var selector in nested){
                var subproperties = nested[selector];
                styles[selector] = $951acce1b360d836$export$6e907e5026f5a8f3(subproperties);
            }
        } else if (key === "$debugName") styles.$displayName = val;
        else styles[key] = val;
    }
    return styles;
}
function $951acce1b360d836$export$ad639ef713faf00d(frames) {
    var result = {};
    for(var offset in frames)if (offset !== "$debugName") result[offset] = frames[offset];
    if (frames.$debugName) result.$displayName = frames.$debugName;
    return result;
}


/** Raf for node + browser */ var $924c9c9699fb56e5$export$27f233d61a9e2fa4 = typeof requestAnimationFrame === "undefined" ? function(cb) {
    return setTimeout(cb);
} : typeof window === "undefined" ? requestAnimationFrame : requestAnimationFrame.bind(window);
function $924c9c9699fb56e5$export$188d75d71883854a() {
    var classes = [];
    for(var _i = 0; _i < arguments.length; _i++)classes[_i] = arguments[_i];
    return classes.map(function(c) {
        return c && typeof c === "object" ? Object.keys(c).map(function(key) {
            return !!c[key] && key;
        }) : [
            c
        ];
    }).reduce(function(flattened, c) {
        return flattened.concat(c);
    }, []).filter(function(c) {
        return !!c;
    }).join(" ");
}
function $924c9c9699fb56e5$export$8b58be045bf06082() {
    var objects = [];
    for(var _i = 0; _i < arguments.length; _i++)objects[_i] = arguments[_i];
    /** The final result we will return */ var result = {};
    for(var _a = 0, objects_1 = objects; _a < objects_1.length; _a++){
        var object = objects_1[_a];
        if (object == null || object === false) continue;
        for(var key in object){
            /** Falsy values except a explicit 0 is ignored */ var val = object[key];
            if (!val && val !== 0) continue;
            /** if nested media or pseudo selector */ if (key === "$nest" && val) result[key] = result["$nest"] ? $924c9c9699fb56e5$export$8b58be045bf06082(result["$nest"], val) : val;
            else if (key.indexOf("&") !== -1 || key.indexOf("@media") === 0) result[key] = result[key] ? $924c9c9699fb56e5$export$8b58be045bf06082(result[key], val) : val;
            else result[key] = val;
        }
    }
    return result;
}
var $924c9c9699fb56e5$export$987d49ffe1b0900f = function(mediaQuery) {
    var _a;
    var objects = [];
    for(var _i = 1; _i < arguments.length; _i++)objects[_i - 1] = arguments[_i];
    var mediaQuerySections = [];
    if (mediaQuery.type) mediaQuerySections.push(mediaQuery.type);
    if (mediaQuery.orientation) mediaQuerySections.push("(orientation: " + mediaQuery.orientation + ")");
    if (mediaQuery.minWidth) mediaQuerySections.push("(min-width: " + $924c9c9699fb56e5$var$mediaLength(mediaQuery.minWidth) + ")");
    if (mediaQuery.maxWidth) mediaQuerySections.push("(max-width: " + $924c9c9699fb56e5$var$mediaLength(mediaQuery.maxWidth) + ")");
    if (mediaQuery.minHeight) mediaQuerySections.push("(min-height: " + $924c9c9699fb56e5$var$mediaLength(mediaQuery.minHeight) + ")");
    if (mediaQuery.maxHeight) mediaQuerySections.push("(max-height: " + $924c9c9699fb56e5$var$mediaLength(mediaQuery.maxHeight) + ")");
    if (mediaQuery.prefersColorScheme) mediaQuerySections.push("(prefers-color-scheme: " + mediaQuery.prefersColorScheme + ")");
    var stringMediaQuery = "@media " + mediaQuerySections.join(" and ");
    var object = {
        $nest: (_a = {}, _a[stringMediaQuery] = $924c9c9699fb56e5$export$8b58be045bf06082.apply(void 0, objects), _a)
    };
    return object;
};
var $924c9c9699fb56e5$var$mediaLength = function(value) {
    return typeof value === "string" ? value : value + "px";
};


/**
 * Creates an instance of free style with our options
 */ var $85a6bf9a93d1c6a7$var$createFreeStyle = function() {
    return $bb5666e07862b1ef$export$185802fd694ee1f5();
};
/**
 * Maintains a single stylesheet and keeps it in sync with requested styles
 */ var $85a6bf9a93d1c6a7$export$f8557f743de52359 = /** @class */ function() {
    function TypeStyle(_a) {
        var _this = this;
        var autoGenerateTag = _a.autoGenerateTag;
        /**
         * Insert `raw` CSS as a string. This is useful for e.g.
         * - third party CSS that you are customizing with template strings
         * - generating raw CSS in JavaScript
         * - reset libraries like normalize.css that you can use without loaders
         */ this.cssRaw = function(mustBeValidCSS) {
            if (!mustBeValidCSS) return;
            _this._raw += mustBeValidCSS || "";
            _this._pendingRawChange = true;
            _this._styleUpdated();
        };
        /**
         * Takes CSSProperties and registers it to a global selector (body, html, etc.)
         */ this.cssRule = function(selector) {
            var objects = [];
            for(var _i = 1; _i < arguments.length; _i++)objects[_i - 1] = arguments[_i];
            var styles = (0, $951acce1b360d836$export$6e907e5026f5a8f3)((0, $924c9c9699fb56e5$export$8b58be045bf06082).apply(void 0, objects));
            _this._freeStyle.registerRule(selector, styles);
            _this._styleUpdated();
            return;
        };
        /**
         * Renders styles to the singleton tag imediately
         * NOTE: You should only call it on initial render to prevent any non CSS flash.
         * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
         **/ this.forceRenderStyles = function() {
            var target = _this._getTag();
            if (!target) return;
            target.textContent = _this.getStyles();
        };
        /**
         * Utility function to register an @font-face
         */ this.fontFace = function() {
            var fontFace = [];
            for(var _i = 0; _i < arguments.length; _i++)fontFace[_i] = arguments[_i];
            var freeStyle = _this._freeStyle;
            for(var _a = 0, _b = fontFace; _a < _b.length; _a++){
                var face = _b[_a];
                freeStyle.registerRule("@font-face", face);
            }
            _this._styleUpdated();
            return;
        };
        /**
         * Allows use to use the stylesheet in a node.js environment
         */ this.getStyles = function() {
            return (_this._raw || "") + _this._freeStyle.getStyles();
        };
        /**
         * Takes keyframes and returns a generated animationName
         */ this.keyframes = function(frames) {
            var keyframes = (0, $951acce1b360d836$export$ad639ef713faf00d)(frames);
            // TODO: replace $debugName with display name
            var animationName = _this._freeStyle.registerKeyframes(keyframes);
            _this._styleUpdated();
            return animationName;
        };
        /**
         * Helps with testing. Reinitializes FreeStyle + raw
         */ this.reinit = function() {
            /** reinit freestyle */ var freeStyle = $85a6bf9a93d1c6a7$var$createFreeStyle();
            _this._freeStyle = freeStyle;
            _this._lastFreeStyleChangeId = freeStyle.changeId;
            /** reinit raw */ _this._raw = "";
            _this._pendingRawChange = false;
            /** Clear any styles that were flushed */ var target = _this._getTag();
            if (target) target.textContent = "";
        };
        /** Sets the target tag where we write the css on style updates */ this.setStylesTarget = function(tag) {
            /** Clear any data in any previous tag */ if (_this._tag) _this._tag.textContent = "";
            _this._tag = tag;
            /** This special time buffer immediately */ _this.forceRenderStyles();
        };
        /**
         * Takes an object where property names are ideal class names and property values are CSSProperties, and
         * returns an object where property names are the same ideal class names and the property values are
         * the actual generated class names using the ideal class name as the $debugName
         */ this.stylesheet = function(classes) {
            var classNames = Object.getOwnPropertyNames(classes);
            var result = {};
            for(var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++){
                var className = classNames_1[_i];
                var classDef = classes[className];
                if (classDef) {
                    classDef.$debugName = className;
                    result[className] = _this.style(classDef);
                }
            }
            return result;
        };
        var freeStyle = $85a6bf9a93d1c6a7$var$createFreeStyle();
        this._autoGenerateTag = autoGenerateTag;
        this._freeStyle = freeStyle;
        this._lastFreeStyleChangeId = freeStyle.changeId;
        this._pending = 0;
        this._pendingRawChange = false;
        this._raw = "";
        this._tag = undefined;
        // rebind prototype to TypeStyle.  It might be better to do a function() { return this.style.apply(this, arguments)}
        this.style = this.style.bind(this);
    }
    /**
     * Only calls cb all sync operations settle
     */ TypeStyle.prototype._afterAllSync = function(cb) {
        var _this = this;
        this._pending++;
        var pending = this._pending;
        (0, $924c9c9699fb56e5$export$27f233d61a9e2fa4)(function() {
            if (pending !== _this._pending) return;
            cb();
        });
    };
    TypeStyle.prototype._getTag = function() {
        if (this._tag) return this._tag;
        if (this._autoGenerateTag) {
            var tag = typeof window === "undefined" ? {
                textContent: ""
            } : document.createElement("style");
            if (typeof document !== "undefined") document.head.appendChild(tag);
            this._tag = tag;
            return tag;
        }
        return undefined;
    };
    /** Checks if the style tag needs updating and if so queues up the change */ TypeStyle.prototype._styleUpdated = function() {
        var _this = this;
        var changeId = this._freeStyle.changeId;
        var lastChangeId = this._lastFreeStyleChangeId;
        if (!this._pendingRawChange && changeId === lastChangeId) return;
        this._lastFreeStyleChangeId = changeId;
        this._pendingRawChange = false;
        this._afterAllSync(function() {
            return _this.forceRenderStyles();
        });
    };
    TypeStyle.prototype.style = function() {
        var className = this._freeStyle.registerStyle((0, $951acce1b360d836$export$6e907e5026f5a8f3)((0, $924c9c9699fb56e5$export$8b58be045bf06082).apply(undefined, arguments)));
        this._styleUpdated();
        return className;
    };
    return TypeStyle;
}();





/** Zero configuration, default instance of TypeStyle */ var $20ee2a2bdb014770$var$ts = new (0, $85a6bf9a93d1c6a7$export$f8557f743de52359)({
    autoGenerateTag: true
});
var $20ee2a2bdb014770$export$b4c1ed5cd8d22259 = $20ee2a2bdb014770$var$ts.setStylesTarget;
var $20ee2a2bdb014770$export$d28212b8a4a9b69d = $20ee2a2bdb014770$var$ts.cssRaw;
var $20ee2a2bdb014770$export$7bffc948341a2c5c = $20ee2a2bdb014770$var$ts.cssRule;
var $20ee2a2bdb014770$export$9770592101341c48 = $20ee2a2bdb014770$var$ts.forceRenderStyles;
var $20ee2a2bdb014770$export$566c6c2ff0443c7 = $20ee2a2bdb014770$var$ts.fontFace;
var $20ee2a2bdb014770$export$ffd58b7f6f099a57 = $20ee2a2bdb014770$var$ts.getStyles;
var $20ee2a2bdb014770$export$d25ddfdf17c3ad3e = $20ee2a2bdb014770$var$ts.keyframes;
var $20ee2a2bdb014770$export$b545ad0f2df0be16 = $20ee2a2bdb014770$var$ts.reinit;
var $20ee2a2bdb014770$export$1d567c320f4763bc = $20ee2a2bdb014770$var$ts.style;
var $20ee2a2bdb014770$export$ab599ac46a775d57 = $20ee2a2bdb014770$var$ts.stylesheet;
function $20ee2a2bdb014770$export$33b2ae9d5b1dc022(target) {
    var instance = new (0, $85a6bf9a93d1c6a7$export$f8557f743de52359)({
        autoGenerateTag: false
    });
    if (target) instance.setStylesTarget(target);
    return instance;
}


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function $64ec2c4ca9e4602d$export$10fdab3683b55b22(val, searchString) {
    return new RegExp(`${searchString}$`).test(`${val}`);
}
const $64ec2c4ca9e4602d$export$7d7c0eab80e1d30c = (array, predicate)=>{
    const len = array.length;
    for(let i = 0; i < len; i++){
        if (predicate(array[i], i)) return i;
    }
    return -1;
};
const $64ec2c4ca9e4602d$export$43128fadae87b74a = (array, predicate)=>{
    const idx = $64ec2c4ca9e4602d$export$7d7c0eab80e1d30c(array, predicate);
    return idx > -1 ? array[idx] : undefined;
};


const $b740921611e46f8c$var$staticCssField = "__sc_static_css";
const $b740921611e46f8c$var$dynamicCssField = "__sc_dynamic_css";
const $b740921611e46f8c$var$cssSetFlag = "__sc_css_set";
const $b740921611e46f8c$var$classNameFactory = (scope)=>(debugName, ...cssProps)=>{
        const cssProperties = cssProps.filter((css)=>!!css).reduce((r, c)=>r.concat(c), []);
        const isEmpty = cssProperties.every((css)=>!Object.keys(css).length);
        const debugProps = {
            $debugName: `${scope}-${debugName}`
        };
        return isEmpty ? "" : (0, $20ee2a2bdb014770$export$1d567c320f4763bc)(...cssProperties, debugProps);
    };
const $b740921611e46f8c$var$animationNameFactory = ()=>(timeline)=>{
        return (0, $20ee2a2bdb014770$export$d25ddfdf17c3ad3e)(timeline);
    };
const $b740921611e46f8c$var$getStaticCssArrayCopy = (Component)=>(Component[$b740921611e46f8c$var$staticCssField] || []).slice();
const $b740921611e46f8c$var$getDynamicCssArrayCopy = (Component)=>(Component[$b740921611e46f8c$var$dynamicCssField] || []).slice();
const $b740921611e46f8c$var$isStyledComponent = (Component)=>!!Component[$b740921611e46f8c$var$dynamicCssField];
const $b740921611e46f8c$var$styledComponentFactory = (getClassName)=>(Component)=>(styledComponentName, css, getCss)=>{
            const staticCssArray = $b740921611e46f8c$var$getStaticCssArrayCopy(Component).concat(css);
            const dynamicCssArray = $b740921611e46f8c$var$getDynamicCssArrayCopy(Component).concat(getCss).filter((fn)=>!!fn);
            const staticCssClassName = getClassName(styledComponentName, ...staticCssArray);
            const isTargetStyledComponent = $b740921611e46f8c$var$isStyledComponent(Component);
            const StyledComponent = class extends $aaLBe.Component {
                static [$b740921611e46f8c$var$staticCssField] = staticCssArray;
                static [$b740921611e46f8c$var$dynamicCssField] = dynamicCssArray;
                render() {
                    const { customProps: customProps = {} , ...props } = this.props;
                    const cssSet = props[$b740921611e46f8c$var$cssSetFlag];
                    props[$b740921611e46f8c$var$cssSetFlag] = undefined;
                    const classNames = [];
                    if (!cssSet) {
                        const dynamicCss = StyledComponent[$b740921611e46f8c$var$dynamicCssField].map((cssFn)=>cssFn({
                                ...props,
                                customProps: customProps
                            }));
                        const dynamicCssClassName = getClassName(styledComponentName, ...dynamicCss);
                        classNames.push(staticCssClassName, dynamicCssClassName);
                    }
                    return $aaLBe.createElement(Component, {
                        ...props,
                        className: $b740921611e46f8c$export$e3747efcbec8332(...classNames, this.props.className),
                        [$b740921611e46f8c$var$cssSetFlag]: isTargetStyledComponent ? true : undefined
                    });
                }
            };
            return (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)(StyledComponent);
        };
function $b740921611e46f8c$export$1483880232688058(cssProps) {
    const important = "!important";
    Object.keys(cssProps).forEach((prop)=>{
        const val = cssProps[prop];
        (0, $64ec2c4ca9e4602d$export$10fdab3683b55b22)(val, important);
    });
    return cssProps;
}
const $b740921611e46f8c$export$e3747efcbec8332 = (...classNames)=>classNames.filter((c)=>c).join(" ");
const $b740921611e46f8c$export$99f00114e7637415 = (scope)=>{
    const getClassName = $b740921611e46f8c$var$classNameFactory(scope);
    const getAnimationName = $b740921611e46f8c$var$animationNameFactory();
    const styleComponent = $b740921611e46f8c$var$styledComponentFactory(getClassName);
    return {
        getClassName: getClassName,
        getAnimationName: getAnimationName,
        styleComponent: styleComponent,
        //HTML stylers
        styleDiv: styleComponent("div"),
        styleSpan: styleComponent("span"),
        styleHeader: styleComponent("header"),
        styleFooter: styleComponent("footer"),
        styleButton: styleComponent("button"),
        styleUlist: styleComponent("ul"),
        styleLi: styleComponent("li"),
        styleAnchor: styleComponent("a"),
        styleInput: styleComponent("input"),
        styleTextArea: styleComponent("textarea"),
        styleParagraph: styleComponent("p"),
        styleLabel: styleComponent("label"),
        styleMain: styleComponent("main"),
        styleIFrame: styleComponent("iframe"),
        //SVG stylers
        styleSvg: styleComponent("svg"),
        styleG: styleComponent("g"),
        styleRect: styleComponent("rect"),
        styleCircle: styleComponent("circle"),
        styleLine: styleComponent("line"),
        stylePath: styleComponent("path")
    };
};


const { styleComponent: $17417c12731462fa$var$styleComponent , styleDiv: $17417c12731462fa$var$styleDiv , styleMain: $17417c12731462fa$var$styleMain  } = (0, $b740921611e46f8c$export$99f00114e7637415)("Chrome");
const $17417c12731462fa$var$STypography = $17417c12731462fa$var$styleComponent((0, $372cadd18a544d36$export$2e2bcd8739ae039))("STypography", {
    flexGrow: 1
});
const $17417c12731462fa$var$Container = $17417c12731462fa$var$styleDiv("Container", {
    display: "flex",
    flexDirection: "column",
    height: "100vh",
    position: "relative",
    overflow: "hidden"
});
const $17417c12731462fa$var$Content = $17417c12731462fa$var$styleMain("Content", {
    flex: "1",
    display: "flex",
    height: "100%",
    padding: "0px",
    position: "relative"
});
const $17417c12731462fa$var$Header = $17417c12731462fa$var$styleComponent((0, $918dca7716ce40a7$export$2e2bcd8739ae039))("Header", {
    flex: "0 0 auto",
    padding: "0 14px",
    fontSize: "12px"
});
let $17417c12731462fa$export$31a305e9779b48b4 = class Chrome extends $aaLBe.Component {
    render() {
        const formatComma = (0, $23de77130e6fabd5$export$d9468344d3651243)(",.2f");
        return /*#__PURE__*/ $aaLBe.createElement($17417c12731462fa$var$Container, null, /*#__PURE__*/ $aaLBe.createElement($17417c12731462fa$var$Header, {
            position: "static"
        }, /*#__PURE__*/ $aaLBe.createElement((0, $125e0e14f9b60abb$export$2e2bcd8739ae039), null, /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($39d00819b5e2256c$exports))), {
            fontSize: "large",
            className: "feature-icon",
            onClick: (_)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).sidebarOpen = !(0, $841120e180d215c5$export$a510af025ac2bbc1).sidebarOpen
        }), /*#__PURE__*/ $aaLBe.createElement($17417c12731462fa$var$STypography, {
            variant: "h5",
            color: "inherit"
        }, "Gamut"), (0, $841120e180d215c5$export$a510af025ac2bbc1).ready ? /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "header-grouping"
        }, /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "header-content"
        }, /*#__PURE__*/ $aaLBe.createElement("label", {
            htmlFor: "datasets",
            className: "smalltext-header"
        }, "model"), /*#__PURE__*/ $aaLBe.createElement("select", {
            id: "datasets",
            className: "dataset header-value",
            required: true,
            value: (0, $841120e180d215c5$export$a510af025ac2bbc1).datasetName,
            onChange: (e)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).loadDataset(e.target.value)
        }, (0, $841120e180d215c5$export$a510af025ac2bbc1).datasetNames.map((name)=>/*#__PURE__*/ $aaLBe.createElement("option", {
                key: name,
                value: name
            }, name)))), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "header-content"
        }, /*#__PURE__*/ $aaLBe.createElement("label", {
            className: "smalltext-header"
        }, "RMSE"), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "header-value"
        }, formatComma((0, $841120e180d215c5$export$a510af025ac2bbc1).model.rms))), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "header-content"
        }, /*#__PURE__*/ $aaLBe.createElement("label", {
            className: "smalltext-header"
        }, "intercept"), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "header-value"
        }, formatComma((0, $841120e180d215c5$export$a510af025ac2bbc1).model.intercept)))) : null)), /*#__PURE__*/ $aaLBe.createElement($17417c12731462fa$var$Content, null, this.props.children));
    }
};
$17417c12731462fa$export$31a305e9779b48b4 = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $17417c12731462fa$export$31a305e9779b48b4);


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");


var $2LmR0 = parcelRequire("2LmR0");

var $5tnPj = parcelRequire("5tnPj");

var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");



var $h0TGs = parcelRequire("h0TGs");


var $aaLBe = parcelRequire("aaLBe");
// TODO v5: consider to make it private
function $f0e8bf3cf815ed82$export$2e2bcd8739ae039(ref, value) {
    if (typeof ref === "function") ref(value);
    else if (ref) ref.current = value;
}


function $ec3bc30a9139d143$export$2e2bcd8739ae039(refA, refB) {
    /**
   * This will create a new function if the ref props change and are defined.
   * This means react will call the old forkRef with `null` and the new forkRef
   * with the ref. Cleanup naturally emerges from this behavior
   */ return $aaLBe.useMemo(function() {
        if (refA == null && refB == null) return null;
        return function(refValue) {
            (0, $f0e8bf3cf815ed82$export$2e2bcd8739ae039)(refA, refValue);
            (0, $f0e8bf3cf815ed82$export$2e2bcd8739ae039)(refB, refValue);
        };
    }, [
        refA,
        refB
    ]);
}



var $aaLBe = parcelRequire("aaLBe");
var $7b27a8aad9696ce9$var$useEnhancedEffect = typeof window !== "undefined" ? $aaLBe.useLayoutEffect : $aaLBe.useEffect;
function $7b27a8aad9696ce9$export$2e2bcd8739ae039(fn) {
    var ref = $aaLBe.useRef(fn);
    $7b27a8aad9696ce9$var$useEnhancedEffect(function() {
        ref.current = fn;
    });
    return $aaLBe.useCallback(function() {
        return (0, ref.current).apply(void 0, arguments);
    }, []);
}




var $2LmR0 = parcelRequire("2LmR0");
// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js

var $aaLBe = parcelRequire("aaLBe");

var $c45ba86bf3b3634e$var$hadKeyboardEvent = true;
var $c45ba86bf3b3634e$var$hadFocusVisibleRecently = false;
var $c45ba86bf3b3634e$var$hadFocusVisibleRecentlyTimeout = null;
var $c45ba86bf3b3634e$var$inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    "datetime-local": true
};
/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} node
 * @return {boolean}
 */ function $c45ba86bf3b3634e$var$focusTriggersKeyboardModality(node) {
    var type = node.type, tagName = node.tagName;
    if (tagName === "INPUT" && $c45ba86bf3b3634e$var$inputTypesWhitelist[type] && !node.readOnly) return true;
    if (tagName === "TEXTAREA" && !node.readOnly) return true;
    if (node.isContentEditable) return true;
    return false;
}
/**
 * Keep track of our keyboard modality state with `hadKeyboardEvent`.
 * If the most recent user interaction was via the keyboard;
 * and the key press did not include a meta, alt/option, or control key;
 * then the modality is keyboard. Otherwise, the modality is not keyboard.
 * @param {KeyboardEvent} event
 */ function $c45ba86bf3b3634e$var$handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) return;
    $c45ba86bf3b3634e$var$hadKeyboardEvent = true;
}
/**
 * If at any point a user clicks with a pointing device, ensure that we change
 * the modality away from keyboard.
 * This avoids the situation where a user presses a key on an already focused
 * element, and then clicks on a different element, focusing it with a
 * pointing device, while we still think we're in keyboard modality.
 */ function $c45ba86bf3b3634e$var$handlePointerDown() {
    $c45ba86bf3b3634e$var$hadKeyboardEvent = false;
}
function $c45ba86bf3b3634e$var$handleVisibilityChange() {
    if (this.visibilityState === "hidden") // If the tab becomes active again, the browser will handle calling focus
    // on the element (Safari actually calls it twice).
    // If this tab change caused a blur on an element with focus-visible,
    // re-apply the class when the user switches back to the tab.
    {
        if ($c45ba86bf3b3634e$var$hadFocusVisibleRecently) $c45ba86bf3b3634e$var$hadKeyboardEvent = true;
    }
}
function $c45ba86bf3b3634e$var$prepare(doc) {
    doc.addEventListener("keydown", $c45ba86bf3b3634e$var$handleKeyDown, true);
    doc.addEventListener("mousedown", $c45ba86bf3b3634e$var$handlePointerDown, true);
    doc.addEventListener("pointerdown", $c45ba86bf3b3634e$var$handlePointerDown, true);
    doc.addEventListener("touchstart", $c45ba86bf3b3634e$var$handlePointerDown, true);
    doc.addEventListener("visibilitychange", $c45ba86bf3b3634e$var$handleVisibilityChange, true);
}
function $c45ba86bf3b3634e$export$4794d9b1949031cf(doc) {
    doc.removeEventListener("keydown", $c45ba86bf3b3634e$var$handleKeyDown, true);
    doc.removeEventListener("mousedown", $c45ba86bf3b3634e$var$handlePointerDown, true);
    doc.removeEventListener("pointerdown", $c45ba86bf3b3634e$var$handlePointerDown, true);
    doc.removeEventListener("touchstart", $c45ba86bf3b3634e$var$handlePointerDown, true);
    doc.removeEventListener("visibilitychange", $c45ba86bf3b3634e$var$handleVisibilityChange, true);
}
function $c45ba86bf3b3634e$var$isFocusVisible(event) {
    var target = event.target;
    try {
        return target.matches(":focus-visible");
    } catch (error) {} // browsers not implementing :focus-visible will throw a SyntaxError
    // we use our own heuristic for those browsers
    // rethrow might be better if it's not the expected error but do we really
    // want to crash if focus-visible malfunctioned?
    // no need for validFocusTarget check. the user does that by attaching it to
    // focusable events only
    return $c45ba86bf3b3634e$var$hadKeyboardEvent || $c45ba86bf3b3634e$var$focusTriggersKeyboardModality(target);
}
/**
 * Should be called if a blur event is fired on a focus-visible element
 */ function $c45ba86bf3b3634e$var$handleBlurVisible() {
    // To detect a tab/window switch, we look for a blur event followed
    // rapidly by a visibility change.
    // If we don't see a visibility change within 100ms, it's probably a
    // regular focus change.
    $c45ba86bf3b3634e$var$hadFocusVisibleRecently = true;
    window.clearTimeout($c45ba86bf3b3634e$var$hadFocusVisibleRecentlyTimeout);
    $c45ba86bf3b3634e$var$hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
        $c45ba86bf3b3634e$var$hadFocusVisibleRecently = false;
    }, 100);
}
function $c45ba86bf3b3634e$export$2e2bcd8739ae039() {
    var ref = $aaLBe.useCallback(function(instance) {
        var node = $ba021dca0cbd5bec$exports.findDOMNode(instance);
        if (node != null) $c45ba86bf3b3634e$var$prepare(node.ownerDocument);
    }, []);
    return {
        isFocusVisible: $c45ba86bf3b3634e$var$isFocusVisible,
        onBlurVisible: $c45ba86bf3b3634e$var$handleBlurVisible,
        ref: ref
    };
}



var $29rXr = parcelRequire("29rXr");

var $j7CoL = parcelRequire("j7CoL");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $9Zx8w = parcelRequire("9Zx8w");

var $29rXr = parcelRequire("29rXr");

var $bPInb = parcelRequire("bPInb");

var $fiJE0 = parcelRequire("fiJE0");


var $aaLBe = parcelRequire("aaLBe");

var $aaLBe = parcelRequire("aaLBe");
var $f7573ca97d71f4ae$export$2e2bcd8739ae039 = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createContext(null);



var $aaLBe = parcelRequire("aaLBe");
function $86b3f3898f1b8b0b$export$bbc8a025727ea824(children, mapFn) {
    var mapper = function mapper(child) {
        return mapFn && (0, $aaLBe.isValidElement)(child) ? mapFn(child) : child;
    };
    var result = Object.create(null);
    if (children) (0, $aaLBe.Children).map(children, function(c) {
        return c;
    }).forEach(function(child) {
        // run the map function here instead so that the key is the computed one
        result[child.key] = mapper(child);
    });
    return result;
}
function $86b3f3898f1b8b0b$export$7a874f95ccf533dd(prev, next) {
    prev = prev || {};
    next = next || {};
    function getValueForKey(key) {
        return key in next ? next[key] : prev[key];
    } // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextKeysPending = Object.create(null);
    var pendingKeys = [];
    for(var prevKey in prev){
        if (prevKey in next) {
            if (pendingKeys.length) {
                nextKeysPending[prevKey] = pendingKeys;
                pendingKeys = [];
            }
        } else pendingKeys.push(prevKey);
    }
    var i;
    var childMapping = {};
    for(var nextKey in next){
        if (nextKeysPending[nextKey]) for(i = 0; i < nextKeysPending[nextKey].length; i++){
            var pendingNextKey = nextKeysPending[nextKey][i];
            childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
        childMapping[nextKey] = getValueForKey(nextKey);
    } // Finally, add the keys which didn't appear before any key in `next`
    for(i = 0; i < pendingKeys.length; i++)childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    return childMapping;
}
function $86b3f3898f1b8b0b$var$getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
}
function $86b3f3898f1b8b0b$export$fa71e2345c31d7a2(props, onExited) {
    return $86b3f3898f1b8b0b$export$bbc8a025727ea824(props.children, function(child) {
        return (0, $aaLBe.cloneElement)(child, {
            onExited: onExited.bind(null, child),
            in: true,
            appear: $86b3f3898f1b8b0b$var$getProp(child, "appear", props),
            enter: $86b3f3898f1b8b0b$var$getProp(child, "enter", props),
            exit: $86b3f3898f1b8b0b$var$getProp(child, "exit", props)
        });
    });
}
function $86b3f3898f1b8b0b$export$36fd1af28d383ec0(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = $86b3f3898f1b8b0b$export$bbc8a025727ea824(nextProps.children);
    var children = $86b3f3898f1b8b0b$export$7a874f95ccf533dd(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function(key) {
        var child = children[key];
        if (!(0, $aaLBe.isValidElement)(child)) return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = (0, $aaLBe.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)
        if (hasNext && (!hasPrev || isLeaving)) // console.log('entering', key)
        children[key] = (0, $aaLBe.cloneElement)(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: $86b3f3898f1b8b0b$var$getProp(child, "exit", nextProps),
            enter: $86b3f3898f1b8b0b$var$getProp(child, "enter", nextProps)
        });
        else if (!hasNext && hasPrev && !isLeaving) // item is old (exiting)
        // console.log('leaving', key)
        children[key] = (0, $aaLBe.cloneElement)(child, {
            in: false
        });
        else if (hasNext && hasPrev && (0, $aaLBe.isValidElement)(prevChild)) // item hasn't changed transition states
        // copy over the last transition props;
        // console.log('unchanged', key)
        children[key] = (0, $aaLBe.cloneElement)(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: $86b3f3898f1b8b0b$var$getProp(child, "exit", nextProps),
            enter: $86b3f3898f1b8b0b$var$getProp(child, "enter", nextProps)
        });
    });
    return children;
}


var $869f68c8099d9ed1$var$values = Object.values || function(obj) {
    return Object.keys(obj).map(function(k) {
        return obj[k];
    });
};
var $869f68c8099d9ed1$var$defaultProps = {
    component: "div",
    childFactory: function childFactory(child) {
        return child;
    }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */ var $869f68c8099d9ed1$var$TransitionGroup = /*#__PURE__*/ function(_React$Component) {
    (0, $fiJE0.default)(TransitionGroup, _React$Component);
    function TransitionGroup(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var handleExited = _this.handleExited.bind((0, $bPInb.default)(_this)); // Initial children should all be entering, dependent on appear
        _this.state = {
            contextValue: {
                isMounting: true
            },
            handleExited: handleExited,
            firstRender: true
        };
        return _this;
    }
    var _proto = TransitionGroup.prototype;
    _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
            contextValue: {
                isMounting: false
            }
        });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
    };
    TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
        return {
            children: firstRender ? (0, $86b3f3898f1b8b0b$export$fa71e2345c31d7a2)(nextProps, handleExited) : (0, $86b3f3898f1b8b0b$export$36fd1af28d383ec0)(nextProps, prevChildMapping, handleExited),
            firstRender: false
        };
    } // node is `undefined` when user provided `nodeRef` prop
    ;
    _proto.handleExited = function handleExited(child, node) {
        var currentChildMapping = (0, $86b3f3898f1b8b0b$export$bbc8a025727ea824)(this.props.children);
        if (child.key in currentChildMapping) return;
        if (child.props.onExited) child.props.onExited(node);
        if (this.mounted) this.setState(function(state) {
            var children = (0, $29rXr.default)({}, state.children);
            delete children[child.key];
            return {
                children: children
            };
        });
    };
    _proto.render = function render() {
        var _this$props = this.props, Component = _this$props.component, childFactory = _this$props.childFactory, props = (0, $9Zx8w.default)(_this$props, [
            "component",
            "childFactory"
        ]);
        var contextValue = this.state.contextValue;
        var children = $869f68c8099d9ed1$var$values(this.state.children).map(childFactory);
        delete props.appear;
        delete props.enter;
        delete props.exit;
        if (Component === null) return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, $f7573ca97d71f4ae$export$2e2bcd8739ae039).Provider, {
            value: contextValue
        }, children);
        return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, $f7573ca97d71f4ae$export$2e2bcd8739ae039).Provider, {
            value: contextValue
        }, /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(Component, props, children));
    };
    return TransitionGroup;
}((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Component);
$869f68c8099d9ed1$var$TransitionGroup.propTypes = {};
$869f68c8099d9ed1$var$TransitionGroup.defaultProps = $869f68c8099d9ed1$var$defaultProps;
var $869f68c8099d9ed1$export$2e2bcd8739ae039 = $869f68c8099d9ed1$var$TransitionGroup;



var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $47a8db269bba3800$var$useEnhancedEffect = typeof window === "undefined" ? $aaLBe.useEffect : $aaLBe.useLayoutEffect;
/**
 * @ignore - internal component.
 */ function $47a8db269bba3800$var$Ripple(props) {
    var classes = props.classes, _props$pulsate = props.pulsate, pulsate = _props$pulsate === void 0 ? false : _props$pulsate, rippleX = props.rippleX, rippleY = props.rippleY, rippleSize = props.rippleSize, inProp = props.in, _props$onExited = props.onExited, onExited = _props$onExited === void 0 ? function() {} : _props$onExited, timeout = props.timeout;
    var _React$useState = $aaLBe.useState(false), leaving = _React$useState[0], setLeaving = _React$useState[1];
    var rippleClassName = (0, $h0TGs.default)(classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    var rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX
    };
    var childClassName = (0, $h0TGs.default)(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    var handleExited = (0, $7b27a8aad9696ce9$export$2e2bcd8739ae039)(onExited); // Ripple is used for user feedback (e.g. click or press) so we want to apply styles with the highest priority
    $47a8db269bba3800$var$useEnhancedEffect(function() {
        if (!inProp) {
            // react-transition-group#onExit
            setLeaving(true); // react-transition-group#onExited
            var timeoutId = setTimeout(handleExited, timeout);
            return function() {
                clearTimeout(timeoutId);
            };
        }
        return undefined;
    }, [
        handleExited,
        inProp,
        timeout
    ]);
    return /*#__PURE__*/ $aaLBe.createElement("span", {
        className: rippleClassName,
        style: rippleStyles
    }, /*#__PURE__*/ $aaLBe.createElement("span", {
        className: childClassName
    }));
}
var $47a8db269bba3800$export$2e2bcd8739ae039 = $47a8db269bba3800$var$Ripple;


var $9ffbf3d2079820db$var$DURATION = 550;
var $9ffbf3d2079820db$export$95d0c9356b2231a3 = 80;
var $9ffbf3d2079820db$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            overflow: "hidden",
            pointerEvents: "none",
            position: "absolute",
            zIndex: 0,
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            borderRadius: "inherit"
        },
        /* Styles applied to the internal `Ripple` components `ripple` class. */ ripple: {
            opacity: 0,
            position: "absolute"
        },
        /* Styles applied to the internal `Ripple` components `rippleVisible` class. */ rippleVisible: {
            opacity: 0.3,
            transform: "scale(1)",
            animation: "$enter ".concat($9ffbf3d2079820db$var$DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
        },
        /* Styles applied to the internal `Ripple` components `ripplePulsate` class. */ ripplePulsate: {
            animationDuration: "".concat(theme.transitions.duration.shorter, "ms")
        },
        /* Styles applied to the internal `Ripple` components `child` class. */ child: {
            opacity: 1,
            display: "block",
            width: "100%",
            height: "100%",
            borderRadius: "50%",
            backgroundColor: "currentColor"
        },
        /* Styles applied to the internal `Ripple` components `childLeaving` class. */ childLeaving: {
            opacity: 0,
            animation: "$exit ".concat($9ffbf3d2079820db$var$DURATION, "ms ").concat(theme.transitions.easing.easeInOut)
        },
        /* Styles applied to the internal `Ripple` components `childPulsate` class. */ childPulsate: {
            position: "absolute",
            left: 0,
            top: 0,
            animation: "$pulsate 2500ms ".concat(theme.transitions.easing.easeInOut, " 200ms infinite")
        },
        "@keyframes enter": {
            "0%": {
                transform: "scale(0)",
                opacity: 0.1
            },
            "100%": {
                transform: "scale(1)",
                opacity: 0.3
            }
        },
        "@keyframes exit": {
            "0%": {
                opacity: 1
            },
            "100%": {
                opacity: 0
            }
        },
        "@keyframes pulsate": {
            "0%": {
                transform: "scale(1)"
            },
            "50%": {
                transform: "scale(0.92)"
            },
            "100%": {
                transform: "scale(1)"
            }
        }
    };
};
/**
 * @ignore - internal component.
 *
 * TODO v5: Make private
 */ var $9ffbf3d2079820db$var$TouchRipple = /*#__PURE__*/ $aaLBe.forwardRef(function TouchRipple(props, ref) {
    var _props$center = props.center, centerProp = _props$center === void 0 ? false : _props$center, classes = props.classes, className = props.className, other = (0, $kqze3.default)(props, [
        "center",
        "classes",
        "className"
    ]);
    var _React$useState = $aaLBe.useState([]), ripples = _React$useState[0], setRipples = _React$useState[1];
    var nextKey = $aaLBe.useRef(0);
    var rippleCallback = $aaLBe.useRef(null);
    $aaLBe.useEffect(function() {
        if (rippleCallback.current) {
            rippleCallback.current();
            rippleCallback.current = null;
        }
    }, [
        ripples
    ]); // Used to filter out mouse emulated events on mobile.
    var ignoringMouseDown = $aaLBe.useRef(false); // We use a timer in order to only show the ripples for touch "click" like events.
    // We don't want to display the ripple for touch scroll events.
    var startTimer = $aaLBe.useRef(null); // This is the hook called once the previous timeout is ready.
    var startTimerCommit = $aaLBe.useRef(null);
    var container = $aaLBe.useRef(null);
    $aaLBe.useEffect(function() {
        return function() {
            clearTimeout(startTimer.current);
        };
    }, []);
    var startCommit = $aaLBe.useCallback(function(params) {
        var pulsate = params.pulsate, rippleX = params.rippleX, rippleY = params.rippleY, rippleSize = params.rippleSize, cb = params.cb;
        setRipples(function(oldRipples) {
            return [].concat((0, $j7CoL.default)(oldRipples), [
                /*#__PURE__*/ $aaLBe.createElement((0, $47a8db269bba3800$export$2e2bcd8739ae039), {
                    key: nextKey.current,
                    classes: classes,
                    timeout: $9ffbf3d2079820db$var$DURATION,
                    pulsate: pulsate,
                    rippleX: rippleX,
                    rippleY: rippleY,
                    rippleSize: rippleSize
                })
            ]);
        });
        nextKey.current += 1;
        rippleCallback.current = cb;
    }, [
        classes
    ]);
    var start = $aaLBe.useCallback(function() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var cb = arguments.length > 2 ? arguments[2] : undefined;
        var _options$pulsate = options.pulsate, pulsate = _options$pulsate === void 0 ? false : _options$pulsate, _options$center = options.center, center = _options$center === void 0 ? centerProp || options.pulsate : _options$center, _options$fakeElement = options.fakeElement, fakeElement = _options$fakeElement === void 0 ? false : _options$fakeElement;
        if (event.type === "mousedown" && ignoringMouseDown.current) {
            ignoringMouseDown.current = false;
            return;
        }
        if (event.type === "touchstart") ignoringMouseDown.current = true;
        var element = fakeElement ? null : container.current;
        var rect = element ? element.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
        }; // Get the size of the ripple
        var rippleX;
        var rippleY;
        var rippleSize;
        if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
            rippleX = Math.round(rect.width / 2);
            rippleY = Math.round(rect.height / 2);
        } else {
            var _ref = event.touches ? event.touches[0] : event, clientX = _ref.clientX, clientY = _ref.clientY;
            rippleX = Math.round(clientX - rect.left);
            rippleY = Math.round(clientY - rect.top);
        }
        if (center) {
            rippleSize = Math.sqrt((2 * Math.pow(rect.width, 2) + Math.pow(rect.height, 2)) / 3); // For some reason the animation is broken on Mobile Chrome if the size if even.
            if (rippleSize % 2 === 0) rippleSize += 1;
        } else {
            var sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
            var sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
            rippleSize = Math.sqrt(Math.pow(sizeX, 2) + Math.pow(sizeY, 2));
        } // Touche devices
        if (event.touches) // check that this isn't another touchstart due to multitouch
        // otherwise we will only clear a single timer when unmounting while two
        // are running
        {
            if (startTimerCommit.current === null) {
                // Prepare the ripple effect.
                startTimerCommit.current = function() {
                    startCommit({
                        pulsate: pulsate,
                        rippleX: rippleX,
                        rippleY: rippleY,
                        rippleSize: rippleSize,
                        cb: cb
                    });
                }; // Delay the execution of the ripple effect.
                startTimer.current = setTimeout(function() {
                    if (startTimerCommit.current) {
                        startTimerCommit.current();
                        startTimerCommit.current = null;
                    }
                }, $9ffbf3d2079820db$export$95d0c9356b2231a3); // We have to make a tradeoff with this value.
            }
        } else startCommit({
            pulsate: pulsate,
            rippleX: rippleX,
            rippleY: rippleY,
            rippleSize: rippleSize,
            cb: cb
        });
    }, [
        centerProp,
        startCommit
    ]);
    var pulsate = $aaLBe.useCallback(function() {
        start({}, {
            pulsate: true
        });
    }, [
        start
    ]);
    var stop = $aaLBe.useCallback(function(event, cb) {
        clearTimeout(startTimer.current); // The touch interaction occurs too quickly.
        // We still want to show ripple effect.
        if (event.type === "touchend" && startTimerCommit.current) {
            event.persist();
            startTimerCommit.current();
            startTimerCommit.current = null;
            startTimer.current = setTimeout(function() {
                stop(event, cb);
            });
            return;
        }
        startTimerCommit.current = null;
        setRipples(function(oldRipples) {
            if (oldRipples.length > 0) return oldRipples.slice(1);
            return oldRipples;
        });
        rippleCallback.current = cb;
    }, []);
    $aaLBe.useImperativeHandle(ref, function() {
        return {
            pulsate: pulsate,
            start: start,
            stop: stop
        };
    }, [
        pulsate,
        start,
        stop
    ]);
    return /*#__PURE__*/ $aaLBe.createElement("span", (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className),
        ref: container
    }, other), /*#__PURE__*/ $aaLBe.createElement((0, $869f68c8099d9ed1$export$2e2bcd8739ae039), {
        component: null,
        exit: true
    }, ripples));
});
var $9ffbf3d2079820db$export$2e2bcd8739ae039 = (0, $2LmR0.default)($9ffbf3d2079820db$export$9dd6ff9ea0189349, {
    flip: false,
    name: "MuiTouchRipple"
})(/*#__PURE__*/ $aaLBe.memo($9ffbf3d2079820db$var$TouchRipple));


var $c61f5105fcb078ef$export$9dd6ff9ea0189349 = {
    /* Styles applied to the root element. */ root: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative",
        WebkitTapHighlightColor: "transparent",
        backgroundColor: "transparent",
        // Reset default value
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0,
        border: 0,
        margin: 0,
        // Remove the margin in Safari
        borderRadius: 0,
        padding: 0,
        // Remove the padding in Firefox
        cursor: "pointer",
        userSelect: "none",
        verticalAlign: "middle",
        "-moz-appearance": "none",
        // Reset
        "-webkit-appearance": "none",
        // Reset
        textDecoration: "none",
        // So we take precedent over the style of a native <a /> element.
        color: "inherit",
        "&::-moz-focus-inner": {
            borderStyle: "none" // Remove Firefox dotted outline.
        },
        "&$disabled": {
            pointerEvents: "none",
            // Disable link interactions
            cursor: "default"
        },
        "@media print": {
            colorAdjust: "exact"
        }
    },
    /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {},
    /* Pseudo-class applied to the root element if keyboard focused. */ focusVisible: {}
};
/**
 * `ButtonBase` contains as few styles as possible.
 * It aims to be a simple building block for creating a button.
 * It contains a load of style reset and some focus/ripple logic.
 */ var $c61f5105fcb078ef$var$ButtonBase = /*#__PURE__*/ $aaLBe.forwardRef(function ButtonBase(props, ref) {
    var action = props.action, buttonRefProp = props.buttonRef, _props$centerRipple = props.centerRipple, centerRipple = _props$centerRipple === void 0 ? false : _props$centerRipple, children = props.children, classes = props.classes, className = props.className, _props$component = props.component, component = _props$component === void 0 ? "button" : _props$component, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableRipple = props.disableRipple, disableRipple = _props$disableRipple === void 0 ? false : _props$disableRipple, _props$disableTouchRi = props.disableTouchRipple, disableTouchRipple = _props$disableTouchRi === void 0 ? false : _props$disableTouchRi, _props$focusRipple = props.focusRipple, focusRipple = _props$focusRipple === void 0 ? false : _props$focusRipple, focusVisibleClassName = props.focusVisibleClassName, onBlur = props.onBlur, onClick = props.onClick, onFocus = props.onFocus, onFocusVisible = props.onFocusVisible, onKeyDown = props.onKeyDown, onKeyUp = props.onKeyUp, onMouseDown = props.onMouseDown, onMouseLeave = props.onMouseLeave, onMouseUp = props.onMouseUp, onTouchEnd = props.onTouchEnd, onTouchMove = props.onTouchMove, onTouchStart = props.onTouchStart, onDragLeave = props.onDragLeave, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, TouchRippleProps = props.TouchRippleProps, _props$type = props.type, type = _props$type === void 0 ? "button" : _props$type, other = (0, $kqze3.default)(props, [
        "action",
        "buttonRef",
        "centerRipple",
        "children",
        "classes",
        "className",
        "component",
        "disabled",
        "disableRipple",
        "disableTouchRipple",
        "focusRipple",
        "focusVisibleClassName",
        "onBlur",
        "onClick",
        "onFocus",
        "onFocusVisible",
        "onKeyDown",
        "onKeyUp",
        "onMouseDown",
        "onMouseLeave",
        "onMouseUp",
        "onTouchEnd",
        "onTouchMove",
        "onTouchStart",
        "onDragLeave",
        "tabIndex",
        "TouchRippleProps",
        "type"
    ]);
    var buttonRef = $aaLBe.useRef(null);
    function getButtonNode() {
        // #StrictMode ready
        return $ba021dca0cbd5bec$exports.findDOMNode(buttonRef.current);
    }
    var rippleRef = $aaLBe.useRef(null);
    var _React$useState = $aaLBe.useState(false), focusVisible = _React$useState[0], setFocusVisible = _React$useState[1];
    if (disabled && focusVisible) setFocusVisible(false);
    var _useIsFocusVisible = (0, $c45ba86bf3b3634e$export$2e2bcd8739ae039)(), isFocusVisible = _useIsFocusVisible.isFocusVisible, onBlurVisible = _useIsFocusVisible.onBlurVisible, focusVisibleRef = _useIsFocusVisible.ref;
    $aaLBe.useImperativeHandle(action, function() {
        return {
            focusVisible: function focusVisible() {
                setFocusVisible(true);
                buttonRef.current.focus();
            }
        };
    }, []);
    $aaLBe.useEffect(function() {
        if (focusVisible && focusRipple && !disableRipple) rippleRef.current.pulsate();
    }, [
        disableRipple,
        focusRipple,
        focusVisible
    ]);
    function useRippleHandler(rippleAction, eventCallback) {
        var skipRippleAction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : disableTouchRipple;
        return (0, $7b27a8aad9696ce9$export$2e2bcd8739ae039)(function(event) {
            if (eventCallback) eventCallback(event);
            var ignore = skipRippleAction;
            if (!ignore && rippleRef.current) rippleRef.current[rippleAction](event);
            return true;
        });
    }
    var handleMouseDown = useRippleHandler("start", onMouseDown);
    var handleDragLeave = useRippleHandler("stop", onDragLeave);
    var handleMouseUp = useRippleHandler("stop", onMouseUp);
    var handleMouseLeave = useRippleHandler("stop", function(event) {
        if (focusVisible) event.preventDefault();
        if (onMouseLeave) onMouseLeave(event);
    });
    var handleTouchStart = useRippleHandler("start", onTouchStart);
    var handleTouchEnd = useRippleHandler("stop", onTouchEnd);
    var handleTouchMove = useRippleHandler("stop", onTouchMove);
    var handleBlur = useRippleHandler("stop", function(event) {
        if (focusVisible) {
            onBlurVisible(event);
            setFocusVisible(false);
        }
        if (onBlur) onBlur(event);
    }, false);
    var handleFocus = (0, $7b27a8aad9696ce9$export$2e2bcd8739ae039)(function(event) {
        // Fix for https://github.com/facebook/react/issues/7769
        if (!buttonRef.current) buttonRef.current = event.currentTarget;
        if (isFocusVisible(event)) {
            setFocusVisible(true);
            if (onFocusVisible) onFocusVisible(event);
        }
        if (onFocus) onFocus(event);
    });
    var isNonNativeButton = function isNonNativeButton() {
        var button = getButtonNode();
        return component && component !== "button" && !(button.tagName === "A" && button.href);
    };
    /**
   * IE 11 shim for https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat
   */ var keydownRef = $aaLBe.useRef(false);
    var handleKeyDown = (0, $7b27a8aad9696ce9$export$2e2bcd8739ae039)(function(event) {
        // Check if key is already down to avoid repeats being counted as multiple activations
        if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
            keydownRef.current = true;
            event.persist();
            rippleRef.current.stop(event, function() {
                rippleRef.current.start(event);
            });
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") event.preventDefault();
        if (onKeyDown) onKeyDown(event);
         // Keyboard accessibility for non interactive elements
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
            event.preventDefault();
            if (onClick) onClick(event);
        }
    });
    var handleKeyUp = (0, $7b27a8aad9696ce9$export$2e2bcd8739ae039)(function(event) {
        // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
        // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0
        if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
            keydownRef.current = false;
            event.persist();
            rippleRef.current.stop(event, function() {
                rippleRef.current.pulsate(event);
            });
        }
        if (onKeyUp) onKeyUp(event);
         // Keyboard accessibility for non interactive elements
        if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) onClick(event);
    });
    var ComponentProp = component;
    if (ComponentProp === "button" && other.href) ComponentProp = "a";
    var buttonProps = {};
    if (ComponentProp === "button") {
        buttonProps.type = type;
        buttonProps.disabled = disabled;
    } else {
        if (ComponentProp !== "a" || !other.href) buttonProps.role = "button";
        buttonProps["aria-disabled"] = disabled;
    }
    var handleUserRef = (0, $ec3bc30a9139d143$export$2e2bcd8739ae039)(buttonRefProp, ref);
    var handleOwnRef = (0, $ec3bc30a9139d143$export$2e2bcd8739ae039)(focusVisibleRef, buttonRef);
    var handleRef = (0, $ec3bc30a9139d143$export$2e2bcd8739ae039)(handleUserRef, handleOwnRef);
    var _React$useState2 = $aaLBe.useState(false), mountedState = _React$useState2[0], setMountedState = _React$useState2[1];
    $aaLBe.useEffect(function() {
        setMountedState(true);
    }, []);
    var enableTouchRipple = mountedState && !disableRipple && !disabled;
    return /*#__PURE__*/ $aaLBe.createElement(ComponentProp, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, focusVisible && [
            classes.focusVisible,
            focusVisibleClassName
        ], disabled && classes.disabled),
        onBlur: handleBlur,
        onClick: onClick,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        onMouseLeave: handleMouseLeave,
        onMouseUp: handleMouseUp,
        onDragLeave: handleDragLeave,
        onTouchEnd: handleTouchEnd,
        onTouchMove: handleTouchMove,
        onTouchStart: handleTouchStart,
        ref: handleRef,
        tabIndex: disabled ? -1 : tabIndex
    }, buttonProps, other), children, enableTouchRipple ? /*#__PURE__*/ /* TouchRipple is only needed client-side, x2 boost on the server. */ $aaLBe.createElement((0, $9ffbf3d2079820db$export$2e2bcd8739ae039), (0, $29rXr.default)({
        ref: rippleRef,
        center: centerRipple
    }, TouchRippleProps)) : null);
});
var $c61f5105fcb078ef$export$2e2bcd8739ae039 = (0, $2LmR0.default)($c61f5105fcb078ef$export$9dd6ff9ea0189349, {
    name: "MuiButtonBase"
})($c61f5105fcb078ef$var$ButtonBase);



var $gqsD7 = parcelRequire("gqsD7");
var $391e58f71c9818f8$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            textAlign: "center",
            flex: "0 0 auto",
            fontSize: theme.typography.pxToRem(24),
            padding: 12,
            borderRadius: "50%",
            overflow: "visible",
            // Explicitly set the default value to solve a bug on IE 11.
            color: theme.palette.action.active,
            transition: theme.transitions.create("background-color", {
                duration: theme.transitions.duration.shortest
            }),
            "&:hover": {
                backgroundColor: (0, $5tnPj.alpha)(theme.palette.action.active, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            },
            "&$disabled": {
                backgroundColor: "transparent",
                color: theme.palette.action.disabled
            }
        },
        /* Styles applied to the root element if `edge="start"`. */ edgeStart: {
            marginLeft: -12,
            "$sizeSmall&": {
                marginLeft: -3
            }
        },
        /* Styles applied to the root element if `edge="end"`. */ edgeEnd: {
            marginRight: -12,
            "$sizeSmall&": {
                marginRight: -3
            }
        },
        /* Styles applied to the root element if `color="inherit"`. */ colorInherit: {
            color: "inherit"
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            color: theme.palette.primary.main,
            "&:hover": {
                backgroundColor: (0, $5tnPj.alpha)(theme.palette.primary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        },
        /* Styles applied to the root element if `color="secondary"`. */ colorSecondary: {
            color: theme.palette.secondary.main,
            "&:hover": {
                backgroundColor: (0, $5tnPj.alpha)(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        },
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {},
        /* Styles applied to the root element if `size="small"`. */ sizeSmall: {
            padding: 3,
            fontSize: theme.typography.pxToRem(18)
        },
        /* Styles applied to the children container element. */ label: {
            width: "100%",
            display: "flex",
            alignItems: "inherit",
            justifyContent: "inherit"
        }
    };
};
/**
 * Refer to the [Icons](/components/icons/) section of the documentation
 * regarding the available icon options.
 */ var $391e58f71c9818f8$var$IconButton = /*#__PURE__*/ $aaLBe.forwardRef(function IconButton(props, ref) {
    var _props$edge = props.edge, edge = _props$edge === void 0 ? false : _props$edge, children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "default" : _props$color, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableFocusRi = props.disableFocusRipple, disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, other = (0, $kqze3.default)(props, [
        "edge",
        "children",
        "classes",
        "className",
        "color",
        "disabled",
        "disableFocusRipple",
        "size"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement((0, $c61f5105fcb078ef$export$2e2bcd8739ae039), (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, color !== "default" && classes["color".concat((0, $gqsD7.default)(color))], disabled && classes.disabled, size === "small" && classes["size".concat((0, $gqsD7.default)(size))], {
            "start": classes.edgeStart,
            "end": classes.edgeEnd
        }[edge]),
        centerRipple: true,
        focusRipple: !disableFocusRipple,
        disabled: disabled,
        ref: ref
    }, other), /*#__PURE__*/ $aaLBe.createElement("span", {
        className: classes.label
    }, children));
});
var $391e58f71c9818f8$export$2e2bcd8739ae039 = (0, $2LmR0.default)($391e58f71c9818f8$export$9dd6ff9ea0189349, {
    name: "MuiIconButton"
})($391e58f71c9818f8$var$IconButton);


var $8eb9945f6249aa81$exports = {};
"use strict";


Object.defineProperty($8eb9945f6249aa81$exports, "__esModule", {
    value: true
});
$8eb9945f6249aa81$exports.default = void 0;

var $8eb9945f6249aa81$var$React = $80a9c2f6d1811a06$exports((parcelRequire("aaLBe")));

var $8eb9945f6249aa81$var$_createSvgIcon = $69f4ded615f6c2c8$exports((parcelRequire("jxmMp")));
var $8eb9945f6249aa81$var$_default = (0, $8eb9945f6249aa81$var$_createSvgIcon.default)(/*#__PURE__*/ $8eb9945f6249aa81$var$React.createElement("path", {
    d: "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
}), "ExpandLess");
$8eb9945f6249aa81$exports.default = $8eb9945f6249aa81$var$_default;


var $250892691146d37a$exports = {};
"use strict";


Object.defineProperty($250892691146d37a$exports, "__esModule", {
    value: true
});
$250892691146d37a$exports.default = void 0;

var $250892691146d37a$var$React = $80a9c2f6d1811a06$exports((parcelRequire("aaLBe")));

var $250892691146d37a$var$_createSvgIcon = $69f4ded615f6c2c8$exports((parcelRequire("jxmMp")));
var $250892691146d37a$var$_default = (0, $250892691146d37a$var$_createSvgIcon.default)(/*#__PURE__*/ $250892691146d37a$var$React.createElement("path", {
    d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");
$250892691146d37a$exports.default = $250892691146d37a$var$_default;









function $9d039393e721bc0c$export$2e2bcd8739ae039(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
    if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
}




function $8135bfe43e77e1e7$var$transformLog(x) {
    return Math.log(x);
}
function $8135bfe43e77e1e7$var$transformExp(x) {
    return Math.exp(x);
}
function $8135bfe43e77e1e7$var$transformLogn(x) {
    return -Math.log(-x);
}
function $8135bfe43e77e1e7$var$transformExpn(x) {
    return -Math.exp(-x);
}
function $8135bfe43e77e1e7$var$pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}
function $8135bfe43e77e1e7$var$powp(base) {
    return base === 10 ? $8135bfe43e77e1e7$var$pow10 : base === Math.E ? Math.exp : (x)=>Math.pow(base, x);
}
function $8135bfe43e77e1e7$var$logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x)=>Math.log(x) / base);
}
function $8135bfe43e77e1e7$var$reflect(f) {
    return (x, k)=>-f(-x, k);
}
function $8135bfe43e77e1e7$export$860836db074028f0(transform) {
    const scale = transform($8135bfe43e77e1e7$var$transformLog, $8135bfe43e77e1e7$var$transformExp);
    const domain = scale.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
        logs = $8135bfe43e77e1e7$var$logp(base), pows = $8135bfe43e77e1e7$var$powp(base);
        if (domain()[0] < 0) {
            logs = $8135bfe43e77e1e7$var$reflect(logs), pows = $8135bfe43e77e1e7$var$reflect(pows);
            transform($8135bfe43e77e1e7$var$transformLogn, $8135bfe43e77e1e7$var$transformExpn);
        } else transform($8135bfe43e77e1e7$var$transformLog, $8135bfe43e77e1e7$var$transformExp);
        return scale;
    }
    scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
    };
    scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.ticks = (count)=>{
        const d = domain();
        let u = d[0];
        let v = d[d.length - 1];
        const r = v < u;
        if (r) [u, v] = [
            v,
            u
        ];
        let i = logs(u);
        let j = logs(v);
        let k;
        let t;
        const n = count == null ? 10 : +count;
        let z = [];
        if (!(base % 1) && j - i < n) {
            i = Math.floor(i), j = Math.ceil(j);
            if (u > 0) for(; i <= j; ++i)for(k = 1; k < base; ++k){
                t = i < 0 ? k / pows(-i) : k * pows(i);
                if (t < u) continue;
                if (t > v) break;
                z.push(t);
            }
            else for(; i <= j; ++i)for(k = base - 1; k >= 1; --k){
                t = i > 0 ? k / pows(-i) : k * pows(i);
                if (t < u) continue;
                if (t > v) break;
                z.push(t);
            }
            if (z.length * 2 < n) z = (0, $13e83a9ae37bfd32$export$2e2bcd8739ae039)(u, v, n);
        } else z = (0, $13e83a9ae37bfd32$export$2e2bcd8739ae039)(i, j, Math.min(j - i, n)).map(pows);
        return r ? z.reverse() : z;
    };
    scale.tickFormat = (count, specifier)=>{
        if (count == null) count = 10;
        if (specifier == null) specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
            if (!(base % 1) && (specifier = (0, $babd3c0ee933dbfb$export$2e2bcd8739ae039)(specifier)).precision == null) specifier.trim = true;
            specifier = (0, $23de77130e6fabd5$export$d9468344d3651243)(specifier);
        }
        if (count === Infinity) return specifier;
        const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return (d)=>{
            let i = d / pows(Math.round(logs(d)));
            if (i * base < base - 0.5) i *= base;
            return i <= k ? specifier(d) : "";
        };
    };
    scale.nice = ()=>{
        return domain((0, $9d039393e721bc0c$export$2e2bcd8739ae039)(domain(), {
            floor: (x)=>pows(Math.floor(logs(x))),
            ceil: (x)=>pows(Math.ceil(logs(x)))
        }));
    };
    return scale;
}
function $8135bfe43e77e1e7$export$2e2bcd8739ae039() {
    const scale = $8135bfe43e77e1e7$export$860836db074028f0((0, $d1720577d8838e88$export$6b468dcfb64c653c)()).domain([
        1,
        10
    ]);
    scale.copy = ()=>(0, $d1720577d8838e88$export$784d13d8ee351f07)(scale, $8135bfe43e77e1e7$export$2e2bcd8739ae039()).base(scale.base());
    (0, $a672075a618c81db$export$23c7bb9e6558da2a).apply(scale, arguments);
    return scale;
}





function $78d890155e0c3bc0$var$transformSymlog(c) {
    return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
    };
}
function $78d890155e0c3bc0$var$transformSymexp(c) {
    return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
    };
}
function $78d890155e0c3bc0$export$4602684e614eba38(transform) {
    var c = 1, scale = transform($78d890155e0c3bc0$var$transformSymlog(c), $78d890155e0c3bc0$var$transformSymexp(c));
    scale.constant = function(_) {
        return arguments.length ? transform($78d890155e0c3bc0$var$transformSymlog(c = +_), $78d890155e0c3bc0$var$transformSymexp(c)) : c;
    };
    return (0, $46dd7dd0ac807af9$export$16a5d4b4a61a274d)(scale);
}
function $78d890155e0c3bc0$export$2e2bcd8739ae039() {
    var scale = $78d890155e0c3bc0$export$4602684e614eba38((0, $d1720577d8838e88$export$6b468dcfb64c653c)());
    scale.copy = function() {
        return (0, $d1720577d8838e88$export$784d13d8ee351f07)(scale, $78d890155e0c3bc0$export$2e2bcd8739ae039()).constant(scale.constant());
    };
    return (0, $a672075a618c81db$export$23c7bb9e6558da2a).apply(scale, arguments);
}





function $720ef613fc169f9e$var$transformPow(exponent) {
    return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    };
}
function $720ef613fc169f9e$var$transformSqrt(x) {
    return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}
function $720ef613fc169f9e$var$transformSquare(x) {
    return x < 0 ? -x * x : x * x;
}
function $720ef613fc169f9e$export$34695211ec403a46(transform) {
    var scale = transform((0, $d1720577d8838e88$export$f0954fd7d5368655), (0, $d1720577d8838e88$export$f0954fd7d5368655)), exponent = 1;
    function rescale() {
        return exponent === 1 ? transform((0, $d1720577d8838e88$export$f0954fd7d5368655), (0, $d1720577d8838e88$export$f0954fd7d5368655)) : exponent === 0.5 ? transform($720ef613fc169f9e$var$transformSqrt, $720ef613fc169f9e$var$transformSquare) : transform($720ef613fc169f9e$var$transformPow(exponent), $720ef613fc169f9e$var$transformPow(1 / exponent));
    }
    scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
    };
    return (0, $46dd7dd0ac807af9$export$16a5d4b4a61a274d)(scale);
}
function $720ef613fc169f9e$export$2e2bcd8739ae039() {
    var scale = $720ef613fc169f9e$export$34695211ec403a46((0, $d1720577d8838e88$export$6b468dcfb64c653c)());
    scale.copy = function() {
        return (0, $d1720577d8838e88$export$784d13d8ee351f07)(scale, $720ef613fc169f9e$export$2e2bcd8739ae039()).exponent(scale.exponent());
    };
    (0, $a672075a618c81db$export$23c7bb9e6558da2a).apply(scale, arguments);
    return scale;
}
function $720ef613fc169f9e$export$eba8049fb5020b81() {
    return $720ef613fc169f9e$export$2e2bcd8739ae039.apply(null, arguments).exponent(0.5);
}


function $231f47eacdf10284$var$transformer() {
    var x0 = 0, x1 = 1, t0, t1, k10, transform, interpolator = (0, $d1720577d8838e88$export$f0954fd7d5368655), clamp = false, unknown;
    function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
    }
    scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [
            x0,
            x1
        ];
    };
    scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
    };
    scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
    };
    function range(interpolate) {
        return function(_) {
            var r0, r1;
            return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [
                interpolator(0),
                interpolator(1)
            ];
        };
    }
    scale.range = range((0, $d6f598373d8c7921$export$2e2bcd8739ae039));
    scale.rangeRound = range((0, $17ba21bccb8f8ee4$export$2e2bcd8739ae039));
    scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
    };
}
function $231f47eacdf10284$export$784d13d8ee351f07(source, target) {
    return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function $231f47eacdf10284$export$2e2bcd8739ae039() {
    var scale = (0, $46dd7dd0ac807af9$export$16a5d4b4a61a274d)($231f47eacdf10284$var$transformer()((0, $d1720577d8838e88$export$f0954fd7d5368655)));
    scale.copy = function() {
        return $231f47eacdf10284$export$784d13d8ee351f07(scale, $231f47eacdf10284$export$2e2bcd8739ae039());
    };
    return (0, $a672075a618c81db$export$7d6b419e59e83f3d).apply(scale, arguments);
}
function $231f47eacdf10284$export$6843e08bf2ff981f() {
    var scale = (0, $8135bfe43e77e1e7$export$860836db074028f0)($231f47eacdf10284$var$transformer()).domain([
        1,
        10
    ]);
    scale.copy = function() {
        return $231f47eacdf10284$export$784d13d8ee351f07(scale, $231f47eacdf10284$export$6843e08bf2ff981f()).base(scale.base());
    };
    return (0, $a672075a618c81db$export$7d6b419e59e83f3d).apply(scale, arguments);
}
function $231f47eacdf10284$export$9d4af4de62c81941() {
    var scale = (0, $78d890155e0c3bc0$export$4602684e614eba38)($231f47eacdf10284$var$transformer());
    scale.copy = function() {
        return $231f47eacdf10284$export$784d13d8ee351f07(scale, $231f47eacdf10284$export$9d4af4de62c81941()).constant(scale.constant());
    };
    return (0, $a672075a618c81db$export$7d6b419e59e83f3d).apply(scale, arguments);
}
function $231f47eacdf10284$export$de9f78581b4f2405() {
    var scale = (0, $720ef613fc169f9e$export$34695211ec403a46)($231f47eacdf10284$var$transformer());
    scale.copy = function() {
        return $231f47eacdf10284$export$784d13d8ee351f07(scale, $231f47eacdf10284$export$de9f78581b4f2405()).exponent(scale.exponent());
    };
    return (0, $a672075a618c81db$export$7d6b419e59e83f3d).apply(scale, arguments);
}
function $231f47eacdf10284$export$413d935127ed466e() {
    return $231f47eacdf10284$export$de9f78581b4f2405.apply(null, arguments).exponent(0.5);
}




const $a2371c3fd6aa3c7a$export$8449e153fbd325fc = Math.PI / 180;
const $a2371c3fd6aa3c7a$export$41fc368e1a942b97 = 180 / Math.PI;


var $53dc595e19a670f7$var$A = -0.14861, $53dc595e19a670f7$var$B = 1.78277, $53dc595e19a670f7$var$C = -0.29227, $53dc595e19a670f7$var$D = -0.90649, $53dc595e19a670f7$var$E = 1.97294, $53dc595e19a670f7$var$ED = $53dc595e19a670f7$var$E * $53dc595e19a670f7$var$D, $53dc595e19a670f7$var$EB = $53dc595e19a670f7$var$E * $53dc595e19a670f7$var$B, $53dc595e19a670f7$var$BC_DA = $53dc595e19a670f7$var$B * $53dc595e19a670f7$var$C - $53dc595e19a670f7$var$D * $53dc595e19a670f7$var$A;
function $53dc595e19a670f7$var$cubehelixConvert(o) {
    if (o instanceof $53dc595e19a670f7$export$57ed4bde61a1e2f2) return new $53dc595e19a670f7$export$57ed4bde61a1e2f2(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof (0, $cf694006e2c2e1e2$export$5e05a94393ac29e3))) o = (0, $cf694006e2c2e1e2$export$42da0a331c2802f5)(o);
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = ($53dc595e19a670f7$var$BC_DA * b + $53dc595e19a670f7$var$ED * r - $53dc595e19a670f7$var$EB * g) / ($53dc595e19a670f7$var$BC_DA + $53dc595e19a670f7$var$ED - $53dc595e19a670f7$var$EB), bl = b - l, k = ($53dc595e19a670f7$var$E * (g - l) - $53dc595e19a670f7$var$C * bl) / $53dc595e19a670f7$var$D, s = Math.sqrt(k * k + bl * bl) / ($53dc595e19a670f7$var$E * l * (1 - l)), h = s ? Math.atan2(k, bl) * (0, $a2371c3fd6aa3c7a$export$41fc368e1a942b97) - 120 : NaN;
    return new $53dc595e19a670f7$export$57ed4bde61a1e2f2(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function $53dc595e19a670f7$export$2e2bcd8739ae039(h, s, l, opacity) {
    return arguments.length === 1 ? $53dc595e19a670f7$var$cubehelixConvert(h) : new $53dc595e19a670f7$export$57ed4bde61a1e2f2(h, s, l, opacity == null ? 1 : opacity);
}
function $53dc595e19a670f7$export$57ed4bde61a1e2f2(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
}
(0, $901f80c70ca6856e$export$2e2bcd8739ae039)($53dc595e19a670f7$export$57ed4bde61a1e2f2, $53dc595e19a670f7$export$2e2bcd8739ae039, (0, $901f80c70ca6856e$export$8b58be045bf06082)((0, $cf694006e2c2e1e2$export$892596cec99bc70e), {
    brighter (k) {
        k = k == null ? (0, $cf694006e2c2e1e2$export$9eace2cc0d12c98d) : Math.pow((0, $cf694006e2c2e1e2$export$9eace2cc0d12c98d), k);
        return new $53dc595e19a670f7$export$57ed4bde61a1e2f2(this.h, this.s, this.l * k, this.opacity);
    },
    darker (k) {
        k = k == null ? (0, $cf694006e2c2e1e2$export$4adafc6ed0600c10) : Math.pow((0, $cf694006e2c2e1e2$export$4adafc6ed0600c10), k);
        return new $53dc595e19a670f7$export$57ed4bde61a1e2f2(this.h, this.s, this.l * k, this.opacity);
    },
    rgb () {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * (0, $a2371c3fd6aa3c7a$export$8449e153fbd325fc), l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
        return new (0, $cf694006e2c2e1e2$export$5e05a94393ac29e3)(255 * (l + a * ($53dc595e19a670f7$var$A * cosh + $53dc595e19a670f7$var$B * sinh)), 255 * (l + a * ($53dc595e19a670f7$var$C * cosh + $53dc595e19a670f7$var$D * sinh)), 255 * (l + a * ($53dc595e19a670f7$var$E * cosh)), this.opacity);
    }
}));




function $aaff42e6950eead5$var$cubehelix(hue) {
    return function cubehelixGamma(y) {
        y = +y;
        function cubehelix(start, end) {
            var h = hue((start = (0, $53dc595e19a670f7$export$2e2bcd8739ae039)(start)).h, (end = (0, $53dc595e19a670f7$export$2e2bcd8739ae039)(end)).h), s = (0, $129eda5b6d4cb725$export$2e2bcd8739ae039)(start.s, end.s), l = (0, $129eda5b6d4cb725$export$2e2bcd8739ae039)(start.l, end.l), opacity = (0, $129eda5b6d4cb725$export$2e2bcd8739ae039)(start.opacity, end.opacity);
            return function(t) {
                start.h = h(t);
                start.s = s(t);
                start.l = l(Math.pow(t, y));
                start.opacity = opacity(t);
                return start + "";
            };
        }
        cubehelix.gamma = cubehelixGamma;
        return cubehelix;
    }(1);
}
var $aaff42e6950eead5$export$2e2bcd8739ae039 = $aaff42e6950eead5$var$cubehelix((0, $129eda5b6d4cb725$export$97d7b0c7ddb78dcf));
var $aaff42e6950eead5$export$934fa09ad474a1b4 = $aaff42e6950eead5$var$cubehelix((0, $129eda5b6d4cb725$export$2e2bcd8739ae039));


var $2bc0efb4f93ab16b$export$fc70efcec537be98 = (0, $aaff42e6950eead5$export$934fa09ad474a1b4)((0, $53dc595e19a670f7$export$2e2bcd8739ae039)(-100, 0.75, 0.35), (0, $53dc595e19a670f7$export$2e2bcd8739ae039)(80, 1.50, 0.8));
var $2bc0efb4f93ab16b$export$c5cedbc1ab3be2c3 = (0, $aaff42e6950eead5$export$934fa09ad474a1b4)((0, $53dc595e19a670f7$export$2e2bcd8739ae039)(260, 0.75, 0.35), (0, $53dc595e19a670f7$export$2e2bcd8739ae039)(80, 1.50, 0.8));
var $2bc0efb4f93ab16b$var$c = (0, $53dc595e19a670f7$export$2e2bcd8739ae039)();
function $2bc0efb4f93ab16b$export$2e2bcd8739ae039(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    $2bc0efb4f93ab16b$var$c.h = 360 * t - 100;
    $2bc0efb4f93ab16b$var$c.s = 1.5 - 1.5 * ts;
    $2bc0efb4f93ab16b$var$c.l = 0.8 - 0.9 * ts;
    return $2bc0efb4f93ab16b$var$c + "";
}





var $aaLBe = parcelRequire("aaLBe");

var $aaLBe = parcelRequire("aaLBe");

var $3RiQf = parcelRequire("3RiQf");
var $3fcb7c8379d80fb4$exports = {};
var $1e6496c3d238466f$exports = {};
// GENERATED DO NOT EDIT
$1e6496c3d238466f$exports = [
    "alignContent",
    "MozAlignContent",
    "WebkitAlignContent",
    "MSAlignContent",
    "OAlignContent",
    "alignItems",
    "MozAlignItems",
    "WebkitAlignItems",
    "MSAlignItems",
    "OAlignItems",
    "alignSelf",
    "MozAlignSelf",
    "WebkitAlignSelf",
    "MSAlignSelf",
    "OAlignSelf",
    "all",
    "MozAll",
    "WebkitAll",
    "MSAll",
    "OAll",
    "animation",
    "MozAnimation",
    "WebkitAnimation",
    "MSAnimation",
    "OAnimation",
    "animationDelay",
    "MozAnimationDelay",
    "WebkitAnimationDelay",
    "MSAnimationDelay",
    "OAnimationDelay",
    "animationDirection",
    "MozAnimationDirection",
    "WebkitAnimationDirection",
    "MSAnimationDirection",
    "OAnimationDirection",
    "animationDuration",
    "MozAnimationDuration",
    "WebkitAnimationDuration",
    "MSAnimationDuration",
    "OAnimationDuration",
    "animationFillMode",
    "MozAnimationFillMode",
    "WebkitAnimationFillMode",
    "MSAnimationFillMode",
    "OAnimationFillMode",
    "animationIterationCount",
    "MozAnimationIterationCount",
    "WebkitAnimationIterationCount",
    "MSAnimationIterationCount",
    "OAnimationIterationCount",
    "animationName",
    "MozAnimationName",
    "WebkitAnimationName",
    "MSAnimationName",
    "OAnimationName",
    "animationPlayState",
    "MozAnimationPlayState",
    "WebkitAnimationPlayState",
    "MSAnimationPlayState",
    "OAnimationPlayState",
    "animationTimingFunction",
    "MozAnimationTimingFunction",
    "WebkitAnimationTimingFunction",
    "MSAnimationTimingFunction",
    "OAnimationTimingFunction",
    "backfaceVisibility",
    "MozBackfaceVisibility",
    "WebkitBackfaceVisibility",
    "MSBackfaceVisibility",
    "OBackfaceVisibility",
    "background",
    "MozBackground",
    "WebkitBackground",
    "MSBackground",
    "OBackground",
    "backgroundAttachment",
    "MozBackgroundAttachment",
    "WebkitBackgroundAttachment",
    "MSBackgroundAttachment",
    "OBackgroundAttachment",
    "backgroundBlendMode",
    "MozBackgroundBlendMode",
    "WebkitBackgroundBlendMode",
    "MSBackgroundBlendMode",
    "OBackgroundBlendMode",
    "backgroundClip",
    "MozBackgroundClip",
    "WebkitBackgroundClip",
    "MSBackgroundClip",
    "OBackgroundClip",
    "backgroundColor",
    "MozBackgroundColor",
    "WebkitBackgroundColor",
    "MSBackgroundColor",
    "OBackgroundColor",
    "backgroundImage",
    "MozBackgroundImage",
    "WebkitBackgroundImage",
    "MSBackgroundImage",
    "OBackgroundImage",
    "backgroundOrigin",
    "MozBackgroundOrigin",
    "WebkitBackgroundOrigin",
    "MSBackgroundOrigin",
    "OBackgroundOrigin",
    "backgroundPosition",
    "MozBackgroundPosition",
    "WebkitBackgroundPosition",
    "MSBackgroundPosition",
    "OBackgroundPosition",
    "backgroundRepeat",
    "MozBackgroundRepeat",
    "WebkitBackgroundRepeat",
    "MSBackgroundRepeat",
    "OBackgroundRepeat",
    "backgroundSize",
    "MozBackgroundSize",
    "WebkitBackgroundSize",
    "MSBackgroundSize",
    "OBackgroundSize",
    "blockSize",
    "MozBlockSize",
    "WebkitBlockSize",
    "MSBlockSize",
    "OBlockSize",
    "border",
    "MozBorder",
    "WebkitBorder",
    "MSBorder",
    "OBorder",
    "borderBlockEnd",
    "MozBorderBlockEnd",
    "WebkitBorderBlockEnd",
    "MSBorderBlockEnd",
    "OBorderBlockEnd",
    "borderBlockEndColor",
    "MozBorderBlockEndColor",
    "WebkitBorderBlockEndColor",
    "MSBorderBlockEndColor",
    "OBorderBlockEndColor",
    "borderBlockEndStyle",
    "MozBorderBlockEndStyle",
    "WebkitBorderBlockEndStyle",
    "MSBorderBlockEndStyle",
    "OBorderBlockEndStyle",
    "borderBlockEndWidth",
    "MozBorderBlockEndWidth",
    "WebkitBorderBlockEndWidth",
    "MSBorderBlockEndWidth",
    "OBorderBlockEndWidth",
    "borderBlockStart",
    "MozBorderBlockStart",
    "WebkitBorderBlockStart",
    "MSBorderBlockStart",
    "OBorderBlockStart",
    "borderBlockStartColor",
    "MozBorderBlockStartColor",
    "WebkitBorderBlockStartColor",
    "MSBorderBlockStartColor",
    "OBorderBlockStartColor",
    "borderBlockStartStyle",
    "MozBorderBlockStartStyle",
    "WebkitBorderBlockStartStyle",
    "MSBorderBlockStartStyle",
    "OBorderBlockStartStyle",
    "borderBlockStartWidth",
    "MozBorderBlockStartWidth",
    "WebkitBorderBlockStartWidth",
    "MSBorderBlockStartWidth",
    "OBorderBlockStartWidth",
    "borderBottom",
    "MozBorderBottom",
    "WebkitBorderBottom",
    "MSBorderBottom",
    "OBorderBottom",
    "borderBottomColor",
    "MozBorderBottomColor",
    "WebkitBorderBottomColor",
    "MSBorderBottomColor",
    "OBorderBottomColor",
    "borderBottomLeftRadius",
    "MozBorderBottomLeftRadius",
    "WebkitBorderBottomLeftRadius",
    "MSBorderBottomLeftRadius",
    "OBorderBottomLeftRadius",
    "borderBottomRightRadius",
    "MozBorderBottomRightRadius",
    "WebkitBorderBottomRightRadius",
    "MSBorderBottomRightRadius",
    "OBorderBottomRightRadius",
    "borderBottomStyle",
    "MozBorderBottomStyle",
    "WebkitBorderBottomStyle",
    "MSBorderBottomStyle",
    "OBorderBottomStyle",
    "borderBottomWidth",
    "MozBorderBottomWidth",
    "WebkitBorderBottomWidth",
    "MSBorderBottomWidth",
    "OBorderBottomWidth",
    "borderCollapse",
    "MozBorderCollapse",
    "WebkitBorderCollapse",
    "MSBorderCollapse",
    "OBorderCollapse",
    "borderColor",
    "MozBorderColor",
    "WebkitBorderColor",
    "MSBorderColor",
    "OBorderColor",
    "borderImage",
    "MozBorderImage",
    "WebkitBorderImage",
    "MSBorderImage",
    "OBorderImage",
    "borderImageOutset",
    "MozBorderImageOutset",
    "WebkitBorderImageOutset",
    "MSBorderImageOutset",
    "OBorderImageOutset",
    "borderImageRepeat",
    "MozBorderImageRepeat",
    "WebkitBorderImageRepeat",
    "MSBorderImageRepeat",
    "OBorderImageRepeat",
    "borderImageSlice",
    "MozBorderImageSlice",
    "WebkitBorderImageSlice",
    "MSBorderImageSlice",
    "OBorderImageSlice",
    "borderImageSource",
    "MozBorderImageSource",
    "WebkitBorderImageSource",
    "MSBorderImageSource",
    "OBorderImageSource",
    "borderImageWidth",
    "MozBorderImageWidth",
    "WebkitBorderImageWidth",
    "MSBorderImageWidth",
    "OBorderImageWidth",
    "borderInlineEnd",
    "MozBorderInlineEnd",
    "WebkitBorderInlineEnd",
    "MSBorderInlineEnd",
    "OBorderInlineEnd",
    "borderInlineEndColor",
    "MozBorderInlineEndColor",
    "WebkitBorderInlineEndColor",
    "MSBorderInlineEndColor",
    "OBorderInlineEndColor",
    "borderInlineEndStyle",
    "MozBorderInlineEndStyle",
    "WebkitBorderInlineEndStyle",
    "MSBorderInlineEndStyle",
    "OBorderInlineEndStyle",
    "borderInlineEndWidth",
    "MozBorderInlineEndWidth",
    "WebkitBorderInlineEndWidth",
    "MSBorderInlineEndWidth",
    "OBorderInlineEndWidth",
    "borderInlineStart",
    "MozBorderInlineStart",
    "WebkitBorderInlineStart",
    "MSBorderInlineStart",
    "OBorderInlineStart",
    "borderInlineStartColor",
    "MozBorderInlineStartColor",
    "WebkitBorderInlineStartColor",
    "MSBorderInlineStartColor",
    "OBorderInlineStartColor",
    "borderInlineStartStyle",
    "MozBorderInlineStartStyle",
    "WebkitBorderInlineStartStyle",
    "MSBorderInlineStartStyle",
    "OBorderInlineStartStyle",
    "borderInlineStartWidth",
    "MozBorderInlineStartWidth",
    "WebkitBorderInlineStartWidth",
    "MSBorderInlineStartWidth",
    "OBorderInlineStartWidth",
    "borderLeft",
    "MozBorderLeft",
    "WebkitBorderLeft",
    "MSBorderLeft",
    "OBorderLeft",
    "borderLeftColor",
    "MozBorderLeftColor",
    "WebkitBorderLeftColor",
    "MSBorderLeftColor",
    "OBorderLeftColor",
    "borderLeftStyle",
    "MozBorderLeftStyle",
    "WebkitBorderLeftStyle",
    "MSBorderLeftStyle",
    "OBorderLeftStyle",
    "borderLeftWidth",
    "MozBorderLeftWidth",
    "WebkitBorderLeftWidth",
    "MSBorderLeftWidth",
    "OBorderLeftWidth",
    "borderRadius",
    "MozBorderRadius",
    "WebkitBorderRadius",
    "MSBorderRadius",
    "OBorderRadius",
    "borderRight",
    "MozBorderRight",
    "WebkitBorderRight",
    "MSBorderRight",
    "OBorderRight",
    "borderRightColor",
    "MozBorderRightColor",
    "WebkitBorderRightColor",
    "MSBorderRightColor",
    "OBorderRightColor",
    "borderRightStyle",
    "MozBorderRightStyle",
    "WebkitBorderRightStyle",
    "MSBorderRightStyle",
    "OBorderRightStyle",
    "borderRightWidth",
    "MozBorderRightWidth",
    "WebkitBorderRightWidth",
    "MSBorderRightWidth",
    "OBorderRightWidth",
    "borderSpacing",
    "MozBorderSpacing",
    "WebkitBorderSpacing",
    "MSBorderSpacing",
    "OBorderSpacing",
    "borderStyle",
    "MozBorderStyle",
    "WebkitBorderStyle",
    "MSBorderStyle",
    "OBorderStyle",
    "borderTop",
    "MozBorderTop",
    "WebkitBorderTop",
    "MSBorderTop",
    "OBorderTop",
    "borderTopColor",
    "MozBorderTopColor",
    "WebkitBorderTopColor",
    "MSBorderTopColor",
    "OBorderTopColor",
    "borderTopLeftRadius",
    "MozBorderTopLeftRadius",
    "WebkitBorderTopLeftRadius",
    "MSBorderTopLeftRadius",
    "OBorderTopLeftRadius",
    "borderTopRightRadius",
    "MozBorderTopRightRadius",
    "WebkitBorderTopRightRadius",
    "MSBorderTopRightRadius",
    "OBorderTopRightRadius",
    "borderTopStyle",
    "MozBorderTopStyle",
    "WebkitBorderTopStyle",
    "MSBorderTopStyle",
    "OBorderTopStyle",
    "borderTopWidth",
    "MozBorderTopWidth",
    "WebkitBorderTopWidth",
    "MSBorderTopWidth",
    "OBorderTopWidth",
    "borderWidth",
    "MozBorderWidth",
    "WebkitBorderWidth",
    "MSBorderWidth",
    "OBorderWidth",
    "bottom",
    "MozBottom",
    "WebkitBottom",
    "MSBottom",
    "OBottom",
    "boxDecorationBreak",
    "MozBoxDecorationBreak",
    "WebkitBoxDecorationBreak",
    "MSBoxDecorationBreak",
    "OBoxDecorationBreak",
    "boxShadow",
    "MozBoxShadow",
    "WebkitBoxShadow",
    "MSBoxShadow",
    "OBoxShadow",
    "boxSizing",
    "MozBoxSizing",
    "WebkitBoxSizing",
    "MSBoxSizing",
    "OBoxSizing",
    "breakAfter",
    "MozBreakAfter",
    "WebkitBreakAfter",
    "MSBreakAfter",
    "OBreakAfter",
    "breakBefore",
    "MozBreakBefore",
    "WebkitBreakBefore",
    "MSBreakBefore",
    "OBreakBefore",
    "breakInside",
    "MozBreakInside",
    "WebkitBreakInside",
    "MSBreakInside",
    "OBreakInside",
    "captionSide",
    "MozCaptionSide",
    "WebkitCaptionSide",
    "MSCaptionSide",
    "OCaptionSide",
    "caretColor",
    "MozCaretColor",
    "WebkitCaretColor",
    "MSCaretColor",
    "OCaretColor",
    "ch",
    "MozCh",
    "WebkitCh",
    "MSCh",
    "OCh",
    "clear",
    "MozClear",
    "WebkitClear",
    "MSClear",
    "OClear",
    "clip",
    "MozClip",
    "WebkitClip",
    "MSClip",
    "OClip",
    "clipPath",
    "MozClipPath",
    "WebkitClipPath",
    "MSClipPath",
    "OClipPath",
    "cm",
    "MozCm",
    "WebkitCm",
    "MSCm",
    "OCm",
    "color",
    "MozColor",
    "WebkitColor",
    "MSColor",
    "OColor",
    "columnCount",
    "MozColumnCount",
    "WebkitColumnCount",
    "MSColumnCount",
    "OColumnCount",
    "columnFill",
    "MozColumnFill",
    "WebkitColumnFill",
    "MSColumnFill",
    "OColumnFill",
    "columnGap",
    "MozColumnGap",
    "WebkitColumnGap",
    "MSColumnGap",
    "OColumnGap",
    "columnRule",
    "MozColumnRule",
    "WebkitColumnRule",
    "MSColumnRule",
    "OColumnRule",
    "columnRuleColor",
    "MozColumnRuleColor",
    "WebkitColumnRuleColor",
    "MSColumnRuleColor",
    "OColumnRuleColor",
    "columnRuleStyle",
    "MozColumnRuleStyle",
    "WebkitColumnRuleStyle",
    "MSColumnRuleStyle",
    "OColumnRuleStyle",
    "columnRuleWidth",
    "MozColumnRuleWidth",
    "WebkitColumnRuleWidth",
    "MSColumnRuleWidth",
    "OColumnRuleWidth",
    "columnSpan",
    "MozColumnSpan",
    "WebkitColumnSpan",
    "MSColumnSpan",
    "OColumnSpan",
    "columnWidth",
    "MozColumnWidth",
    "WebkitColumnWidth",
    "MSColumnWidth",
    "OColumnWidth",
    "columns",
    "MozColumns",
    "WebkitColumns",
    "MSColumns",
    "OColumns",
    "content",
    "MozContent",
    "WebkitContent",
    "MSContent",
    "OContent",
    "counterIncrement",
    "MozCounterIncrement",
    "WebkitCounterIncrement",
    "MSCounterIncrement",
    "OCounterIncrement",
    "counterReset",
    "MozCounterReset",
    "WebkitCounterReset",
    "MSCounterReset",
    "OCounterReset",
    "cursor",
    "MozCursor",
    "WebkitCursor",
    "MSCursor",
    "OCursor",
    "deg",
    "MozDeg",
    "WebkitDeg",
    "MSDeg",
    "ODeg",
    "direction",
    "MozDirection",
    "WebkitDirection",
    "MSDirection",
    "ODirection",
    "display",
    "MozDisplay",
    "WebkitDisplay",
    "MSDisplay",
    "ODisplay",
    "dpcm",
    "MozDpcm",
    "WebkitDpcm",
    "MSDpcm",
    "ODpcm",
    "dpi",
    "MozDpi",
    "WebkitDpi",
    "MSDpi",
    "ODpi",
    "dppx",
    "MozDppx",
    "WebkitDppx",
    "MSDppx",
    "ODppx",
    "em",
    "MozEm",
    "WebkitEm",
    "MSEm",
    "OEm",
    "emptyCells",
    "MozEmptyCells",
    "WebkitEmptyCells",
    "MSEmptyCells",
    "OEmptyCells",
    "ex",
    "MozEx",
    "WebkitEx",
    "MSEx",
    "OEx",
    "filter",
    "MozFilter",
    "WebkitFilter",
    "MSFilter",
    "OFilter",
    "flexBasis",
    "MozFlexBasis",
    "WebkitFlexBasis",
    "MSFlexBasis",
    "OFlexBasis",
    "flexDirection",
    "MozFlexDirection",
    "WebkitFlexDirection",
    "MSFlexDirection",
    "OFlexDirection",
    "flexFlow",
    "MozFlexFlow",
    "WebkitFlexFlow",
    "MSFlexFlow",
    "OFlexFlow",
    "flexGrow",
    "MozFlexGrow",
    "WebkitFlexGrow",
    "MSFlexGrow",
    "OFlexGrow",
    "flexShrink",
    "MozFlexShrink",
    "WebkitFlexShrink",
    "MSFlexShrink",
    "OFlexShrink",
    "flexWrap",
    "MozFlexWrap",
    "WebkitFlexWrap",
    "MSFlexWrap",
    "OFlexWrap",
    "float",
    "MozFloat",
    "WebkitFloat",
    "MSFloat",
    "OFloat",
    "font",
    "MozFont",
    "WebkitFont",
    "MSFont",
    "OFont",
    "fontFamily",
    "MozFontFamily",
    "WebkitFontFamily",
    "MSFontFamily",
    "OFontFamily",
    "fontFeatureSettings",
    "MozFontFeatureSettings",
    "WebkitFontFeatureSettings",
    "MSFontFeatureSettings",
    "OFontFeatureSettings",
    "fontKerning",
    "MozFontKerning",
    "WebkitFontKerning",
    "MSFontKerning",
    "OFontKerning",
    "fontLanguageOverride",
    "MozFontLanguageOverride",
    "WebkitFontLanguageOverride",
    "MSFontLanguageOverride",
    "OFontLanguageOverride",
    "fontSize",
    "MozFontSize",
    "WebkitFontSize",
    "MSFontSize",
    "OFontSize",
    "fontSizeAdjust",
    "MozFontSizeAdjust",
    "WebkitFontSizeAdjust",
    "MSFontSizeAdjust",
    "OFontSizeAdjust",
    "fontStretch",
    "MozFontStretch",
    "WebkitFontStretch",
    "MSFontStretch",
    "OFontStretch",
    "fontStyle",
    "MozFontStyle",
    "WebkitFontStyle",
    "MSFontStyle",
    "OFontStyle",
    "fontSynthesis",
    "MozFontSynthesis",
    "WebkitFontSynthesis",
    "MSFontSynthesis",
    "OFontSynthesis",
    "fontVariant",
    "MozFontVariant",
    "WebkitFontVariant",
    "MSFontVariant",
    "OFontVariant",
    "fontVariantAlternates",
    "MozFontVariantAlternates",
    "WebkitFontVariantAlternates",
    "MSFontVariantAlternates",
    "OFontVariantAlternates",
    "fontVariantCaps",
    "MozFontVariantCaps",
    "WebkitFontVariantCaps",
    "MSFontVariantCaps",
    "OFontVariantCaps",
    "fontVariantEastAsian",
    "MozFontVariantEastAsian",
    "WebkitFontVariantEastAsian",
    "MSFontVariantEastAsian",
    "OFontVariantEastAsian",
    "fontVariantLigatures",
    "MozFontVariantLigatures",
    "WebkitFontVariantLigatures",
    "MSFontVariantLigatures",
    "OFontVariantLigatures",
    "fontVariantNumeric",
    "MozFontVariantNumeric",
    "WebkitFontVariantNumeric",
    "MSFontVariantNumeric",
    "OFontVariantNumeric",
    "fontVariantPosition",
    "MozFontVariantPosition",
    "WebkitFontVariantPosition",
    "MSFontVariantPosition",
    "OFontVariantPosition",
    "fontWeight",
    "MozFontWeight",
    "WebkitFontWeight",
    "MSFontWeight",
    "OFontWeight",
    "fr",
    "MozFr",
    "WebkitFr",
    "MSFr",
    "OFr",
    "grad",
    "MozGrad",
    "WebkitGrad",
    "MSGrad",
    "OGrad",
    "grid",
    "MozGrid",
    "WebkitGrid",
    "MSGrid",
    "OGrid",
    "gridArea",
    "MozGridArea",
    "WebkitGridArea",
    "MSGridArea",
    "OGridArea",
    "gridAutoColumns",
    "MozGridAutoColumns",
    "WebkitGridAutoColumns",
    "MSGridAutoColumns",
    "OGridAutoColumns",
    "gridAutoFlow",
    "MozGridAutoFlow",
    "WebkitGridAutoFlow",
    "MSGridAutoFlow",
    "OGridAutoFlow",
    "gridAutoRows",
    "MozGridAutoRows",
    "WebkitGridAutoRows",
    "MSGridAutoRows",
    "OGridAutoRows",
    "gridColumn",
    "MozGridColumn",
    "WebkitGridColumn",
    "MSGridColumn",
    "OGridColumn",
    "gridColumnEnd",
    "MozGridColumnEnd",
    "WebkitGridColumnEnd",
    "MSGridColumnEnd",
    "OGridColumnEnd",
    "gridColumnGap",
    "MozGridColumnGap",
    "WebkitGridColumnGap",
    "MSGridColumnGap",
    "OGridColumnGap",
    "gridColumnStart",
    "MozGridColumnStart",
    "WebkitGridColumnStart",
    "MSGridColumnStart",
    "OGridColumnStart",
    "gridGap",
    "MozGridGap",
    "WebkitGridGap",
    "MSGridGap",
    "OGridGap",
    "gridRow",
    "MozGridRow",
    "WebkitGridRow",
    "MSGridRow",
    "OGridRow",
    "gridRowEnd",
    "MozGridRowEnd",
    "WebkitGridRowEnd",
    "MSGridRowEnd",
    "OGridRowEnd",
    "gridRowGap",
    "MozGridRowGap",
    "WebkitGridRowGap",
    "MSGridRowGap",
    "OGridRowGap",
    "gridRowStart",
    "MozGridRowStart",
    "WebkitGridRowStart",
    "MSGridRowStart",
    "OGridRowStart",
    "gridTemplate",
    "MozGridTemplate",
    "WebkitGridTemplate",
    "MSGridTemplate",
    "OGridTemplate",
    "gridTemplateAreas",
    "MozGridTemplateAreas",
    "WebkitGridTemplateAreas",
    "MSGridTemplateAreas",
    "OGridTemplateAreas",
    "gridTemplateColumns",
    "MozGridTemplateColumns",
    "WebkitGridTemplateColumns",
    "MSGridTemplateColumns",
    "OGridTemplateColumns",
    "gridTemplateRows",
    "MozGridTemplateRows",
    "WebkitGridTemplateRows",
    "MSGridTemplateRows",
    "OGridTemplateRows",
    "height",
    "MozHeight",
    "WebkitHeight",
    "MSHeight",
    "OHeight",
    "hyphens",
    "MozHyphens",
    "WebkitHyphens",
    "MSHyphens",
    "OHyphens",
    "hz",
    "MozHz",
    "WebkitHz",
    "MSHz",
    "OHz",
    "imageOrientation",
    "MozImageOrientation",
    "WebkitImageOrientation",
    "MSImageOrientation",
    "OImageOrientation",
    "imageRendering",
    "MozImageRendering",
    "WebkitImageRendering",
    "MSImageRendering",
    "OImageRendering",
    "imageResolution",
    "MozImageResolution",
    "WebkitImageResolution",
    "MSImageResolution",
    "OImageResolution",
    "imeMode",
    "MozImeMode",
    "WebkitImeMode",
    "MSImeMode",
    "OImeMode",
    "in",
    "MozIn",
    "WebkitIn",
    "MSIn",
    "OIn",
    "inherit",
    "MozInherit",
    "WebkitInherit",
    "MSInherit",
    "OInherit",
    "initial",
    "MozInitial",
    "WebkitInitial",
    "MSInitial",
    "OInitial",
    "inlineSize",
    "MozInlineSize",
    "WebkitInlineSize",
    "MSInlineSize",
    "OInlineSize",
    "isolation",
    "MozIsolation",
    "WebkitIsolation",
    "MSIsolation",
    "OIsolation",
    "justifyContent",
    "MozJustifyContent",
    "WebkitJustifyContent",
    "MSJustifyContent",
    "OJustifyContent",
    "khz",
    "MozKhz",
    "WebkitKhz",
    "MSKhz",
    "OKhz",
    "left",
    "MozLeft",
    "WebkitLeft",
    "MSLeft",
    "OLeft",
    "letterSpacing",
    "MozLetterSpacing",
    "WebkitLetterSpacing",
    "MSLetterSpacing",
    "OLetterSpacing",
    "lineBreak",
    "MozLineBreak",
    "WebkitLineBreak",
    "MSLineBreak",
    "OLineBreak",
    "lineHeight",
    "MozLineHeight",
    "WebkitLineHeight",
    "MSLineHeight",
    "OLineHeight",
    "listStyle",
    "MozListStyle",
    "WebkitListStyle",
    "MSListStyle",
    "OListStyle",
    "listStyleImage",
    "MozListStyleImage",
    "WebkitListStyleImage",
    "MSListStyleImage",
    "OListStyleImage",
    "listStylePosition",
    "MozListStylePosition",
    "WebkitListStylePosition",
    "MSListStylePosition",
    "OListStylePosition",
    "listStyleType",
    "MozListStyleType",
    "WebkitListStyleType",
    "MSListStyleType",
    "OListStyleType",
    "margin",
    "MozMargin",
    "WebkitMargin",
    "MSMargin",
    "OMargin",
    "marginBlockEnd",
    "MozMarginBlockEnd",
    "WebkitMarginBlockEnd",
    "MSMarginBlockEnd",
    "OMarginBlockEnd",
    "marginBlockStart",
    "MozMarginBlockStart",
    "WebkitMarginBlockStart",
    "MSMarginBlockStart",
    "OMarginBlockStart",
    "marginBottom",
    "MozMarginBottom",
    "WebkitMarginBottom",
    "MSMarginBottom",
    "OMarginBottom",
    "marginInlineEnd",
    "MozMarginInlineEnd",
    "WebkitMarginInlineEnd",
    "MSMarginInlineEnd",
    "OMarginInlineEnd",
    "marginInlineStart",
    "MozMarginInlineStart",
    "WebkitMarginInlineStart",
    "MSMarginInlineStart",
    "OMarginInlineStart",
    "marginLeft",
    "MozMarginLeft",
    "WebkitMarginLeft",
    "MSMarginLeft",
    "OMarginLeft",
    "marginRight",
    "MozMarginRight",
    "WebkitMarginRight",
    "MSMarginRight",
    "OMarginRight",
    "marginTop",
    "MozMarginTop",
    "WebkitMarginTop",
    "MSMarginTop",
    "OMarginTop",
    "mask",
    "MozMask",
    "WebkitMask",
    "MSMask",
    "OMask",
    "maskClip",
    "MozMaskClip",
    "WebkitMaskClip",
    "MSMaskClip",
    "OMaskClip",
    "maskComposite",
    "MozMaskComposite",
    "WebkitMaskComposite",
    "MSMaskComposite",
    "OMaskComposite",
    "maskImage",
    "MozMaskImage",
    "WebkitMaskImage",
    "MSMaskImage",
    "OMaskImage",
    "maskMode",
    "MozMaskMode",
    "WebkitMaskMode",
    "MSMaskMode",
    "OMaskMode",
    "maskOrigin",
    "MozMaskOrigin",
    "WebkitMaskOrigin",
    "MSMaskOrigin",
    "OMaskOrigin",
    "maskPosition",
    "MozMaskPosition",
    "WebkitMaskPosition",
    "MSMaskPosition",
    "OMaskPosition",
    "maskRepeat",
    "MozMaskRepeat",
    "WebkitMaskRepeat",
    "MSMaskRepeat",
    "OMaskRepeat",
    "maskSize",
    "MozMaskSize",
    "WebkitMaskSize",
    "MSMaskSize",
    "OMaskSize",
    "maskType",
    "MozMaskType",
    "WebkitMaskType",
    "MSMaskType",
    "OMaskType",
    "maxHeight",
    "MozMaxHeight",
    "WebkitMaxHeight",
    "MSMaxHeight",
    "OMaxHeight",
    "maxWidth",
    "MozMaxWidth",
    "WebkitMaxWidth",
    "MSMaxWidth",
    "OMaxWidth",
    "minBlockSize",
    "MozMinBlockSize",
    "WebkitMinBlockSize",
    "MSMinBlockSize",
    "OMinBlockSize",
    "minHeight",
    "MozMinHeight",
    "WebkitMinHeight",
    "MSMinHeight",
    "OMinHeight",
    "minInlineSize",
    "MozMinInlineSize",
    "WebkitMinInlineSize",
    "MSMinInlineSize",
    "OMinInlineSize",
    "minWidth",
    "MozMinWidth",
    "WebkitMinWidth",
    "MSMinWidth",
    "OMinWidth",
    "mixBlendMode",
    "MozMixBlendMode",
    "WebkitMixBlendMode",
    "MSMixBlendMode",
    "OMixBlendMode",
    "mm",
    "MozMm",
    "WebkitMm",
    "MSMm",
    "OMm",
    "ms",
    "MozMs",
    "WebkitMs",
    "MSMs",
    "OMs",
    "objectFit",
    "MozObjectFit",
    "WebkitObjectFit",
    "MSObjectFit",
    "OObjectFit",
    "objectPosition",
    "MozObjectPosition",
    "WebkitObjectPosition",
    "MSObjectPosition",
    "OObjectPosition",
    "offsetBlockEnd",
    "MozOffsetBlockEnd",
    "WebkitOffsetBlockEnd",
    "MSOffsetBlockEnd",
    "OOffsetBlockEnd",
    "offsetBlockStart",
    "MozOffsetBlockStart",
    "WebkitOffsetBlockStart",
    "MSOffsetBlockStart",
    "OOffsetBlockStart",
    "offsetInlineEnd",
    "MozOffsetInlineEnd",
    "WebkitOffsetInlineEnd",
    "MSOffsetInlineEnd",
    "OOffsetInlineEnd",
    "offsetInlineStart",
    "MozOffsetInlineStart",
    "WebkitOffsetInlineStart",
    "MSOffsetInlineStart",
    "OOffsetInlineStart",
    "opacity",
    "MozOpacity",
    "WebkitOpacity",
    "MSOpacity",
    "OOpacity",
    "order",
    "MozOrder",
    "WebkitOrder",
    "MSOrder",
    "OOrder",
    "orphans",
    "MozOrphans",
    "WebkitOrphans",
    "MSOrphans",
    "OOrphans",
    "outline",
    "MozOutline",
    "WebkitOutline",
    "MSOutline",
    "OOutline",
    "outlineColor",
    "MozOutlineColor",
    "WebkitOutlineColor",
    "MSOutlineColor",
    "OOutlineColor",
    "outlineOffset",
    "MozOutlineOffset",
    "WebkitOutlineOffset",
    "MSOutlineOffset",
    "OOutlineOffset",
    "outlineStyle",
    "MozOutlineStyle",
    "WebkitOutlineStyle",
    "MSOutlineStyle",
    "OOutlineStyle",
    "outlineWidth",
    "MozOutlineWidth",
    "WebkitOutlineWidth",
    "MSOutlineWidth",
    "OOutlineWidth",
    "overflow",
    "MozOverflow",
    "WebkitOverflow",
    "MSOverflow",
    "OOverflow",
    "overflowWrap",
    "MozOverflowWrap",
    "WebkitOverflowWrap",
    "MSOverflowWrap",
    "OOverflowWrap",
    "overflowX",
    "MozOverflowX",
    "WebkitOverflowX",
    "MSOverflowX",
    "OOverflowX",
    "overflowY",
    "MozOverflowY",
    "WebkitOverflowY",
    "MSOverflowY",
    "OOverflowY",
    "padding",
    "MozPadding",
    "WebkitPadding",
    "MSPadding",
    "OPadding",
    "paddingBlockEnd",
    "MozPaddingBlockEnd",
    "WebkitPaddingBlockEnd",
    "MSPaddingBlockEnd",
    "OPaddingBlockEnd",
    "paddingBlockStart",
    "MozPaddingBlockStart",
    "WebkitPaddingBlockStart",
    "MSPaddingBlockStart",
    "OPaddingBlockStart",
    "paddingBottom",
    "MozPaddingBottom",
    "WebkitPaddingBottom",
    "MSPaddingBottom",
    "OPaddingBottom",
    "paddingInlineEnd",
    "MozPaddingInlineEnd",
    "WebkitPaddingInlineEnd",
    "MSPaddingInlineEnd",
    "OPaddingInlineEnd",
    "paddingInlineStart",
    "MozPaddingInlineStart",
    "WebkitPaddingInlineStart",
    "MSPaddingInlineStart",
    "OPaddingInlineStart",
    "paddingLeft",
    "MozPaddingLeft",
    "WebkitPaddingLeft",
    "MSPaddingLeft",
    "OPaddingLeft",
    "paddingRight",
    "MozPaddingRight",
    "WebkitPaddingRight",
    "MSPaddingRight",
    "OPaddingRight",
    "paddingTop",
    "MozPaddingTop",
    "WebkitPaddingTop",
    "MSPaddingTop",
    "OPaddingTop",
    "pageBreakAfter",
    "MozPageBreakAfter",
    "WebkitPageBreakAfter",
    "MSPageBreakAfter",
    "OPageBreakAfter",
    "pageBreakBefore",
    "MozPageBreakBefore",
    "WebkitPageBreakBefore",
    "MSPageBreakBefore",
    "OPageBreakBefore",
    "pageBreakInside",
    "MozPageBreakInside",
    "WebkitPageBreakInside",
    "MSPageBreakInside",
    "OPageBreakInside",
    "pc",
    "MozPc",
    "WebkitPc",
    "MSPc",
    "OPc",
    "perspective",
    "MozPerspective",
    "WebkitPerspective",
    "MSPerspective",
    "OPerspective",
    "perspectiveOrigin",
    "MozPerspectiveOrigin",
    "WebkitPerspectiveOrigin",
    "MSPerspectiveOrigin",
    "OPerspectiveOrigin",
    "pointerEvents",
    "MozPointerEvents",
    "WebkitPointerEvents",
    "MSPointerEvents",
    "OPointerEvents",
    "position",
    "MozPosition",
    "WebkitPosition",
    "MSPosition",
    "OPosition",
    "pt",
    "MozPt",
    "WebkitPt",
    "MSPt",
    "OPt",
    "px",
    "MozPx",
    "WebkitPx",
    "MSPx",
    "OPx",
    "q",
    "MozQ",
    "WebkitQ",
    "MSQ",
    "OQ",
    "quotes",
    "MozQuotes",
    "WebkitQuotes",
    "MSQuotes",
    "OQuotes",
    "rad",
    "MozRad",
    "WebkitRad",
    "MSRad",
    "ORad",
    "rem",
    "MozRem",
    "WebkitRem",
    "MSRem",
    "ORem",
    "resize",
    "MozResize",
    "WebkitResize",
    "MSResize",
    "OResize",
    "revert",
    "MozRevert",
    "WebkitRevert",
    "MSRevert",
    "ORevert",
    "right",
    "MozRight",
    "WebkitRight",
    "MSRight",
    "ORight",
    "rubyAlign",
    "MozRubyAlign",
    "WebkitRubyAlign",
    "MSRubyAlign",
    "ORubyAlign",
    "rubyMerge",
    "MozRubyMerge",
    "WebkitRubyMerge",
    "MSRubyMerge",
    "ORubyMerge",
    "rubyPosition",
    "MozRubyPosition",
    "WebkitRubyPosition",
    "MSRubyPosition",
    "ORubyPosition",
    "s",
    "MozS",
    "WebkitS",
    "MSS",
    "OS",
    "scrollBehavior",
    "MozScrollBehavior",
    "WebkitScrollBehavior",
    "MSScrollBehavior",
    "OScrollBehavior",
    "scrollSnapCoordinate",
    "MozScrollSnapCoordinate",
    "WebkitScrollSnapCoordinate",
    "MSScrollSnapCoordinate",
    "OScrollSnapCoordinate",
    "scrollSnapDestination",
    "MozScrollSnapDestination",
    "WebkitScrollSnapDestination",
    "MSScrollSnapDestination",
    "OScrollSnapDestination",
    "scrollSnapType",
    "MozScrollSnapType",
    "WebkitScrollSnapType",
    "MSScrollSnapType",
    "OScrollSnapType",
    "shapeImageThreshold",
    "MozShapeImageThreshold",
    "WebkitShapeImageThreshold",
    "MSShapeImageThreshold",
    "OShapeImageThreshold",
    "shapeMargin",
    "MozShapeMargin",
    "WebkitShapeMargin",
    "MSShapeMargin",
    "OShapeMargin",
    "shapeOutside",
    "MozShapeOutside",
    "WebkitShapeOutside",
    "MSShapeOutside",
    "OShapeOutside",
    "tabSize",
    "MozTabSize",
    "WebkitTabSize",
    "MSTabSize",
    "OTabSize",
    "tableLayout",
    "MozTableLayout",
    "WebkitTableLayout",
    "MSTableLayout",
    "OTableLayout",
    "textAlign",
    "MozTextAlign",
    "WebkitTextAlign",
    "MSTextAlign",
    "OTextAlign",
    "textAlignLast",
    "MozTextAlignLast",
    "WebkitTextAlignLast",
    "MSTextAlignLast",
    "OTextAlignLast",
    "textCombineUpright",
    "MozTextCombineUpright",
    "WebkitTextCombineUpright",
    "MSTextCombineUpright",
    "OTextCombineUpright",
    "textDecoration",
    "MozTextDecoration",
    "WebkitTextDecoration",
    "MSTextDecoration",
    "OTextDecoration",
    "textDecorationColor",
    "MozTextDecorationColor",
    "WebkitTextDecorationColor",
    "MSTextDecorationColor",
    "OTextDecorationColor",
    "textDecorationLine",
    "MozTextDecorationLine",
    "WebkitTextDecorationLine",
    "MSTextDecorationLine",
    "OTextDecorationLine",
    "textDecorationStyle",
    "MozTextDecorationStyle",
    "WebkitTextDecorationStyle",
    "MSTextDecorationStyle",
    "OTextDecorationStyle",
    "textEmphasis",
    "MozTextEmphasis",
    "WebkitTextEmphasis",
    "MSTextEmphasis",
    "OTextEmphasis",
    "textEmphasisColor",
    "MozTextEmphasisColor",
    "WebkitTextEmphasisColor",
    "MSTextEmphasisColor",
    "OTextEmphasisColor",
    "textEmphasisPosition",
    "MozTextEmphasisPosition",
    "WebkitTextEmphasisPosition",
    "MSTextEmphasisPosition",
    "OTextEmphasisPosition",
    "textEmphasisStyle",
    "MozTextEmphasisStyle",
    "WebkitTextEmphasisStyle",
    "MSTextEmphasisStyle",
    "OTextEmphasisStyle",
    "textIndent",
    "MozTextIndent",
    "WebkitTextIndent",
    "MSTextIndent",
    "OTextIndent",
    "textOrientation",
    "MozTextOrientation",
    "WebkitTextOrientation",
    "MSTextOrientation",
    "OTextOrientation",
    "textOverflow",
    "MozTextOverflow",
    "WebkitTextOverflow",
    "MSTextOverflow",
    "OTextOverflow",
    "textRendering",
    "MozTextRendering",
    "WebkitTextRendering",
    "MSTextRendering",
    "OTextRendering",
    "textShadow",
    "MozTextShadow",
    "WebkitTextShadow",
    "MSTextShadow",
    "OTextShadow",
    "textTransform",
    "MozTextTransform",
    "WebkitTextTransform",
    "MSTextTransform",
    "OTextTransform",
    "textUnderlinePosition",
    "MozTextUnderlinePosition",
    "WebkitTextUnderlinePosition",
    "MSTextUnderlinePosition",
    "OTextUnderlinePosition",
    "top",
    "MozTop",
    "WebkitTop",
    "MSTop",
    "OTop",
    "touchAction",
    "MozTouchAction",
    "WebkitTouchAction",
    "MSTouchAction",
    "OTouchAction",
    "transform",
    "MozTransform",
    "WebkitTransform",
    "msTransform",
    "OTransform",
    "transformBox",
    "MozTransformBox",
    "WebkitTransformBox",
    "MSTransformBox",
    "OTransformBox",
    "transformOrigin",
    "MozTransformOrigin",
    "WebkitTransformOrigin",
    "MSTransformOrigin",
    "OTransformOrigin",
    "transformStyle",
    "MozTransformStyle",
    "WebkitTransformStyle",
    "MSTransformStyle",
    "OTransformStyle",
    "transition",
    "MozTransition",
    "WebkitTransition",
    "MSTransition",
    "OTransition",
    "transitionDelay",
    "MozTransitionDelay",
    "WebkitTransitionDelay",
    "MSTransitionDelay",
    "OTransitionDelay",
    "transitionDuration",
    "MozTransitionDuration",
    "WebkitTransitionDuration",
    "MSTransitionDuration",
    "OTransitionDuration",
    "transitionProperty",
    "MozTransitionProperty",
    "WebkitTransitionProperty",
    "MSTransitionProperty",
    "OTransitionProperty",
    "transitionTimingFunction",
    "MozTransitionTimingFunction",
    "WebkitTransitionTimingFunction",
    "MSTransitionTimingFunction",
    "OTransitionTimingFunction",
    "turn",
    "MozTurn",
    "WebkitTurn",
    "MSTurn",
    "OTurn",
    "unicodeBidi",
    "MozUnicodeBidi",
    "WebkitUnicodeBidi",
    "MSUnicodeBidi",
    "OUnicodeBidi",
    "unset",
    "MozUnset",
    "WebkitUnset",
    "MSUnset",
    "OUnset",
    "verticalAlign",
    "MozVerticalAlign",
    "WebkitVerticalAlign",
    "MSVerticalAlign",
    "OVerticalAlign",
    "vh",
    "MozVh",
    "WebkitVh",
    "MSVh",
    "OVh",
    "visibility",
    "MozVisibility",
    "WebkitVisibility",
    "MSVisibility",
    "OVisibility",
    "vmax",
    "MozVmax",
    "WebkitVmax",
    "MSVmax",
    "OVmax",
    "vmin",
    "MozVmin",
    "WebkitVmin",
    "MSVmin",
    "OVmin",
    "vw",
    "MozVw",
    "WebkitVw",
    "MSVw",
    "OVw",
    "whiteSpace",
    "MozWhiteSpace",
    "WebkitWhiteSpace",
    "MSWhiteSpace",
    "OWhiteSpace",
    "widows",
    "MozWidows",
    "WebkitWidows",
    "MSWidows",
    "OWidows",
    "width",
    "MozWidth",
    "WebkitWidth",
    "MSWidth",
    "OWidth",
    "willChange",
    "MozWillChange",
    "WebkitWillChange",
    "MSWillChange",
    "OWillChange",
    "wordBreak",
    "MozWordBreak",
    "WebkitWordBreak",
    "MSWordBreak",
    "OWordBreak",
    "wordSpacing",
    "MozWordSpacing",
    "WebkitWordSpacing",
    "MSWordSpacing",
    "OWordSpacing",
    "wordWrap",
    "MozWordWrap",
    "WebkitWordWrap",
    "MSWordWrap",
    "OWordWrap",
    "writingMode",
    "MozWritingMode",
    "WebkitWritingMode",
    "MSWritingMode",
    "OWritingMode",
    "zIndex",
    "MozZIndex",
    "WebkitZIndex",
    "MSZIndex",
    "OZIndex",
    "fontSize",
    "MozFontSize",
    "WebkitFontSize",
    "MSFontSize",
    "OFontSize",
    "flex",
    "MozFlex",
    "WebkitFlex",
    "MSFlex",
    "OFlex",
    "fr",
    "MozFr",
    "WebkitFr",
    "MSFr",
    "OFr",
    "overflowScrolling",
    "MozOverflowScrolling",
    "WebkitOverflowScrolling",
    "MSOverflowScrolling",
    "OOverflowScrolling",
    "userSelect",
    "MozUserSelect",
    "WebkitUserSelect",
    "MSUserSelect",
    "OUserSelect"
];



var $3RiQf = parcelRequire("3RiQf");
$3fcb7c8379d80fb4$exports = function(props, propName, componentName) {
    var styles = props[propName];
    if (!styles) return;
    var failures = [];
    Object.keys(styles).forEach(function(styleKey) {
        if ($1e6496c3d238466f$exports.indexOf(styleKey) === -1) failures.push(styleKey);
    });
    if (failures.length) throw new Error("Prop " + propName + " passed to " + componentName + ". Has invalid keys " + failures.join(", "));
};
$3fcb7c8379d80fb4$exports.isRequired = function(props, propName, componentName) {
    if (!props[propName]) throw new Error("Prop " + propName + " passed to " + componentName + " is required");
    return $3fcb7c8379d80fb4$exports(props, propName, componentName);
};
$3fcb7c8379d80fb4$exports.supportingArrays = $3RiQf.oneOfType([
    $3RiQf.arrayOf($3fcb7c8379d80fb4$exports),
    $3fcb7c8379d80fb4$exports
]);


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function $237980aaa4fab6f1$var$componentWillMount() {
    // Call this.constructor.gDSFP to support sub-classes.
    var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
    if (state !== null && state !== undefined) this.setState(state);
}
function $237980aaa4fab6f1$var$componentWillReceiveProps(nextProps) {
    // Call this.constructor.gDSFP to support sub-classes.
    // Use the setState() updater to ensure state isn't stale in certain edge cases.
    function updater(prevState) {
        var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
        return state !== null && state !== undefined ? state : null;
    }
    // Binding "this" is important for shallow renderer support.
    this.setState(updater.bind(this));
}
function $237980aaa4fab6f1$var$componentWillUpdate(nextProps, nextState) {
    try {
        var prevProps = this.props;
        var prevState = this.state;
        this.props = nextProps;
        this.state = nextState;
        this.__reactInternalSnapshotFlag = true;
        this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
    } finally{
        this.props = prevProps;
        this.state = prevState;
    }
}
// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
$237980aaa4fab6f1$var$componentWillMount.__suppressDeprecationWarning = true;
$237980aaa4fab6f1$var$componentWillReceiveProps.__suppressDeprecationWarning = true;
$237980aaa4fab6f1$var$componentWillUpdate.__suppressDeprecationWarning = true;
function $237980aaa4fab6f1$export$cea1c58a6db52bca(Component) {
    var prototype = Component.prototype;
    if (!prototype || !prototype.isReactComponent) throw new Error("Can only polyfill class components");
    if (typeof Component.getDerivedStateFromProps !== "function" && typeof prototype.getSnapshotBeforeUpdate !== "function") return Component;
    // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Error if any of these lifecycles are present,
    // Because they would work differently between older and newer (16.3+) versions of React.
    var foundWillMountName = null;
    var foundWillReceivePropsName = null;
    var foundWillUpdateName = null;
    if (typeof prototype.componentWillMount === "function") foundWillMountName = "componentWillMount";
    else if (typeof prototype.UNSAFE_componentWillMount === "function") foundWillMountName = "UNSAFE_componentWillMount";
    if (typeof prototype.componentWillReceiveProps === "function") foundWillReceivePropsName = "componentWillReceiveProps";
    else if (typeof prototype.UNSAFE_componentWillReceiveProps === "function") foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
    if (typeof prototype.componentWillUpdate === "function") foundWillUpdateName = "componentWillUpdate";
    else if (typeof prototype.UNSAFE_componentWillUpdate === "function") foundWillUpdateName = "UNSAFE_componentWillUpdate";
    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var componentName = Component.displayName || Component.name;
        var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
        throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (foundWillMountName !== null ? "\n  " + foundWillMountName : "") + (foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "") + (foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\n" + "https://fb.me/react-async-component-lifecycle-hooks");
    }
    // React <= 16.2 does not support static getDerivedStateFromProps.
    // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
    // Newer versions of React will ignore these lifecycles if gDSFP exists.
    if (typeof Component.getDerivedStateFromProps === "function") {
        prototype.componentWillMount = $237980aaa4fab6f1$var$componentWillMount;
        prototype.componentWillReceiveProps = $237980aaa4fab6f1$var$componentWillReceiveProps;
    }
    // React <= 16.2 does not support getSnapshotBeforeUpdate.
    // As a workaround, use cWU to invoke the new lifecycle.
    // Newer versions of React will ignore that lifecycle if gSBU exists.
    if (typeof prototype.getSnapshotBeforeUpdate === "function") {
        if (typeof prototype.componentDidUpdate !== "function") throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
        prototype.componentWillUpdate = $237980aaa4fab6f1$var$componentWillUpdate;
        var componentDidUpdate = prototype.componentDidUpdate;
        prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
            // 16.3+ will not execute our will-update method;
            // It will pass a snapshot value to did-update though.
            // Older versions will require our polyfilled will-update value.
            // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
            // Because for <= 15.x versions this might be a "prevContext" object.
            // We also can't just check "__reactInternalSnapshot",
            // Because get-snapshot might return a falsy value.
            // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
            var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
            componentDidUpdate.call(this, prevProps, prevState, snapshot);
        };
    }
    return Component;
}


function $e4e47bbe06cfcef3$var$_classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function $e4e47bbe06cfcef3$var$_defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function $e4e47bbe06cfcef3$var$_createClass(Constructor, protoProps, staticProps) {
    if (protoProps) $e4e47bbe06cfcef3$var$_defineProperties(Constructor.prototype, protoProps);
    if (staticProps) $e4e47bbe06cfcef3$var$_defineProperties(Constructor, staticProps);
    return Constructor;
}
function $e4e47bbe06cfcef3$var$_defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function $e4e47bbe06cfcef3$var$_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
        ownKeys.forEach(function(key) {
            $e4e47bbe06cfcef3$var$_defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function $e4e47bbe06cfcef3$var$_inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) $e4e47bbe06cfcef3$var$_setPrototypeOf(subClass, superClass);
}
function $e4e47bbe06cfcef3$var$_getPrototypeOf(o) {
    $e4e47bbe06cfcef3$var$_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return $e4e47bbe06cfcef3$var$_getPrototypeOf(o);
}
function $e4e47bbe06cfcef3$var$_setPrototypeOf(o, p) {
    $e4e47bbe06cfcef3$var$_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return $e4e47bbe06cfcef3$var$_setPrototypeOf(o, p);
}
function $e4e47bbe06cfcef3$var$_assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function $e4e47bbe06cfcef3$var$_possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) return call;
    return $e4e47bbe06cfcef3$var$_assertThisInitialized(self);
}
var $e4e47bbe06cfcef3$var$Pane = /*#__PURE__*/ function(_React$PureComponent) {
    $e4e47bbe06cfcef3$var$_inherits(Pane, _React$PureComponent);
    function Pane() {
        $e4e47bbe06cfcef3$var$_classCallCheck(this, Pane);
        return $e4e47bbe06cfcef3$var$_possibleConstructorReturn(this, $e4e47bbe06cfcef3$var$_getPrototypeOf(Pane).apply(this, arguments));
    }
    $e4e47bbe06cfcef3$var$_createClass(Pane, [
        {
            key: "render",
            value: function render() {
                var _this$props = this.props, children = _this$props.children, className = _this$props.className, split = _this$props.split, styleProps = _this$props.style, size = _this$props.size, eleRef = _this$props.eleRef;
                var classes = [
                    "Pane",
                    split,
                    className
                ];
                var style = Object.assign({}, styleProps || {}, {
                    flex: 1,
                    position: "relative",
                    outline: "none"
                });
                if (size !== undefined) {
                    if (split === "vertical") style.width = size;
                    else {
                        style.height = size;
                        style.display = "flex";
                    }
                    style.flex = "none";
                }
                return (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
                    ref: eleRef,
                    className: classes.join(" "),
                    style: style
                }, children);
            }
        }
    ]);
    return Pane;
}((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).PureComponent);
$e4e47bbe06cfcef3$var$Pane.propTypes = {
    className: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string.isRequired,
    children: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).node.isRequired,
    size: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOfType([
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).number
    ]),
    split: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOf([
        "vertical",
        "horizontal"
    ]),
    style: (0, (/*@__PURE__*/$parcel$interopDefault($3fcb7c8379d80fb4$exports))),
    eleRef: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func
};
$e4e47bbe06cfcef3$var$Pane.defaultProps = {};
var $e4e47bbe06cfcef3$var$RESIZER_DEFAULT_CLASSNAME = "Resizer";
var $e4e47bbe06cfcef3$var$Resizer = /*#__PURE__*/ function(_React$Component) {
    $e4e47bbe06cfcef3$var$_inherits(Resizer, _React$Component);
    function Resizer() {
        $e4e47bbe06cfcef3$var$_classCallCheck(this, Resizer);
        return $e4e47bbe06cfcef3$var$_possibleConstructorReturn(this, $e4e47bbe06cfcef3$var$_getPrototypeOf(Resizer).apply(this, arguments));
    }
    $e4e47bbe06cfcef3$var$_createClass(Resizer, [
        {
            key: "render",
            value: function render() {
                var _this$props = this.props, className = _this$props.className, _onClick = _this$props.onClick, _onDoubleClick = _this$props.onDoubleClick, _onMouseDown = _this$props.onMouseDown, _onTouchEnd = _this$props.onTouchEnd, _onTouchStart = _this$props.onTouchStart, resizerClassName = _this$props.resizerClassName, split = _this$props.split, style = _this$props.style;
                var classes = [
                    resizerClassName,
                    split,
                    className
                ];
                return (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("span", {
                    role: "presentation",
                    className: classes.join(" "),
                    style: style,
                    onMouseDown: function onMouseDown(event) {
                        return _onMouseDown(event);
                    },
                    onTouchStart: function onTouchStart(event) {
                        event.preventDefault();
                        _onTouchStart(event);
                    },
                    onTouchEnd: function onTouchEnd(event) {
                        event.preventDefault();
                        _onTouchEnd(event);
                    },
                    onClick: function onClick(event) {
                        if (_onClick) {
                            event.preventDefault();
                            _onClick(event);
                        }
                    },
                    onDoubleClick: function onDoubleClick(event) {
                        if (_onDoubleClick) {
                            event.preventDefault();
                            _onDoubleClick(event);
                        }
                    }
                });
            }
        }
    ]);
    return Resizer;
}((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Component);
$e4e47bbe06cfcef3$var$Resizer.propTypes = {
    className: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string.isRequired,
    onClick: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func,
    onDoubleClick: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func,
    onMouseDown: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func.isRequired,
    onTouchStart: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func.isRequired,
    onTouchEnd: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func.isRequired,
    split: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOf([
        "vertical",
        "horizontal"
    ]),
    style: (0, (/*@__PURE__*/$parcel$interopDefault($3fcb7c8379d80fb4$exports))),
    resizerClassName: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string.isRequired
};
$e4e47bbe06cfcef3$var$Resizer.defaultProps = {
    resizerClassName: $e4e47bbe06cfcef3$var$RESIZER_DEFAULT_CLASSNAME
};
function $e4e47bbe06cfcef3$var$unFocus(document1, window1) {
    if (document1.selection) document1.selection.empty();
    else try {
        window1.getSelection().removeAllRanges(); // eslint-disable-next-line no-empty
    } catch (e) {}
}
function $e4e47bbe06cfcef3$var$getDefaultSize(defaultSize, minSize, maxSize, draggedSize) {
    if (typeof draggedSize === "number") {
        var min = typeof minSize === "number" ? minSize : 0;
        var max = typeof maxSize === "number" && maxSize >= 0 ? maxSize : Infinity;
        return Math.max(min, Math.min(max, draggedSize));
    }
    if (defaultSize !== undefined) return defaultSize;
    return minSize;
}
function $e4e47bbe06cfcef3$var$removeNullChildren(children) {
    return (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Children.toArray(children).filter(function(c) {
        return c;
    });
}
var $e4e47bbe06cfcef3$var$SplitPane = /*#__PURE__*/ function(_React$Component) {
    $e4e47bbe06cfcef3$var$_inherits(SplitPane, _React$Component);
    function SplitPane(props) {
        var _this;
        $e4e47bbe06cfcef3$var$_classCallCheck(this, SplitPane);
        _this = $e4e47bbe06cfcef3$var$_possibleConstructorReturn(this, $e4e47bbe06cfcef3$var$_getPrototypeOf(SplitPane).call(this, props));
        _this.onMouseDown = _this.onMouseDown.bind($e4e47bbe06cfcef3$var$_assertThisInitialized($e4e47bbe06cfcef3$var$_assertThisInitialized(_this)));
        _this.onTouchStart = _this.onTouchStart.bind($e4e47bbe06cfcef3$var$_assertThisInitialized($e4e47bbe06cfcef3$var$_assertThisInitialized(_this)));
        _this.onMouseMove = _this.onMouseMove.bind($e4e47bbe06cfcef3$var$_assertThisInitialized($e4e47bbe06cfcef3$var$_assertThisInitialized(_this)));
        _this.onTouchMove = _this.onTouchMove.bind($e4e47bbe06cfcef3$var$_assertThisInitialized($e4e47bbe06cfcef3$var$_assertThisInitialized(_this)));
        _this.onMouseUp = _this.onMouseUp.bind($e4e47bbe06cfcef3$var$_assertThisInitialized($e4e47bbe06cfcef3$var$_assertThisInitialized(_this))); // order of setting panel sizes.
        // 1. size
        // 2. getDefaultSize(defaultSize, minsize, maxSize)
        var size = props.size, defaultSize = props.defaultSize, minSize = props.minSize, maxSize = props.maxSize, primary = props.primary;
        var initialSize = size !== undefined ? size : $e4e47bbe06cfcef3$var$getDefaultSize(defaultSize, minSize, maxSize, null);
        _this.state = {
            active: false,
            resized: false,
            pane1Size: primary === "first" ? initialSize : undefined,
            pane2Size: primary === "second" ? initialSize : undefined,
            // these are props that are needed in static functions. ie: gDSFP
            instanceProps: {
                size: size
            }
        };
        return _this;
    }
    $e4e47bbe06cfcef3$var$_createClass(SplitPane, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                document.addEventListener("mouseup", this.onMouseUp);
                document.addEventListener("mousemove", this.onMouseMove);
                document.addEventListener("touchmove", this.onTouchMove);
                this.setState(SplitPane.getSizeUpdate(this.props, this.state));
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                document.removeEventListener("mouseup", this.onMouseUp);
                document.removeEventListener("mousemove", this.onMouseMove);
                document.removeEventListener("touchmove", this.onTouchMove);
            }
        },
        {
            key: "onMouseDown",
            value: function onMouseDown(event) {
                var eventWithTouches = Object.assign({}, event, {
                    touches: [
                        {
                            clientX: event.clientX,
                            clientY: event.clientY
                        }
                    ]
                });
                this.onTouchStart(eventWithTouches);
            }
        },
        {
            key: "onTouchStart",
            value: function onTouchStart(event) {
                var _this$props = this.props, allowResize = _this$props.allowResize, onDragStarted = _this$props.onDragStarted, split = _this$props.split;
                if (allowResize) {
                    $e4e47bbe06cfcef3$var$unFocus(document, window);
                    var position = split === "vertical" ? event.touches[0].clientX : event.touches[0].clientY;
                    if (typeof onDragStarted === "function") onDragStarted();
                    this.setState({
                        active: true,
                        position: position
                    });
                }
            }
        },
        {
            key: "onMouseMove",
            value: function onMouseMove(event) {
                var eventWithTouches = Object.assign({}, event, {
                    touches: [
                        {
                            clientX: event.clientX,
                            clientY: event.clientY
                        }
                    ]
                });
                this.onTouchMove(eventWithTouches);
            }
        },
        {
            key: "onTouchMove",
            value: function onTouchMove(event) {
                var _this$props2 = this.props, allowResize = _this$props2.allowResize, maxSize = _this$props2.maxSize, minSize = _this$props2.minSize, onChange = _this$props2.onChange, split = _this$props2.split, step = _this$props2.step;
                var _this$state = this.state, active = _this$state.active, position = _this$state.position;
                if (allowResize && active) {
                    $e4e47bbe06cfcef3$var$unFocus(document, window);
                    var isPrimaryFirst = this.props.primary === "first";
                    var ref = isPrimaryFirst ? this.pane1 : this.pane2;
                    var ref2 = isPrimaryFirst ? this.pane2 : this.pane1;
                    if (ref) {
                        var node = ref;
                        var node2 = ref2;
                        if (node.getBoundingClientRect) {
                            var width = node.getBoundingClientRect().width;
                            var height = node.getBoundingClientRect().height;
                            var current = split === "vertical" ? event.touches[0].clientX : event.touches[0].clientY;
                            var size = split === "vertical" ? width : height;
                            var positionDelta = position - current;
                            if (step) {
                                if (Math.abs(positionDelta) < step) return;
                                 // Integer division
                                // eslint-disable-next-line no-bitwise
                                positionDelta = ~~(positionDelta / step) * step;
                            }
                            var sizeDelta = isPrimaryFirst ? positionDelta : -positionDelta;
                            var pane1Order = parseInt(window.getComputedStyle(node).order);
                            var pane2Order = parseInt(window.getComputedStyle(node2).order);
                            if (pane1Order > pane2Order) sizeDelta = -sizeDelta;
                            var newMaxSize = maxSize;
                            if (maxSize !== undefined && maxSize <= 0) {
                                var splitPane = this.splitPane;
                                if (split === "vertical") newMaxSize = splitPane.getBoundingClientRect().width + maxSize;
                                else newMaxSize = splitPane.getBoundingClientRect().height + maxSize;
                            }
                            var newSize = size - sizeDelta;
                            var newPosition = position - positionDelta;
                            if (newSize < minSize) newSize = minSize;
                            else if (maxSize !== undefined && newSize > newMaxSize) newSize = newMaxSize;
                            else this.setState({
                                position: newPosition,
                                resized: true
                            });
                            if (onChange) onChange(newSize);
                            this.setState($e4e47bbe06cfcef3$var$_defineProperty({
                                draggedSize: newSize
                            }, isPrimaryFirst ? "pane1Size" : "pane2Size", newSize));
                        }
                    }
                }
            }
        },
        {
            key: "onMouseUp",
            value: function onMouseUp() {
                var _this$props3 = this.props, allowResize = _this$props3.allowResize, onDragFinished = _this$props3.onDragFinished;
                var _this$state2 = this.state, active = _this$state2.active, draggedSize = _this$state2.draggedSize;
                if (allowResize && active) {
                    if (typeof onDragFinished === "function") onDragFinished(draggedSize);
                    this.setState({
                        active: false
                    });
                }
            } // we have to check values since gDSFP is called on every render and more in StrictMode
        },
        {
            key: "render",
            value: function render() {
                var _this2 = this;
                var _this$props4 = this.props, allowResize = _this$props4.allowResize, children = _this$props4.children, className = _this$props4.className, onResizerClick = _this$props4.onResizerClick, onResizerDoubleClick = _this$props4.onResizerDoubleClick, paneClassName = _this$props4.paneClassName, pane1ClassName = _this$props4.pane1ClassName, pane2ClassName = _this$props4.pane2ClassName, paneStyle = _this$props4.paneStyle, pane1StyleProps = _this$props4.pane1Style, pane2StyleProps = _this$props4.pane2Style, resizerClassName = _this$props4.resizerClassName, resizerStyle = _this$props4.resizerStyle, split = _this$props4.split, styleProps = _this$props4.style;
                var _this$state3 = this.state, pane1Size = _this$state3.pane1Size, pane2Size = _this$state3.pane2Size;
                var disabledClass = allowResize ? "" : "disabled";
                var resizerClassNamesIncludingDefault = resizerClassName ? "".concat(resizerClassName, " ").concat($e4e47bbe06cfcef3$var$RESIZER_DEFAULT_CLASSNAME) : resizerClassName;
                var notNullChildren = $e4e47bbe06cfcef3$var$removeNullChildren(children);
                var style = $e4e47bbe06cfcef3$var$_objectSpread({
                    display: "flex",
                    flex: 1,
                    height: "100%",
                    position: "absolute",
                    outline: "none",
                    overflow: "hidden",
                    MozUserSelect: "text",
                    WebkitUserSelect: "text",
                    msUserSelect: "text",
                    userSelect: "text"
                }, styleProps);
                if (split === "vertical") Object.assign(style, {
                    flexDirection: "row",
                    left: 0,
                    right: 0
                });
                else Object.assign(style, {
                    bottom: 0,
                    flexDirection: "column",
                    minHeight: "100%",
                    top: 0,
                    width: "100%"
                });
                var classes = [
                    "SplitPane",
                    className,
                    split,
                    disabledClass
                ];
                var pane1Style = $e4e47bbe06cfcef3$var$_objectSpread({}, paneStyle, pane1StyleProps);
                var pane2Style = $e4e47bbe06cfcef3$var$_objectSpread({}, paneStyle, pane2StyleProps);
                var pane1Classes = [
                    "Pane1",
                    paneClassName,
                    pane1ClassName
                ].join(" ");
                var pane2Classes = [
                    "Pane2",
                    paneClassName,
                    pane2ClassName
                ].join(" ");
                return (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
                    className: classes.join(" "),
                    ref: function ref(node) {
                        _this2.splitPane = node;
                    },
                    style: style
                }, (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($e4e47bbe06cfcef3$var$Pane, {
                    className: pane1Classes,
                    key: "pane1",
                    eleRef: function eleRef(node) {
                        _this2.pane1 = node;
                    },
                    size: pane1Size,
                    split: split,
                    style: pane1Style
                }, notNullChildren[0]), (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($e4e47bbe06cfcef3$var$Resizer, {
                    className: disabledClass,
                    onClick: onResizerClick,
                    onDoubleClick: onResizerDoubleClick,
                    onMouseDown: this.onMouseDown,
                    onTouchStart: this.onTouchStart,
                    onTouchEnd: this.onMouseUp,
                    key: "resizer",
                    resizerClassName: resizerClassNamesIncludingDefault,
                    split: split,
                    style: resizerStyle || {}
                }), (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($e4e47bbe06cfcef3$var$Pane, {
                    className: pane2Classes,
                    key: "pane2",
                    eleRef: function eleRef(node) {
                        _this2.pane2 = node;
                    },
                    size: pane2Size,
                    split: split,
                    style: pane2Style
                }, notNullChildren[1]));
            }
        }
    ], [
        {
            key: "getDerivedStateFromProps",
            value: function getDerivedStateFromProps(nextProps, prevState) {
                return SplitPane.getSizeUpdate(nextProps, prevState);
            }
        },
        {
            key: "getSizeUpdate",
            value: function getSizeUpdate(props, state) {
                var newState = {};
                var instanceProps = state.instanceProps;
                if (instanceProps.size === props.size && props.size !== undefined) return {};
                var newSize = props.size !== undefined ? props.size : $e4e47bbe06cfcef3$var$getDefaultSize(props.defaultSize, props.minSize, props.maxSize, state.draggedSize);
                if (props.size !== undefined) newState.draggedSize = newSize;
                var isPanel1Primary = props.primary === "first";
                newState[isPanel1Primary ? "pane1Size" : "pane2Size"] = newSize;
                newState[isPanel1Primary ? "pane2Size" : "pane1Size"] = undefined;
                newState.instanceProps = {
                    size: props.size
                };
                return newState;
            }
        }
    ]);
    return SplitPane;
}((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Component);
$e4e47bbe06cfcef3$var$SplitPane.propTypes = {
    allowResize: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).bool,
    children: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).arrayOf((0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).node).isRequired,
    className: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
    primary: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOf([
        "first",
        "second"
    ]),
    minSize: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOfType([
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).number
    ]),
    maxSize: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOfType([
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).number
    ]),
    // eslint-disable-next-line react/no-unused-prop-types
    defaultSize: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOfType([
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).number
    ]),
    size: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOfType([
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
        (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).number
    ]),
    split: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).oneOf([
        "vertical",
        "horizontal"
    ]),
    onDragStarted: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func,
    onDragFinished: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func,
    onChange: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func,
    onResizerClick: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func,
    onResizerDoubleClick: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).func,
    style: (0, (/*@__PURE__*/$parcel$interopDefault($3fcb7c8379d80fb4$exports))),
    resizerStyle: (0, (/*@__PURE__*/$parcel$interopDefault($3fcb7c8379d80fb4$exports))),
    paneClassName: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
    pane1ClassName: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
    pane2ClassName: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
    paneStyle: (0, (/*@__PURE__*/$parcel$interopDefault($3fcb7c8379d80fb4$exports))),
    pane1Style: (0, (/*@__PURE__*/$parcel$interopDefault($3fcb7c8379d80fb4$exports))),
    pane2Style: (0, (/*@__PURE__*/$parcel$interopDefault($3fcb7c8379d80fb4$exports))),
    resizerClassName: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).string,
    step: (0, (/*@__PURE__*/$parcel$interopDefault($3RiQf))).number
};
$e4e47bbe06cfcef3$var$SplitPane.defaultProps = {
    allowResize: true,
    minSize: 50,
    primary: "first",
    split: "vertical",
    paneClassName: "",
    pane1ClassName: "",
    pane2ClassName: ""
};
(0, $237980aaa4fab6f1$export$cea1c58a6db52bca)($e4e47bbe06cfcef3$var$SplitPane);
var $e4e47bbe06cfcef3$export$2e2bcd8739ae039 = $e4e47bbe06cfcef3$var$SplitPane;


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");


var $2LmR0 = parcelRequire("2LmR0");
var $7ed1099ec7c52c31$export$9dd6ff9ea0189349 = {
    /* Styles applied to the root element. */ root: {
        overflow: "hidden"
    }
};
var $7ed1099ec7c52c31$var$Card = /*#__PURE__*/ $aaLBe.forwardRef(function Card(props, ref) {
    var classes = props.classes, className = props.className, _props$raised = props.raised, raised = _props$raised === void 0 ? false : _props$raised, other = (0, $kqze3.default)(props, [
        "classes",
        "className",
        "raised"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement((0, $1d208f46a78f549a$export$2e2bcd8739ae039), (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className),
        elevation: raised ? 8 : 1,
        ref: ref
    }, other));
});
var $7ed1099ec7c52c31$export$2e2bcd8739ae039 = (0, $2LmR0.default)($7ed1099ec7c52c31$export$9dd6ff9ea0189349, {
    name: "MuiCard"
})($7ed1099ec7c52c31$var$Card);


var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");
var $5caaf602cc8daa08$export$9dd6ff9ea0189349 = {
    /* Styles applied to the root element. */ root: {
        padding: 16,
        "&:last-child": {
            paddingBottom: 24
        }
    }
};
var $5caaf602cc8daa08$var$CardContent = /*#__PURE__*/ $aaLBe.forwardRef(function CardContent(props, ref) {
    var classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, other = (0, $kqze3.default)(props, [
        "classes",
        "className",
        "component"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className),
        ref: ref
    }, other));
});
var $5caaf602cc8daa08$export$2e2bcd8739ae039 = (0, $2LmR0.default)($5caaf602cc8daa08$export$9dd6ff9ea0189349, {
    name: "MuiCardContent"
})($5caaf602cc8daa08$var$CardContent);


var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");

var $d76986ce9d4ea56e$export$9dd6ff9ea0189349 = {
    /* Styles applied to the root element. */ root: {
        display: "flex",
        alignItems: "center",
        padding: 16
    },
    /* Styles applied to the avatar element. */ avatar: {
        flex: "0 0 auto",
        marginRight: 16
    },
    /* Styles applied to the action element. */ action: {
        flex: "0 0 auto",
        alignSelf: "flex-start",
        marginTop: -8,
        marginRight: -8
    },
    /* Styles applied to the content wrapper element. */ content: {
        flex: "1 1 auto"
    },
    /* Styles applied to the title Typography element. */ title: {},
    /* Styles applied to the subheader Typography element. */ subheader: {}
};
var $d76986ce9d4ea56e$var$CardHeader = /*#__PURE__*/ $aaLBe.forwardRef(function CardHeader(props, ref) {
    var action = props.action, avatar = props.avatar, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _props$disableTypogra = props.disableTypography, disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra, subheaderProp = props.subheader, subheaderTypographyProps = props.subheaderTypographyProps, titleProp = props.title, titleTypographyProps = props.titleTypographyProps, other = (0, $kqze3.default)(props, [
        "action",
        "avatar",
        "classes",
        "className",
        "component",
        "disableTypography",
        "subheader",
        "subheaderTypographyProps",
        "title",
        "titleTypographyProps"
    ]);
    var title = titleProp;
    if (title != null && title.type !== (0, $372cadd18a544d36$export$2e2bcd8739ae039) && !disableTypography) title = /*#__PURE__*/ $aaLBe.createElement((0, $372cadd18a544d36$export$2e2bcd8739ae039), (0, $29rXr.default)({
        variant: avatar ? "body2" : "h5",
        className: classes.title,
        component: "span",
        display: "block"
    }, titleTypographyProps), title);
    var subheader = subheaderProp;
    if (subheader != null && subheader.type !== (0, $372cadd18a544d36$export$2e2bcd8739ae039) && !disableTypography) subheader = /*#__PURE__*/ $aaLBe.createElement((0, $372cadd18a544d36$export$2e2bcd8739ae039), (0, $29rXr.default)({
        variant: avatar ? "body2" : "body1",
        className: classes.subheader,
        color: "textSecondary",
        component: "span",
        display: "block"
    }, subheaderTypographyProps), subheader);
    return /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className),
        ref: ref
    }, other), avatar && /*#__PURE__*/ $aaLBe.createElement("div", {
        className: classes.avatar
    }, avatar), /*#__PURE__*/ $aaLBe.createElement("div", {
        className: classes.content
    }, title, subheader), action && /*#__PURE__*/ $aaLBe.createElement("div", {
        className: classes.action
    }, action));
});
var $d76986ce9d4ea56e$export$2e2bcd8739ae039 = (0, $2LmR0.default)($d76986ce9d4ea56e$export$9dd6ff9ea0189349, {
    name: "MuiCardHeader"
})($d76986ce9d4ea56e$var$CardHeader);


var $c35e9f5a8731094a$exports = {};
"use strict";


Object.defineProperty($c35e9f5a8731094a$exports, "__esModule", {
    value: true
});
$c35e9f5a8731094a$exports.default = void 0;

var $c35e9f5a8731094a$var$React = $80a9c2f6d1811a06$exports((parcelRequire("aaLBe")));

var $c35e9f5a8731094a$var$_createSvgIcon = $69f4ded615f6c2c8$exports((parcelRequire("jxmMp")));
var $c35e9f5a8731094a$var$_default = (0, $c35e9f5a8731094a$var$_createSvgIcon.default)(/*#__PURE__*/ $c35e9f5a8731094a$var$React.createElement("path", {
    d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
$c35e9f5a8731094a$exports.default = $c35e9f5a8731094a$var$_default;


var $fb40a9e8ed15938b$exports = {};
"use strict";


Object.defineProperty($fb40a9e8ed15938b$exports, "__esModule", {
    value: true
});
$fb40a9e8ed15938b$exports.default = void 0;

var $fb40a9e8ed15938b$var$React = $80a9c2f6d1811a06$exports((parcelRequire("aaLBe")));

var $fb40a9e8ed15938b$var$_createSvgIcon = $69f4ded615f6c2c8$exports((parcelRequire("jxmMp")));
var $fb40a9e8ed15938b$var$_default = (0, $fb40a9e8ed15938b$var$_createSvgIcon.default)(/*#__PURE__*/ $fb40a9e8ed15938b$var$React.createElement("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"
}), "Info");
$fb40a9e8ed15938b$exports.default = $fb40a9e8ed15938b$var$_default;





var $aaLBe = parcelRequire("aaLBe");




// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


var $7436528c4dad37e7$export$58adb3bec8346d0f = Array.prototype.slice;


function $52d402a25857ac97$export$2e2bcd8739ae039(x) {
    return x;
}


var $f289c843701a4cef$var$top = 1, $f289c843701a4cef$var$right = 2, $f289c843701a4cef$var$bottom = 3, $f289c843701a4cef$var$left = 4, $f289c843701a4cef$var$epsilon = 1e-6;
function $f289c843701a4cef$var$translateX(x) {
    return "translate(" + (x + 0.5) + ",0)";
}
function $f289c843701a4cef$var$translateY(y) {
    return "translate(0," + (y + 0.5) + ")";
}
function $f289c843701a4cef$var$number(scale) {
    return function(d) {
        return +scale(d);
    };
}
function $f289c843701a4cef$var$center(scale) {
    var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
    if (scale.round()) offset = Math.round(offset);
    return function(d) {
        return +scale(d) + offset;
    };
}
function $f289c843701a4cef$var$entering() {
    return !this.__axis;
}
function $f289c843701a4cef$var$axis(orient, scale) {
    var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k = orient === $f289c843701a4cef$var$top || orient === $f289c843701a4cef$var$left ? -1 : 1, x = orient === $f289c843701a4cef$var$left || orient === $f289c843701a4cef$var$right ? "x" : "y", transform = orient === $f289c843701a4cef$var$top || orient === $f289c843701a4cef$var$bottom ? $f289c843701a4cef$var$translateX : $f289c843701a4cef$var$translateY;
    function axis(context) {
        var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : (0, $52d402a25857ac97$export$2e2bcd8739ae039) : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + 0.5, range1 = +range[range.length - 1] + 0.5, position = (scale.bandwidth ? $f289c843701a4cef$var$center : $f289c843701a4cef$var$number)(scale.copy()), selection = context.selection ? context.selection() : context, path = selection.selectAll(".domain").data([
            null
        ]), tick = selection.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
        path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
        tick = tick.merge(tickEnter);
        line = line.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x + "2", k * tickSizeInner));
        text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x, k * spacing).attr("dy", orient === $f289c843701a4cef$var$top ? "0em" : orient === $f289c843701a4cef$var$bottom ? "0.71em" : "0.32em"));
        if (context !== selection) {
            path = path.transition(context);
            tick = tick.transition(context);
            line = line.transition(context);
            text = text.transition(context);
            tickExit = tickExit.transition(context).attr("opacity", $f289c843701a4cef$var$epsilon).attr("transform", function(d) {
                return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform");
            });
            tickEnter.attr("opacity", $f289c843701a4cef$var$epsilon).attr("transform", function(d) {
                var p = this.parentNode.__axis;
                return transform(p && isFinite(p = p(d)) ? p : position(d));
            });
        }
        tickExit.remove();
        path.attr("d", orient === $f289c843701a4cef$var$left || orient == $f289c843701a4cef$var$right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1);
        tick.attr("opacity", 1).attr("transform", function(d) {
            return transform(position(d));
        });
        line.attr(x + "2", k * tickSizeInner);
        text.attr(x, k * spacing).text(format);
        selection.filter($f289c843701a4cef$var$entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === $f289c843701a4cef$var$right ? "start" : orient === $f289c843701a4cef$var$left ? "end" : "middle");
        selection.each(function() {
            this.__axis = position;
        });
    }
    axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
    };
    axis.ticks = function() {
        return tickArguments = (0, $7436528c4dad37e7$export$58adb3bec8346d0f).call(arguments), axis;
    };
    axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : (0, $7436528c4dad37e7$export$58adb3bec8346d0f).call(_), axis) : tickArguments.slice();
    };
    axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : (0, $7436528c4dad37e7$export$58adb3bec8346d0f).call(_), axis) : tickValues && tickValues.slice();
    };
    axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
    };
    axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
    };
    axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
    };
    axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
    };
    axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
    };
    return axis;
}
function $f289c843701a4cef$export$59b8cfab074bdeb1(scale) {
    return $f289c843701a4cef$var$axis($f289c843701a4cef$var$top, scale);
}
function $f289c843701a4cef$export$b0d2e24dc4f898f0(scale) {
    return $f289c843701a4cef$var$axis($f289c843701a4cef$var$right, scale);
}
function $f289c843701a4cef$export$e5cb22533a15e72e(scale) {
    return $f289c843701a4cef$var$axis($f289c843701a4cef$var$bottom, scale);
}
function $f289c843701a4cef$export$2749afb169a520d2(scale) {
    return $f289c843701a4cef$var$axis($f289c843701a4cef$var$left, scale);
}






var $15c1b0df3e13ed9a$export$201a3f7520ccc326 = "http://www.w3.org/1999/xhtml";
var $15c1b0df3e13ed9a$export$2e2bcd8739ae039 = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: $15c1b0df3e13ed9a$export$201a3f7520ccc326,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
};


function $edfd550093082bc6$export$2e2bcd8739ae039(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
    return (0, $15c1b0df3e13ed9a$export$2e2bcd8739ae039).hasOwnProperty(prefix) ? {
        space: (0, $15c1b0df3e13ed9a$export$2e2bcd8739ae039)[prefix],
        local: name
    } : name;
}



function $fda9367c6a588803$var$creatorInherit(name) {
    return function() {
        var document = this.ownerDocument, uri = this.namespaceURI;
        return uri === (0, $15c1b0df3e13ed9a$export$201a3f7520ccc326) && document.documentElement.namespaceURI === (0, $15c1b0df3e13ed9a$export$201a3f7520ccc326) ? document.createElement(name) : document.createElementNS(uri, name);
    };
}
function $fda9367c6a588803$var$creatorFixed(fullname) {
    return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
}
function $fda9367c6a588803$export$2e2bcd8739ae039(name) {
    var fullname = (0, $edfd550093082bc6$export$2e2bcd8739ae039)(name);
    return (fullname.local ? $fda9367c6a588803$var$creatorFixed : $fda9367c6a588803$var$creatorInherit)(fullname);
}



function $4f590ea611a05bef$var$none() {}
function $4f590ea611a05bef$export$2e2bcd8739ae039(selector) {
    return selector == null ? $4f590ea611a05bef$var$none : function() {
        return this.querySelector(selector);
    };
}


function $dab03710c0a0451f$export$2e2bcd8739ae039(select) {
    if (typeof select !== "function") select = (0, $4f590ea611a05bef$export$2e2bcd8739ae039)(select);
    for(var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i)if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
        }
    }
    return new (0, $47f0ff7527d817e6$export$52baac22726c72bf)(subgroups, this._parents);
}



function $88500f8ff512f685$var$empty() {
    return [];
}
function $88500f8ff512f685$export$2e2bcd8739ae039(selector) {
    return selector == null ? $88500f8ff512f685$var$empty : function() {
        return this.querySelectorAll(selector);
    };
}


function $f30f5dd19c67a4c1$export$2e2bcd8739ae039(select) {
    if (typeof select !== "function") select = (0, $88500f8ff512f685$export$2e2bcd8739ae039)(select);
    for(var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, node, i = 0; i < n; ++i)if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
        }
    }
    return new (0, $47f0ff7527d817e6$export$52baac22726c72bf)(subgroups, parents);
}



function $bbe47e0dca9aec73$export$2e2bcd8739ae039(selector) {
    return function() {
        return this.matches(selector);
    };
}


function $81f52857269808bb$export$2e2bcd8739ae039(match) {
    if (typeof match !== "function") match = (0, $bbe47e0dca9aec73$export$2e2bcd8739ae039)(match);
    for(var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i)if ((node = group[i]) && match.call(node, node.__data__, i, group)) subgroup.push(node);
    }
    return new (0, $47f0ff7527d817e6$export$52baac22726c72bf)(subgroups, this._parents);
}



function $282dce788bc12e7b$export$2e2bcd8739ae039(update) {
    return new Array(update.length);
}



function $05992484860795d1$export$2e2bcd8739ae039() {
    return new (0, $47f0ff7527d817e6$export$52baac22726c72bf)(this._enter || this._groups.map((0, $282dce788bc12e7b$export$2e2bcd8739ae039)), this._parents);
}
function $05992484860795d1$export$67b01759a14cf6a4(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
}
$05992484860795d1$export$67b01759a14cf6a4.prototype = {
    constructor: $05992484860795d1$export$67b01759a14cf6a4,
    appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
        return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
        return this._parent.querySelectorAll(selector);
    }
};


function $4cc7db969d2df2eb$export$2e2bcd8739ae039(x) {
    return function() {
        return x;
    };
}


var $b1f902012fae0c37$var$keyPrefix = "$"; // Protect against keys like “__proto__”.
function $b1f902012fae0c37$var$bindIndex(parent, group, enter, update, exit, data) {
    var i = 0, node, groupLength = group.length, dataLength = data.length;
    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for(; i < dataLength; ++i)if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
    } else enter[i] = new (0, $05992484860795d1$export$67b01759a14cf6a4)(parent, data[i]);
    // Put any non-null nodes that don’t fit into exit.
    for(; i < groupLength; ++i)if (node = group[i]) exit[i] = node;
}
function $b1f902012fae0c37$var$bindKey(parent, group, enter, update, exit, data, key) {
    var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for(i = 0; i < groupLength; ++i)if (node = group[i]) {
        keyValues[i] = keyValue = $b1f902012fae0c37$var$keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) exit[i] = node;
        else nodeByKeyValue[keyValue] = node;
    }
    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for(i = 0; i < dataLength; ++i){
        keyValue = $b1f902012fae0c37$var$keyPrefix + key.call(parent, data[i], i, data);
        if (node = nodeByKeyValue[keyValue]) {
            update[i] = node;
            node.__data__ = data[i];
            nodeByKeyValue[keyValue] = null;
        } else enter[i] = new (0, $05992484860795d1$export$67b01759a14cf6a4)(parent, data[i]);
    }
    // Add any remaining nodes that were not bound to data to exit.
    for(i = 0; i < groupLength; ++i)if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) exit[i] = node;
}
function $b1f902012fae0c37$export$2e2bcd8739ae039(value, key) {
    if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function(d) {
            data[++j] = d;
        });
        return data;
    }
    var bind = key ? $b1f902012fae0c37$var$bindKey : $b1f902012fae0c37$var$bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function") value = (0, $4cc7db969d2df2eb$export$2e2bcd8739ae039)(value);
    for(var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j){
        var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for(var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0)if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while(!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
        }
    }
    update = new (0, $47f0ff7527d817e6$export$52baac22726c72bf)(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
}





function $89bc1abb0fb02bc8$export$2e2bcd8739ae039() {
    return new (0, $47f0ff7527d817e6$export$52baac22726c72bf)(this._exit || this._groups.map((0, $282dce788bc12e7b$export$2e2bcd8739ae039)), this._parents);
}


function $3cd2d8246dadad45$export$2e2bcd8739ae039(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) update = onupdate(update);
    if (onexit == null) exit.remove();
    else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
}



function $14fd56101d35ce5c$export$2e2bcd8739ae039(selection) {
    for(var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j){
        for(var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i)if (node = group0[i] || group1[i]) merge[i] = node;
    }
    for(; j < m0; ++j)merges[j] = groups0[j];
    return new (0, $47f0ff7527d817e6$export$52baac22726c72bf)(merges, this._parents);
}


function $bea68a5a8e60349e$export$2e2bcd8739ae039() {
    for(var groups = this._groups, j = -1, m = groups.length; ++j < m;){
        for(var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;)if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
        }
    }
    return this;
}



function $a68c5ea1f0ea990f$export$2e2bcd8739ae039(compare) {
    if (!compare) compare = $a68c5ea1f0ea990f$var$ascending;
    function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }
    for(var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j){
        for(var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i)if (node = group[i]) sortgroup[i] = node;
        sortgroup.sort(compareNode);
    }
    return new (0, $47f0ff7527d817e6$export$52baac22726c72bf)(sortgroups, this._parents).order();
}
function $a68c5ea1f0ea990f$var$ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


function $0bd409e62410acd0$export$2e2bcd8739ae039() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
}


function $75ef816dfb407940$export$2e2bcd8739ae039() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() {
        nodes[++i] = this;
    });
    return nodes;
}


function $32beb5e8d7d9e650$export$2e2bcd8739ae039() {
    for(var groups = this._groups, j = 0, m = groups.length; j < m; ++j)for(var group = groups[j], i = 0, n = group.length; i < n; ++i){
        var node = group[i];
        if (node) return node;
    }
    return null;
}


function $443db4f3d9afd0a6$export$2e2bcd8739ae039() {
    var size = 0;
    this.each(function() {
        ++size;
    });
    return size;
}


function $fe407d70e508eb9b$export$2e2bcd8739ae039() {
    return !this.node();
}


function $2f8eba843281fe2a$export$2e2bcd8739ae039(callback) {
    for(var groups = this._groups, j = 0, m = groups.length; j < m; ++j){
        for(var group = groups[j], i = 0, n = group.length, node; i < n; ++i)if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
    return this;
}



function $fda437b40b08c6ad$var$attrRemove(name) {
    return function() {
        this.removeAttribute(name);
    };
}
function $fda437b40b08c6ad$var$attrRemoveNS(fullname) {
    return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
    };
}
function $fda437b40b08c6ad$var$attrConstant(name, value) {
    return function() {
        this.setAttribute(name, value);
    };
}
function $fda437b40b08c6ad$var$attrConstantNS(fullname, value) {
    return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
    };
}
function $fda437b40b08c6ad$var$attrFunction(name, value) {
    return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
    };
}
function $fda437b40b08c6ad$var$attrFunctionNS(fullname, value) {
    return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
    };
}
function $fda437b40b08c6ad$export$2e2bcd8739ae039(name, value) {
    var fullname = (0, $edfd550093082bc6$export$2e2bcd8739ae039)(name);
    if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? $fda437b40b08c6ad$var$attrRemoveNS : $fda437b40b08c6ad$var$attrRemove : typeof value === "function" ? fullname.local ? $fda437b40b08c6ad$var$attrFunctionNS : $fda437b40b08c6ad$var$attrFunction : fullname.local ? $fda437b40b08c6ad$var$attrConstantNS : $fda437b40b08c6ad$var$attrConstant)(fullname, value));
}


function $eab7317b4bab2edf$export$2e2bcd8739ae039(node) {
    return node.ownerDocument && node.ownerDocument.defaultView // node is a Node
     || node.document && node // node is a Window
     || node.defaultView; // node is a Document
}


function $d94089f91c15df8b$var$styleRemove(name) {
    return function() {
        this.style.removeProperty(name);
    };
}
function $d94089f91c15df8b$var$styleConstant(name, value, priority) {
    return function() {
        this.style.setProperty(name, value, priority);
    };
}
function $d94089f91c15df8b$var$styleFunction(name, value, priority) {
    return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
    };
}
function $d94089f91c15df8b$export$2e2bcd8739ae039(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? $d94089f91c15df8b$var$styleRemove : typeof value === "function" ? $d94089f91c15df8b$var$styleFunction : $d94089f91c15df8b$var$styleConstant)(name, value, priority == null ? "" : priority)) : $d94089f91c15df8b$export$5e3cec964f0b5efd(this.node(), name);
}
function $d94089f91c15df8b$export$5e3cec964f0b5efd(node, name) {
    return node.style.getPropertyValue(name) || (0, $eab7317b4bab2edf$export$2e2bcd8739ae039)(node).getComputedStyle(node, null).getPropertyValue(name);
}


function $09c129a968eeefc2$var$propertyRemove(name) {
    return function() {
        delete this[name];
    };
}
function $09c129a968eeefc2$var$propertyConstant(name, value) {
    return function() {
        this[name] = value;
    };
}
function $09c129a968eeefc2$var$propertyFunction(name, value) {
    return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
    };
}
function $09c129a968eeefc2$export$2e2bcd8739ae039(name, value) {
    return arguments.length > 1 ? this.each((value == null ? $09c129a968eeefc2$var$propertyRemove : typeof value === "function" ? $09c129a968eeefc2$var$propertyFunction : $09c129a968eeefc2$var$propertyConstant)(name, value)) : this.node()[name];
}


function $c0383476dc52626a$var$classArray(string) {
    return string.trim().split(/^|\s+/);
}
function $c0383476dc52626a$var$classList(node) {
    return node.classList || new $c0383476dc52626a$var$ClassList(node);
}
function $c0383476dc52626a$var$ClassList(node) {
    this._node = node;
    this._names = $c0383476dc52626a$var$classArray(node.getAttribute("class") || "");
}
$c0383476dc52626a$var$ClassList.prototype = {
    add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
            this._names.push(name);
            this._node.setAttribute("class", this._names.join(" "));
        }
    },
    remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
            this._names.splice(i, 1);
            this._node.setAttribute("class", this._names.join(" "));
        }
    },
    contains: function(name) {
        return this._names.indexOf(name) >= 0;
    }
};
function $c0383476dc52626a$var$classedAdd(node, names) {
    var list = $c0383476dc52626a$var$classList(node), i = -1, n = names.length;
    while(++i < n)list.add(names[i]);
}
function $c0383476dc52626a$var$classedRemove(node, names) {
    var list = $c0383476dc52626a$var$classList(node), i = -1, n = names.length;
    while(++i < n)list.remove(names[i]);
}
function $c0383476dc52626a$var$classedTrue(names) {
    return function() {
        $c0383476dc52626a$var$classedAdd(this, names);
    };
}
function $c0383476dc52626a$var$classedFalse(names) {
    return function() {
        $c0383476dc52626a$var$classedRemove(this, names);
    };
}
function $c0383476dc52626a$var$classedFunction(names, value) {
    return function() {
        (value.apply(this, arguments) ? $c0383476dc52626a$var$classedAdd : $c0383476dc52626a$var$classedRemove)(this, names);
    };
}
function $c0383476dc52626a$export$2e2bcd8739ae039(name, value) {
    var names = $c0383476dc52626a$var$classArray(name + "");
    if (arguments.length < 2) {
        var list = $c0383476dc52626a$var$classList(this.node()), i = -1, n = names.length;
        while(++i < n)if (!list.contains(names[i])) return false;
        return true;
    }
    return this.each((typeof value === "function" ? $c0383476dc52626a$var$classedFunction : value ? $c0383476dc52626a$var$classedTrue : $c0383476dc52626a$var$classedFalse)(names, value));
}


function $254b8a45c270ca3d$var$textRemove() {
    this.textContent = "";
}
function $254b8a45c270ca3d$var$textConstant(value) {
    return function() {
        this.textContent = value;
    };
}
function $254b8a45c270ca3d$var$textFunction(value) {
    return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
    };
}
function $254b8a45c270ca3d$export$2e2bcd8739ae039(value) {
    return arguments.length ? this.each(value == null ? $254b8a45c270ca3d$var$textRemove : (typeof value === "function" ? $254b8a45c270ca3d$var$textFunction : $254b8a45c270ca3d$var$textConstant)(value)) : this.node().textContent;
}


function $b6a03aaf18b82cb7$var$htmlRemove() {
    this.innerHTML = "";
}
function $b6a03aaf18b82cb7$var$htmlConstant(value) {
    return function() {
        this.innerHTML = value;
    };
}
function $b6a03aaf18b82cb7$var$htmlFunction(value) {
    return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
    };
}
function $b6a03aaf18b82cb7$export$2e2bcd8739ae039(value) {
    return arguments.length ? this.each(value == null ? $b6a03aaf18b82cb7$var$htmlRemove : (typeof value === "function" ? $b6a03aaf18b82cb7$var$htmlFunction : $b6a03aaf18b82cb7$var$htmlConstant)(value)) : this.node().innerHTML;
}


function $f826d3768bd640e1$var$raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
}
function $f826d3768bd640e1$export$2e2bcd8739ae039() {
    return this.each($f826d3768bd640e1$var$raise);
}


function $580c034a94e47c45$var$lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function $580c034a94e47c45$export$2e2bcd8739ae039() {
    return this.each($580c034a94e47c45$var$lower);
}



function $1d0c0b7756bbc053$export$2e2bcd8739ae039(name) {
    var create = typeof name === "function" ? name : (0, $fda9367c6a588803$export$2e2bcd8739ae039)(name);
    return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
    });
}




function $22fcc9c1cabe0784$var$constantNull() {
    return null;
}
function $22fcc9c1cabe0784$export$2e2bcd8739ae039(name, before) {
    var create = typeof name === "function" ? name : (0, $fda9367c6a588803$export$2e2bcd8739ae039)(name), select = before == null ? $22fcc9c1cabe0784$var$constantNull : typeof before === "function" ? before : (0, $4f590ea611a05bef$export$2e2bcd8739ae039)(before);
    return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
}


function $ea0c50a7edb145ef$var$remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
}
function $ea0c50a7edb145ef$export$2e2bcd8739ae039() {
    return this.each($ea0c50a7edb145ef$var$remove);
}


function $4ed2c00d2b5a3648$var$selection_cloneShallow() {
    return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}
function $4ed2c00d2b5a3648$var$selection_cloneDeep() {
    return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}
function $4ed2c00d2b5a3648$export$2e2bcd8739ae039(deep) {
    return this.select(deep ? $4ed2c00d2b5a3648$var$selection_cloneDeep : $4ed2c00d2b5a3648$var$selection_cloneShallow);
}


function $213cb822c2fd339d$export$2e2bcd8739ae039(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
}


var $51221d920397815f$var$filterEvents = {};
var $51221d920397815f$export$6cd530ed55e06764 = null;
if (typeof document !== "undefined") {
    var $51221d920397815f$var$element = document.documentElement;
    if (!("onmouseenter" in $51221d920397815f$var$element)) $51221d920397815f$var$filterEvents = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };
}
function $51221d920397815f$var$filterContextListener(listener, index, group) {
    listener = $51221d920397815f$var$contextListener(listener, index, group);
    return function(event) {
        var related = event.relatedTarget;
        if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) listener.call(this, event);
    };
}
function $51221d920397815f$var$contextListener(listener, index, group) {
    return function(event1) {
        var event0 = $51221d920397815f$export$6cd530ed55e06764; // Events can be reentrant (e.g., focus).
        $51221d920397815f$export$6cd530ed55e06764 = event1;
        try {
            listener.call(this, this.__data__, index, group);
        } finally{
            $51221d920397815f$export$6cd530ed55e06764 = event0;
        }
    };
}
function $51221d920397815f$var$parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {
            type: t,
            name: name
        };
    });
}
function $51221d920397815f$var$onRemove(typename) {
    return function() {
        var on = this.__on;
        if (!on) return;
        for(var j = 0, i = -1, m = on.length, o; j < m; ++j)if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) this.removeEventListener(o.type, o.listener, o.capture);
        else on[++i] = o;
        if (++i) on.length = i;
        else delete this.__on;
    };
}
function $51221d920397815f$var$onAdd(typename, value, capture) {
    var wrap = $51221d920397815f$var$filterEvents.hasOwnProperty(typename.type) ? $51221d920397815f$var$filterContextListener : $51221d920397815f$var$contextListener;
    return function(d, i, group) {
        var on = this.__on, o, listener = wrap(value, i, group);
        if (on) {
            for(var j = 0, m = on.length; j < m; ++j)if ((o = on[j]).type === typename.type && o.name === typename.name) {
                this.removeEventListener(o.type, o.listener, o.capture);
                this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                o.value = value;
                return;
            }
        }
        this.addEventListener(typename.type, listener, capture);
        o = {
            type: typename.type,
            name: typename.name,
            value: value,
            listener: listener,
            capture: capture
        };
        if (!on) this.__on = [
            o
        ];
        else on.push(o);
    };
}
function $51221d920397815f$export$2e2bcd8739ae039(typename, value, capture) {
    var typenames = $51221d920397815f$var$parseTypenames(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for(var j = 0, m = on.length, o; j < m; ++j)for(i = 0, o = on[j]; i < n; ++i){
            if ((t = typenames[i]).type === o.type && t.name === o.name) return o.value;
        }
        return;
    }
    on = value ? $51221d920397815f$var$onAdd : $51221d920397815f$var$onRemove;
    if (capture == null) capture = false;
    for(i = 0; i < n; ++i)this.each(on(typenames[i], value, capture));
    return this;
}
function $51221d920397815f$export$4c724631b4750aef(event1, listener, that, args) {
    var event0 = $51221d920397815f$export$6cd530ed55e06764;
    event1.sourceEvent = $51221d920397815f$export$6cd530ed55e06764;
    $51221d920397815f$export$6cd530ed55e06764 = event1;
    try {
        return listener.apply(that, args);
    } finally{
        $51221d920397815f$export$6cd530ed55e06764 = event0;
    }
}



function $b78a95ba28249439$var$dispatchEvent(node, type, params) {
    var window = (0, $eab7317b4bab2edf$export$2e2bcd8739ae039)(node), event = window.CustomEvent;
    if (typeof event === "function") event = new event(type, params);
    else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
    }
    node.dispatchEvent(event);
}
function $b78a95ba28249439$var$dispatchConstant(type, params) {
    return function() {
        return $b78a95ba28249439$var$dispatchEvent(this, type, params);
    };
}
function $b78a95ba28249439$var$dispatchFunction(type, params) {
    return function() {
        return $b78a95ba28249439$var$dispatchEvent(this, type, params.apply(this, arguments));
    };
}
function $b78a95ba28249439$export$2e2bcd8739ae039(type, params) {
    return this.each((typeof params === "function" ? $b78a95ba28249439$var$dispatchFunction : $b78a95ba28249439$var$dispatchConstant)(type, params));
}


var $47f0ff7527d817e6$export$e8e78c978b129247 = [
    null
];
function $47f0ff7527d817e6$export$52baac22726c72bf(groups, parents) {
    this._groups = groups;
    this._parents = parents;
}
function $47f0ff7527d817e6$var$selection() {
    return new $47f0ff7527d817e6$export$52baac22726c72bf([
        [
            document.documentElement
        ]
    ], $47f0ff7527d817e6$export$e8e78c978b129247);
}
$47f0ff7527d817e6$export$52baac22726c72bf.prototype = $47f0ff7527d817e6$var$selection.prototype = {
    constructor: $47f0ff7527d817e6$export$52baac22726c72bf,
    select: (0, $dab03710c0a0451f$export$2e2bcd8739ae039),
    selectAll: (0, $f30f5dd19c67a4c1$export$2e2bcd8739ae039),
    filter: (0, $81f52857269808bb$export$2e2bcd8739ae039),
    data: (0, $b1f902012fae0c37$export$2e2bcd8739ae039),
    enter: (0, $05992484860795d1$export$2e2bcd8739ae039),
    exit: (0, $89bc1abb0fb02bc8$export$2e2bcd8739ae039),
    join: (0, $3cd2d8246dadad45$export$2e2bcd8739ae039),
    merge: (0, $14fd56101d35ce5c$export$2e2bcd8739ae039),
    order: (0, $bea68a5a8e60349e$export$2e2bcd8739ae039),
    sort: (0, $a68c5ea1f0ea990f$export$2e2bcd8739ae039),
    call: (0, $0bd409e62410acd0$export$2e2bcd8739ae039),
    nodes: (0, $75ef816dfb407940$export$2e2bcd8739ae039),
    node: (0, $32beb5e8d7d9e650$export$2e2bcd8739ae039),
    size: (0, $443db4f3d9afd0a6$export$2e2bcd8739ae039),
    empty: (0, $fe407d70e508eb9b$export$2e2bcd8739ae039),
    each: (0, $2f8eba843281fe2a$export$2e2bcd8739ae039),
    attr: (0, $fda437b40b08c6ad$export$2e2bcd8739ae039),
    style: (0, $d94089f91c15df8b$export$2e2bcd8739ae039),
    property: (0, $09c129a968eeefc2$export$2e2bcd8739ae039),
    classed: (0, $c0383476dc52626a$export$2e2bcd8739ae039),
    text: (0, $254b8a45c270ca3d$export$2e2bcd8739ae039),
    html: (0, $b6a03aaf18b82cb7$export$2e2bcd8739ae039),
    raise: (0, $f826d3768bd640e1$export$2e2bcd8739ae039),
    lower: (0, $580c034a94e47c45$export$2e2bcd8739ae039),
    append: (0, $1d0c0b7756bbc053$export$2e2bcd8739ae039),
    insert: (0, $22fcc9c1cabe0784$export$2e2bcd8739ae039),
    remove: (0, $ea0c50a7edb145ef$export$2e2bcd8739ae039),
    clone: (0, $4ed2c00d2b5a3648$export$2e2bcd8739ae039),
    datum: (0, $213cb822c2fd339d$export$2e2bcd8739ae039),
    on: (0, $51221d920397815f$export$2e2bcd8739ae039),
    dispatch: (0, $b78a95ba28249439$export$2e2bcd8739ae039)
};
var $47f0ff7527d817e6$export$2e2bcd8739ae039 = $47f0ff7527d817e6$var$selection;


function $16996812f6dbb2fd$export$2e2bcd8739ae039(selector) {
    return typeof selector === "string" ? new (0, $47f0ff7527d817e6$export$52baac22726c72bf)([
        [
            document.querySelector(selector)
        ]
    ], [
        document.documentElement
    ]) : new (0, $47f0ff7527d817e6$export$52baac22726c72bf)([
        [
            selector
        ]
    ], (0, $47f0ff7527d817e6$export$e8e78c978b129247));
}


function $b8c3510a5195aebd$export$2e2bcd8739ae039(name) {
    return (0, $16996812f6dbb2fd$export$2e2bcd8739ae039)((0, $fda9367c6a588803$export$2e2bcd8739ae039)(name).call(document.documentElement));
}



var $6beb2d084a386243$var$nextId = 0;
function $6beb2d084a386243$export$2e2bcd8739ae039() {
    return new $6beb2d084a386243$var$Local;
}
function $6beb2d084a386243$var$Local() {
    this._ = "@" + (++$6beb2d084a386243$var$nextId).toString(36);
}
$6beb2d084a386243$var$Local.prototype = $6beb2d084a386243$export$2e2bcd8739ae039.prototype = {
    constructor: $6beb2d084a386243$var$Local,
    get: function(node) {
        var id = this._;
        while(!(id in node))if (!(node = node.parentNode)) return;
        return node[id];
    },
    set: function(node, value) {
        return node[this._] = value;
    },
    remove: function(node) {
        return this._ in node && delete node[this._];
    },
    toString: function() {
        return this._;
    }
};




function $869112a2865769de$export$2e2bcd8739ae039() {
    var current = (0, $51221d920397815f$export$6cd530ed55e06764), source;
    while(source = current.sourceEvent)current = source;
    return current;
}


function $a748b3612c025563$export$2e2bcd8739ae039(node, event) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [
            point.x,
            point.y
        ];
    }
    var rect = node.getBoundingClientRect();
    return [
        event.clientX - rect.left - node.clientLeft,
        event.clientY - rect.top - node.clientTop
    ];
}


function $4d642f975effb3fb$export$2e2bcd8739ae039(node) {
    var event = (0, $869112a2865769de$export$2e2bcd8739ae039)();
    if (event.changedTouches) event = event.changedTouches[0];
    return (0, $a748b3612c025563$export$2e2bcd8739ae039)(node, event);
}







function $bea78a970dd2ffbd$export$2e2bcd8739ae039(selector) {
    return typeof selector === "string" ? new (0, $47f0ff7527d817e6$export$52baac22726c72bf)([
        document.querySelectorAll(selector)
    ], [
        document.documentElement
    ]) : new (0, $47f0ff7527d817e6$export$52baac22726c72bf)([
        selector == null ? [] : selector
    ], (0, $47f0ff7527d817e6$export$e8e78c978b129247));
}








function $acce0f202953a1f6$export$2e2bcd8739ae039(node, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = (0, $869112a2865769de$export$2e2bcd8739ae039)().changedTouches;
    for(var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i){
        if ((touch = touches[i]).identifier === identifier) return (0, $a748b3612c025563$export$2e2bcd8739ae039)(node, touch);
    }
    return null;
}




function $d396329a5562b58d$export$2e2bcd8739ae039(node, touches) {
    if (touches == null) touches = (0, $869112a2865769de$export$2e2bcd8739ae039)().touches;
    for(var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i)points[i] = (0, $a748b3612c025563$export$2e2bcd8739ae039)(node, touches[i]);
    return points;
}






var $659a76e54bfee561$var$pi = Math.PI, $659a76e54bfee561$var$tau = 2 * $659a76e54bfee561$var$pi, $659a76e54bfee561$var$epsilon = 1e-6, $659a76e54bfee561$var$tauEpsilon = $659a76e54bfee561$var$tau - $659a76e54bfee561$var$epsilon;
function $659a76e54bfee561$var$Path() {
    this._x0 = this._y0 = this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
}
function $659a76e54bfee561$var$path() {
    return new $659a76e54bfee561$var$Path;
}
$659a76e54bfee561$var$Path.prototype = $659a76e54bfee561$var$path.prototype = {
    constructor: $659a76e54bfee561$var$Path,
    moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
    },
    closePath: function() {
        if (this._x1 !== null) {
            this._x1 = this._x0, this._y1 = this._y0;
            this._ += "Z";
        }
    },
    lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
    },
    arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);
        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        else if (!(l01_2 > $659a76e54bfee561$var$epsilon)) ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > $659a76e54bfee561$var$epsilon) || !r) this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        else {
            var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan(($659a76e54bfee561$var$pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
            // If the start tangent is not coincident with (x0,y0), line to.
            if (Math.abs(t01 - 1) > $659a76e54bfee561$var$epsilon) this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
            this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
    },
    arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r;
        var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);
        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) this._ += "M" + x0 + "," + y0;
        else if (Math.abs(this._x1 - x0) > $659a76e54bfee561$var$epsilon || Math.abs(this._y1 - y0) > $659a76e54bfee561$var$epsilon) this._ += "L" + x0 + "," + y0;
        // Is this arc empty? We’re done.
        if (!r) return;
        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % $659a76e54bfee561$var$tau + $659a76e54bfee561$var$tau;
        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > $659a76e54bfee561$var$tauEpsilon) this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        else if (da > $659a76e54bfee561$var$epsilon) this._ += "A" + r + "," + r + ",0," + +(da >= $659a76e54bfee561$var$pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    },
    rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
    },
    toString: function() {
        return this._;
    }
};
var $659a76e54bfee561$export$2e2bcd8739ae039 = $659a76e54bfee561$var$path;




function $c0b6093b05e97285$export$2e2bcd8739ae039(x) {
    return function constant() {
        return x;
    };
}


var $58fe29fc1704624d$export$2335f513bbd82c6d = Math.abs;
var $58fe29fc1704624d$export$b8b770ee6a0d9760 = Math.atan2;
var $58fe29fc1704624d$export$50d414a77b60d802 = Math.cos;
var $58fe29fc1704624d$export$8960430cfd85939f = Math.max;
var $58fe29fc1704624d$export$96ec731ed4dcb222 = Math.min;
var $58fe29fc1704624d$export$5de3937cb4b592ed = Math.sin;
var $58fe29fc1704624d$export$eba8049fb5020b81 = Math.sqrt;
var $58fe29fc1704624d$export$6c421550c66a327d = 1e-12;
var $58fe29fc1704624d$export$18c7bea995a110f = Math.PI;
var $58fe29fc1704624d$export$e51408a300e8929a = $58fe29fc1704624d$export$18c7bea995a110f / 2;
var $58fe29fc1704624d$export$a4b4b4d4d776fe92 = 2 * $58fe29fc1704624d$export$18c7bea995a110f;
function $58fe29fc1704624d$export$fd6306be3fde5b04(x) {
    return x > 1 ? 0 : x < -1 ? $58fe29fc1704624d$export$18c7bea995a110f : Math.acos(x);
}
function $58fe29fc1704624d$export$41726bdb1fc63f(x) {
    return x >= 1 ? $58fe29fc1704624d$export$e51408a300e8929a : x <= -1 ? -$58fe29fc1704624d$export$e51408a300e8929a : Math.asin(x);
}


function $18605775c60868be$var$arcInnerRadius(d) {
    return d.innerRadius;
}
function $18605775c60868be$var$arcOuterRadius(d) {
    return d.outerRadius;
}
function $18605775c60868be$var$arcStartAngle(d) {
    return d.startAngle;
}
function $18605775c60868be$var$arcEndAngle(d) {
    return d.endAngle;
}
function $18605775c60868be$var$arcPadAngle(d) {
    return d && d.padAngle; // Note: optional!
}
function $18605775c60868be$var$intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
    if (t * t < (0, $58fe29fc1704624d$export$6c421550c66a327d)) return;
    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
    return [
        x0 + t * x10,
        y0 + t * y10
    ];
}
// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function $18605775c60868be$var$cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
    var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / (0, $58fe29fc1704624d$export$eba8049fb5020b81)(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * (0, $58fe29fc1704624d$export$eba8049fb5020b81)((0, $58fe29fc1704624d$export$8960430cfd85939f)(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
    // Pick the closer of the two intersection points.
    // TODO Is there a faster way to determine which intersection to use?
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
    };
}
function $18605775c60868be$export$2e2bcd8739ae039() {
    var innerRadius = $18605775c60868be$var$arcInnerRadius, outerRadius = $18605775c60868be$var$arcOuterRadius, cornerRadius = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(0), padRadius = null, startAngle = $18605775c60868be$var$arcStartAngle, endAngle = $18605775c60868be$var$arcEndAngle, padAngle = $18605775c60868be$var$arcPadAngle, context = null;
    function arc() {
        var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - (0, $58fe29fc1704624d$export$e51408a300e8929a), a1 = endAngle.apply(this, arguments) - (0, $58fe29fc1704624d$export$e51408a300e8929a), da = (0, $58fe29fc1704624d$export$2335f513bbd82c6d)(a1 - a0), cw = a1 > a0;
        if (!context) context = buffer = (0, $659a76e54bfee561$export$2e2bcd8739ae039)();
        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;
        // Is it a point?
        if (!(r1 > (0, $58fe29fc1704624d$export$6c421550c66a327d))) context.moveTo(0, 0);
        else if (da > (0, $58fe29fc1704624d$export$a4b4b4d4d776fe92) - (0, $58fe29fc1704624d$export$6c421550c66a327d)) {
            context.moveTo(r1 * (0, $58fe29fc1704624d$export$50d414a77b60d802)(a0), r1 * (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(a0));
            context.arc(0, 0, r1, a0, a1, !cw);
            if (r0 > (0, $58fe29fc1704624d$export$6c421550c66a327d)) {
                context.moveTo(r0 * (0, $58fe29fc1704624d$export$50d414a77b60d802)(a1), r0 * (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(a1));
                context.arc(0, 0, r0, a1, a0, cw);
            }
        } else {
            var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > (0, $58fe29fc1704624d$export$6c421550c66a327d) && (padRadius ? +padRadius.apply(this, arguments) : (0, $58fe29fc1704624d$export$eba8049fb5020b81)(r0 * r0 + r1 * r1)), rc = (0, $58fe29fc1704624d$export$96ec731ed4dcb222)((0, $58fe29fc1704624d$export$2335f513bbd82c6d)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
            // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
            if (rp > (0, $58fe29fc1704624d$export$6c421550c66a327d)) {
                var p0 = (0, $58fe29fc1704624d$export$41726bdb1fc63f)(rp / r0 * (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(ap)), p1 = (0, $58fe29fc1704624d$export$41726bdb1fc63f)(rp / r1 * (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(ap));
                if ((da0 -= p0 * 2) > (0, $58fe29fc1704624d$export$6c421550c66a327d)) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
                else da0 = 0, a00 = a10 = (a0 + a1) / 2;
                if ((da1 -= p1 * 2) > (0, $58fe29fc1704624d$export$6c421550c66a327d)) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
                else da1 = 0, a01 = a11 = (a0 + a1) / 2;
            }
            var x01 = r1 * (0, $58fe29fc1704624d$export$50d414a77b60d802)(a01), y01 = r1 * (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(a01), x10 = r0 * (0, $58fe29fc1704624d$export$50d414a77b60d802)(a10), y10 = r0 * (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(a10);
            // Apply rounded corners?
            if (rc > (0, $58fe29fc1704624d$export$6c421550c66a327d)) {
                var x11 = r1 * (0, $58fe29fc1704624d$export$50d414a77b60d802)(a11), y11 = r1 * (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(a11), x00 = r0 * (0, $58fe29fc1704624d$export$50d414a77b60d802)(a00), y00 = r0 * (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(a00), oc;
                // Restrict the corner radius according to the sector angle.
                if (da < (0, $58fe29fc1704624d$export$18c7bea995a110f) && (oc = $18605775c60868be$var$intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
                    var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / (0, $58fe29fc1704624d$export$5de3937cb4b592ed)((0, $58fe29fc1704624d$export$fd6306be3fde5b04)((ax * bx + ay * by) / ((0, $58fe29fc1704624d$export$eba8049fb5020b81)(ax * ax + ay * ay) * (0, $58fe29fc1704624d$export$eba8049fb5020b81)(bx * bx + by * by))) / 2), lc = (0, $58fe29fc1704624d$export$eba8049fb5020b81)(oc[0] * oc[0] + oc[1] * oc[1]);
                    rc0 = (0, $58fe29fc1704624d$export$96ec731ed4dcb222)(rc, (r0 - lc) / (kc - 1));
                    rc1 = (0, $58fe29fc1704624d$export$96ec731ed4dcb222)(rc, (r1 - lc) / (kc + 1));
                }
            }
            // Is the sector collapsed to a line?
            if (!(da1 > (0, $58fe29fc1704624d$export$6c421550c66a327d))) context.moveTo(x01, y01);
            else if (rc1 > (0, $58fe29fc1704624d$export$6c421550c66a327d)) {
                t0 = $18605775c60868be$var$cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
                t1 = $18605775c60868be$var$cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
                context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
                // Have the corners merged?
                if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t0.y01, t0.x01), (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t1.y01, t1.x01), !cw);
                else {
                    context.arc(t0.cx, t0.cy, rc1, (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t0.y01, t0.x01), (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t0.y11, t0.x11), !cw);
                    context.arc(0, 0, r1, (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t0.cy + t0.y11, t0.cx + t0.x11), (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                    context.arc(t1.cx, t1.cy, rc1, (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t1.y11, t1.x11), (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t1.y01, t1.x01), !cw);
                }
            } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
            // Is there no inner ring, and it’s a circular sector?
            // Or perhaps it’s an annular sector collapsed due to padding?
            if (!(r0 > (0, $58fe29fc1704624d$export$6c421550c66a327d)) || !(da0 > (0, $58fe29fc1704624d$export$6c421550c66a327d))) context.lineTo(x10, y10);
            else if (rc0 > (0, $58fe29fc1704624d$export$6c421550c66a327d)) {
                t0 = $18605775c60868be$var$cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
                t1 = $18605775c60868be$var$cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
                context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
                // Have the corners merged?
                if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t0.y01, t0.x01), (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t1.y01, t1.x01), !cw);
                else {
                    context.arc(t0.cx, t0.cy, rc0, (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t0.y01, t0.x01), (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t0.y11, t0.x11), !cw);
                    context.arc(0, 0, r0, (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t0.cy + t0.y11, t0.cx + t0.x11), (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                    context.arc(t1.cx, t1.cy, rc0, (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t1.y11, t1.x11), (0, $58fe29fc1704624d$export$b8b770ee6a0d9760)(t1.y01, t1.x01), !cw);
                }
            } else context.arc(0, 0, r0, a10, a00, cw);
        }
        context.closePath();
        if (buffer) return context = null, buffer + "" || null;
    }
    arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - (0, $58fe29fc1704624d$export$18c7bea995a110f) / 2;
        return [
            (0, $58fe29fc1704624d$export$50d414a77b60d802)(a) * r,
            (0, $58fe29fc1704624d$export$5de3937cb4b592ed)(a) * r
        ];
    };
    arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), arc) : innerRadius;
    };
    arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), arc) : outerRadius;
    };
    arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), arc) : cornerRadius;
    };
    arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), arc) : padRadius;
    };
    arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), arc) : startAngle;
    };
    arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), arc) : endAngle;
    };
    arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), arc) : padAngle;
    };
    arc.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, arc) : context;
    };
    return arc;
}




function $c62bbc2e0d5ae3c1$var$Linear(context) {
    this._context = context;
}
$c62bbc2e0d5ae3c1$var$Linear.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._point = 0;
    },
    lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2; // proceed
            default:
                this._context.lineTo(x, y);
                break;
        }
    }
};
function $c62bbc2e0d5ae3c1$export$2e2bcd8739ae039(context) {
    return new $c62bbc2e0d5ae3c1$var$Linear(context);
}





function $02f8ab0d96e4d093$export$d141bba7fdc215a3(p) {
    return p[0];
}
function $02f8ab0d96e4d093$export$4a5767248b18ef41(p) {
    return p[1];
}


function $14ae03011f3febeb$export$2e2bcd8739ae039() {
    var x = (0, $02f8ab0d96e4d093$export$d141bba7fdc215a3), y = (0, $02f8ab0d96e4d093$export$4a5767248b18ef41), defined = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(true), context = null, curve = (0, $c62bbc2e0d5ae3c1$export$2e2bcd8739ae039), output = null;
    function line(data) {
        var i, n = data.length, d, defined0 = false, buffer;
        if (context == null) output = curve(buffer = (0, $659a76e54bfee561$export$2e2bcd8739ae039)());
        for(i = 0; i <= n; ++i){
            if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                if (defined0 = !defined0) output.lineStart();
                else output.lineEnd();
            }
            if (defined0) output.point(+x(d, i, data), +y(d, i, data));
        }
        if (buffer) return output = null, buffer + "" || null;
    }
    line.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), line) : x;
    };
    line.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), line) : y;
    };
    line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(!!_), line) : defined;
    };
    line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
    };
    line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
    };
    return line;
}



function $bb46690fa2aa234b$export$2e2bcd8739ae039() {
    var x0 = (0, $02f8ab0d96e4d093$export$d141bba7fdc215a3), x1 = null, y0 = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(0), y1 = (0, $02f8ab0d96e4d093$export$4a5767248b18ef41), defined = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(true), context = null, curve = (0, $c62bbc2e0d5ae3c1$export$2e2bcd8739ae039), output = null;
    function area(data) {
        var i, j, k, n = data.length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
        if (context == null) output = curve(buffer = (0, $659a76e54bfee561$export$2e2bcd8739ae039)());
        for(i = 0; i <= n; ++i){
            if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                if (defined0 = !defined0) {
                    j = i;
                    output.areaStart();
                    output.lineStart();
                } else {
                    output.lineEnd();
                    output.lineStart();
                    for(k = i - 1; k >= j; --k)output.point(x0z[k], y0z[k]);
                    output.lineEnd();
                    output.areaEnd();
                }
            }
            if (defined0) {
                x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
                output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
            }
        }
        if (buffer) return output = null, buffer + "" || null;
    }
    function arealine() {
        return (0, $14ae03011f3febeb$export$2e2bcd8739ae039)().defined(defined).curve(curve).context(context);
    }
    area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), x1 = null, area) : x0;
    };
    area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), area) : x0;
    };
    area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), area) : x1;
    };
    area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), y1 = null, area) : y0;
    };
    area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), area) : y0;
    };
    area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), area) : y1;
    };
    area.lineX0 = area.lineY0 = function() {
        return arealine().x(x0).y(y0);
    };
    area.lineY1 = function() {
        return arealine().x(x0).y(y1);
    };
    area.lineX1 = function() {
        return arealine().x(x1).y(y0);
    };
    area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(!!_), area) : defined;
    };
    area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
    };
    area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
    };
    return area;
}




function $d9fabc3692b70c71$export$2e2bcd8739ae039(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}


function $dce25991d6107fd2$export$2e2bcd8739ae039(d) {
    return d;
}



function $55a45b89c38f5c6d$export$2e2bcd8739ae039() {
    var value = (0, $dce25991d6107fd2$export$2e2bcd8739ae039), sortValues = (0, $d9fabc3692b70c71$export$2e2bcd8739ae039), sort = null, startAngle = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(0), endAngle = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)((0, $58fe29fc1704624d$export$a4b4b4d4d776fe92)), padAngle = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(0);
    function pie(data) {
        var i, n = data.length, j, k, sum = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min((0, $58fe29fc1704624d$export$a4b4b4d4d776fe92), Math.max(-(0, $58fe29fc1704624d$export$a4b4b4d4d776fe92), endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
        for(i = 0; i < n; ++i)if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) sum += v;
        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) {
            return sortValues(arcs[i], arcs[j]);
        });
        else if (sort != null) index.sort(function(i, j) {
            return sort(data[i], data[j]);
        });
        // Compute the arcs! They are stored in the original data's order.
        for(i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1)j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
        };
        return arcs;
    }
    pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), pie) : value;
    };
    pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
    };
    pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
    };
    pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), pie) : startAngle;
    };
    pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), pie) : endAngle;
    };
    pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), pie) : padAngle;
    };
    return pie;
}



var $8c1f3d71453fa6cb$export$22d25ffb9fb15b6f = $8c1f3d71453fa6cb$export$2e2bcd8739ae039((0, $c62bbc2e0d5ae3c1$export$2e2bcd8739ae039));
function $8c1f3d71453fa6cb$var$Radial(curve) {
    this._curve = curve;
}
$8c1f3d71453fa6cb$var$Radial.prototype = {
    areaStart: function() {
        this._curve.areaStart();
    },
    areaEnd: function() {
        this._curve.areaEnd();
    },
    lineStart: function() {
        this._curve.lineStart();
    },
    lineEnd: function() {
        this._curve.lineEnd();
    },
    point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
    }
};
function $8c1f3d71453fa6cb$export$2e2bcd8739ae039(curve) {
    function radial(context) {
        return new $8c1f3d71453fa6cb$var$Radial(curve(context));
    }
    radial._curve = curve;
    return radial;
}





function $41197ff81f85f528$export$4d8815a75dc8cd4d(l) {
    var c = l.curve;
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    l.curve = function(_) {
        return arguments.length ? c((0, $8c1f3d71453fa6cb$export$2e2bcd8739ae039)(_)) : c()._curve;
    };
    return l;
}
function $41197ff81f85f528$export$2e2bcd8739ae039() {
    return $41197ff81f85f528$export$4d8815a75dc8cd4d((0, $14ae03011f3febeb$export$2e2bcd8739ae039)().curve((0, $8c1f3d71453fa6cb$export$22d25ffb9fb15b6f)));
}


function $93a2a166285469f6$export$2e2bcd8739ae039() {
    var a = (0, $bb46690fa2aa234b$export$2e2bcd8739ae039)().curve((0, $8c1f3d71453fa6cb$export$22d25ffb9fb15b6f)), c = a.curve, x0 = a.lineX0, x1 = a.lineX1, y0 = a.lineY0, y1 = a.lineY1;
    a.angle = a.x, delete a.x;
    a.startAngle = a.x0, delete a.x0;
    a.endAngle = a.x1, delete a.x1;
    a.radius = a.y, delete a.y;
    a.innerRadius = a.y0, delete a.y0;
    a.outerRadius = a.y1, delete a.y1;
    a.lineStartAngle = function() {
        return (0, $41197ff81f85f528$export$4d8815a75dc8cd4d)(x0());
    }, delete a.lineX0;
    a.lineEndAngle = function() {
        return (0, $41197ff81f85f528$export$4d8815a75dc8cd4d)(x1());
    }, delete a.lineX1;
    a.lineInnerRadius = function() {
        return (0, $41197ff81f85f528$export$4d8815a75dc8cd4d)(y0());
    }, delete a.lineY0;
    a.lineOuterRadius = function() {
        return (0, $41197ff81f85f528$export$4d8815a75dc8cd4d)(y1());
    }, delete a.lineY1;
    a.curve = function(_) {
        return arguments.length ? c((0, $8c1f3d71453fa6cb$export$2e2bcd8739ae039)(_)) : c()._curve;
    };
    return a;
}



function $f8ea25b22812809f$export$2e2bcd8739ae039(x, y) {
    return [
        (y = +y) * Math.cos(x -= Math.PI / 2),
        y * Math.sin(x)
    ];
}



var $1ea21deb2cf4686c$export$58adb3bec8346d0f = Array.prototype.slice;





function $d16d7467e5ecbb0c$var$linkSource(d) {
    return d.source;
}
function $d16d7467e5ecbb0c$var$linkTarget(d) {
    return d.target;
}
function $d16d7467e5ecbb0c$var$link(curve) {
    var source = $d16d7467e5ecbb0c$var$linkSource, target = $d16d7467e5ecbb0c$var$linkTarget, x = (0, $02f8ab0d96e4d093$export$d141bba7fdc215a3), y = (0, $02f8ab0d96e4d093$export$4a5767248b18ef41), context = null;
    function link() {
        var buffer, argv = (0, $1ea21deb2cf4686c$export$58adb3bec8346d0f).call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
        if (!context) context = buffer = (0, $659a76e54bfee561$export$2e2bcd8739ae039)();
        curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
        if (buffer) return context = null, buffer + "" || null;
    }
    link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
    };
    link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
    };
    link.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), link) : x;
    };
    link.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), link) : y;
    };
    link.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, link) : context;
    };
    return link;
}
function $d16d7467e5ecbb0c$var$curveHorizontal(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}
function $d16d7467e5ecbb0c$var$curveVertical(context, x0, y0, x1, y1) {
    context.moveTo(x0, y0);
    context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}
function $d16d7467e5ecbb0c$var$curveRadial(context, x0, y0, x1, y1) {
    var p0 = (0, $f8ea25b22812809f$export$2e2bcd8739ae039)(x0, y0), p1 = (0, $f8ea25b22812809f$export$2e2bcd8739ae039)(x0, y0 = (y0 + y1) / 2), p2 = (0, $f8ea25b22812809f$export$2e2bcd8739ae039)(x1, y0), p3 = (0, $f8ea25b22812809f$export$2e2bcd8739ae039)(x1, y1);
    context.moveTo(p0[0], p0[1]);
    context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}
function $d16d7467e5ecbb0c$export$e7c381889b2cd14d() {
    return $d16d7467e5ecbb0c$var$link($d16d7467e5ecbb0c$var$curveHorizontal);
}
function $d16d7467e5ecbb0c$export$75de4c8c66884e04() {
    return $d16d7467e5ecbb0c$var$link($d16d7467e5ecbb0c$var$curveVertical);
}
function $d16d7467e5ecbb0c$export$7739cfe68d4e0799() {
    var l = $d16d7467e5ecbb0c$var$link($d16d7467e5ecbb0c$var$curveRadial);
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    return l;
}




var $28e55ddb3ac1e20c$export$2e2bcd8739ae039 = {
    draw: function(context, size) {
        var r = Math.sqrt(size / (0, $58fe29fc1704624d$export$18c7bea995a110f));
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, (0, $58fe29fc1704624d$export$a4b4b4d4d776fe92));
    }
};


var $c01388b9e0237eea$export$2e2bcd8739ae039 = {
    draw: function(context, size) {
        var r = Math.sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
    }
};


var $c9755e22155ee12d$var$tan30 = Math.sqrt(1 / 3), $c9755e22155ee12d$var$tan30_2 = $c9755e22155ee12d$var$tan30 * 2;
var $c9755e22155ee12d$export$2e2bcd8739ae039 = {
    draw: function(context, size) {
        var y = Math.sqrt(size / $c9755e22155ee12d$var$tan30_2), x = y * $c9755e22155ee12d$var$tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
    }
};



var $792afb9d435fed72$var$ka = 0.89081309152928522810, $792afb9d435fed72$var$kr = Math.sin((0, $58fe29fc1704624d$export$18c7bea995a110f) / 10) / Math.sin(7 * (0, $58fe29fc1704624d$export$18c7bea995a110f) / 10), $792afb9d435fed72$var$kx = Math.sin((0, $58fe29fc1704624d$export$a4b4b4d4d776fe92) / 10) * $792afb9d435fed72$var$kr, $792afb9d435fed72$var$ky = -Math.cos((0, $58fe29fc1704624d$export$a4b4b4d4d776fe92) / 10) * $792afb9d435fed72$var$kr;
var $792afb9d435fed72$export$2e2bcd8739ae039 = {
    draw: function(context, size) {
        var r = Math.sqrt(size * $792afb9d435fed72$var$ka), x = $792afb9d435fed72$var$kx * r, y = $792afb9d435fed72$var$ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for(var i = 1; i < 5; ++i){
            var a = (0, $58fe29fc1704624d$export$a4b4b4d4d776fe92) * i / 5, c = Math.cos(a), s = Math.sin(a);
            context.lineTo(s * r, -c * r);
            context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
    }
};


var $d5dc71be3a015b6e$export$2e2bcd8739ae039 = {
    draw: function(context, size) {
        var w = Math.sqrt(size), x = -w / 2;
        context.rect(x, x, w, w);
    }
};


var $b15f1c07b54e1260$var$sqrt3 = Math.sqrt(3);
var $b15f1c07b54e1260$export$2e2bcd8739ae039 = {
    draw: function(context, size) {
        var y = -Math.sqrt(size / ($b15f1c07b54e1260$var$sqrt3 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-$b15f1c07b54e1260$var$sqrt3 * y, -y);
        context.lineTo($b15f1c07b54e1260$var$sqrt3 * y, -y);
        context.closePath();
    }
};


var $0edf2fd5163e54d8$var$c = -0.5, $0edf2fd5163e54d8$var$s = Math.sqrt(3) / 2, $0edf2fd5163e54d8$var$k = 1 / Math.sqrt(12), $0edf2fd5163e54d8$var$a = ($0edf2fd5163e54d8$var$k / 2 + 1) * 3;
var $0edf2fd5163e54d8$export$2e2bcd8739ae039 = {
    draw: function(context, size) {
        var r = Math.sqrt(size / $0edf2fd5163e54d8$var$a), x0 = r / 2, y0 = r * $0edf2fd5163e54d8$var$k, x1 = x0, y1 = r * $0edf2fd5163e54d8$var$k + r, x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo($0edf2fd5163e54d8$var$c * x0 - $0edf2fd5163e54d8$var$s * y0, $0edf2fd5163e54d8$var$s * x0 + $0edf2fd5163e54d8$var$c * y0);
        context.lineTo($0edf2fd5163e54d8$var$c * x1 - $0edf2fd5163e54d8$var$s * y1, $0edf2fd5163e54d8$var$s * x1 + $0edf2fd5163e54d8$var$c * y1);
        context.lineTo($0edf2fd5163e54d8$var$c * x2 - $0edf2fd5163e54d8$var$s * y2, $0edf2fd5163e54d8$var$s * x2 + $0edf2fd5163e54d8$var$c * y2);
        context.lineTo($0edf2fd5163e54d8$var$c * x0 + $0edf2fd5163e54d8$var$s * y0, $0edf2fd5163e54d8$var$c * y0 - $0edf2fd5163e54d8$var$s * x0);
        context.lineTo($0edf2fd5163e54d8$var$c * x1 + $0edf2fd5163e54d8$var$s * y1, $0edf2fd5163e54d8$var$c * y1 - $0edf2fd5163e54d8$var$s * x1);
        context.lineTo($0edf2fd5163e54d8$var$c * x2 + $0edf2fd5163e54d8$var$s * y2, $0edf2fd5163e54d8$var$c * y2 - $0edf2fd5163e54d8$var$s * x2);
        context.closePath();
    }
};



var $c69e5775ad0965c9$export$47616e9f7f5fe113 = [
    (0, $28e55ddb3ac1e20c$export$2e2bcd8739ae039),
    (0, $c01388b9e0237eea$export$2e2bcd8739ae039),
    (0, $c9755e22155ee12d$export$2e2bcd8739ae039),
    (0, $d5dc71be3a015b6e$export$2e2bcd8739ae039),
    (0, $792afb9d435fed72$export$2e2bcd8739ae039),
    (0, $b15f1c07b54e1260$export$2e2bcd8739ae039),
    (0, $0edf2fd5163e54d8$export$2e2bcd8739ae039)
];
function $c69e5775ad0965c9$export$2e2bcd8739ae039() {
    var type = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)((0, $28e55ddb3ac1e20c$export$2e2bcd8739ae039)), size = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(64), context = null;
    function symbol() {
        var buffer;
        if (!context) context = buffer = (0, $659a76e54bfee561$export$2e2bcd8739ae039)();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
    }
    symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(_), symbol) : type;
    };
    symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), symbol) : size;
    };
    symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
    };
    return symbol;
}









function $a52f81df76dd5c9d$export$2e2bcd8739ae039() {}


function $e4fdf817574b5934$export$105684a3041cb6f3(that, x, y) {
    that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}
function $e4fdf817574b5934$export$957f7263e89bedd2(context) {
    this._context = context;
}
$e4fdf817574b5934$export$957f7263e89bedd2.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 3:
                $e4fdf817574b5934$export$105684a3041cb6f3(this, this._x1, this._y1); // proceed
            case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
            default:
                $e4fdf817574b5934$export$105684a3041cb6f3(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
    }
};
function $e4fdf817574b5934$export$2e2bcd8739ae039(context) {
    return new $e4fdf817574b5934$export$957f7263e89bedd2(context);
}


function $bf869cb37297c110$var$BasisClosed(context) {
    this._context = context;
}
$bf869cb37297c110$var$BasisClosed.prototype = {
    areaStart: (0, $a52f81df76dd5c9d$export$2e2bcd8739ae039),
    areaEnd: (0, $a52f81df76dd5c9d$export$2e2bcd8739ae039),
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 1:
                this._context.moveTo(this._x2, this._y2);
                this._context.closePath();
                break;
            case 2:
                this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
                this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
                this._context.closePath();
                break;
            case 3:
                this.point(this._x2, this._y2);
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                break;
        }
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._x2 = x, this._y2 = y;
                break;
            case 1:
                this._point = 2;
                this._x3 = x, this._y3 = y;
                break;
            case 2:
                this._point = 3;
                this._x4 = x, this._y4 = y;
                this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);
                break;
            default:
                (0, $e4fdf817574b5934$export$105684a3041cb6f3)(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
    }
};
function $bf869cb37297c110$export$2e2bcd8739ae039(context) {
    return new $bf869cb37297c110$var$BasisClosed(context);
}



function $a15c69d7830165e8$var$BasisOpen(context) {
    this._context = context;
}
$a15c69d7830165e8$var$BasisOpen.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6;
                this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
                break;
            case 3:
                this._point = 4; // proceed
            default:
                (0, $e4fdf817574b5934$export$105684a3041cb6f3)(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
    }
};
function $a15c69d7830165e8$export$2e2bcd8739ae039(context) {
    return new $a15c69d7830165e8$var$BasisOpen(context);
}




function $f7d25b7a9308435c$var$Bundle(context, beta) {
    this._basis = new (0, $e4fdf817574b5934$export$957f7263e89bedd2)(context);
    this._beta = beta;
}
$f7d25b7a9308435c$var$Bundle.prototype = {
    lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
    },
    lineEnd: function() {
        var x = this._x, y = this._y, j = x.length - 1;
        if (j > 0) {
            var x0 = x[0], y0 = y[0], dx = x[j] - x0, dy = y[j] - y0, i = -1, t;
            while(++i <= j){
                t = i / j;
                this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
            }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
    },
    point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
    }
};
var $f7d25b7a9308435c$export$2e2bcd8739ae039 = function custom(beta) {
    function bundle(context) {
        return beta === 1 ? new (0, $e4fdf817574b5934$export$957f7263e89bedd2)(context) : new $f7d25b7a9308435c$var$Bundle(context, beta);
    }
    bundle.beta = function(beta) {
        return custom(+beta);
    };
    return bundle;
}(0.85);



function $a9243399d4181168$export$105684a3041cb6f3(that, x, y) {
    that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}
function $a9243399d4181168$export$ee51ff373511cbeb(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
}
$a9243399d4181168$export$ee51ff373511cbeb.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 2:
                this._context.lineTo(this._x2, this._y2);
                break;
            case 3:
                $a9243399d4181168$export$105684a3041cb6f3(this, this._x1, this._y1);
                break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                this._x1 = x, this._y1 = y;
                break;
            case 2:
                this._point = 3; // proceed
            default:
                $a9243399d4181168$export$105684a3041cb6f3(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
var $a9243399d4181168$export$2e2bcd8739ae039 = function custom(tension) {
    function cardinal(context) {
        return new $a9243399d4181168$export$ee51ff373511cbeb(context, tension);
    }
    cardinal.tension = function(tension) {
        return custom(+tension);
    };
    return cardinal;
}(0);


function $3b31fc8f2a67ec3b$export$da3940d7e9162858(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
}
$3b31fc8f2a67ec3b$export$da3940d7e9162858.prototype = {
    areaStart: (0, $a52f81df76dd5c9d$export$2e2bcd8739ae039),
    areaEnd: (0, $a52f81df76dd5c9d$export$2e2bcd8739ae039),
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 1:
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
            case 2:
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
            case 3:
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
        }
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._x3 = x, this._y3 = y;
                break;
            case 1:
                this._point = 2;
                this._context.moveTo(this._x4 = x, this._y4 = y);
                break;
            case 2:
                this._point = 3;
                this._x5 = x, this._y5 = y;
                break;
            default:
                (0, $a9243399d4181168$export$105684a3041cb6f3)(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
var $3b31fc8f2a67ec3b$export$2e2bcd8739ae039 = function custom(tension) {
    function cardinal(context) {
        return new $3b31fc8f2a67ec3b$export$da3940d7e9162858(context, tension);
    }
    cardinal.tension = function(tension) {
        return custom(+tension);
    };
    return cardinal;
}(0);



function $7ab51d756d450b7a$export$cd7d1a617282f2f1(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
}
$7ab51d756d450b7a$export$cd7d1a617282f2f1.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                break;
            case 3:
                this._point = 4; // proceed
            default:
                (0, $a9243399d4181168$export$105684a3041cb6f3)(this, x, y);
                break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
var $7ab51d756d450b7a$export$2e2bcd8739ae039 = function custom(tension) {
    function cardinal(context) {
        return new $7ab51d756d450b7a$export$cd7d1a617282f2f1(context, tension);
    }
    cardinal.tension = function(tension) {
        return custom(+tension);
    };
    return cardinal;
}(0);







function $d92544c575400883$export$105684a3041cb6f3(that, x, y) {
    var x1 = that._x1, y1 = that._y1, x2 = that._x2, y2 = that._y2;
    if (that._l01_a > (0, $58fe29fc1704624d$export$6c421550c66a327d)) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
    }
    if (that._l23_a > (0, $58fe29fc1704624d$export$6c421550c66a327d)) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
    }
    that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}
function $d92544c575400883$var$CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
}
$d92544c575400883$var$CatmullRom.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 2:
                this._context.lineTo(this._x2, this._y2);
                break;
            case 3:
                this.point(this._x2, this._y2);
                break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        if (this._point) {
            var x23 = this._x2 - x, y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3; // proceed
            default:
                $d92544c575400883$export$105684a3041cb6f3(this, x, y);
                break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
var $d92544c575400883$export$2e2bcd8739ae039 = function custom(alpha) {
    function catmullRom(context) {
        return alpha ? new $d92544c575400883$var$CatmullRom(context, alpha) : new (0, $a9243399d4181168$export$ee51ff373511cbeb)(context, 0);
    }
    catmullRom.alpha = function(alpha) {
        return custom(+alpha);
    };
    return catmullRom;
}(0.5);


function $265f344876d7bce7$var$CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
}
$265f344876d7bce7$var$CatmullRomClosed.prototype = {
    areaStart: (0, $a52f81df76dd5c9d$export$2e2bcd8739ae039),
    areaEnd: (0, $a52f81df76dd5c9d$export$2e2bcd8739ae039),
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 1:
                this._context.moveTo(this._x3, this._y3);
                this._context.closePath();
                break;
            case 2:
                this._context.lineTo(this._x3, this._y3);
                this._context.closePath();
                break;
            case 3:
                this.point(this._x3, this._y3);
                this.point(this._x4, this._y4);
                this.point(this._x5, this._y5);
                break;
        }
    },
    point: function(x, y) {
        x = +x, y = +y;
        if (this._point) {
            var x23 = this._x2 - x, y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch(this._point){
            case 0:
                this._point = 1;
                this._x3 = x, this._y3 = y;
                break;
            case 1:
                this._point = 2;
                this._context.moveTo(this._x4 = x, this._y4 = y);
                break;
            case 2:
                this._point = 3;
                this._x5 = x, this._y5 = y;
                break;
            default:
                (0, $d92544c575400883$export$105684a3041cb6f3)(this, x, y);
                break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
var $265f344876d7bce7$export$2e2bcd8739ae039 = function custom(alpha) {
    function catmullRom(context) {
        return alpha ? new $265f344876d7bce7$var$CatmullRomClosed(context, alpha) : new (0, $3b31fc8f2a67ec3b$export$da3940d7e9162858)(context, 0);
    }
    catmullRom.alpha = function(alpha) {
        return custom(+alpha);
    };
    return catmullRom;
}(0.5);




function $d673e23cb420c930$var$CatmullRomOpen(context, alpha) {
    this._context = context;
    this._alpha = alpha;
}
$d673e23cb420c930$var$CatmullRomOpen.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        if (this._point) {
            var x23 = this._x2 - x, y23 = this._y2 - y;
            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch(this._point){
            case 0:
                this._point = 1;
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                break;
            case 3:
                this._point = 4; // proceed
            default:
                (0, $d92544c575400883$export$105684a3041cb6f3)(this, x, y);
                break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
    }
};
var $d673e23cb420c930$export$2e2bcd8739ae039 = function custom(alpha) {
    function catmullRom(context) {
        return alpha ? new $d673e23cb420c930$var$CatmullRomOpen(context, alpha) : new (0, $7ab51d756d450b7a$export$cd7d1a617282f2f1)(context, 0);
    }
    catmullRom.alpha = function(alpha) {
        return custom(+alpha);
    };
    return catmullRom;
}(0.5);




function $dddbe39c397fa6ba$var$LinearClosed(context) {
    this._context = context;
}
$dddbe39c397fa6ba$var$LinearClosed.prototype = {
    areaStart: (0, $a52f81df76dd5c9d$export$2e2bcd8739ae039),
    areaEnd: (0, $a52f81df76dd5c9d$export$2e2bcd8739ae039),
    lineStart: function() {
        this._point = 0;
    },
    lineEnd: function() {
        if (this._point) this._context.closePath();
    },
    point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
    }
};
function $dddbe39c397fa6ba$export$2e2bcd8739ae039(context) {
    return new $dddbe39c397fa6ba$var$LinearClosed(context);
}



function $5ea3e689a22014cd$var$sign(x) {
    return x < 0 ? -1 : 1;
}
// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function $5ea3e689a22014cd$var$slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return ($5ea3e689a22014cd$var$sign(s0) + $5ea3e689a22014cd$var$sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
// Calculate a one-sided slope.
function $5ea3e689a22014cd$var$slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function $5ea3e689a22014cd$var$point(that, t0, t1) {
    var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}
function $5ea3e689a22014cd$var$MonotoneX(context) {
    this._context = context;
}
$5ea3e689a22014cd$var$MonotoneX.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        switch(this._point){
            case 2:
                this._context.lineTo(this._x1, this._y1);
                break;
            case 3:
                $5ea3e689a22014cd$var$point(this, this._t0, $5ea3e689a22014cd$var$slope2(this, this._t0));
                break;
        }
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
    },
    point: function(x, y) {
        var t1 = NaN;
        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                $5ea3e689a22014cd$var$point(this, $5ea3e689a22014cd$var$slope2(this, t1 = $5ea3e689a22014cd$var$slope3(this, x, y)), t1);
                break;
            default:
                $5ea3e689a22014cd$var$point(this, this._t0, t1 = $5ea3e689a22014cd$var$slope3(this, x, y));
                break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
    }
};
function $5ea3e689a22014cd$var$MonotoneY(context) {
    this._context = new $5ea3e689a22014cd$var$ReflectContext(context);
}
($5ea3e689a22014cd$var$MonotoneY.prototype = Object.create($5ea3e689a22014cd$var$MonotoneX.prototype)).point = function(x, y) {
    $5ea3e689a22014cd$var$MonotoneX.prototype.point.call(this, y, x);
};
function $5ea3e689a22014cd$var$ReflectContext(context) {
    this._context = context;
}
$5ea3e689a22014cd$var$ReflectContext.prototype = {
    moveTo: function(x, y) {
        this._context.moveTo(y, x);
    },
    closePath: function() {
        this._context.closePath();
    },
    lineTo: function(x, y) {
        this._context.lineTo(y, x);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
    }
};
function $5ea3e689a22014cd$export$99563b5420dbdc55(context) {
    return new $5ea3e689a22014cd$var$MonotoneX(context);
}
function $5ea3e689a22014cd$export$8b5360456d6bdb88(context) {
    return new $5ea3e689a22014cd$var$MonotoneY(context);
}


function $4e30ebc830a42a27$var$Natural(context) {
    this._context = context;
}
$4e30ebc830a42a27$var$Natural.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x = [];
        this._y = [];
    },
    lineEnd: function() {
        var x = this._x, y = this._y, n = x.length;
        if (n) {
            this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
            if (n === 2) this._context.lineTo(x[1], y[1]);
            else {
                var px = $4e30ebc830a42a27$var$controlPoints(x), py = $4e30ebc830a42a27$var$controlPoints(y);
                for(var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1)this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
        }
        if (this._line || this._line !== 0 && n === 1) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
    },
    point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
    }
};
// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function $4e30ebc830a42a27$var$controlPoints(x) {
    var i, n = x.length - 1, m, a = new Array(n), b = new Array(n), r = new Array(n);
    a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
    for(i = 1; i < n - 1; ++i)a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
    a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
    for(i = 1; i < n; ++i)m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
    a[n - 1] = r[n - 1] / b[n - 1];
    for(i = n - 2; i >= 0; --i)a[i] = (r[i] - a[i + 1]) / b[i];
    b[n - 1] = (x[n] + a[n - 1]) / 2;
    for(i = 0; i < n - 1; ++i)b[i] = 2 * x[i + 1] - a[i + 1];
    return [
        a,
        b
    ];
}
function $4e30ebc830a42a27$export$2e2bcd8739ae039(context) {
    return new $4e30ebc830a42a27$var$Natural(context);
}


function $d67a219f4d6f6740$var$Step(context, t) {
    this._context = context;
    this._t = t;
}
$d67a219f4d6f6740$var$Step.prototype = {
    areaStart: function() {
        this._line = 0;
    },
    areaEnd: function() {
        this._line = NaN;
    },
    lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
    },
    lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x, y) {
        x = +x, y = +y;
        switch(this._point){
            case 0:
                this._point = 1;
                this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                break;
            case 1:
                this._point = 2; // proceed
            default:
                if (this._t <= 0) {
                    this._context.lineTo(this._x, y);
                    this._context.lineTo(x, y);
                } else {
                    var x1 = this._x * (1 - this._t) + x * this._t;
                    this._context.lineTo(x1, this._y);
                    this._context.lineTo(x1, y);
                }
                break;
        }
        this._x = x, this._y = y;
    }
};
function $d67a219f4d6f6740$export$2e2bcd8739ae039(context) {
    return new $d67a219f4d6f6740$var$Step(context, 0.5);
}
function $d67a219f4d6f6740$export$10eafa5b7478b343(context) {
    return new $d67a219f4d6f6740$var$Step(context, 0);
}
function $d67a219f4d6f6740$export$793b3db073781cbb(context) {
    return new $d67a219f4d6f6740$var$Step(context, 1);
}




function $1c9db2b18ac54216$export$2e2bcd8739ae039(series, order) {
    if (!((n = series.length) > 1)) return;
    for(var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i){
        s0 = s1, s1 = series[order[i]];
        for(j = 0; j < m; ++j)s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
}


function $01369ffdc21f4142$export$2e2bcd8739ae039(series) {
    var n = series.length, o = new Array(n);
    while(--n >= 0)o[n] = n;
    return o;
}


function $3349e466f7240ede$var$stackValue(d, key) {
    return d[key];
}
function $3349e466f7240ede$export$2e2bcd8739ae039() {
    var keys = (0, $c0b6093b05e97285$export$2e2bcd8739ae039)([]), order = (0, $01369ffdc21f4142$export$2e2bcd8739ae039), offset = (0, $1c9db2b18ac54216$export$2e2bcd8739ae039), value = $3349e466f7240ede$var$stackValue;
    function stack(data) {
        var kz = keys.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;
        for(i = 0; i < n; ++i){
            for(var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j){
                si[j] = sij = [
                    0,
                    +value(data[j], ki, j, data)
                ];
                sij.data = data[j];
            }
            si.key = ki;
        }
        for(i = 0, oz = order(sz); i < n; ++i)sz[oz[i]].index = i;
        offset(sz, oz);
        return sz;
    }
    stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)((0, $1ea21deb2cf4686c$export$58adb3bec8346d0f).call(_)), stack) : keys;
    };
    stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)(+_), stack) : value;
    };
    stack.order = function(_) {
        return arguments.length ? (order = _ == null ? (0, $01369ffdc21f4142$export$2e2bcd8739ae039) : typeof _ === "function" ? _ : (0, $c0b6093b05e97285$export$2e2bcd8739ae039)((0, $1ea21deb2cf4686c$export$58adb3bec8346d0f).call(_)), stack) : order;
    };
    stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? (0, $1c9db2b18ac54216$export$2e2bcd8739ae039) : _, stack) : offset;
    };
    return stack;
}



function $d20ff38acf83bbc1$export$2e2bcd8739ae039(series, order) {
    if (!((n = series.length) > 0)) return;
    for(var i, n, j = 0, m = series[0].length, y; j < m; ++j){
        for(y = i = 0; i < n; ++i)y += series[i][j][1] || 0;
        if (y) for(i = 0; i < n; ++i)series[i][j][1] /= y;
    }
    (0, $1c9db2b18ac54216$export$2e2bcd8739ae039)(series, order);
}


function $c8bed2a984959293$export$2e2bcd8739ae039(series, order) {
    if (!((n = series.length) > 0)) return;
    for(var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j)for(yp = yn = 0, i = 0; i < n; ++i){
        if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) d[0] = yp, d[1] = yp += dy;
        else if (dy < 0) d[1] = yn, d[0] = yn += dy;
        else d[0] = yp;
    }
}




function $3079b05d9671ea5d$export$2e2bcd8739ae039(series, order) {
    if (!((n = series.length) > 0)) return;
    for(var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j){
        for(var i = 0, y = 0; i < n; ++i)y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
    }
    (0, $1c9db2b18ac54216$export$2e2bcd8739ae039)(series, order);
}



function $f2564751c0176cb5$export$2e2bcd8739ae039(series, order) {
    if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
    for(var y = 0, j = 1, s0, m, n; j < m; ++j){
        for(var i = 0, s1 = 0, s2 = 0; i < n; ++i){
            var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
            for(var k = 0; k < i; ++k){
                var sk = series[order[k]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
                s3 += skj0 - skj1;
            }
            s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    (0, $1c9db2b18ac54216$export$2e2bcd8739ae039)(series, order);
}



function $d1a3966ac5b2ee01$export$2e2bcd8739ae039(series) {
    var peaks = series.map($d1a3966ac5b2ee01$var$peak);
    return (0, $01369ffdc21f4142$export$2e2bcd8739ae039)(series).sort(function(a, b) {
        return peaks[a] - peaks[b];
    });
}
function $d1a3966ac5b2ee01$var$peak(series) {
    var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
    while(++i < n)if ((vi = +series[i][1]) > vj) vj = vi, j = i;
    return j;
}



function $1cd14c89163897f2$export$2e2bcd8739ae039(series) {
    var sums = series.map($1cd14c89163897f2$export$8a63f25cc62965f1);
    return (0, $01369ffdc21f4142$export$2e2bcd8739ae039)(series).sort(function(a, b) {
        return sums[a] - sums[b];
    });
}
function $1cd14c89163897f2$export$8a63f25cc62965f1(series) {
    var s = 0, i = -1, n = series.length, v;
    while(++i < n)if (v = +series[i][1]) s += v;
    return s;
}



function $1880a21aa34f2fb0$export$2e2bcd8739ae039(series) {
    return (0, $1cd14c89163897f2$export$2e2bcd8739ae039)(series).reverse();
}




function $2862173abfe9fd92$export$2e2bcd8739ae039(series) {
    var n = series.length, i, j, sums = series.map((0, $1cd14c89163897f2$export$8a63f25cc62965f1)), order = (0, $d1a3966ac5b2ee01$export$2e2bcd8739ae039)(series), top = 0, bottom = 0, tops = [], bottoms = [];
    for(i = 0; i < n; ++i){
        j = order[i];
        if (top < bottom) {
            top += sums[j];
            tops.push(j);
        } else {
            bottom += sums[j];
            bottoms.push(j);
        }
    }
    return bottoms.reverse().concat(tops);
}




function $c2d6d1e248093399$export$2e2bcd8739ae039(series) {
    return (0, $01369ffdc21f4142$export$2e2bcd8739ae039)(series).reverse();
}







var $aaLBe = parcelRequire("aaLBe");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.




var $aaLBe = parcelRequire("aaLBe");
let $166742fb3809db53$export$6e85f3d13744656e = class SvgTooltip extends $aaLBe.Component {
    constructor(...args){
        super(...args);
        this.width = 0;
        this.height = 0;
    }
    render() {
        return /*#__PURE__*/ $aaLBe.createElement("g", {
            transform: `translate(${-0.5 * this.width},0)`
        }, /*#__PURE__*/ $aaLBe.createElement("rect", {
            x: this.props.x - 10,
            y: this.props.y,
            rx: 2,
            ry: 2,
            width: this.width + 20,
            height: this.height + 10,
            className: "tooltip-background"
        }), /*#__PURE__*/ $aaLBe.createElement("text", {
            y: this.props.y,
            ref: (e)=>{
                if (e) {
                    const r = e.getBoundingClientRect();
                    this.width = r.width;
                    this.height = r.height;
                }
            }
        }, this.props.lines.map((line, i)=>/*#__PURE__*/ $aaLBe.createElement("tspan", {
                key: i,
                className: "tip-text",
                x: this.props.x,
                dy: "12pt"
            }, line))));
    }
};
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $166742fb3809db53$export$6e85f3d13744656e.prototype, "width", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $166742fb3809db53$export$6e85f3d13744656e.prototype, "height", void 0);
$166742fb3809db53$export$6e85f3d13744656e = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $166742fb3809db53$export$6e85f3d13744656e);


const $30946a890274e276$var$range = (n)=>Array.from({
        length: n
    }, (_, key)=>key);
const $30946a890274e276$var$HISTOGRAM_HEIGHT = 40;
function $30946a890274e276$var$invertBand(scale, x) {
    const rg = scale.range();
    if (x < rg[0] || x > rg[1]) return NaN;
    const index = Math.floor((x - rg[0]) / (rg[1] - rg[0]) * scale.domain().length);
    return scale.domain()[index];
}
function $30946a890274e276$var$fixupStepCurve(path) {
    // example path: M1,77L74,77L74,77L147,77L147,77
    // this only works with rounded to integers which i problematic for scales with non rounding, perhaps either round AFTER scale or use better regular expression
    // like this: [-+]?[0-9]*\.?[0-9]+. instead of (\d+)
    // const match = /(\d+),(\d+)L(\d+),(\d+)L(\d+),(\d+)$/.exec(path);
    // const x = 2 * parseInt(match[5]) - parseInt(match[1]);
    const match = /([-+]?[0-9]*\.?[0-9]+),([-+]?[0-9]*\.?[0-9]+)L([-+]?[0-9]*\.?[0-9]+),([-+]?[0-9]*\.?[0-9]+)L([-+]?[0-9]*\.?[0-9]+),([-+]?[0-9]*\.?[0-9]+)$/.exec(path);
    const x = 2 * parseInt(match[5]) - parseInt(match[1]);
    return path + `L${x},${match[6]}`;
}
let $30946a890274e276$export$c29a7778178a18c9 = class ShapeChart extends $aaLBe.Component {
    constructor(...args){
        super(...args);
        this.showCrosshair = false;
        this.crosshairPosition = [
            0,
            0
        ];
        this.showTooltip1 = false;
        this.showTooltip2 = false;
    }
    mouseMove(e, feature, x, y) {
        const margin = {
            top: 0,
            right: 20,
            bottom: 0,
            left: 60
        };
        const myContainer = e.currentTarget;
        const mouseX = (0, $a748b3612c025563$export$2e2bcd8739ae039)(myContainer, e)[0] - margin.left;
        this.crosshairDomain = feature.valueType === "numerical" ? x.invert(mouseX) : $30946a890274e276$var$invertBand(x, mouseX);
        this.crosshairPrediction = feature.getPrediction(this.crosshairDomain);
        if (!isNaN(this.crosshairPrediction)) this.crosshairPosition = [
            mouseX,
            y(this.crosshairPrediction)
        ];
    }
    getGradientId(feature) {
        return `svgGradient-${feature.name}`;
    }
    defineColorGradient(feature, instance, instanceFieldData) {
        const numOfColorSamplePoints = 10;
        const colorGradientScale = (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().domain([
            0,
            numOfColorSamplePoints
        ]).range([
            feature.minY,
            feature.maxY
        ]);
        const predictionExtent = (0, $841120e180d215c5$export$a510af025ac2bbc1).model.getPrediction(instance) - instanceFieldData.pdep;
        const samplePoints = $30946a890274e276$var$range(numOfColorSamplePoints).map((i)=>predictionExtent + colorGradientScale(i));
        return /*#__PURE__*/ $aaLBe.createElement("linearGradient", {
            id: this.getGradientId(feature),
            x1: "0%",
            x2: "100%",
            y1: "0%",
            y2: "0%"
        }, samplePoints.map((d, i)=>/*#__PURE__*/ $aaLBe.createElement("stop", {
                key: i,
                offset: i / (samplePoints.length - 1),
                stopColor: this.props.colorDRPrediction(d)
            })));
    }
    render() {
        const { feature: feature  } = this.props;
        if (!feature || !feature.shape) return null;
        const chartWidth = 300;
        let chartHeight = 150;
        const margin = {
            top: 0,
            right: 20,
            bottom: 0,
            left: 60
        };
        const width = chartWidth - margin.left - margin.right;
        const height = chartHeight - margin.top - margin.bottom;
        const x = feature.shape.getScale(width);
        const yScale = this.props.commonYScale || {
            min: feature.minY,
            max: feature.maxY
        };
        const y = (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().rangeRound([
            height,
            0
        ]).domain([
            yScale.min,
            yScale.max
        ]);
        const instance = (0, $841120e180d215c5$export$a510af025ac2bbc1).selectedInstance;
        const instanceFeatureData = instance ? instance.data.find((field)=>field.name === feature.name) : undefined;
        const instance2 = (0, $841120e180d215c5$export$a510af025ac2bbc1).selectedInstance2;
        const instance2FeatureData = instance2 ? instance2.data.find((field)=>field.name === feature.name) : undefined;
        let histogram = null;
        const shape = feature.shape;
        if ((0, $841120e180d215c5$export$a510af025ac2bbc1).showHistograms) {
            histogram = shape instanceof (0, $bbdd41951bc984bf$export$e26c98255b26aeaf) ? this.renderNumericalHistogram((0, $841120e180d215c5$export$a510af025ac2bbc1).model.instances.map((i)=>i[feature.name]), chartWidth, height) : shape instanceof (0, $bbdd41951bc984bf$export$f9f2b84b3d833d93) ? this.renderNumericalHistogram(shape.pdep.map((p)=>p.x), chartWidth, height) : shape instanceof (0, $bbdd41951bc984bf$export$221d31c781f75234) ? this.renderCategoricalHistogram((0, $841120e180d215c5$export$a510af025ac2bbc1).model.gethistogram(feature.name), chartWidth, height) : null;
            chartHeight += $30946a890274e276$var$HISTOGRAM_HEIGHT;
        } else chartHeight += 20;
        const curve = !shape.isPiecewiseConstant ? (0, $c62bbc2e0d5ae3c1$export$2e2bcd8739ae039) : (0, $d67a219f4d6f6740$export$793b3db073781cbb);
        const pdepLine = (0, $14ae03011f3febeb$export$2e2bcd8739ae039)().x((d)=>x(d.x)).y((d)=>y(d.y)).curve(curve);
        const confiULine = (0, $14ae03011f3febeb$export$2e2bcd8739ae039)().x((d)=>x(d.x)).y((d)=>y(d.y)).curve(curve);
        const confiLLine = (0, $14ae03011f3febeb$export$2e2bcd8739ae039)().x((d)=>x(d.x)).y((d)=>y(d.y)).curve(curve);
        const fixup = !shape.isPiecewiseConstant ? (x)=>x : $30946a890274e276$var$fixupStepCurve;
        return /*#__PURE__*/ $aaLBe.createElement("svg", {
            className: "shape-chart",
            width: chartWidth,
            height: chartHeight,
            onMouseEnter: (_)=>this.showCrosshair = true,
            onMouseLeave: (_)=>this.showCrosshair = false,
            onMouseMove: (e)=>this.mouseMove(e, feature, x, y)
        }, /*#__PURE__*/ $aaLBe.createElement("defs", null, instance && instanceFeatureData ? this.defineColorGradient(feature, instance, instanceFeatureData) : null), /*#__PURE__*/ $aaLBe.createElement("g", {
            transform: `translate(${margin.left}, ${margin.top})`
        }, histogram, /*#__PURE__*/ $aaLBe.createElement("g", {
            className: "axis shape-chart-axis",
            transform: `translate(0,${height})`,
            ref: (g)=>(0, $16996812f6dbb2fd$export$2e2bcd8739ae039)(g).call((0, $f289c843701a4cef$export$e5cb22533a15e72e)(x).ticks(5)).selectAll("text").attr("transform", "rotate(45)").style("text-anchor", "start").style("font-size", "10px")
        }), /*#__PURE__*/ $aaLBe.createElement("g", {
            className: "axis",
            ref: (g)=>(0, $16996812f6dbb2fd$export$2e2bcd8739ae039)(g).call((0, $f289c843701a4cef$export$2749afb169a520d2)(y).ticks(5))
        }), /*#__PURE__*/ $aaLBe.createElement("line", {
            className: "zeroline",
            x1: 0,
            y1: y(0),
            x2: width,
            y2: y(0)
        }), /*#__PURE__*/ $aaLBe.createElement("path", {
            className: "confidence-line",
            d: fixup(confiULine(shape.upperConf))
        }), /*#__PURE__*/ $aaLBe.createElement("path", {
            className: "confidence-line",
            d: fixup(confiLLine(shape.lowerConf))
        }), /*#__PURE__*/ $aaLBe.createElement("path", {
            className: "pdep",
            d: fixup(pdepLine(shape.pdep)),
            style: {
                stroke: `url(#${this.getGradientId(feature)})`
            }
        }), this.renderCrosshair(instanceFeatureData, x, y, height), instance2FeatureData ? this.renderInstancePoint(feature, instance2.id, instance2FeatureData, "square", this.showTooltip2, x, y) : null, instanceFeatureData ? this.renderInstancePoint(feature, instance.id, instanceFeatureData, "circle", this.showTooltip1, x, y) : null));
    }
    renderCrosshair(datum, x, y, height) {
        if (!this.showCrosshair || isNaN(this.crosshairDomain) || isNaN(this.crosshairPrediction)) return null;
        const crosshairX = this.crosshairPosition[0];
        const crosshairY = this.crosshairPosition[1];
        const crosshairColor = this.props.colorDRPrediction(this.crosshairPrediction);
        const formatComma = (0, $23de77130e6fabd5$export$d9468344d3651243)(",.2f");
        const formatDiff = (0, $23de77130e6fabd5$export$d9468344d3651243)("+,.2f");
        return /*#__PURE__*/ $aaLBe.createElement("g", null, /*#__PURE__*/ $aaLBe.createElement("line", {
            className: "crosshair X",
            x1: crosshairX,
            y1: y(y.domain()[0]),
            x2: crosshairX,
            y2: crosshairY
        }), /*#__PURE__*/ $aaLBe.createElement("line", {
            className: "crosshair Y",
            x1: x(x.domain()[0]),
            y1: crosshairY,
            x2: crosshairX,
            y2: crosshairY,
            stroke: crosshairColor
        }), /*#__PURE__*/ $aaLBe.createElement("circle", {
            cx: crosshairX,
            cy: crosshairY,
            r: "5",
            fill: crosshairColor,
            style: {
                strokeWidth: "2px",
                stroke: "#ffffff"
            }
        }), /*#__PURE__*/ $aaLBe.createElement("text", {
            className: "crosshairX-text",
            x: crosshairX + 5,
            y: height - 3
        }, formatDiff(this.crosshairDomain - (datum ? datum.X : 0))), /*#__PURE__*/ $aaLBe.createElement("text", {
            className: "crosshairY-text",
            x: crosshairX + 15,
            y: crosshairY,
            fill: crosshairColor
        }, `=${formatComma(this.crosshairPrediction)}`));
    }
    renderNumericalHistogram(xs, chartWidth, height) {
        const histWidth = chartWidth;
        const histMargin = {
            top: 0,
            right: 20,
            bottom: 0,
            left: 60
        };
        const histWidthInside = histWidth - histMargin.left - histMargin.right;
        const histHeightInside = $30946a890274e276$var$HISTOGRAM_HEIGHT - histMargin.top - histMargin.bottom;
        const histx = (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().rangeRound([
            0,
            histWidthInside
        ]).domain((0, $719ebe1dfe21c6ae$export$2e2bcd8739ae039)(xs));
        const bins = (0, $2e5a6772496690f7$export$2e2bcd8739ae039)().domain(histx.domain()).thresholds(20)(xs);
        const histy = (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().rangeRound([
            histHeightInside,
            0
        ]).domain([
            0,
            (0, $3c6663a447dc3064$export$2e2bcd8739ae039)(bins, (d)=>d.length)
        ]);
        return /*#__PURE__*/ $aaLBe.createElement("g", {
            transform: `translate(0,${height})`
        }, bins.map((bin, b)=>/*#__PURE__*/ $aaLBe.createElement("rect", {
                key: b,
                className: "hist-bar",
                x: histx(bin.x0) + 1,
                y: histy(histy.domain()[1]),
                width: Math.max(0, histx(bin.x1) - histx(bin.x0) - 1),
                height: histy(0) - histy(bin.length)
            })));
    }
    renderCategoricalHistogram(valCounts, chartWidth, height) {
        const histWidth = chartWidth;
        const histMargin = {
            top: 0,
            right: 20,
            bottom: 0,
            left: 60
        };
        const histWidthInside = histWidth - histMargin.left - histMargin.right;
        const histHeightInside = $30946a890274e276$var$HISTOGRAM_HEIGHT - histMargin.top - histMargin.bottom;
        const values = Object.getOwnPropertyNames(valCounts).sort();
        const counts = values.map((v)=>valCounts[v]);
        const { feature: feature  } = this.props;
        if (!feature || !feature.shape) return null;
        const histx = (0, $1c006476403aa8e7$export$2e2bcd8739ae039)().domain(values).range([
            0,
            histWidthInside
        ]).padding(0.1).align(0.5);
        const histy = (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().rangeRound([
            histHeightInside,
            0
        ]).domain([
            0,
            (0, $3c6663a447dc3064$export$2e2bcd8739ae039)(counts)
        ]);
        //const width = histWidthInside / values.length;
        return /*#__PURE__*/ $aaLBe.createElement("g", {
            transform: `translate(0,${height})`
        }, values.map((v)=>/*#__PURE__*/ $aaLBe.createElement("rect", {
                key: v,
                className: "hist-bar",
                x: histx(v),
                y: histy(histy.domain()[1]),
                width: histx.bandwidth(),
                height: histy(0) - histy(valCounts[v])
            })));
    }
    renderInstancePoint(feature, id, datum, shape, showTooltip, x, y) {
        const adjust = x.bandwidth ? 0.5 * x.bandwidth() : 0;
        return [
            (0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature === feature.name ? /*#__PURE__*/ $aaLBe.createElement("line", {
                className: "instance-hover-line",
                key: "line",
                x1: x(datum.X) + adjust,
                y1: y(datum.pdep),
                x2: x(datum.X) + adjust,
                y2: y(0)
            }) : null,
            shape === "square" ? /*#__PURE__*/ $aaLBe.createElement("rect", {
                className: "instancePoint-fixed",
                key: "spot",
                x: x(datum.X) + adjust - 4.5,
                y: y(datum.pdep) - 4.5,
                width: 9,
                height: 9,
                onMouseOver: ()=>this.showTooltip2 = true,
                onMouseLeave: ()=>this.showTooltip2 = false
            }) : /*#__PURE__*/ $aaLBe.createElement("circle", {
                className: "instancePoint-fixed",
                key: "spot",
                cx: x(datum.X) + adjust,
                cy: y(datum.pdep),
                r: "5",
                onMouseOver: ()=>this.showTooltip1 = true,
                onMouseLeave: ()=>this.showTooltip1 = false
            }),
            showTooltip ? /*#__PURE__*/ $aaLBe.createElement((0, $166742fb3809db53$export$6e85f3d13744656e), {
                key: "tip",
                x: x(datum.X),
                y: y(datum.pdep) - 70,
                lines: [
                    `Instance: ${id}`,
                    `X: ${datum.X + adjust}`,
                    `pdep: ${datum.pdep.toFixed(2)}`
                ]
            }) : null
        ];
    }
};
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $30946a890274e276$export$c29a7778178a18c9.prototype, "showCrosshair", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $30946a890274e276$export$c29a7778178a18c9.prototype, "crosshairPosition", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $30946a890274e276$export$c29a7778178a18c9.prototype, "crosshairDomain", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $30946a890274e276$export$c29a7778178a18c9.prototype, "crosshairPrediction", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $30946a890274e276$export$c29a7778178a18c9.prototype, "showTooltip1", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $30946a890274e276$export$c29a7778178a18c9.prototype, "showTooltip2", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$31eb53bd5b582a97)
], $30946a890274e276$export$c29a7778178a18c9.prototype, "mouseMove", null);
$30946a890274e276$export$c29a7778178a18c9 = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $30946a890274e276$export$c29a7778178a18c9);


const { styleDiv: $ff19f33054265590$var$styleDiv  } = (0, $b740921611e46f8c$export$99f00114e7637415)("ChartArea");
const $ff19f33054265590$var$Container = $ff19f33054265590$var$styleDiv("Container", {
    display: "flex",
    width: "100%",
    height: "100%",
    position: "relative",
    overflowY: "auto",
    flexWrap: "wrap"
});
const $ff19f33054265590$var$ChartContainer = $ff19f33054265590$var$styleDiv("ChartContainer", {
    margin: 8
});
const $ff19f33054265590$var$fredData = true;
const { styleComponent: $ff19f33054265590$var$styleComponent  } = (0, $b740921611e46f8c$export$99f00114e7637415)("FeatureChart");
const $ff19f33054265590$var$DenseCardContent = $ff19f33054265590$var$styleComponent((0, $5caaf602cc8daa08$export$2e2bcd8739ae039))("DenseCardContent", {
    padding: 0
});
let $ff19f33054265590$export$2d13e9563b23a413 = class ChartArea extends $aaLBe.Component {
    // save refs to cards for scrolling
    cardrefs = [];
    render() {
        // const chartWidth = 400;
        const chartHeight = 300;
        (0, $11a86e62e4f971e6$export$7203b476385689ae)(()=>(0, $841120e180d215c5$export$a510af025ac2bbc1).focusedFeature, (val, _)=>{
            const myref = this.cardrefs[val];
            // should abstract this out into a function, but for now, do the calculations here:
            const element = $ba021dca0cbd5bec$exports.findDOMNode(myref);
            const topPos = element.offsetTop;
            const parentElement = element.parentElement;
            parentElement.scrollTop = topPos;
        //console.log("updateded focused feature to " + val + "reaction" + reaction)
        });
        if ($ff19f33054265590$var$fredData) {
            const model = (0, $841120e180d215c5$export$a510af025ac2bbc1).model;
            const commonYScale = (0, $841120e180d215c5$export$a510af025ac2bbc1).normalizeAxes ? {
                min: model.globalMinY,
                max: model.globalMaxY
            } : undefined;
            return /*#__PURE__*/ $aaLBe.createElement($ff19f33054265590$var$Container, null, model.features.filter((fs)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).isFeatureVisible(fs.name)).filter((fs)=>fs.valueType != (0, $bbdd41951bc984bf$export$c40deacab7e2491c).Unused).map((fs)=>/*#__PURE__*/ $aaLBe.createElement($ff19f33054265590$var$ChartContainer, {
                    key: fs.name,
                    ref: (card)=>{
                        this.cardrefs[fs.name] = card;
                    }
                }, /*#__PURE__*/ $aaLBe.createElement((0, $7ed1099ec7c52c31$export$2e2bcd8739ae039), null, /*#__PURE__*/ $aaLBe.createElement((0, $d76986ce9d4ea56e$export$2e2bcd8739ae039), {
                    title: fs.name,
                    action: /*#__PURE__*/ $aaLBe.createElement("span", null, fs.description && /*#__PURE__*/ $aaLBe.createElement((0, $391e58f71c9818f8$export$2e2bcd8739ae039), {
                        title: fs.description
                    }, /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($fb40a9e8ed15938b$exports))), {
                        fontSize: "small"
                    })), /*#__PURE__*/ $aaLBe.createElement((0, $391e58f71c9818f8$export$2e2bcd8739ae039), {
                        onClick: (_)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).toggleFeatureVisibility(fs.name),
                        title: "Hide this feature"
                    }, /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($c35e9f5a8731094a$exports))), {
                        fontSize: "small"
                    })))
                }), /*#__PURE__*/ $aaLBe.createElement($ff19f33054265590$var$DenseCardContent, null, /*#__PURE__*/ $aaLBe.createElement($ff19f33054265590$var$Container, {
                    customProps: {
                        height: chartHeight
                    }
                }, /*#__PURE__*/ $aaLBe.createElement((0, $30946a890274e276$export$c29a7778178a18c9), {
                    feature: fs,
                    colorDRPrediction: this.props.colorDRPrediction,
                    commonYScale: commonYScale
                })))))));
        }
    }
};
$ff19f33054265590$export$2d13e9563b23a413 = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $ff19f33054265590$export$2d13e9563b23a413);


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.






var $aaLBe = parcelRequire("aaLBe");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.








var $aaLBe = parcelRequire("aaLBe");




const { styleDiv: $0316c316c885be63$var$styleDiv  } = (0, $b740921611e46f8c$export$99f00114e7637415)("SummaryArea");
const $0316c316c885be63$var$Container = $0316c316c885be63$var$styleDiv("Container", {
    display: "flex",
    flexDirection: "column",
    position: "relative"
});
const $0316c316c885be63$var$TOTAL_FEATURE = "TOTAL";
let $0316c316c885be63$export$f07f60f2153bf8dc = class FeatureDiffChart extends $aaLBe.Component {
    render() {
        const { data: data  } = this.props;
        const model = (0, $841120e180d215c5$export$a510af025ac2bbc1).model;
        const featureDiffSVGWidth = 600;
        const featureDiffSVGHeight = 250;
        const featureDiffMargin = {
            top: 0,
            right: 20,
            bottom: 50,
            left: 50
        };
        const featureDiffWidth = featureDiffSVGWidth - featureDiffMargin.left - featureDiffMargin.right;
        const featureDiffHeight = featureDiffSVGHeight - featureDiffMargin.top - featureDiffMargin.bottom;
        const featureDiffX = (0, $1c006476403aa8e7$export$2e2bcd8739ae039)().rangeRound([
            0,
            featureDiffWidth
        ]).padding(0.1);
        const featureDiffY = (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().range([
            featureDiffHeight,
            0
        ]);
        const featureDiffXAxis = (0, $f289c843701a4cef$export$e5cb22533a15e72e)(featureDiffX).ticks(5);
        const featureDiffYAxis = (0, $f289c843701a4cef$export$2749afb169a520d2)(featureDiffY).tickSize(0).tickPadding(6);
        function makefeatureDiffData(data) {
            const featureDiffData = [];
            //let cumulative = 0;
            for(let i = 0; i < data.length; i++)if (model.getType(data[i].name) != (0, $bbdd41951bc984bf$export$c40deacab7e2491c).Unused) {
                const pdep = data[i].pdep;
                featureDiffData.push({
                    ...data[i],
                    start: 0,
                    end: pdep
                });
            //  cumulative += pdep;
            }
            featureDiffData.push({
                name: $0316c316c885be63$var$TOTAL_FEATURE,
                end: 0,
                start: 0,
                X: 0,
                pdep: 0,
                confi_u_X: 0,
                confi_l_X: 0
            });
            return featureDiffData;
        }
        const featureDiffData = makefeatureDiffData(data);
        featureDiffX.domain(featureDiffData.map((d)=>d.name));
        const featureDiffExtent = (0, $719ebe1dfe21c6ae$export$2e2bcd8739ae039)(featureDiffData, (d)=>d.end);
        featureDiffY.domain([
            (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)([
                0,
                featureDiffExtent[0]
            ]),
            (0, $3c6663a447dc3064$export$2e2bcd8739ae039)([
                0,
                featureDiffExtent[1]
            ])
        ]);
        const formatComma = (0, $23de77130e6fabd5$export$d9468344d3651243)(",.2f");
        const hoverData = (0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature ? featureDiffData.find((d)=>d.name === (0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature) : undefined;
        return /*#__PURE__*/ $aaLBe.createElement($0316c316c885be63$var$Container, {
            style: {
                padding: "10px"
            }
        }, /*#__PURE__*/ $aaLBe.createElement("svg", {
            className: "featureDiff-chart",
            width: featureDiffSVGWidth,
            height: featureDiffSVGHeight
        }, /*#__PURE__*/ $aaLBe.createElement("g", {
            transform: `translate(${featureDiffMargin.left},${featureDiffMargin.top})`
        }, /*#__PURE__*/ $aaLBe.createElement("line", {
            className: "zeroline",
            x1: 0,
            y1: featureDiffY(0),
            x2: featureDiffX($0316c316c885be63$var$TOTAL_FEATURE),
            y2: featureDiffY(0),
            style: {
                visibility: (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)([
                    0,
                    featureDiffExtent[0]
                ]) < 0 ? "visible" : "hidden"
            }
        }), featureDiffData.map((d)=>/*#__PURE__*/ $aaLBe.createElement("g", {
                key: d.name,
                className: "featureDiff-bar",
                transform: `translate(${featureDiffX(d.name)},0)`
            }, /*#__PURE__*/ $aaLBe.createElement("rect", {
                className: `featureDiff-bar-rect bar bar--${d.pdep < 0 ? "negative" : "positive"} ${d.name === (0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature ? "hover" : ""}`,
                y: featureDiffY(Math.max(d.start, d.end)),
                height: d.name === "intercept" ? 5 : Math.abs(featureDiffY(d.start) - featureDiffY(d.end)),
                width: featureDiffX.bandwidth(),
                onMouseOver: (_)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature = d.name,
                onMouseLeave: (_)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature = undefined,
                onClick: (_)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).setFeatureVisibility(d.name, true)
            }))), /*#__PURE__*/ $aaLBe.createElement("g", {
            id: "featureDiff-x-axis",
            transform: `translate(0,${featureDiffHeight})`,
            ref: (g)=>(0, $16996812f6dbb2fd$export$2e2bcd8739ae039)(g).call(featureDiffXAxis).selectAll("text").attr("y", 0).attr("x", 9).attr("dy", ".5em").attr("transform", "rotate(45)").style("text-anchor", "start").style("font-size", "12px")
        }), /*#__PURE__*/ $aaLBe.createElement("g", {
            id: "featureDiff-y-axis",
            transform: "translate(0,0)",
            ref: (g)=>(0, $16996812f6dbb2fd$export$2e2bcd8739ae039)(g).call(featureDiffYAxis)
        }), hoverData ? /*#__PURE__*/ $aaLBe.createElement((0, $166742fb3809db53$export$6e85f3d13744656e), {
            x: featureDiffX(hoverData.name),
            y: featureDiffY(Math.max(hoverData.start, hoverData.end)) - 60,
            lines: [
                `${hoverData.name}: ${hoverData.X}`,
                `Contrib: ${formatComma(hoverData.pdep)}`
            ]
        }) : null)));
    }
};
$0316c316c885be63$export$f07f60f2153bf8dc = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $0316c316c885be63$export$f07f60f2153bf8dc);


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.








var $aaLBe = parcelRequire("aaLBe");




const { styleDiv: $792047402a781090$var$styleDiv  } = (0, $b740921611e46f8c$export$99f00114e7637415)("SummaryArea");
const $792047402a781090$var$Container = $792047402a781090$var$styleDiv("Container", {
    display: "flex",
    flexDirection: "column",
    position: "relative"
});
const $792047402a781090$var$TOTAL_FEATURE = "TOTAL";
class $792047402a781090$export$7ddf8866c1afa278 {
    waterfallData = [];
    constructor(data, intercept){
        this.data = data;
        this.intercept = intercept;
        this.makeWaterfallData();
    }
    makeWaterfallData() {
        let cumulative = this.intercept;
        const model = (0, $841120e180d215c5$export$a510af025ac2bbc1).model;
        for(let i = 0; i < this.data.length; i++)if (model.getType(this.data[i].name) != (0, $bbdd41951bc984bf$export$c40deacab7e2491c).Unused) {
            const pdep = this.data[i].pdep;
            this.waterfallData.push({
                ...this.data[i],
                start: cumulative,
                end: cumulative + pdep
            });
            cumulative += pdep;
        }
        this.waterfallData.push({
            name: $792047402a781090$var$TOTAL_FEATURE,
            end: cumulative,
            start: cumulative,
            X: 0,
            pdep: 0,
            confi_u_X: 0,
            confi_l_X: 0
        });
    }
    getExtents() {
        const waterfallExtent = (0, $719ebe1dfe21c6ae$export$2e2bcd8739ae039)(this.waterfallData, (d)=>d.end);
        return waterfallExtent;
    }
}
let $792047402a781090$export$8a7baaba5110806e = class WaterfallChart extends $aaLBe.Component {
    render() {
        const { model: model , intercept: intercept , forceExtents: forceExtents  } = this.props;
        const waterfallSVGWidth = 600;
        const waterfallSVGHeight = 250;
        const waterfallMargin = {
            top: 0,
            right: 20,
            bottom: 30,
            left: 50
        };
        const waterfallWidth = waterfallSVGWidth - waterfallMargin.left - waterfallMargin.right;
        const waterfallHeight = waterfallSVGHeight - waterfallMargin.top - waterfallMargin.bottom;
        const waterfallX = (0, $1c006476403aa8e7$export$2e2bcd8739ae039)().rangeRound([
            0,
            waterfallWidth
        ]).padding(0.1);
        const waterfallY = (0, $46dd7dd0ac807af9$export$2e2bcd8739ae039)().range([
            waterfallHeight,
            0
        ]);
        const waterfallXAxis = (0, $f289c843701a4cef$export$e5cb22533a15e72e)(waterfallX).ticks(5);
        const waterfallYAxis = (0, $f289c843701a4cef$export$2749afb169a520d2)(waterfallY).tickSize(0).tickPadding(6);
        waterfallX.domain(model.waterfallData.map((d)=>d.name));
        //let waterfallExtent: [number, number] = model.getExtents();
        const waterfallExtent = forceExtents;
        // go to 10% below and above intercept or min,max values
        const domainpad = (forceExtents[1] - forceExtents[0]) * 0.1;
        waterfallY.domain([
            (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)([
                intercept - domainpad,
                forceExtents[0] - domainpad
            ]),
            (0, $3c6663a447dc3064$export$2e2bcd8739ae039)([
                intercept + domainpad,
                forceExtents[1] + domainpad
            ])
        ]);
        //waterfallY.domain([min([intercept, forceExtents[0]]), max([intercept, forceExtents[1]])]);
        //waterfallY.domain([min([0, forceExtents[0]]), max([intercept, forceExtents[1]])]);
        ////waterfallY.domain([min([0, waterfallExtent[0]]), max([intercept, waterfallExtent[1]])]);
        const formatComma = (0, $23de77130e6fabd5$export$d9468344d3651243)(",.2f");
        const hoverData = (0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature ? model.waterfallData.find((d)=>d.name === (0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature) : undefined;
        return /*#__PURE__*/ $aaLBe.createElement($792047402a781090$var$Container, {
            style: {
                padding: "10px"
            }
        }, /*#__PURE__*/ $aaLBe.createElement("svg", {
            className: "waterfall-chart",
            width: waterfallSVGWidth,
            height: waterfallSVGHeight
        }, /*#__PURE__*/ $aaLBe.createElement("g", {
            transform: `translate(${waterfallMargin.left},${waterfallMargin.top})`
        }, /*#__PURE__*/ $aaLBe.createElement("line", {
            className: "zeroline",
            x1: 0,
            y1: waterfallY(0),
            x2: waterfallX($792047402a781090$var$TOTAL_FEATURE),
            y2: waterfallY(0),
            style: {
                visibility: (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)([
                    0,
                    waterfallExtent[0]
                ]) < 0 ? "visible" : "hidden"
            }
        }), /*#__PURE__*/ $aaLBe.createElement("line", {
            className: "intercept-line",
            x1: 0,
            y1: waterfallY(intercept),
            x2: waterfallX($792047402a781090$var$TOTAL_FEATURE),
            y2: waterfallY(intercept)
        }), /*#__PURE__*/ $aaLBe.createElement("text", {
            x: waterfallX($792047402a781090$var$TOTAL_FEATURE) - 5,
            y: waterfallY(intercept),
            dy: "-0.25em",
            textAnchor: "end"
        }, "Intercept"), model.waterfallData.map((d)=>/*#__PURE__*/ $aaLBe.createElement("g", {
                key: d.name,
                className: "waterfall-bar",
                transform: `translate(${waterfallX(d.name)},0)`
            }, /*#__PURE__*/ $aaLBe.createElement("rect", {
                className: `waterfall-bar-rect bar bar--${d.pdep < 0 ? "negative" : "positive"} ${d.name === (0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature ? "hover" : ""}`,
                y: waterfallY(Math.max(d.start, d.end)),
                height: d.name === "intercept" ? 5 : Math.abs(waterfallY(d.start) - waterfallY(d.end)),
                width: waterfallX.bandwidth(),
                onMouseOver: (_)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature = d.name,
                onMouseLeave: (_)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).hoverFeature = undefined,
                onClick: (_)=>{
                    (0, $841120e180d215c5$export$a510af025ac2bbc1).setFeatureVisibility(d.name, true);
                    (0, $841120e180d215c5$export$a510af025ac2bbc1).setFocusedFeature(d.name);
                }
            }))), /*#__PURE__*/ $aaLBe.createElement("g", {
            id: "waterfall-x-axis",
            transform: `translate(0,${waterfallHeight})`,
            ref: (g)=>(0, $16996812f6dbb2fd$export$2e2bcd8739ae039)(g).call(waterfallXAxis).selectAll("text").attr("y", 0).attr("x", 9).attr("dy", "1em").attr("transform", "rotate(45)").style("text-anchor", "start").style("font-size", "12px")
        }), /*#__PURE__*/ $aaLBe.createElement("g", {
            id: "waterfall-y-axis",
            transform: "translate(0,0)",
            ref: (g)=>(0, $16996812f6dbb2fd$export$2e2bcd8739ae039)(g).call(waterfallYAxis)
        }), hoverData ? /*#__PURE__*/ $aaLBe.createElement((0, $166742fb3809db53$export$6e85f3d13744656e), {
            x: waterfallX(hoverData.name),
            y: waterfallY(Math.max(hoverData.start, hoverData.end)) - 60,
            lines: [
                `${hoverData.name}: ${hoverData.X}`,
                `Contrib: ${formatComma(hoverData.pdep)}`
            ]
        }) : null)));
    }
};
$792047402a781090$export$8a7baaba5110806e = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $792047402a781090$export$8a7baaba5110806e);


const $711b34c4742621de$var$headerStyle = {
    padding: "0px 10px"
};
let $711b34c4742621de$export$47380024ae00923f = class InstanceArea extends $aaLBe.Component {
    constructor(...args){
        super(...args);
        this.sortOrder = "Absolute Contribution";
    }
    sortOrders = [
        "Contribution",
        "Absolute Contribution",
        "Differences"
    ];
    instanceArea(anInstance, watModel, extent) {
        const formatComma = (0, $23de77130e6fabd5$export$d9468344d3651243)(",.2f");
        const { model: model  } = this.props;
        const prediction = model.getPrediction(anInstance);
        const instanceHeader = anInstance === null ? /*#__PURE__*/ $aaLBe.createElement("div", {
            style: $711b34c4742621de$var$headerStyle
        }, "Differences: ") : /*#__PURE__*/ $aaLBe.createElement("div", {
            style: $711b34c4742621de$var$headerStyle
        }, /*#__PURE__*/ $aaLBe.createElement("div", {
            style: {
                display: "flex",
                float: "left",
                paddingTop: "5px"
            }
        }, "Instance ", /*#__PURE__*/ $aaLBe.createElement("span", {
            style: {
                paddingLeft: "5px",
                paddingRight: "50px"
            }
        }, anInstance.id)), /*#__PURE__*/ $aaLBe.createElement("div", {
            style: {
                display: "flex",
                padding: "0px",
                flexDirection: "row"
            }
        }, /*#__PURE__*/ $aaLBe.createElement("div", {
            style: {
                display: "flex",
                paddingBottom: "5px"
            }
        }, /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "label"
        }, "Actual:"), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "value-label"
        }, formatComma(anInstance.y), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "colorbox",
            style: {
                backgroundColor: this.props.colorDRPrediction(anInstance.y)
            }
        }))), /*#__PURE__*/ $aaLBe.createElement("div", {
            style: {
                display: "flex",
                paddingBottom: "5px"
            }
        }, /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "label",
            style: {
                padding: "5px"
            }
        }, "Prediction:"), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "value-label"
        }, formatComma(prediction), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "colorbox",
            style: {
                backgroundColor: this.props.colorDRPrediction(prediction)
            }
        })))));
        const instanceBody = anInstance === null ? /*#__PURE__*/ $aaLBe.createElement((0, $0316c316c885be63$export$f07f60f2153bf8dc), {
            data: watModel.data,
            intercept: model.intercept
        }) : /*#__PURE__*/ $aaLBe.createElement((0, $792047402a781090$export$8a7baaba5110806e), {
            model: watModel,
            intercept: model.intercept,
            forceExtents: extent
        });
        return /*#__PURE__*/ $aaLBe.createElement("div", {
            style: {
                paddingBottom: "30px"
            }
        }, instanceHeader, instanceBody);
    }
    differenceArea(theData) {
        const { model: model  } = this.props;
        const instanceHeader = /*#__PURE__*/ $aaLBe.createElement("div", {
            style: $711b34c4742621de$var$headerStyle
        }, "Differences: ");
        const instanceBody = /*#__PURE__*/ $aaLBe.createElement((0, $0316c316c885be63$export$f07f60f2153bf8dc), {
            data: theData,
            intercept: model.intercept
        });
        return /*#__PURE__*/ $aaLBe.createElement("div", {
            style: {
                paddingBottom: "30px"
            }
        }, instanceHeader, instanceBody);
    }
    simpleOutArea(anInstance) {
        const { model: model  } = this.props;
        const instanceData = anInstance.data.slice();
        if (this.sortOrder === "Contribution") instanceData.sort((x, y)=>(0, $fd670c0f0109e50d$export$2e2bcd8739ae039)(x.pdep, y.pdep));
        else if (this.sortOrder === "Absolute Contribution") instanceData.sort((x, y)=>(0, $fd670c0f0109e50d$export$2e2bcd8739ae039)(Math.abs(x.pdep), Math.abs(y.pdep)));
        const myWat1 = new (0, $792047402a781090$export$7ddf8866c1afa278)(instanceData, model.intercept);
        const [minx, maxx] = myWat1.getExtents();
        return this.instanceArea(anInstance, myWat1, [
            minx,
            maxx
        ]);
    }
    compoundOutArea(instance1, instance2) {
        const { model: model  } = this.props;
        const instanceData1 = instance1.data.slice();
        const instanceData2 = instance2.data.slice();
        const differenceData = instanceData1.map((obj)=>{
            const ele = instanceData2.find((d)=>d.name === obj.name);
            const newele = {
                ...ele
            };
            newele.pdep = obj.pdep - newele.pdep;
            return newele;
        });
        // if sorting by either Contribution or Absolute Contribution, then sort the primary results first by that order
        if (this.sortOrder === "Contribution") instanceData1.sort((x, y)=>(0, $fd670c0f0109e50d$export$2e2bcd8739ae039)(x.pdep, y.pdep));
        else if (this.sortOrder === "Absolute Contribution") instanceData1.sort((x, y)=>(0, $fd670c0f0109e50d$export$2e2bcd8739ae039)(Math.abs(x.pdep), Math.abs(y.pdep)));
        // if NOT sorting by Differences, sort the secondary results AND difference by the primary order
        if (this.sortOrder !== "Differences") {
            if (instanceData2) {
                instanceData2.sort((x, y)=>instanceData1.findIndex((e)=>e.name === x.name) - instanceData1.findIndex((e)=>e.name === y.name));
                differenceData.sort((x, y)=>instanceData1.findIndex((e)=>e.name === x.name) - instanceData1.findIndex((e)=>e.name === y.name));
            }
        } else {
            // else sort all three by magnitude of differences
            differenceData.sort((x, y)=>(0, $fd670c0f0109e50d$export$2e2bcd8739ae039)(Math.abs(x.pdep), Math.abs(y.pdep)));
            instanceData1.sort((x, y)=>differenceData.findIndex((e)=>e.name === x.name) - differenceData.findIndex((e)=>e.name === y.name));
            instanceData2.sort((x, y)=>differenceData.findIndex((e)=>e.name === x.name) - differenceData.findIndex((e)=>e.name === y.name));
        }
        const myWat1 = new (0, $792047402a781090$export$7ddf8866c1afa278)(instanceData1, model.intercept);
        const [minx1, maxx1] = myWat1.getExtents();
        const myWat2 = new (0, $792047402a781090$export$7ddf8866c1afa278)(instanceData2, model.intercept);
        const [minx2, maxx2] = myWat2.getExtents();
        const minx = Math.min(minx1, minx2);
        const maxx = Math.max(maxx1, maxx2);
        const instanceArea1 = this.instanceArea((0, $841120e180d215c5$export$a510af025ac2bbc1).selectedInstance, myWat1, [
            minx,
            maxx
        ]);
        const instanceArea2 = instance2 != null ? this.instanceArea((0, $841120e180d215c5$export$a510af025ac2bbc1).selectedInstance2, myWat2, [
            minx,
            maxx
        ]) : /*#__PURE__*/ $aaLBe.createElement("div", null, " ");
        const instanceAreaDiff = instance2 != null ? this.differenceArea(differenceData) : /*#__PURE__*/ $aaLBe.createElement("div", null, " ");
        return /*#__PURE__*/ $aaLBe.createElement("div", null, instanceArea1, instanceArea2, instanceAreaDiff);
    }
    render() {
        const instance = (0, $841120e180d215c5$export$a510af025ac2bbc1).selectedInstance;
        const instance2 = (0, $841120e180d215c5$export$a510af025ac2bbc1).selectedInstance2;
        if (!instance) return null;
        let outputArea = null;
        if (instance2 == null) outputArea = this.simpleOutArea(instance);
        else outputArea = this.compoundOutArea(instance, instance2);
        return /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "instance-area"
        }, /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "right-wrapper-content"
        }, /*#__PURE__*/ $aaLBe.createElement("label", {
            htmlFor: "sortOrder"
        }, "Sort Features By:"), /*#__PURE__*/ $aaLBe.createElement("select", {
            id: "sortOrder",
            value: this.sortOrder,
            onChange: (e)=>this.sortOrder = e.target.value
        }, this.sortOrders.map((name)=>/*#__PURE__*/ $aaLBe.createElement("option", {
                key: name,
                value: name
            }, name)))), outputArea);
    }
} // <FlagChart data={data}
 // <NeighborList colorDRPrediction={this.props.colorDRPrediction} />
 // interface NeighborListProps {
 //     colorDRPrediction: ScaleSequential<string>;
 // }
 // @observer
 // class NeighborList extends React.Component<NeighborListProps> {
 //     public render() {
 //         const neighbors = fredAppStore.neighborsOfSelection;
 //         const instanceDistanceScale = scaleLinear().domain([0, 1]).range([100, 0]).clamp(true);
 //         return [
 //             <div id="neighbors-title" className="right-wrapper-content">
 //                 <div className="select">
 //                     <select id='nearest-neighbors' className="select-text" required
 //                         value={fredAppStore.featureSpace}
 //                         onChange={e => fredAppStore.setFeatureSpace(e.target.value)}>
 //                         <option value="feature">Feature space</option>
 //                         <option value="gam">GAM space</option>
 //                     </select>
 //                     <span className="select-highlight"></span>
 //                     <span className="select-bar"></span>
 //                     <label className="select-label">Nearest neighbors in</label>
 //                 </div>
 //             </div>,
 //             <div id="instance-list-wrapper">
 //                 {
 //                     neighbors.map(neighbor =>
 //                         <div key={neighbor.id}
 //                             className="instance"
 //                             onClick={_ => fredAppStore.updateSelection(neighbor.id)}
 //                         >
 //                             <div style={{ display: "flex", justifyContent: "space-between" }}>
 //                                 <div className="neighbor-id"
 //                                     style={{ display: "flex", justifyContent: "space-between" }}>
 //                                     {neighbor.id}
 //                                 </div>
 //                                 <div className="neighbor-label"
 //                                     style={{ backgroundColor: this.props.colorDRPrediction(fredAppStore.getPrediction(neighbor)) }}>
 //                                     {neighbor.y.toFixed(2)}
 //                                 </div>
 //                             </div>
 //                             <div className="instance-distance-bar"
 //                                 style={{
 //                                     width: instanceDistanceScale(neighbor.distance) + "%",
 //                                     backgroundColor: this.props.colorDRPrediction(fredAppStore.getPrediction(neighbor))
 //                                 }}>{"\u00A0"}</div>
 //                         </div>)
 //                 }
 //             </div>
 //         ];
 //     }
 //}
;
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $711b34c4742621de$export$47380024ae00923f.prototype, "sortOrder", void 0);
$711b34c4742621de$export$47380024ae00923f = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $711b34c4742621de$export$47380024ae00923f);


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


var $kqze3 = parcelRequire("kqze3");

var $29rXr = parcelRequire("29rXr");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");

var $5tnPj = parcelRequire("5tnPj");


var $gqsD7 = parcelRequire("gqsD7");
var $12ad4d7e3c9070fc$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: (0, $29rXr.default)({}, theme.typography.button, {
            boxSizing: "border-box",
            minWidth: 64,
            padding: "6px 16px",
            borderRadius: theme.shape.borderRadius,
            color: theme.palette.text.primary,
            transition: theme.transitions.create([
                "background-color",
                "box-shadow",
                "border"
            ], {
                duration: theme.transitions.duration.short
            }),
            "&:hover": {
                textDecoration: "none",
                backgroundColor: (0, $5tnPj.alpha)(theme.palette.text.primary, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                },
                "&$disabled": {
                    backgroundColor: "transparent"
                }
            },
            "&$disabled": {
                color: theme.palette.action.disabled
            }
        }),
        /* Styles applied to the span element that wraps the children. */ label: {
            width: "100%",
            // Ensure the correct width for iOS Safari
            display: "inherit",
            alignItems: "inherit",
            justifyContent: "inherit"
        },
        /* Styles applied to the root element if `variant="text"`. */ text: {
            padding: "6px 8px"
        },
        /* Styles applied to the root element if `variant="text"` and `color="primary"`. */ textPrimary: {
            color: theme.palette.primary.main,
            "&:hover": {
                backgroundColor: (0, $5tnPj.alpha)(theme.palette.primary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        },
        /* Styles applied to the root element if `variant="text"` and `color="secondary"`. */ textSecondary: {
            color: theme.palette.secondary.main,
            "&:hover": {
                backgroundColor: (0, $5tnPj.alpha)(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        },
        /* Styles applied to the root element if `variant="outlined"`. */ outlined: {
            padding: "5px 15px",
            border: "1px solid ".concat(theme.palette.type === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"),
            "&$disabled": {
                border: "1px solid ".concat(theme.palette.action.disabledBackground)
            }
        },
        /* Styles applied to the root element if `variant="outlined"` and `color="primary"`. */ outlinedPrimary: {
            color: theme.palette.primary.main,
            border: "1px solid ".concat((0, $5tnPj.alpha)(theme.palette.primary.main, 0.5)),
            "&:hover": {
                border: "1px solid ".concat(theme.palette.primary.main),
                backgroundColor: (0, $5tnPj.alpha)(theme.palette.primary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        },
        /* Styles applied to the root element if `variant="outlined"` and `color="secondary"`. */ outlinedSecondary: {
            color: theme.palette.secondary.main,
            border: "1px solid ".concat((0, $5tnPj.alpha)(theme.palette.secondary.main, 0.5)),
            "&:hover": {
                border: "1px solid ".concat(theme.palette.secondary.main),
                backgroundColor: (0, $5tnPj.alpha)(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            },
            "&$disabled": {
                border: "1px solid ".concat(theme.palette.action.disabled)
            }
        },
        /* Styles applied to the root element if `variant="contained"`. */ contained: {
            color: theme.palette.getContrastText(theme.palette.grey[300]),
            backgroundColor: theme.palette.grey[300],
            boxShadow: theme.shadows[2],
            "&:hover": {
                backgroundColor: theme.palette.grey.A100,
                boxShadow: theme.shadows[4],
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    boxShadow: theme.shadows[2],
                    backgroundColor: theme.palette.grey[300]
                },
                "&$disabled": {
                    backgroundColor: theme.palette.action.disabledBackground
                }
            },
            "&$focusVisible": {
                boxShadow: theme.shadows[6]
            },
            "&:active": {
                boxShadow: theme.shadows[8]
            },
            "&$disabled": {
                color: theme.palette.action.disabled,
                boxShadow: theme.shadows[0],
                backgroundColor: theme.palette.action.disabledBackground
            }
        },
        /* Styles applied to the root element if `variant="contained"` and `color="primary"`. */ containedPrimary: {
            color: theme.palette.primary.contrastText,
            backgroundColor: theme.palette.primary.main,
            "&:hover": {
                backgroundColor: theme.palette.primary.dark,
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: theme.palette.primary.main
                }
            }
        },
        /* Styles applied to the root element if `variant="contained"` and `color="secondary"`. */ containedSecondary: {
            color: theme.palette.secondary.contrastText,
            backgroundColor: theme.palette.secondary.main,
            "&:hover": {
                backgroundColor: theme.palette.secondary.dark,
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: theme.palette.secondary.main
                }
            }
        },
        /* Styles applied to the root element if `disableElevation={true}`. */ disableElevation: {
            boxShadow: "none",
            "&:hover": {
                boxShadow: "none"
            },
            "&$focusVisible": {
                boxShadow: "none"
            },
            "&:active": {
                boxShadow: "none"
            },
            "&$disabled": {
                boxShadow: "none"
            }
        },
        /* Pseudo-class applied to the ButtonBase root element if the button is keyboard focused. */ focusVisible: {},
        /* Pseudo-class applied to the root element if `disabled={true}`. */ disabled: {},
        /* Styles applied to the root element if `color="inherit"`. */ colorInherit: {
            color: "inherit",
            borderColor: "currentColor"
        },
        /* Styles applied to the root element if `size="small"` and `variant="text"`. */ textSizeSmall: {
            padding: "4px 5px",
            fontSize: theme.typography.pxToRem(13)
        },
        /* Styles applied to the root element if `size="large"` and `variant="text"`. */ textSizeLarge: {
            padding: "8px 11px",
            fontSize: theme.typography.pxToRem(15)
        },
        /* Styles applied to the root element if `size="small"` and `variant="outlined"`. */ outlinedSizeSmall: {
            padding: "3px 9px",
            fontSize: theme.typography.pxToRem(13)
        },
        /* Styles applied to the root element if `size="large"` and `variant="outlined"`. */ outlinedSizeLarge: {
            padding: "7px 21px",
            fontSize: theme.typography.pxToRem(15)
        },
        /* Styles applied to the root element if `size="small"` and `variant="contained"`. */ containedSizeSmall: {
            padding: "4px 10px",
            fontSize: theme.typography.pxToRem(13)
        },
        /* Styles applied to the root element if `size="large"` and `variant="contained"`. */ containedSizeLarge: {
            padding: "8px 22px",
            fontSize: theme.typography.pxToRem(15)
        },
        /* Styles applied to the root element if `size="small"`. */ sizeSmall: {},
        /* Styles applied to the root element if `size="large"`. */ sizeLarge: {},
        /* Styles applied to the root element if `fullWidth={true}`. */ fullWidth: {
            width: "100%"
        },
        /* Styles applied to the startIcon element if supplied. */ startIcon: {
            display: "inherit",
            marginRight: 8,
            marginLeft: -4,
            "&$iconSizeSmall": {
                marginLeft: -2
            }
        },
        /* Styles applied to the endIcon element if supplied. */ endIcon: {
            display: "inherit",
            marginRight: -4,
            marginLeft: 8,
            "&$iconSizeSmall": {
                marginRight: -2
            }
        },
        /* Styles applied to the icon element if supplied and `size="small"`. */ iconSizeSmall: {
            "& > *:first-child": {
                fontSize: 18
            }
        },
        /* Styles applied to the icon element if supplied and `size="medium"`. */ iconSizeMedium: {
            "& > *:first-child": {
                fontSize: 20
            }
        },
        /* Styles applied to the icon element if supplied and `size="large"`. */ iconSizeLarge: {
            "& > *:first-child": {
                fontSize: 22
            }
        }
    };
};
var $12ad4d7e3c9070fc$var$Button = /*#__PURE__*/ $aaLBe.forwardRef(function Button(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "default" : _props$color, _props$component = props.component, component = _props$component === void 0 ? "button" : _props$component, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableElevati = props.disableElevation, disableElevation = _props$disableElevati === void 0 ? false : _props$disableElevati, _props$disableFocusRi = props.disableFocusRipple, disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi, endIconProp = props.endIcon, focusVisibleClassName = props.focusVisibleClassName, _props$fullWidth = props.fullWidth, fullWidth = _props$fullWidth === void 0 ? false : _props$fullWidth, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, startIconProp = props.startIcon, _props$type = props.type, type = _props$type === void 0 ? "button" : _props$type, _props$variant = props.variant, variant = _props$variant === void 0 ? "text" : _props$variant, other = (0, $kqze3.default)(props, [
        "children",
        "classes",
        "className",
        "color",
        "component",
        "disabled",
        "disableElevation",
        "disableFocusRipple",
        "endIcon",
        "focusVisibleClassName",
        "fullWidth",
        "size",
        "startIcon",
        "type",
        "variant"
    ]);
    var startIcon = startIconProp && /*#__PURE__*/ $aaLBe.createElement("span", {
        className: (0, $h0TGs.default)(classes.startIcon, classes["iconSize".concat((0, $gqsD7.default)(size))])
    }, startIconProp);
    var endIcon = endIconProp && /*#__PURE__*/ $aaLBe.createElement("span", {
        className: (0, $h0TGs.default)(classes.endIcon, classes["iconSize".concat((0, $gqsD7.default)(size))])
    }, endIconProp);
    return /*#__PURE__*/ $aaLBe.createElement((0, $c61f5105fcb078ef$export$2e2bcd8739ae039), (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, classes[variant], className, color === "inherit" ? classes.colorInherit : color !== "default" && classes["".concat(variant).concat((0, $gqsD7.default)(color))], size !== "medium" && [
            classes["".concat(variant, "Size").concat((0, $gqsD7.default)(size))],
            classes["size".concat((0, $gqsD7.default)(size))]
        ], disableElevation && classes.disableElevation, disabled && classes.disabled, fullWidth && classes.fullWidth),
        component: component,
        disabled: disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: (0, $h0TGs.default)(classes.focusVisible, focusVisibleClassName),
        ref: ref,
        type: type
    }, other), /*#__PURE__*/ $aaLBe.createElement("span", {
        className: classes.label
    }, startIcon, children, endIcon));
});
var $12ad4d7e3c9070fc$export$2e2bcd8739ae039 = (0, $2LmR0.default)($12ad4d7e3c9070fc$export$9dd6ff9ea0189349, {
    name: "MuiButton"
})($12ad4d7e3c9070fc$var$Button);




// packages/ag-grid-react/src/agGridReact.tsx

var $aaLBe = parcelRequire("aaLBe");
// community-modules/core/src/localEventService.ts
var $7b57b57eaf5a9648$export$820da7696a401cdc = class {
    constructor(){
        this.allSyncListeners = /* @__PURE__ */ new Map();
        this.allAsyncListeners = /* @__PURE__ */ new Map();
        this.globalSyncListeners = /* @__PURE__ */ new Set();
        this.globalAsyncListeners = /* @__PURE__ */ new Set();
        this.asyncFunctionsQueue = [];
        this.scheduled = false;
        // using an object performs better than a Set for the number of different events we have
        this.firedEvents = {};
    }
    setFrameworkOverrides(frameworkOverrides) {
        this.frameworkOverrides = frameworkOverrides;
    }
    getListeners(eventType, async, autoCreateListenerCollection) {
        const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
        let listeners = listenerMap.get(eventType);
        if (!listeners && autoCreateListenerCollection) {
            listeners = /* @__PURE__ */ new Set();
            listenerMap.set(eventType, listeners);
        }
        return listeners;
    }
    noRegisteredListenersExist() {
        return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
    }
    addEventListener(eventType, listener, async = false) {
        this.getListeners(eventType, async, true).add(listener);
    }
    removeEventListener(eventType, listener, async = false) {
        const listeners = this.getListeners(eventType, async, false);
        if (!listeners) return;
        listeners.delete(listener);
        if (listeners.size === 0) {
            const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
            listenerMap.delete(eventType);
        }
    }
    addGlobalListener(listener, async = false) {
        (async ? this.globalAsyncListeners : this.globalSyncListeners).add(listener);
    }
    removeGlobalListener(listener, async = false) {
        (async ? this.globalAsyncListeners : this.globalSyncListeners).delete(listener);
    }
    dispatchEvent(event) {
        const agEvent = event;
        this.dispatchToListeners(agEvent, true);
        this.dispatchToListeners(agEvent, false);
        this.firedEvents[agEvent.type] = true;
    }
    dispatchEventOnce(event) {
        if (!this.firedEvents[event.type]) this.dispatchEvent(event);
    }
    dispatchToListeners(event, async) {
        const eventType = event.type;
        if (async && "event" in event) {
            const browserEvent = event.event;
            if (browserEvent instanceof Event) event.eventPath = browserEvent.composedPath();
        }
        const processEventListeners = (listeners2, originalListeners2)=>listeners2.forEach((listener)=>{
                if (!originalListeners2.has(listener)) return;
                const callback = this.frameworkOverrides ? ()=>this.frameworkOverrides.wrapIncoming(()=>listener(event)) : ()=>listener(event);
                if (async) this.dispatchAsync(callback);
                else callback();
            });
        const originalListeners = this.getListeners(eventType, async, false) ?? /* @__PURE__ */ new Set();
        const listeners = new Set(originalListeners);
        if (listeners.size > 0) processEventListeners(listeners, originalListeners);
        const globalListeners = new Set(async ? this.globalAsyncListeners : this.globalSyncListeners);
        globalListeners.forEach((listener)=>{
            const callback = this.frameworkOverrides ? ()=>this.frameworkOverrides.wrapIncoming(()=>listener(eventType, event)) : ()=>listener(eventType, event);
            if (async) this.dispatchAsync(callback);
            else callback();
        });
    }
    // this gets called inside the grid's thread, for each event that it
    // wants to set async. the grid then batches the events into one setTimeout()
    // because setTimeout() is an expensive operation. ideally we would have
    // each event in it's own setTimeout(), but we batch for performance.
    dispatchAsync(func) {
        this.asyncFunctionsQueue.push(func);
        if (!this.scheduled) {
            const flush = ()=>{
                window.setTimeout(this.flushAsyncQueue.bind(this), 0);
            };
            this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(flush) : flush();
            this.scheduled = true;
        }
    }
    // this happens in the next VM turn only, and empties the queue of events
    flushAsyncQueue() {
        this.scheduled = false;
        const queueCopy = this.asyncFunctionsQueue.slice();
        this.asyncFunctionsQueue = [];
        queueCopy.forEach((func)=>func());
    }
};
// community-modules/core/src/utils/array.ts
function $7b57b57eaf5a9648$export$ac1efbcc438ea223(value) {
    return value != null && value.length > 0;
}
function $7b57b57eaf5a9648$export$236389741107357f(arr) {
    if (!arr || !arr.length) return;
    return arr[arr.length - 1];
}
function $7b57b57eaf5a9648$export$893967cdb9833fdd(a, b, comparator) {
    if (a == null && b == null) return true;
    return a != null && b != null && a.length === b.length && a.every((value, index)=>comparator ? comparator(value, b[index]) : b[index] === value);
}
function $7b57b57eaf5a9648$export$a624c3a0e1a31b73(arr1, arr2) {
    return $7b57b57eaf5a9648$export$893967cdb9833fdd(arr1, arr2);
}
function $7b57b57eaf5a9648$var$_sortNumerically(array) {
    return array.sort((a, b)=>a - b);
}
function $7b57b57eaf5a9648$export$1b9c960911f1ad8e(array, object) {
    if (!array) return;
    for(let index = array.length - 2; index >= 0; index--){
        const thisOneMatches = array[index] === object;
        const nextOneMatches = array[index + 1] === object;
        if (thisOneMatches && nextOneMatches) array.splice(index + 1, 1);
    }
}
function $7b57b57eaf5a9648$var$_removeFromUnorderedArray(array, object) {
    const index = array.indexOf(object);
    if (index >= 0) {
        array[index] = array[array.length - 1];
        array.pop();
    }
}
function $7b57b57eaf5a9648$export$83a881c8b5120679(array, object) {
    const index = array.indexOf(object);
    if (index >= 0) array.splice(index, 1);
}
function $7b57b57eaf5a9648$var$_removeAllFromUnorderedArray(array, toRemove) {
    for(let i = 0; i < toRemove.length; i++)$7b57b57eaf5a9648$var$_removeFromUnorderedArray(array, toRemove[i]);
}
function $7b57b57eaf5a9648$var$_removeAllFromArray(array, toRemove) {
    for(let i = 0; i < toRemove.length; i++)$7b57b57eaf5a9648$export$83a881c8b5120679(array, toRemove[i]);
}
function $7b57b57eaf5a9648$export$820a25988ad46b8d(array, object, toIndex) {
    array.splice(toIndex, 0, object);
}
function $7b57b57eaf5a9648$export$8902ee82a7fb2a35(dest, src, toIndex) {
    if (dest == null || src == null) return;
    for(let i = src.length - 1; i >= 0; i--){
        const item = src[i];
        $7b57b57eaf5a9648$export$820a25988ad46b8d(dest, item, toIndex);
    }
}
function $7b57b57eaf5a9648$var$_moveInArray(array, objectsToMove, toIndex) {
    $7b57b57eaf5a9648$var$_removeAllFromArray(array, objectsToMove);
    objectsToMove.slice().reverse().forEach((obj)=>$7b57b57eaf5a9648$export$820a25988ad46b8d(array, obj, toIndex));
}
function $7b57b57eaf5a9648$export$fccf016a6caa651d(array, value) {
    return array.indexOf(value) > -1;
}
function $7b57b57eaf5a9648$export$5e3f39c5068e375d(arrayOfArrays) {
    return [].concat.apply([], arrayOfArrays);
}
function $7b57b57eaf5a9648$var$_pushAll(target, source) {
    if (source == null || target == null) return;
    source.forEach((value)=>target.push(value));
}
function $7b57b57eaf5a9648$export$f36fb1d1d67f88(list, action) {
    if (list == null) return;
    for(let i = list.length - 1; i >= 0; i--)action(list[i], i);
}
// community-modules/core/src/utils/event.ts
var $7b57b57eaf5a9648$var$AG_GRID_STOP_PROPAGATION = "__ag_Grid_Stop_Propagation";
var $7b57b57eaf5a9648$var$PASSIVE_EVENTS = [
    "touchstart",
    "touchend",
    "touchmove",
    "touchcancel",
    "scroll"
];
var $7b57b57eaf5a9648$var$supports = {};
function $7b57b57eaf5a9648$export$456c40e80134d72a(event) {
    event[$7b57b57eaf5a9648$var$AG_GRID_STOP_PROPAGATION] = true;
}
function $7b57b57eaf5a9648$export$9a48e23524c6d58(event) {
    return event[$7b57b57eaf5a9648$var$AG_GRID_STOP_PROPAGATION] === true;
}
var $7b57b57eaf5a9648$var$_isEventSupported = /* @__PURE__ */ (()=>{
    const tags = {
        select: "input",
        change: "input",
        submit: "form",
        reset: "form",
        error: "img",
        load: "img",
        abort: "img"
    };
    const eventChecker = (eventName)=>{
        if (typeof $7b57b57eaf5a9648$var$supports[eventName] === "boolean") return $7b57b57eaf5a9648$var$supports[eventName];
        const el = document.createElement(tags[eventName] || "div");
        eventName = "on" + eventName;
        return $7b57b57eaf5a9648$var$supports[eventName] = eventName in el;
    };
    return eventChecker;
})();
function $7b57b57eaf5a9648$export$debbc44ebeaf0dc2(gos, eventTarget, type) {
    let sourceElement = eventTarget;
    while(sourceElement){
        const renderedComp = gos.getDomData(sourceElement, type);
        if (renderedComp) return renderedComp;
        sourceElement = sourceElement.parentElement;
    }
    return null;
}
function $7b57b57eaf5a9648$export$b5446458166e97b4(element, event) {
    if (!event || !element) return false;
    return $7b57b57eaf5a9648$var$_getEventPath(event).indexOf(element) >= 0;
}
function $7b57b57eaf5a9648$var$_createEventPath(event) {
    const res = [];
    let pointer = event.target;
    while(pointer){
        res.push(pointer);
        pointer = pointer.parentElement;
    }
    return res;
}
function $7b57b57eaf5a9648$var$_getEventPath(event) {
    const eventNoType = event;
    if (eventNoType.path) return eventNoType.path;
    if (eventNoType.composedPath) return eventNoType.composedPath();
    return $7b57b57eaf5a9648$var$_createEventPath(eventNoType);
}
function $7b57b57eaf5a9648$var$_addSafePassiveEventListener(frameworkOverrides, eElement, event, listener) {
    const isPassive = $7b57b57eaf5a9648$export$fccf016a6caa651d($7b57b57eaf5a9648$var$PASSIVE_EVENTS, event);
    const options = isPassive ? {
        passive: true
    } : void 0;
    if (frameworkOverrides && frameworkOverrides.addEventListener) frameworkOverrides.addEventListener(eElement, event, listener, options);
}
// community-modules/core/src/context/beanStub.ts
var $7b57b57eaf5a9648$export$2032c8ef3788dfbd = class {
    constructor(){
        // not named context to allow children to use 'context' as a variable name
        this.destroyFunctions = [];
        this.destroyed = false;
        // for vue 3 - prevents Vue from trying to make this (and obviously any sub classes) from being reactive
        // prevents vue from creating proxies for created objects and prevents identity related issues
        this.__v_skip = true;
        this.propertyListenerId = 0;
        // Enable multiple grid properties to be updated together by the user but only trigger shared logic once.
        // Closely related to logic in ComponentUtil.ts
        this.lastChangeSetIdLookup = {};
        this.isAlive = ()=>!this.destroyed;
    }
    preWireBeans(beans) {
        this.gridId = beans.context.getGridId();
        this.frameworkOverrides = beans.frameworkOverrides;
        this.stubContext = beans.context;
        this.eventService = beans.eventService;
        this.gos = beans.gos;
        this.localeService = beans.localeService;
    }
    // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
    // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
    // points to a bean or component that was not properly disposed of.
    // constructor() {
    //     setTimeout(()=> {
    //         if (this.isAlive()) {
    //             let prototype: any = Object.getPrototypeOf(this);
    //             const constructor: any = prototype.constructor;
    //             const constructorString = constructor.toString();
    //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
    //             console.log('is alive ' + beanName);
    //         }
    //     }, 5000);
    // }
    // CellComp and GridComp and override this because they get the FrameworkOverrides from the Beans bean
    getFrameworkOverrides() {
        return this.frameworkOverrides;
    }
    destroy() {
        for(let i = 0; i < this.destroyFunctions.length; i++)this.destroyFunctions[i]();
        this.destroyFunctions.length = 0;
        this.destroyed = true;
        this.dispatchLocalEvent({
            type: "destroyed"
        });
    }
    // The typing of AgEventListener<any, any, any> is not ideal, but it's the best we can do at the moment to enable
    // eventService to have the best typing at the expense of BeanStub local events
    /** Add a local event listener against this BeanStub */ addEventListener(eventType, listener) {
        if (!this.localEventService) this.localEventService = new $7b57b57eaf5a9648$export$820da7696a401cdc();
        this.localEventService.addEventListener(eventType, listener);
    }
    /** Remove a local event listener from this BeanStub */ removeEventListener(eventType, listener) {
        if (this.localEventService) this.localEventService.removeEventListener(eventType, listener);
    }
    dispatchLocalEvent(event) {
        if (this.localEventService) this.localEventService.dispatchEvent(event);
    }
    addManagedElementListeners(object, handlers) {
        return this._setupListeners(object, handlers);
    }
    addManagedEventListeners(handlers) {
        return this._setupListeners(this.eventService, handlers);
    }
    addManagedListeners(object, handlers) {
        return this._setupListeners(object, handlers);
    }
    _setupListeners(object, handlers) {
        const destroyFuncs = [];
        for(const k in handlers){
            const handler = handlers[k];
            if (handler) destroyFuncs.push(this._setupListener(object, k, handler));
        }
        return destroyFuncs;
    }
    _setupListener(object, event, listener) {
        if (this.destroyed) return ()=>null;
        if (object instanceof HTMLElement) $7b57b57eaf5a9648$var$_addSafePassiveEventListener(this.getFrameworkOverrides(), object, event, listener);
        else object.addEventListener(event, listener);
        const destroyFunc = ()=>{
            object.removeEventListener(event, listener);
            return null;
        };
        this.destroyFunctions.push(destroyFunc);
        return ()=>{
            destroyFunc();
            this.destroyFunctions = this.destroyFunctions.filter((fn)=>fn !== destroyFunc);
            return null;
        };
    }
    /**
   * Setup a managed property listener for the given GridOption property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the GridOptionsService is destroyed.
   */ setupGridOptionListener(event, listener) {
        this.gos.addPropertyEventListener(event, listener);
        const destroyFunc = ()=>{
            this.gos.removePropertyEventListener(event, listener);
            return null;
        };
        this.destroyFunctions.push(destroyFunc);
        return ()=>{
            destroyFunc();
            this.destroyFunctions = this.destroyFunctions.filter((fn)=>fn !== destroyFunc);
            return null;
        };
    }
    /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */ addManagedPropertyListener(event, listener) {
        if (this.destroyed) return ()=>null;
        return this.setupGridOptionListener(event, listener);
    }
    /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */ addManagedPropertyListeners(events, listener) {
        if (this.destroyed) return;
        const eventsKey = events.join("-") + this.propertyListenerId++;
        const wrappedListener = (event)=>{
            if (event.changeSet) {
                if (event.changeSet && event.changeSet.id === this.lastChangeSetIdLookup[eventsKey]) return;
                this.lastChangeSetIdLookup[eventsKey] = event.changeSet.id;
            }
            const propertiesChangeEvent = {
                type: "gridPropertyChanged",
                changeSet: event.changeSet,
                source: event.source
            };
            listener(propertiesChangeEvent);
        };
        events.forEach((event)=>this.setupGridOptionListener(event, wrappedListener));
    }
    addDestroyFunc(func) {
        if (this.isAlive()) this.destroyFunctions.push(func);
        else func();
    }
    createManagedBean(bean, context) {
        const res = this.createBean(bean, context);
        this.addDestroyFunc(this.destroyBean.bind(this, bean, context));
        return res;
    }
    createBean(bean, context, afterPreCreateCallback) {
        return (context || this.stubContext).createBean(bean, afterPreCreateCallback);
    }
    /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */ destroyBean(bean, context) {
        return (context || this.stubContext).destroyBean(bean);
    }
    /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */ destroyBeans(beans, context) {
        return (context || this.stubContext).destroyBeans(beans);
    }
};
// community-modules/core/src/misc/frameworkEventListenerService.ts
var $7b57b57eaf5a9648$var$FrameworkEventListenerService = class {
    constructor(frameworkOverrides){
        this.frameworkOverrides = frameworkOverrides;
        // Map from user listener to wrapped listener so we can remove listener provided by user
        this.wrappedListeners = /* @__PURE__ */ new Map();
        this.wrappedGlobalListeners = /* @__PURE__ */ new Map();
    }
    wrap(userListener) {
        let listener = userListener;
        if (this.frameworkOverrides.shouldWrapOutgoing) {
            listener = (event)=>{
                this.frameworkOverrides.wrapOutgoing(()=>userListener(event));
            };
            this.wrappedListeners.set(userListener, listener);
        }
        return listener;
    }
    wrapGlobal(userListener) {
        let listener = userListener;
        if (this.frameworkOverrides.shouldWrapOutgoing) {
            listener = (eventType, event)=>{
                this.frameworkOverrides.wrapOutgoing(()=>userListener(eventType, event));
            };
            this.wrappedGlobalListeners.set(userListener, listener);
        }
        return listener;
    }
    unwrap(userListener) {
        return this.wrappedListeners.get(userListener) ?? userListener;
    }
    unwrapGlobal(userListener) {
        return this.wrappedGlobalListeners.get(userListener) ?? userListener;
    }
};
// community-modules/core/src/utils/generic.ts
function $7b57b57eaf5a9648$export$4978424c4f7b5fc0(value) {
    if (value == null || value === "") return null;
    return value;
}
function $7b57b57eaf5a9648$export$25d27f17d3af40f7(value, allowEmptyString = false) {
    return value != null && (value !== "" || allowEmptyString);
}
function $7b57b57eaf5a9648$export$672d9e47bc342bac(value) {
    return !$7b57b57eaf5a9648$export$25d27f17d3af40f7(value);
}
function $7b57b57eaf5a9648$export$c15f339f10321853(value) {
    return value == null || value.length === 0;
}
function $7b57b57eaf5a9648$export$2a74c29220d5c88e(value) {
    return value != null && typeof value.toString === "function" ? value.toString() : null;
}
function $7b57b57eaf5a9648$var$_attrToNumber(value) {
    if (value === void 0) return;
    if (value === null || value === "") return null;
    if (typeof value === "number") return isNaN(value) ? void 0 : value;
    const valueParsed = parseInt(value, 10);
    return isNaN(valueParsed) ? void 0 : valueParsed;
}
function $7b57b57eaf5a9648$var$_attrToBoolean(value) {
    if (value === void 0) return;
    if (value === null || value === "") return false;
    return $7b57b57eaf5a9648$var$toBoolean(value);
}
function $7b57b57eaf5a9648$var$toBoolean(value) {
    if (typeof value === "boolean") return value;
    if (typeof value === "string") return value.toUpperCase() === "TRUE" || value == "";
    return false;
}
function $7b57b57eaf5a9648$export$dbc2068cc90f5875(val1, val2) {
    const val1Json = val1 ? JSON.stringify(val1) : null;
    const val2Json = val2 ? JSON.stringify(val2) : null;
    return val1Json === val2Json;
}
function $7b57b57eaf5a9648$export$b0cca9f3c87c8df8(valueA, valueB, accentedCompare = false) {
    const valueAMissing = valueA == null;
    const valueBMissing = valueB == null;
    if (valueA && valueA.toNumber) valueA = valueA.toNumber();
    if (valueB && valueB.toNumber) valueB = valueB.toNumber();
    if (valueAMissing && valueBMissing) return 0;
    if (valueAMissing) return -1;
    if (valueBMissing) return 1;
    function doQuickCompare(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
    }
    if (typeof valueA !== "string") return doQuickCompare(valueA, valueB);
    if (!accentedCompare) return doQuickCompare(valueA, valueB);
    try {
        return valueA.localeCompare(valueB);
    } catch (e) {
        return doQuickCompare(valueA, valueB);
    }
}
function $7b57b57eaf5a9648$export$3d4b197b660054d2(object) {
    if (object instanceof Set || object instanceof Map) {
        const arr = [];
        object.forEach((value)=>arr.push(value));
        return arr;
    }
    return Object.values(object);
}
// community-modules/core/src/utils/object.ts
var $7b57b57eaf5a9648$var$SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([
    "__proto__",
    "constructor",
    "prototype"
]);
function $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(object, callback) {
    if (object == null) return;
    if (Array.isArray(object)) {
        for(let i = 0; i < object.length; i++)callback(i.toString(), object[i]);
        return;
    }
    for (const [key, value] of Object.entries(object))callback(key, value);
}
function $7b57b57eaf5a9648$export$b0cc93169835e7eb(object) {
    const copy = {};
    const keys = Object.keys(object);
    for(let i = 0; i < keys.length; i++){
        if ($7b57b57eaf5a9648$var$SKIP_JS_BUILTINS.has(keys[i])) continue;
        const key = keys[i];
        const value = object[key];
        copy[key] = value;
    }
    return copy;
}
function $7b57b57eaf5a9648$var$_deepCloneDefinition(object, keysToSkip) {
    if (!object) return;
    const obj = object;
    const res = {};
    Object.keys(obj).forEach((key)=>{
        if (keysToSkip && keysToSkip.indexOf(key) >= 0 || $7b57b57eaf5a9648$var$SKIP_JS_BUILTINS.has(key)) return;
        const value = obj[key];
        const sourceIsSimpleObject = $7b57b57eaf5a9648$var$_isNonNullObject(value) && value.constructor === Object;
        if (sourceIsSimpleObject) res[key] = $7b57b57eaf5a9648$var$_deepCloneDefinition(value);
        else res[key] = value;
    });
    return res;
}
function $7b57b57eaf5a9648$export$2f52ef471f042094(obj) {
    if (!obj) return [];
    const anyObject = Object;
    if (typeof anyObject.values === "function") return anyObject.values(obj);
    const ret = [];
    for(const key in obj)if (obj.hasOwnProperty(key) && obj.propertyIsEnumerable(key)) ret.push(obj[key]);
    return ret;
}
function $7b57b57eaf5a9648$export$8ade6bd474fcde42(dest, source, copyUndefined = true, makeCopyOfSimpleObjects = false) {
    if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(source)) return;
    $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(source, (key, sourceValue)=>{
        if ($7b57b57eaf5a9648$var$SKIP_JS_BUILTINS.has(key)) return;
        let destValue = dest[key];
        if (destValue === sourceValue) return;
        if (makeCopyOfSimpleObjects) {
            const objectIsDueToBeCopied = destValue == null && sourceValue != null;
            if (objectIsDueToBeCopied) {
                const sourceIsSimpleObject = typeof sourceValue === "object" && sourceValue.constructor === Object;
                const dontCopy = sourceIsSimpleObject;
                if (dontCopy) {
                    destValue = {};
                    dest[key] = destValue;
                }
            }
        }
        if ($7b57b57eaf5a9648$var$_isNonNullObject(sourceValue) && $7b57b57eaf5a9648$var$_isNonNullObject(destValue) && !Array.isArray(destValue)) $7b57b57eaf5a9648$export$8ade6bd474fcde42(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);
        else if (copyUndefined || sourceValue !== void 0) dest[key] = sourceValue;
    });
}
function $7b57b57eaf5a9648$var$_getValueUsingField(data, field, fieldContainsDots) {
    if (!field || !data) return;
    if (!fieldContainsDots) return data[field];
    const fields = field.split(".");
    let currentObject = data;
    for(let i = 0; i < fields.length; i++){
        if (currentObject == null) return void 0;
        currentObject = currentObject[fields[i]];
    }
    return currentObject;
}
function $7b57b57eaf5a9648$var$_isNonNullObject(value) {
    return typeof value === "object" && value !== null;
}
// community-modules/core/src/entities/agColumn.ts
var $7b57b57eaf5a9648$var$COL_DEF_DEFAULTS = {
    resizable: true,
    sortable: true
};
var $7b57b57eaf5a9648$var$instanceIdSequence = 0;
function $7b57b57eaf5a9648$var$getNextColInstanceId() {
    return $7b57b57eaf5a9648$var$instanceIdSequence++;
}
function $7b57b57eaf5a9648$export$891484e65a02ec71(col) {
    return col instanceof $7b57b57eaf5a9648$export$a8da3e2b83e5ddf2;
}
var $7b57b57eaf5a9648$var$DEFAULT_COLUMN_MIN_WIDTH = 20;
var $7b57b57eaf5a9648$export$a8da3e2b83e5ddf2 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(colDef, userProvidedColDef, colId, primary){
        super();
        this.isColumn = true;
        // used by React (and possibly other frameworks) as key for rendering. also used to
        // identify old vs new columns for destroying cols when no longer used.
        this.instanceId = $7b57b57eaf5a9648$var$getNextColInstanceId();
        // The measured height of this column's header when autoHeaderHeight is enabled
        this.autoHeaderHeight = null;
        this.moving = false;
        this.menuVisible = false;
        this.lastLeftPinned = false;
        this.firstRightPinned = false;
        this.filterActive = false;
        this.columnEventService = new $7b57b57eaf5a9648$export$820da7696a401cdc();
        this.tooltipEnabled = false;
        this.rowGroupActive = false;
        this.pivotActive = false;
        this.aggregationActive = false;
        this.colDef = colDef;
        this.userProvidedColDef = userProvidedColDef;
        this.colId = colId;
        this.primary = primary;
        this.setState(colDef);
    }
    wireBeans(beans) {
        this.columnHoverService = beans.columnHoverService;
    }
    getInstanceId() {
        return this.instanceId;
    }
    setState(colDef) {
        if (colDef.sort !== void 0) {
            if (colDef.sort === "asc" || colDef.sort === "desc") this.sort = colDef.sort;
        } else if (colDef.initialSort === "asc" || colDef.initialSort === "desc") this.sort = colDef.initialSort;
        const sortIndex = colDef.sortIndex;
        const initialSortIndex = colDef.initialSortIndex;
        if (sortIndex !== void 0) {
            if (sortIndex !== null) this.sortIndex = sortIndex;
        } else if (initialSortIndex !== null) this.sortIndex = initialSortIndex;
        const hide = colDef.hide;
        const initialHide = colDef.initialHide;
        if (hide !== void 0) this.visible = !hide;
        else this.visible = !initialHide;
        if (colDef.pinned !== void 0) this.setPinned(colDef.pinned);
        else this.setPinned(colDef.initialPinned);
        const flex = colDef.flex;
        const initialFlex = colDef.initialFlex;
        if (flex !== void 0) this.flex = flex;
        else if (initialFlex !== void 0) this.flex = initialFlex;
    }
    // gets called when user provides an alternative colDef, eg
    setColDef(colDef, userProvidedColDef, source) {
        this.colDef = colDef;
        this.userProvidedColDef = userProvidedColDef;
        this.initMinAndMaxWidths();
        this.initDotNotation();
        this.initTooltip();
        this.columnEventService.dispatchEvent(this.createColumnEvent("colDefChanged", source));
    }
    getUserProvidedColDef() {
        return this.userProvidedColDef;
    }
    setParent(parent) {
        this.parent = parent;
    }
    getParent() {
        return this.parent;
    }
    setOriginalParent(originalParent) {
        this.originalParent = originalParent;
    }
    getOriginalParent() {
        return this.originalParent;
    }
    // this is done after constructor as it uses gridOptionsService
    postConstruct() {
        this.initMinAndMaxWidths();
        this.resetActualWidth("gridInitializing");
        this.initDotNotation();
        this.initTooltip();
    }
    initDotNotation() {
        const suppressDotNotation = this.gos.get("suppressFieldDotNotation");
        this.fieldContainsDots = $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !suppressDotNotation;
        this.tooltipFieldContainsDots = $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !suppressDotNotation;
    }
    initMinAndMaxWidths() {
        const colDef = this.colDef;
        this.minWidth = colDef.minWidth ?? $7b57b57eaf5a9648$var$DEFAULT_COLUMN_MIN_WIDTH;
        this.maxWidth = colDef.maxWidth ?? Number.MAX_SAFE_INTEGER;
    }
    initTooltip() {
        this.tooltipEnabled = $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.colDef.tooltipField) || $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.colDef.tooltipValueGetter) || $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.colDef.tooltipComponent);
    }
    resetActualWidth(source) {
        const initialWidth = this.calculateColInitialWidth(this.colDef);
        this.setActualWidth(initialWidth, source, true);
    }
    calculateColInitialWidth(colDef) {
        let width;
        const colDefWidth = $7b57b57eaf5a9648$var$_attrToNumber(colDef.width);
        const colDefInitialWidth = $7b57b57eaf5a9648$var$_attrToNumber(colDef.initialWidth);
        if (colDefWidth != null) width = colDefWidth;
        else if (colDefInitialWidth != null) width = colDefInitialWidth;
        else width = 200;
        return Math.max(Math.min(width, this.maxWidth), this.minWidth);
    }
    isEmptyGroup() {
        return false;
    }
    isRowGroupDisplayed(colId) {
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(this.colDef) || $7b57b57eaf5a9648$export$672d9e47bc342bac(this.colDef.showRowGroup)) return false;
        const showingAllGroups = this.colDef.showRowGroup === true;
        const showingThisGroup = this.colDef.showRowGroup === colId;
        return showingAllGroups || showingThisGroup;
    }
    isPrimary() {
        return this.primary;
    }
    isFilterAllowed() {
        const filterDefined = !!this.colDef.filter;
        return filterDefined;
    }
    isFieldContainsDots() {
        return this.fieldContainsDots;
    }
    isTooltipEnabled() {
        return this.tooltipEnabled;
    }
    isTooltipFieldContainsDots() {
        return this.tooltipFieldContainsDots;
    }
    addEventListener(eventType, userListener) {
        if (this.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService) {
            this.columnEventService.setFrameworkOverrides(this.frameworkOverrides);
            this.frameworkEventListenerService = new $7b57b57eaf5a9648$var$FrameworkEventListenerService(this.frameworkOverrides);
        }
        const listener = this.frameworkEventListenerService?.wrap(userListener) ?? userListener;
        this.columnEventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, userListener) {
        const listener = this.frameworkEventListenerService?.unwrap(userListener) ?? userListener;
        this.columnEventService.removeEventListener(eventType, listener);
    }
    createColumnFunctionCallbackParams(rowNode) {
        return this.gos.addGridCommonParams({
            node: rowNode,
            data: rowNode.data,
            column: this,
            colDef: this.colDef
        });
    }
    isSuppressNavigable(rowNode) {
        if (typeof this.colDef.suppressNavigable === "boolean") return this.colDef.suppressNavigable;
        if (typeof this.colDef.suppressNavigable === "function") {
            const params = this.createColumnFunctionCallbackParams(rowNode);
            const userFunc = this.colDef.suppressNavigable;
            return userFunc(params);
        }
        return false;
    }
    isCellEditable(rowNode) {
        if (rowNode.group && !this.gos.get("enableGroupEdit")) return false;
        return this.isColumnFunc(rowNode, this.colDef.editable);
    }
    isSuppressFillHandle() {
        return !!this.colDef.suppressFillHandle;
    }
    isAutoHeight() {
        return !!this.colDef.autoHeight;
    }
    isAutoHeaderHeight() {
        return !!this.colDef.autoHeaderHeight;
    }
    isRowDrag(rowNode) {
        return this.isColumnFunc(rowNode, this.colDef.rowDrag);
    }
    isDndSource(rowNode) {
        return this.isColumnFunc(rowNode, this.colDef.dndSource);
    }
    isCellCheckboxSelection(rowNode) {
        return this.isColumnFunc(rowNode, this.colDef.checkboxSelection);
    }
    isSuppressPaste(rowNode) {
        return this.isColumnFunc(rowNode, this.colDef ? this.colDef.suppressPaste : null);
    }
    isResizable() {
        return !!this.getColDefValue("resizable");
    }
    /** Get value from ColDef or default if it exists. */ getColDefValue(key) {
        return this.colDef[key] ?? $7b57b57eaf5a9648$var$COL_DEF_DEFAULTS[key];
    }
    isColumnFunc(rowNode, value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "function") {
            const params = this.createColumnFunctionCallbackParams(rowNode);
            const editableFunc = value;
            return editableFunc(params);
        }
        return false;
    }
    setMoving(moving, source) {
        this.moving = moving;
        this.columnEventService.dispatchEvent(this.createColumnEvent("movingChanged", source));
    }
    createColumnEvent(type, source) {
        return this.gos.addGridCommonParams({
            type: type,
            column: this,
            columns: [
                this
            ],
            source: source
        });
    }
    isMoving() {
        return this.moving;
    }
    getSort() {
        return this.sort;
    }
    setSort(sort, source) {
        if (this.sort !== sort) {
            this.sort = sort;
            this.columnEventService.dispatchEvent(this.createColumnEvent("sortChanged", source));
        }
        this.dispatchStateUpdatedEvent("sort");
    }
    isSortable() {
        return !!this.getColDefValue("sortable");
    }
    /** @deprecated v32 use col.getSort() === 'asc */ isSortAscending() {
        return this.sort === "asc";
    }
    /** @deprecated v32 use col.getSort() === 'desc */ isSortDescending() {
        return this.sort === "desc";
    }
    /** @deprecated v32 use col.getSort() === undefined */ isSortNone() {
        return $7b57b57eaf5a9648$export$672d9e47bc342bac(this.sort);
    }
    /** @deprecated v32 use col.getSort() !== undefined */ isSorting() {
        return $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.sort);
    }
    getSortIndex() {
        return this.sortIndex;
    }
    setSortIndex(sortOrder) {
        this.sortIndex = sortOrder;
        this.dispatchStateUpdatedEvent("sortIndex");
    }
    setMenuVisible(visible, source) {
        if (this.menuVisible !== visible) {
            this.menuVisible = visible;
            this.columnEventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", source));
        }
    }
    isMenuVisible() {
        return this.menuVisible;
    }
    setAggFunc(aggFunc) {
        this.aggFunc = aggFunc;
        this.dispatchStateUpdatedEvent("aggFunc");
    }
    getAggFunc() {
        return this.aggFunc;
    }
    getLeft() {
        return this.left;
    }
    getOldLeft() {
        return this.oldLeft;
    }
    getRight() {
        return this.left + this.actualWidth;
    }
    setLeft(left, source) {
        this.oldLeft = this.left;
        if (this.left !== left) {
            this.left = left;
            this.columnEventService.dispatchEvent(this.createColumnEvent("leftChanged", source));
        }
    }
    isFilterActive() {
        return this.filterActive;
    }
    // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
    setFilterActive(active, source, additionalEventAttributes) {
        if (this.filterActive !== active) {
            this.filterActive = active;
            this.columnEventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", source));
        }
        const filterChangedEvent = this.createColumnEvent("filterChanged", source);
        if (additionalEventAttributes) $7b57b57eaf5a9648$export$8ade6bd474fcde42(filterChangedEvent, additionalEventAttributes);
        this.columnEventService.dispatchEvent(filterChangedEvent);
    }
    isHovered() {
        return this.columnHoverService.isHovered(this);
    }
    setPinned(pinned) {
        if (pinned === true || pinned === "left") this.pinned = "left";
        else if (pinned === "right") this.pinned = "right";
        else this.pinned = null;
        this.dispatchStateUpdatedEvent("pinned");
    }
    setFirstRightPinned(firstRightPinned, source) {
        if (this.firstRightPinned !== firstRightPinned) {
            this.firstRightPinned = firstRightPinned;
            this.columnEventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", source));
        }
    }
    setLastLeftPinned(lastLeftPinned, source) {
        if (this.lastLeftPinned !== lastLeftPinned) {
            this.lastLeftPinned = lastLeftPinned;
            this.columnEventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", source));
        }
    }
    isFirstRightPinned() {
        return this.firstRightPinned;
    }
    isLastLeftPinned() {
        return this.lastLeftPinned;
    }
    isPinned() {
        return this.pinned === "left" || this.pinned === "right";
    }
    isPinnedLeft() {
        return this.pinned === "left";
    }
    isPinnedRight() {
        return this.pinned === "right";
    }
    getPinned() {
        return this.pinned;
    }
    setVisible(visible, source) {
        const newValue = visible === true;
        if (this.visible !== newValue) {
            this.visible = newValue;
            this.columnEventService.dispatchEvent(this.createColumnEvent("visibleChanged", source));
        }
        this.dispatchStateUpdatedEvent("hide");
    }
    isVisible() {
        return this.visible;
    }
    isSpanHeaderHeight() {
        const colDef = this.getColDef();
        return !colDef.suppressSpanHeaderHeight && !colDef.autoHeaderHeight;
    }
    getColumnGroupPaddingInfo() {
        let parent = this.getParent();
        if (!parent || !parent.isPadding()) return {
            numberOfParents: 0,
            isSpanningTotal: false
        };
        const numberOfParents = parent.getPaddingLevel() + 1;
        let isSpanningTotal = true;
        while(parent){
            if (!parent.isPadding()) {
                isSpanningTotal = false;
                break;
            }
            parent = parent.getParent();
        }
        return {
            numberOfParents: numberOfParents,
            isSpanningTotal: isSpanningTotal
        };
    }
    getColDef() {
        return this.colDef;
    }
    getDefinition() {
        return this.colDef;
    }
    getColumnGroupShow() {
        return this.colDef.columnGroupShow;
    }
    getColId() {
        return this.colId;
    }
    getId() {
        return this.colId;
    }
    getUniqueId() {
        return this.colId;
    }
    getActualWidth() {
        return this.actualWidth;
    }
    getAutoHeaderHeight() {
        return this.autoHeaderHeight;
    }
    /** Returns true if the header height has changed */ setAutoHeaderHeight(height) {
        const changed = height !== this.autoHeaderHeight;
        this.autoHeaderHeight = height;
        return changed;
    }
    createBaseColDefParams(rowNode) {
        const params = this.gos.addGridCommonParams({
            node: rowNode,
            data: rowNode.data,
            colDef: this.colDef,
            column: this
        });
        return params;
    }
    getColSpan(rowNode) {
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(this.colDef.colSpan)) return 1;
        const params = this.createBaseColDefParams(rowNode);
        const colSpan = this.colDef.colSpan(params);
        return Math.max(colSpan, 1);
    }
    getRowSpan(rowNode) {
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(this.colDef.rowSpan)) return 1;
        const params = this.createBaseColDefParams(rowNode);
        const rowSpan = this.colDef.rowSpan(params);
        return Math.max(rowSpan, 1);
    }
    setActualWidth(actualWidth, source, silent = false) {
        actualWidth = Math.max(actualWidth, this.minWidth);
        actualWidth = Math.min(actualWidth, this.maxWidth);
        if (this.actualWidth !== actualWidth) {
            this.actualWidth = actualWidth;
            if (this.flex && source !== "flex" && source !== "gridInitializing") this.flex = null;
            if (!silent) this.fireColumnWidthChangedEvent(source);
        }
        this.dispatchStateUpdatedEvent("width");
    }
    fireColumnWidthChangedEvent(source) {
        this.columnEventService.dispatchEvent(this.createColumnEvent("widthChanged", source));
    }
    isGreaterThanMax(width) {
        return width > this.maxWidth;
    }
    getMinWidth() {
        return this.minWidth;
    }
    getMaxWidth() {
        return this.maxWidth;
    }
    getFlex() {
        return this.flex || 0;
    }
    // this method should only be used by the columnModel to
    // change flex when required by the applyColumnState method.
    setFlex(flex) {
        if (this.flex !== flex) this.flex = flex;
        this.dispatchStateUpdatedEvent("flex");
    }
    setMinimum(source) {
        this.setActualWidth(this.minWidth, source);
    }
    setRowGroupActive(rowGroup, source) {
        if (this.rowGroupActive !== rowGroup) {
            this.rowGroupActive = rowGroup;
            this.columnEventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", source));
        }
        this.dispatchStateUpdatedEvent("rowGroup");
    }
    isRowGroupActive() {
        return this.rowGroupActive;
    }
    setPivotActive(pivot, source) {
        if (this.pivotActive !== pivot) {
            this.pivotActive = pivot;
            this.columnEventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", source));
        }
        this.dispatchStateUpdatedEvent("pivot");
    }
    isPivotActive() {
        return this.pivotActive;
    }
    isAnyFunctionActive() {
        return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
    }
    isAnyFunctionAllowed() {
        return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
    }
    setValueActive(value, source) {
        if (this.aggregationActive !== value) {
            this.aggregationActive = value;
            this.columnEventService.dispatchEvent(this.createColumnEvent("columnValueChanged", source));
        }
    }
    isValueActive() {
        return this.aggregationActive;
    }
    isAllowPivot() {
        return this.colDef.enablePivot === true;
    }
    isAllowValue() {
        return this.colDef.enableValue === true;
    }
    isAllowRowGroup() {
        return this.colDef.enableRowGroup === true;
    }
    dispatchStateUpdatedEvent(key) {
        this.columnEventService.dispatchEvent({
            type: "columnStateUpdated",
            key: key
        });
    }
};
// community-modules/core/src/entities/agProvidedColumnGroup.ts
function $7b57b57eaf5a9648$export$bb4bfad2b594b78e(col) {
    return col instanceof $7b57b57eaf5a9648$export$7ff27642a6ecc1cf;
}
var $7b57b57eaf5a9648$export$7ff27642a6ecc1cf = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(colGroupDef, groupId, padding, level){
        super();
        this.isColumn = false;
        this.expandable = false;
        // used by React (and possibly other frameworks) as key for rendering. also used to
        // identify old vs new columns for destroying cols when no longer used.
        this.instanceId = $7b57b57eaf5a9648$var$getNextColInstanceId();
        this.expandableListenerRemoveCallback = null;
        this.colGroupDef = colGroupDef;
        this.groupId = groupId;
        this.expanded = !!colGroupDef && !!colGroupDef.openByDefault;
        this.padding = padding;
        this.level = level;
    }
    destroy() {
        if (this.expandableListenerRemoveCallback) this.reset(null, void 0);
        super.destroy();
    }
    reset(colGroupDef, level) {
        this.colGroupDef = colGroupDef;
        this.level = level;
        this.originalParent = null;
        if (this.expandableListenerRemoveCallback) this.expandableListenerRemoveCallback();
        this.children = void 0;
        this.expandable = void 0;
    }
    getInstanceId() {
        return this.instanceId;
    }
    setOriginalParent(originalParent) {
        this.originalParent = originalParent;
    }
    getOriginalParent() {
        return this.originalParent;
    }
    getLevel() {
        return this.level;
    }
    isVisible() {
        if (this.children) return this.children.some((child)=>child.isVisible());
        return false;
    }
    isPadding() {
        return this.padding;
    }
    setExpanded(expanded) {
        this.expanded = expanded === void 0 ? false : expanded;
        this.dispatchLocalEvent({
            type: "expandedChanged"
        });
    }
    isExpandable() {
        return this.expandable;
    }
    isExpanded() {
        return this.expanded;
    }
    getGroupId() {
        return this.groupId;
    }
    getId() {
        return this.getGroupId();
    }
    setChildren(children) {
        this.children = children;
    }
    getChildren() {
        return this.children;
    }
    getColGroupDef() {
        return this.colGroupDef;
    }
    getLeafColumns() {
        const result = [];
        this.addLeafColumns(result);
        return result;
    }
    addLeafColumns(leafColumns) {
        if (!this.children) return;
        this.children.forEach((child)=>{
            if ($7b57b57eaf5a9648$export$891484e65a02ec71(child)) leafColumns.push(child);
            else if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(child)) child.addLeafColumns(leafColumns);
        });
    }
    getColumnGroupShow() {
        const colGroupDef = this.colGroupDef;
        if (!colGroupDef) return;
        return colGroupDef.columnGroupShow;
    }
    // need to check that this group has at least one col showing when both expanded and contracted.
    // if not, then we don't allow expanding and contracting on this group
    setupExpandable() {
        this.setExpandable();
        if (this.expandableListenerRemoveCallback) this.expandableListenerRemoveCallback();
        const listener = this.onColumnVisibilityChanged.bind(this);
        this.getLeafColumns().forEach((col)=>col.addEventListener("visibleChanged", listener));
        this.expandableListenerRemoveCallback = ()=>{
            this.getLeafColumns().forEach((col)=>col.removeEventListener("visibleChanged", listener));
            this.expandableListenerRemoveCallback = null;
        };
    }
    setExpandable() {
        if (this.isPadding()) return;
        let atLeastOneShowingWhenOpen = false;
        let atLeastOneShowingWhenClosed = false;
        let atLeastOneChangeable = false;
        const children = this.findChildrenRemovingPadding();
        for(let i = 0, j = children.length; i < j; i++){
            const abstractColumn = children[i];
            if (!abstractColumn.isVisible()) continue;
            const headerGroupShow = abstractColumn.getColumnGroupShow();
            if (headerGroupShow === "open") {
                atLeastOneShowingWhenOpen = true;
                atLeastOneChangeable = true;
            } else if (headerGroupShow === "closed") {
                atLeastOneShowingWhenClosed = true;
                atLeastOneChangeable = true;
            } else {
                atLeastOneShowingWhenOpen = true;
                atLeastOneShowingWhenClosed = true;
            }
        }
        const expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
        if (this.expandable !== expandable) {
            this.expandable = expandable;
            this.dispatchLocalEvent({
                type: "expandableChanged"
            });
        }
    }
    findChildrenRemovingPadding() {
        const res = [];
        const process = (items)=>{
            items.forEach((item)=>{
                const skipBecausePadding = $7b57b57eaf5a9648$export$bb4bfad2b594b78e(item) && item.isPadding();
                if (skipBecausePadding) process(item.children);
                else res.push(item);
            });
        };
        process(this.children);
        return res;
    }
    onColumnVisibilityChanged() {
        this.setExpandable();
    }
};
// community-modules/core/src/entities/defaultColumnTypes.ts
var $7b57b57eaf5a9648$var$DefaultColumnTypes = {
    numericColumn: {
        headerClass: "ag-right-aligned-header",
        cellClass: "ag-right-aligned-cell"
    },
    rightAligned: {
        headerClass: "ag-right-aligned-header",
        cellClass: "ag-right-aligned-cell"
    }
};
// community-modules/core/src/utils/function.ts
var $7b57b57eaf5a9648$var$doOnceFlags = {};
function $7b57b57eaf5a9648$export$e150fb6ea3b45c0d(func, key) {
    if ($7b57b57eaf5a9648$var$doOnceFlags[key]) return;
    func();
    $7b57b57eaf5a9648$var$doOnceFlags[key] = true;
}
function $7b57b57eaf5a9648$export$1ce471ee7a8b4d23(message, ...args) {
    console.log("AG Grid: " + message, ...args);
}
function $7b57b57eaf5a9648$export$2cf41453020eef66(msg, ...args) {
    $7b57b57eaf5a9648$export$e150fb6ea3b45c0d(()=>console.warn("AG Grid: " + msg, ...args), msg + args?.join(""));
}
function $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(msg, ...args) {
    $7b57b57eaf5a9648$export$e150fb6ea3b45c0d(()=>console.error("AG Grid: " + msg, ...args), msg + args?.join(""));
}
function $7b57b57eaf5a9648$var$_isFunction(val) {
    return !!(val && val.constructor && val.call && val.apply);
}
function $7b57b57eaf5a9648$var$_executeInAWhile(funcs) {
    $7b57b57eaf5a9648$var$_executeAfter(funcs, 400);
}
var $7b57b57eaf5a9648$var$executeNextVMTurnFuncs = [];
var $7b57b57eaf5a9648$var$executeNextVMTurnPending = false;
function $7b57b57eaf5a9648$var$_executeNextVMTurn(func) {
    $7b57b57eaf5a9648$var$executeNextVMTurnFuncs.push(func);
    if ($7b57b57eaf5a9648$var$executeNextVMTurnPending) return;
    $7b57b57eaf5a9648$var$executeNextVMTurnPending = true;
    window.setTimeout(()=>{
        const funcsCopy = $7b57b57eaf5a9648$var$executeNextVMTurnFuncs.slice();
        $7b57b57eaf5a9648$var$executeNextVMTurnFuncs.length = 0;
        $7b57b57eaf5a9648$var$executeNextVMTurnPending = false;
        funcsCopy.forEach((func2)=>func2());
    }, 0);
}
function $7b57b57eaf5a9648$var$_executeAfter(funcs, milliseconds = 0) {
    if (funcs.length > 0) window.setTimeout(()=>funcs.forEach((func)=>func()), milliseconds);
}
function $7b57b57eaf5a9648$export$cf7e39bfb94de6e(func, delay) {
    let timeout;
    return function(...args) {
        const context = this;
        window.clearTimeout(timeout);
        timeout = window.setTimeout(function() {
            func.apply(context, args);
        }, delay);
    };
}
function $7b57b57eaf5a9648$var$_throttle(func, wait) {
    let previousCall = 0;
    return function(...args) {
        const context = this;
        const currentCall = /* @__PURE__ */ new Date().getTime();
        if (currentCall - previousCall < wait) return;
        previousCall = currentCall;
        func.apply(context, args);
    };
}
function $7b57b57eaf5a9648$export$b863e7aac7884b8(condition, callback, timeout = 100, timeoutMessage) {
    const timeStamp = /* @__PURE__ */ new Date().getTime();
    let interval = null;
    let executed = false;
    const internalCallback = ()=>{
        const reachedTimeout = /* @__PURE__ */ new Date().getTime() - timeStamp > timeout;
        if (condition() || reachedTimeout) {
            callback();
            executed = true;
            if (interval != null) {
                window.clearInterval(interval);
                interval = null;
            }
            if (reachedTimeout && timeoutMessage) $7b57b57eaf5a9648$export$2cf41453020eef66(timeoutMessage);
        }
    };
    internalCallback();
    if (!executed) interval = window.setInterval(internalCallback, 10);
}
function $7b57b57eaf5a9648$export$142f8ba6f38315ec(...fns) {
    return (arg)=>fns.reduce((composed, f)=>f(composed), arg);
}
// community-modules/core/src/columns/columnKeyCreator.ts
var $7b57b57eaf5a9648$export$f67d1427302c96a3 = class {
    constructor(){
        this.existingKeys = {};
    }
    addExistingKeys(keys) {
        for(let i = 0; i < keys.length; i++)this.existingKeys[keys[i]] = true;
    }
    getUniqueKey(colId, colField) {
        colId = $7b57b57eaf5a9648$export$2a74c29220d5c88e(colId);
        let count = 0;
        while(true){
            let idToTry;
            if (colId) {
                idToTry = colId;
                if (count !== 0) idToTry += "_" + count;
            } else if (colField) {
                idToTry = colField;
                if (count !== 0) idToTry += "_" + count;
            } else idToTry = count;
            if (!this.existingKeys[idToTry]) {
                this.existingKeys[idToTry] = true;
                return String(idToTry);
            }
            count++;
        }
    }
};
// community-modules/core/src/columns/columnUtils.ts
var $7b57b57eaf5a9648$export$a7016588c430dba6 = "ag-Grid-AutoColumn";
function $7b57b57eaf5a9648$var$getColumnsFromTree(rootColumns) {
    const result = [];
    const recursiveFindColumns = (childColumns)=>{
        for(let i = 0; i < childColumns.length; i++){
            const child = childColumns[i];
            if ($7b57b57eaf5a9648$export$891484e65a02ec71(child)) result.push(child);
            else if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(child)) recursiveFindColumns(child.getChildren());
        }
    };
    recursiveFindColumns(rootColumns);
    return result;
}
function $7b57b57eaf5a9648$var$getWidthOfColsInList(columnList) {
    return columnList.reduce((width, col)=>width + col.getActualWidth(), 0);
}
function $7b57b57eaf5a9648$var$destroyColumnTree(context, oldTree, newTree) {
    const oldObjectsById = {};
    if (!oldTree) return;
    $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(null, oldTree, (child)=>{
        oldObjectsById[child.getInstanceId()] = child;
    });
    if (newTree) $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(null, newTree, (child)=>{
        oldObjectsById[child.getInstanceId()] = null;
    });
    const colsToDestroy = Object.values(oldObjectsById).filter((item)=>item != null);
    context.destroyBeans(colsToDestroy);
}
function $7b57b57eaf5a9648$var$isColumnGroupAutoCol(col) {
    const colId = col.getId();
    return colId.startsWith($7b57b57eaf5a9648$export$a7016588c430dba6);
}
function $7b57b57eaf5a9648$var$convertColumnTypes(type) {
    let typeKeys = [];
    if (type instanceof Array) {
        const invalidArray = type.some((a)=>typeof a !== "string");
        if (invalidArray) $7b57b57eaf5a9648$export$2cf41453020eef66("if colDef.type is supplied an array it should be of type 'string[]'");
        else typeKeys = type;
    } else if (typeof type === "string") typeKeys = type.split(",");
    else $7b57b57eaf5a9648$export$2cf41453020eef66("colDef.type should be of type 'string' | 'string[]'");
    return typeKeys;
}
// community-modules/core/src/columns/columnFactory.ts
var $7b57b57eaf5a9648$export$a988f568cf9d5725 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnFactory";
    }
    wireBeans(beans) {
        this.dataTypeService = beans.dataTypeService;
    }
    createColumnTree(defs, primaryColumns, existingTree, source) {
        const columnKeyCreator = new $7b57b57eaf5a9648$export$f67d1427302c96a3();
        const { existingCols: existingCols , existingGroups: existingGroups , existingColKeys: existingColKeys  } = this.extractExistingTreeData(existingTree);
        columnKeyCreator.addExistingKeys(existingColKeys);
        const unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns, existingCols, columnKeyCreator, existingGroups, source);
        const treeDept = this.findMaxDept(unbalancedTree, 0);
        const columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);
        const deptFirstCallback = (child, parent)=>{
            if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(child)) child.setupExpandable();
            child.setOriginalParent(parent);
        };
        $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);
        return {
            columnTree: columnTree,
            treeDept: treeDept
        };
    }
    extractExistingTreeData(existingTree) {
        const existingCols = [];
        const existingGroups = [];
        const existingColKeys = [];
        if (existingTree) $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(null, existingTree, (item)=>{
            if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(item)) {
                const group = item;
                existingGroups.push(group);
            } else {
                const col = item;
                existingColKeys.push(col.getId());
                existingCols.push(col);
            }
        });
        return {
            existingCols: existingCols,
            existingGroups: existingGroups,
            existingColKeys: existingColKeys
        };
    }
    createForAutoGroups(autoGroupCols, liveTree) {
        const tree = [];
        const dept = this.findDepth(liveTree);
        autoGroupCols.forEach((col)=>{
            let nextChild = col;
            for(let i = dept - 1; i >= 0; i--){
                const autoGroup = new $7b57b57eaf5a9648$export$7ff27642a6ecc1cf(null, `FAKE_PATH_${col.getId()}}_${i}`, true, i);
                this.createBean(autoGroup);
                autoGroup.setChildren([
                    nextChild
                ]);
                nextChild.setOriginalParent(autoGroup);
                nextChild = autoGroup;
            }
            if (dept === 0) col.setOriginalParent(null);
            tree.push(nextChild);
        });
        return [
            tree,
            dept
        ];
    }
    findDepth(balancedColumnTree) {
        let dept = 0;
        let pointer = balancedColumnTree;
        while(pointer && pointer[0] && $7b57b57eaf5a9648$export$bb4bfad2b594b78e(pointer[0])){
            dept++;
            pointer = pointer[0].getChildren();
        }
        return dept;
    }
    balanceColumnTree(unbalancedTree, currentDept, columnDept, columnKeyCreator) {
        const result = [];
        for(let i = 0; i < unbalancedTree.length; i++){
            const child = unbalancedTree[i];
            if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(child)) {
                const originalGroup = child;
                const newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);
                originalGroup.setChildren(newChildren);
                result.push(originalGroup);
            } else {
                let firstPaddedGroup;
                let currentPaddedGroup;
                for(let j = columnDept - 1; j >= currentDept; j--){
                    const newColId = columnKeyCreator.getUniqueKey(null, null);
                    const colGroupDefMerged = this.createMergedColGroupDef(null);
                    const paddedGroup = new $7b57b57eaf5a9648$export$7ff27642a6ecc1cf(colGroupDefMerged, newColId, true, currentDept);
                    this.createBean(paddedGroup);
                    if (currentPaddedGroup) currentPaddedGroup.setChildren([
                        paddedGroup
                    ]);
                    currentPaddedGroup = paddedGroup;
                    if (!firstPaddedGroup) firstPaddedGroup = currentPaddedGroup;
                }
                if (firstPaddedGroup && currentPaddedGroup) {
                    result.push(firstPaddedGroup);
                    const hasGroups = unbalancedTree.some((leaf)=>$7b57b57eaf5a9648$export$bb4bfad2b594b78e(leaf));
                    if (hasGroups) {
                        currentPaddedGroup.setChildren([
                            child
                        ]);
                        continue;
                    } else {
                        currentPaddedGroup.setChildren(unbalancedTree);
                        break;
                    }
                }
                result.push(child);
            }
        }
        return result;
    }
    findMaxDept(treeChildren, dept) {
        let maxDeptThisLevel = dept;
        for(let i = 0; i < treeChildren.length; i++){
            const abstractColumn = treeChildren[i];
            if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(abstractColumn)) {
                const originalGroup = abstractColumn;
                const newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);
                if (maxDeptThisLevel < newDept) maxDeptThisLevel = newDept;
            }
        }
        return maxDeptThisLevel;
    }
    recursivelyCreateColumns(defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups, source) {
        if (!defs) return [];
        const result = new Array(defs.length);
        for(let i = 0; i < result.length; i++){
            const def = defs[i];
            if (this.isColumnGroup(def)) result[i] = this.createColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, existingGroups, source);
            else result[i] = this.createColumn(primaryColumns, def, existingColsCopy, columnKeyCreator, source);
        }
        return result;
    }
    createColumnGroup(primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups, source) {
        const colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);
        const groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId || null, null);
        const providedGroup = new $7b57b57eaf5a9648$export$7ff27642a6ecc1cf(colGroupDefMerged, groupId, false, level);
        this.createBean(providedGroup);
        const existingGroupAndIndex = this.findExistingGroup(colGroupDef, existingGroups);
        if (existingGroupAndIndex) existingGroups.splice(existingGroupAndIndex.idx, 1);
        const existingGroup = existingGroupAndIndex?.group;
        if (existingGroup) providedGroup.setExpanded(existingGroup.isExpanded());
        const children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, existingGroups, source);
        providedGroup.setChildren(children);
        return providedGroup;
    }
    createMergedColGroupDef(colGroupDef) {
        const colGroupDefMerged = {};
        Object.assign(colGroupDefMerged, this.gos.get("defaultColGroupDef"));
        Object.assign(colGroupDefMerged, colGroupDef);
        return colGroupDefMerged;
    }
    createColumn(primaryColumns, colDef, existingColsCopy, columnKeyCreator, source) {
        const existingColAndIndex = this.findExistingColumn(colDef, existingColsCopy);
        if (existingColAndIndex) existingColsCopy?.splice(existingColAndIndex.idx, 1);
        let column = existingColAndIndex?.column;
        if (!column) {
            const colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
            const colDefMerged = this.addColumnDefaultAndTypes(colDef, colId);
            column = new $7b57b57eaf5a9648$export$a8da3e2b83e5ddf2(colDefMerged, colDef, colId, primaryColumns);
            this.createBean(column);
        } else {
            const colDefMerged = this.addColumnDefaultAndTypes(colDef, column.getColId());
            column.setColDef(colDefMerged, colDef, source);
            this.applyColumnState(column, colDefMerged, source);
        }
        this.dataTypeService?.addColumnListeners(column);
        return column;
    }
    applyColumnState(column, colDef, source) {
        const flex = $7b57b57eaf5a9648$var$_attrToNumber(colDef.flex);
        if (flex !== void 0) column.setFlex(flex);
        const noFlexThisCol = column.getFlex() <= 0;
        if (noFlexThisCol) {
            const width = $7b57b57eaf5a9648$var$_attrToNumber(colDef.width);
            if (width != null) column.setActualWidth(width, source);
            else {
                const widthBeforeUpdate = column.getActualWidth();
                column.setActualWidth(widthBeforeUpdate, source);
            }
        }
        if (colDef.sort !== void 0) {
            if (colDef.sort == "asc" || colDef.sort == "desc") column.setSort(colDef.sort, source);
            else column.setSort(void 0, source);
        }
        const sortIndex = $7b57b57eaf5a9648$var$_attrToNumber(colDef.sortIndex);
        if (sortIndex !== void 0) column.setSortIndex(sortIndex);
        const hide = $7b57b57eaf5a9648$var$_attrToBoolean(colDef.hide);
        if (hide !== void 0) column.setVisible(!hide, source);
        if (colDef.pinned !== void 0) column.setPinned(colDef.pinned);
    }
    findExistingColumn(newColDef, existingColsCopy) {
        if (!existingColsCopy) return void 0;
        for(let i = 0; i < existingColsCopy.length; i++){
            const def = existingColsCopy[i].getUserProvidedColDef();
            if (!def) continue;
            const newHasId = newColDef.colId != null;
            if (newHasId) {
                if (existingColsCopy[i].getId() === newColDef.colId) return {
                    idx: i,
                    column: existingColsCopy[i]
                };
                continue;
            }
            const newHasField = newColDef.field != null;
            if (newHasField) {
                if (def.field === newColDef.field) return {
                    idx: i,
                    column: existingColsCopy[i]
                };
                continue;
            }
            if (def === newColDef) return {
                idx: i,
                column: existingColsCopy[i]
            };
        }
        return void 0;
    }
    findExistingGroup(newGroupDef, existingGroups) {
        const newHasId = newGroupDef.groupId != null;
        if (!newHasId) return void 0;
        for(let i = 0; i < existingGroups.length; i++){
            const existingGroup = existingGroups[i];
            const existingDef = existingGroup.getColGroupDef();
            if (!existingDef) continue;
            if (existingGroup.getId() === newGroupDef.groupId) return {
                idx: i,
                group: existingGroup
            };
        }
        return void 0;
    }
    addColumnDefaultAndTypes(colDef, colId) {
        const res = {};
        const defaultColDef = this.gos.get("defaultColDef");
        $7b57b57eaf5a9648$export$8ade6bd474fcde42(res, defaultColDef, false, true);
        const columnType = this.updateColDefAndGetColumnType(res, colDef, colId);
        if (columnType) this.assignColumnTypes(columnType, res);
        $7b57b57eaf5a9648$export$8ade6bd474fcde42(res, colDef, false, true);
        const autoGroupColDef = this.gos.get("autoGroupColumnDef");
        const isSortingCoupled = this.gos.isColumnsSortingCoupledToGroup();
        if (colDef.rowGroup && autoGroupColDef && isSortingCoupled) $7b57b57eaf5a9648$export$8ade6bd474fcde42(res, {
            sort: autoGroupColDef.sort,
            initialSort: autoGroupColDef.initialSort
        }, false, true);
        this.dataTypeService?.validateColDef(res);
        return res;
    }
    updateColDefAndGetColumnType(colDef, userColDef, colId) {
        const dataTypeDefinitionColumnType = this.dataTypeService?.updateColDefAndGetColumnType(colDef, userColDef, colId);
        const columnTypes = userColDef.type ?? dataTypeDefinitionColumnType ?? colDef.type;
        colDef.type = columnTypes;
        return columnTypes ? $7b57b57eaf5a9648$var$convertColumnTypes(columnTypes) : void 0;
    }
    assignColumnTypes(typeKeys, colDefMerged) {
        if (!typeKeys.length) return;
        const allColumnTypes = Object.assign({}, $7b57b57eaf5a9648$var$DefaultColumnTypes);
        const userTypes = this.gos.get("columnTypes") || {};
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(userTypes, (key, value)=>{
            if (key in allColumnTypes) $7b57b57eaf5a9648$export$2cf41453020eef66(`the column type '${key}' is a default column type and cannot be overridden.`);
            else {
                const colType = value;
                if (colType.type) $7b57b57eaf5a9648$export$2cf41453020eef66(`Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.`);
                allColumnTypes[key] = value;
            }
        });
        typeKeys.forEach((t)=>{
            const typeColDef = allColumnTypes[t.trim()];
            if (typeColDef) $7b57b57eaf5a9648$export$8ade6bd474fcde42(colDefMerged, typeColDef, false, true);
            else $7b57b57eaf5a9648$export$2cf41453020eef66("colDef.type '" + t + "' does not correspond to defined gridOptions.columnTypes");
        });
    }
    // if object has children, we assume it's a group
    isColumnGroup(abstractColDef) {
        return abstractColDef.children !== void 0;
    }
};
function $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(parent, tree, callback) {
    if (!tree) return;
    for(let i = 0; i < tree.length; i++){
        const child = tree[i];
        if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(child)) $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(child, child.getChildren(), callback);
        callback(child, parent);
    }
}
// community-modules/core/src/columns/columnModel.ts
var $7b57b57eaf5a9648$export$c9dec256e4c9f340 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnModel";
        // if pivotMode is on, however pivot results are NOT shown if no pivot columns are set
        this.pivotMode = false;
        this.autoHeightActiveAtLeastOnce = false;
        this.ready = false;
        this.changeEventsDispatching = false;
        // when we're waiting for cell data types to be inferred, we need to defer column resizing
        this.shouldQueueResizeOperations = false;
        this.resizeOperationQueue = [];
    }
    wireBeans(beans) {
        this.context = beans.context;
        this.columnFactory = beans.columnFactory;
        this.columnSizeService = beans.columnSizeService;
        this.visibleColsService = beans.visibleColsService;
        this.columnViewportService = beans.columnViewportService;
        this.pivotResultColsService = beans.pivotResultColsService;
        this.columnAnimationService = beans.columnAnimationService;
        this.autoColService = beans.autoColService;
        this.valueCache = beans.valueCache;
        this.columnDefFactory = beans.columnDefFactory;
        this.columnApplyStateService = beans.columnApplyStateService;
        this.columnGroupStateService = beans.columnGroupStateService;
        this.eventDispatcher = beans.columnEventDispatcher;
        this.columnMoveService = beans.columnMoveService;
        this.columnAutosizeService = beans.columnAutosizeService;
        this.funcColsService = beans.funcColsService;
        this.quickFilterService = beans.quickFilterService;
        this.showRowGroupColsService = beans.showRowGroupColsService;
        this.environment = beans.environment;
    }
    postConstruct() {
        const pivotMode = this.gos.get("pivotMode");
        if (this.isPivotSettingAllowed(pivotMode)) this.pivotMode = pivotMode;
        this.addManagedPropertyListeners([
            "groupDisplayType",
            "treeData",
            "treeDataDisplayType",
            "groupHideOpenParents"
        ], (event)=>this.refreshAll($7b57b57eaf5a9648$var$convertSourceType(event.source)));
        this.addManagedPropertyListener("autoGroupColumnDef", (event)=>this.onAutoGroupColumnDefChanged($7b57b57eaf5a9648$var$convertSourceType(event.source)));
        this.addManagedPropertyListeners([
            "defaultColDef",
            "columnTypes",
            "suppressFieldDotNotation"
        ], (event)=>this.recreateColumnDefs($7b57b57eaf5a9648$var$convertSourceType(event.source)));
        this.addManagedPropertyListener("pivotMode", (event)=>this.setPivotMode(this.gos.get("pivotMode"), $7b57b57eaf5a9648$var$convertSourceType(event.source)));
        this.addManagedEventListeners({
            firstDataRendered: ()=>this.onFirstDataRendered()
        });
    }
    // called from SyncService, when grid has finished initialising
    createColsFromColDefs(colsPreviouslyExisted, source) {
        const dispatchEventsFunc = colsPreviouslyExisted ? this.columnApplyStateService.compareColumnStatesAndDispatchEvents(source) : void 0;
        this.valueCache.expire();
        const oldCols = this.colDefCols && this.colDefCols.list;
        const oldTree = this.colDefCols && this.colDefCols.tree;
        const newTree = this.columnFactory.createColumnTree(this.colDefs, true, oldTree, source);
        $7b57b57eaf5a9648$var$destroyColumnTree(this.context, this.colDefCols?.tree, newTree.columnTree);
        const tree = newTree.columnTree;
        const treeDepth = newTree.treeDept;
        const list = $7b57b57eaf5a9648$var$getColumnsFromTree(tree);
        const map = {};
        list.forEach((col)=>map[col.getId()] = col);
        this.colDefCols = {
            tree: tree,
            treeDepth: treeDepth,
            list: list,
            map: map
        };
        this.funcColsService.extractCols(source, oldCols);
        this.ready = true;
        this.refreshCols();
        const maintainColOrder = colsPreviouslyExisted && !this.showingPivotResult && !this.gos.get("maintainColumnOrder");
        if (maintainColOrder) this.orderColsLikeColDefCols();
        this.visibleColsService.refresh(source);
        this.columnViewportService.checkViewportColumns();
        this.eventDispatcher.everythingChanged(source);
        if (dispatchEventsFunc) {
            this.changeEventsDispatching = true;
            dispatchEventsFunc();
            this.changeEventsDispatching = false;
        }
        this.eventDispatcher.newColumnsLoaded(source);
        if (source === "gridInitializing") this.columnSizeService.applyAutosizeStrategy();
    }
    // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
    // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
    // setPivotMode, applyColumnState,
    // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
    // pivotResultColsService.setPivotResultCols
    refreshCols() {
        if (!this.colDefCols) return;
        const prevColTree = this.cols?.tree;
        this.saveColOrder();
        this.selectCols();
        this.createAutoCols();
        this.addAutoCols();
        this.restoreColOrder();
        this.positionLockedCols();
        this.showRowGroupColsService?.refresh();
        this.quickFilterService?.refreshQuickFilterCols();
        this.setColSpanActive();
        this.setAutoHeightActive();
        this.visibleColsService.clear();
        this.columnViewportService.clear();
        const dispatchChangedEvent = !$7b57b57eaf5a9648$export$893967cdb9833fdd(prevColTree, this.cols.tree);
        if (dispatchChangedEvent) this.eventDispatcher.gridColumns();
    }
    selectCols() {
        const pivotResultCols = this.pivotResultColsService.getPivotResultCols();
        this.showingPivotResult = pivotResultCols != null;
        if (pivotResultCols) {
            const { map: map , list: list , tree: tree , treeDepth: treeDepth  } = pivotResultCols;
            this.cols = {
                list: list.slice(),
                map: {
                    ...map
                },
                tree: tree.slice(),
                treeDepth: treeDepth
            };
            const hasSameColumns = pivotResultCols.list.some((col)=>this.cols?.map[col.getColId()] !== void 0);
            if (!hasSameColumns) this.lastPivotOrder = null;
        } else {
            const { map: map , list: list , tree: tree , treeDepth: treeDepth  } = this.colDefCols;
            this.cols = {
                list: list.slice(),
                map: {
                    ...map
                },
                tree: tree.slice(),
                treeDepth: treeDepth
            };
        }
    }
    getColsToShow() {
        const showAutoGroupAndValuesOnly = this.isPivotMode() && !this.isShowingPivotResult();
        const valueColumns = this.funcColsService.getValueColumns();
        const res = this.cols.list.filter((col)=>{
            const isAutoGroupCol = $7b57b57eaf5a9648$var$isColumnGroupAutoCol(col);
            if (showAutoGroupAndValuesOnly) {
                const isValueCol = valueColumns && $7b57b57eaf5a9648$export$fccf016a6caa651d(valueColumns, col);
                return isAutoGroupCol || isValueCol;
            } else return isAutoGroupCol || col.isVisible();
        });
        return res;
    }
    addAutoCols() {
        if (this.autoCols == null) return;
        this.cols.list = this.autoCols.list.concat(this.cols.list);
        this.cols.tree = this.autoCols.tree.concat(this.cols.tree);
        $7b57b57eaf5a9648$var$updateColsMap(this.cols);
    }
    createAutoCols() {
        const groupFullWidthRow = this.gos.isGroupUseEntireRow(this.pivotMode);
        const suppressAutoColumn = this.pivotMode ? this.gos.get("pivotSuppressAutoColumn") : this.isSuppressAutoCol();
        const rowGroupCols = this.funcColsService.getRowGroupColumns();
        const groupingActive = rowGroupCols.length > 0 || this.gos.get("treeData");
        const noAutoCols = !groupingActive || suppressAutoColumn || groupFullWidthRow;
        const destroyPrevious = ()=>{
            if (this.autoCols) {
                $7b57b57eaf5a9648$var$destroyColumnTree(this.context, this.autoCols.tree);
                this.autoCols = null;
            }
        };
        if (noAutoCols || !this.autoColService) {
            destroyPrevious();
            return;
        }
        const list = this.autoColService.createAutoCols(rowGroupCols) ?? [];
        const autoColsSame = $7b57b57eaf5a9648$var$areColIdsEqual(list, this.autoCols?.list || null);
        const newTreeDepth = this.cols.treeDepth;
        const oldTreeDepth = this.autoCols ? this.autoCols.treeDepth : -1;
        const treeDeptSame = oldTreeDepth == newTreeDepth;
        if (autoColsSame && treeDeptSame) return;
        destroyPrevious();
        const [tree, treeDepth] = this.columnFactory.createForAutoGroups(list, this.cols?.tree);
        this.autoCols = {
            list: list,
            tree: tree,
            treeDepth: treeDepth,
            map: {}
        };
        const putAutocolsFirstInList = (cols)=>{
            if (!cols) return null;
            const colsFiltered = cols.filter((col)=>!$7b57b57eaf5a9648$var$isColumnGroupAutoCol(col));
            return [
                ...list,
                ...colsFiltered
            ];
        };
        this.lastOrder = putAutocolsFirstInList(this.lastOrder);
        this.lastPivotOrder = putAutocolsFirstInList(this.lastPivotOrder);
    }
    // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
    refreshAll(source) {
        if (!this.isReady()) return;
        this.refreshCols();
        this.visibleColsService.refresh(source);
    }
    setColsVisible(keys, visible = false, source) {
        this.columnApplyStateService.applyColumnState({
            state: keys.map((key)=>({
                    colId: typeof key === "string" ? key : key.getColId(),
                    hide: !visible
                }))
        }, source);
    }
    setColsPinned(keys, pinned, source) {
        if (!this.cols) return;
        if ($7b57b57eaf5a9648$export$c15f339f10321853(keys)) return;
        if (this.gos.isDomLayout("print")) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`Changing the column pinning status is not allowed with domLayout='print'`);
            return;
        }
        this.columnAnimationService.start();
        let actualPinned;
        if (pinned === true || pinned === "left") actualPinned = "left";
        else if (pinned === "right") actualPinned = "right";
        else actualPinned = null;
        const updatedCols = [];
        keys.forEach((key)=>{
            if (!key) return;
            const column = this.getCol(key);
            if (!column) return;
            if (column.getPinned() !== actualPinned) {
                column.setPinned(actualPinned);
                updatedCols.push(column);
            }
        });
        if (updatedCols.length) {
            this.visibleColsService.refresh(source);
            this.eventDispatcher.columnPinned(updatedCols, source);
        }
        this.columnAnimationService.finish();
    }
    // called by headerRenderer - when a header is opened or closed
    setColumnGroupOpened(key, newValue, source) {
        let keyAsString;
        if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(key)) keyAsString = key.getId();
        else keyAsString = key || "";
        this.columnGroupStateService.setColumnGroupState([
            {
                groupId: keyAsString,
                open: newValue
            }
        ], source);
    }
    getProvidedColGroup(key) {
        let res = null;
        $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(null, this.cols?.tree, (node)=>{
            if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(node)) {
                if (node.getId() === key) res = node;
            }
        });
        return res;
    }
    isColGroupLocked(column) {
        const groupLockGroupColumns = this.gos.get("groupLockGroupColumns");
        if (!column.isRowGroupActive() || groupLockGroupColumns === 0) return false;
        if (groupLockGroupColumns === -1) return true;
        const rowGroupCols = this.funcColsService.getRowGroupColumns();
        const colIndex = rowGroupCols.findIndex((groupCol)=>groupCol.getColId() === column.getColId());
        return groupLockGroupColumns > colIndex;
    }
    isSuppressAutoCol() {
        const groupDisplayType = this.gos.get("groupDisplayType");
        const isCustomRowGroups = groupDisplayType === "custom";
        if (isCustomRowGroups) return true;
        const treeDataDisplayType = this.gos.get("treeDataDisplayType");
        return treeDataDisplayType === "custom";
    }
    setAutoHeightActive() {
        this.autoHeightActive = this.cols.list.some((col)=>col.isAutoHeight());
        if (this.autoHeightActive) {
            this.autoHeightActiveAtLeastOnce = true;
            const supportedRowModel = this.gos.isRowModelType("clientSide") || this.gos.isRowModelType("serverSide");
            if (!supportedRowModel) $7b57b57eaf5a9648$export$2cf41453020eef66("autoHeight columns only work with Client Side Row Model and Server Side Row Model.");
        }
    }
    restoreColOrder() {
        const lastOrder = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
        if (!lastOrder) return;
        const lastOrderMapped = new Map(lastOrder.map((col, index)=>[
                col,
                index
            ]));
        const noColsFound = !this.cols.list.some((col)=>lastOrderMapped.has(col));
        if (noColsFound) return;
        const colsMap = new Map(this.cols.list.map((col)=>[
                col,
                true
            ]));
        const lastOrderFiltered = lastOrder.filter((col)=>colsMap.has(col));
        const lastOrderFilteredMap = new Map(lastOrderFiltered.map((col)=>[
                col,
                true
            ]));
        const missingFromLastOrder = this.cols.list.filter((col)=>!lastOrderFilteredMap.has(col));
        const res = lastOrderFiltered.slice();
        missingFromLastOrder.forEach((newCol)=>{
            let parent = newCol.getOriginalParent();
            if (!parent) {
                res.push(newCol);
                return;
            }
            const siblings = [];
            while(!siblings.length && parent){
                const leafCols = parent.getLeafColumns();
                leafCols.forEach((leafCol)=>{
                    const presentInNewCols = res.indexOf(leafCol) >= 0;
                    const notYetInSiblings = siblings.indexOf(leafCol) < 0;
                    if (presentInNewCols && notYetInSiblings) siblings.push(leafCol);
                });
                parent = parent.getOriginalParent();
            }
            if (!siblings.length) {
                res.push(newCol);
                return;
            }
            const indexes = siblings.map((col)=>res.indexOf(col));
            const lastIndex = Math.max(...indexes);
            $7b57b57eaf5a9648$export$820a25988ad46b8d(res, newCol, lastIndex + 1);
        });
        this.cols.list = res;
    }
    orderColsLikeColDefCols() {
        if (!this.colDefCols || !this.cols) return;
        const colsOrdered = this.colDefCols.list.filter((col)=>this.cols.list.indexOf(col) >= 0);
        const otherCols = this.cols.list.filter((col)=>colsOrdered.indexOf(col) < 0);
        this.cols.list = [
            ...otherCols,
            ...colsOrdered
        ];
        this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list);
    }
    sortColsLikeKeys(colIds) {
        if (this.cols == null) return;
        let newOrder = [];
        const processedColIds = {};
        colIds.forEach((colId)=>{
            if (processedColIds[colId]) return;
            const col = this.cols.map[colId];
            if (col) {
                newOrder.push(col);
                processedColIds[colId] = true;
            }
        });
        let autoGroupInsertIndex = 0;
        this.cols.list.forEach((col)=>{
            const colId = col.getColId();
            const alreadyProcessed = processedColIds[colId] != null;
            if (alreadyProcessed) return;
            const isAutoGroupCol = colId.startsWith($7b57b57eaf5a9648$export$a7016588c430dba6);
            if (isAutoGroupCol) $7b57b57eaf5a9648$export$820a25988ad46b8d(newOrder, col, autoGroupInsertIndex++);
            else newOrder.push(col);
        });
        newOrder = this.columnMoveService.placeLockedColumns(newOrder);
        if (!this.columnMoveService.doesMovePassMarryChildren(newOrder)) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("Applying column order broke a group where columns should be married together. Applying new order has been discarded.");
            return;
        }
        this.cols.list = newOrder;
    }
    // returns the provided cols sorted in same order as they appear in this.cols, eg if this.cols
    // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]
    sortColsLikeCols(cols) {
        if (!cols || cols.length <= 1) return;
        const notAllColsPresent = cols.filter((c)=>this.cols.list.indexOf(c) < 0).length > 0;
        if (notAllColsPresent) return;
        cols.sort((a, b)=>{
            const indexA = this.cols.list.indexOf(a);
            const indexB = this.cols.list.indexOf(b);
            return indexA - indexB;
        });
    }
    resetColDefIntoCol(column, source) {
        const userColDef = column.getUserProvidedColDef();
        if (!userColDef) return false;
        const newColDef = this.columnFactory.addColumnDefaultAndTypes(userColDef, column.getColId());
        column.setColDef(newColDef, userColDef, source);
        return true;
    }
    queueResizeOperations() {
        this.shouldQueueResizeOperations = true;
    }
    isShouldQueueResizeOperations() {
        return this.shouldQueueResizeOperations;
    }
    processResizeOperations() {
        this.shouldQueueResizeOperations = false;
        this.resizeOperationQueue.forEach((resizeOperation)=>resizeOperation());
        this.resizeOperationQueue = [];
    }
    pushResizeOperation(func) {
        this.resizeOperationQueue.push(func);
    }
    moveInCols(movedColumns, toIndex, source) {
        $7b57b57eaf5a9648$var$_moveInArray(this.cols?.list, movedColumns, toIndex);
        this.visibleColsService.refresh(source);
    }
    positionLockedCols() {
        this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list);
    }
    saveColOrder() {
        if (this.showingPivotResult) this.lastPivotOrder = this.cols?.list;
        else this.lastOrder = this.cols?.list;
    }
    getColumnDefs() {
        if (!this.colDefCols) return;
        const cols = this.colDefCols.list.slice();
        if (this.showingPivotResult) cols.sort((a, b)=>this.lastOrder.indexOf(a) - this.lastOrder.indexOf(b));
        else if (this.lastOrder) cols.sort((a, b)=>this.cols.list.indexOf(a) - this.cols.list.indexOf(b));
        const rowGroupColumns = this.funcColsService.getRowGroupColumns();
        const pivotColumns = this.funcColsService.getPivotColumns();
        return this.columnDefFactory.buildColumnDefs(cols, rowGroupColumns, pivotColumns);
    }
    isShowingPivotResult() {
        return this.showingPivotResult;
    }
    // called by clientSideRowModel.refreshModel
    isChangeEventsDispatching() {
        return this.changeEventsDispatching;
    }
    isColSpanActive() {
        return this.colSpanActive;
    }
    // used by Column Tool Panel
    isProvidedColGroupsPresent() {
        return this.colDefCols?.treeDepth > 0;
    }
    setColSpanActive() {
        this.colSpanActive = this.cols.list.some((col)=>col.getColDef().colSpan != null);
    }
    isAutoRowHeightActive() {
        return this.autoHeightActive;
    }
    wasAutoRowHeightEverActive() {
        return this.autoHeightActiveAtLeastOnce;
    }
    // + gridPanel -> for resizing the body and setting top margin
    getHeaderRowCount() {
        return this.cols ? this.cols.treeDepth + 1 : -1;
    }
    isReady() {
        return this.ready;
    }
    isPivotMode() {
        return this.pivotMode;
    }
    setPivotMode(pivotMode, source) {
        if (pivotMode === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) return;
        this.pivotMode = pivotMode;
        if (!this.ready) return;
        this.refreshCols();
        this.visibleColsService.refresh(source);
        this.eventDispatcher.pivotModeChanged();
    }
    isPivotSettingAllowed(pivot) {
        if (pivot && this.gos.get("treeData")) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("Pivot mode not available with treeData.");
            return false;
        }
        return true;
    }
    // + clientSideRowModel
    isPivotActive() {
        const pivotColumns = this.funcColsService.getPivotColumns();
        return this.pivotMode && !$7b57b57eaf5a9648$export$c15f339f10321853(pivotColumns);
    }
    // called when dataTypes change
    recreateColumnDefs(source) {
        if (!this.cols) return;
        if (this.autoCols) this.autoColService.updateAutoCols(this.autoCols.list, source);
        this.createColsFromColDefs(true, source);
    }
    setColumnDefs(columnDefs, source) {
        const colsPreviouslyExisted = !!this.colDefs;
        this.colDefs = columnDefs;
        this.createColsFromColDefs(colsPreviouslyExisted, source);
    }
    destroy() {
        $7b57b57eaf5a9648$var$destroyColumnTree(this.context, this.colDefCols?.tree);
        $7b57b57eaf5a9648$var$destroyColumnTree(this.context, this.autoCols?.tree);
        super.destroy();
    }
    getColTree() {
        return this.cols.tree;
    }
    // + columnSelectPanel
    getColDefColTree() {
        return this.colDefCols.tree;
    }
    // + clientSideRowController -> sorting, building quick filter text
    // + headerRenderer -> sorting (clearing icon)
    getColDefCols() {
        return this.colDefCols?.list ? this.colDefCols.list : null;
    }
    // + moveColumnController
    getCols() {
        return this.cols?.list ?? [];
    }
    // returns colDefCols, pivotResultCols and autoCols
    getAllCols() {
        const pivotResultCols = this.pivotResultColsService.getPivotResultCols();
        const pivotResultColsList = pivotResultCols?.list;
        return [].concat(...[
            this.colDefCols?.list || [],
            this.autoCols?.list || [],
            pivotResultColsList || []
        ]);
    }
    getColsForKeys(keys) {
        if (!keys) return [];
        const res = keys.map((key)=>this.getCol(key)).filter((col)=>col != null);
        return res;
    }
    getColDefCol(key) {
        if (!this.colDefCols?.list) return null;
        return this.getColFromCollection(key, this.colDefCols);
    }
    getCol(key) {
        if (key == null) return null;
        return this.getColFromCollection(key, this.cols);
    }
    getColFromCollection(key, cols) {
        if (cols == null) return null;
        const { map: map , list: list  } = cols;
        if (typeof key == "string" && map[key]) return map[key];
        for(let i = 0; i < list.length; i++){
            if ($7b57b57eaf5a9648$var$columnsMatch(list[i], key)) return list[i];
        }
        return this.getAutoCol(key);
    }
    getAutoCol(key) {
        if (this.autoCols == null) return null;
        return this.autoCols.list.find((groupCol)=>$7b57b57eaf5a9648$var$columnsMatch(groupCol, key)) || null;
    }
    getAutoCols() {
        return this.autoCols?.list || null;
    }
    setColHeaderHeight(col, height) {
        const changed = col.setAutoHeaderHeight(height);
        if (changed) this.eventDispatcher.headerHeight(col);
    }
    getColumnGroupHeaderRowHeight() {
        if (this.isPivotMode()) return this.getPivotGroupHeaderHeight();
        return this.getGroupHeaderHeight();
    }
    getColumnHeaderRowHeight() {
        const defaultHeight = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight();
        const allDisplayedCols = this.visibleColsService.getAllCols();
        const displayedHeights = allDisplayedCols.filter((col)=>col.isAutoHeaderHeight()).map((col)=>col.getAutoHeaderHeight() || 0);
        return Math.max(defaultHeight, ...displayedHeights);
    }
    getHeaderHeight() {
        return this.gos.get("headerHeight") ?? this.environment.getDefaultHeaderHeight();
    }
    getFloatingFiltersHeight() {
        return this.gos.get("floatingFiltersHeight") ?? this.getHeaderHeight();
    }
    getGroupHeaderHeight() {
        return this.gos.get("groupHeaderHeight") ?? this.getHeaderHeight();
    }
    getPivotHeaderHeight() {
        return this.gos.get("pivotHeaderHeight") ?? this.getHeaderHeight();
    }
    getPivotGroupHeaderHeight() {
        return this.gos.get("pivotGroupHeaderHeight") ?? this.getGroupHeaderHeight();
    }
    onFirstDataRendered() {
        const autoSizeStrategy = this.gos.get("autoSizeStrategy");
        if (autoSizeStrategy?.type !== "fitCellContents") return;
        const { colIds: columns , skipHeader: skipHeader  } = autoSizeStrategy;
        setTimeout(()=>{
            if (columns) this.columnAutosizeService.autoSizeCols({
                colKeys: columns,
                skipHeader: skipHeader,
                source: "autosizeColumns"
            });
            else this.columnAutosizeService.autoSizeAllColumns("autosizeColumns", skipHeader);
        });
    }
    onAutoGroupColumnDefChanged(source) {
        if (this.autoCols) this.autoColService.updateAutoCols(this.autoCols.list, source);
    }
};
function $7b57b57eaf5a9648$var$convertSourceType(source) {
    return source === "gridOptionsUpdated" ? "gridOptionsChanged" : source;
}
function $7b57b57eaf5a9648$var$updateColsMap(cols) {
    cols.map = {};
    cols.list.forEach((col)=>cols.map[col.getId()] = col);
}
function $7b57b57eaf5a9648$var$columnsMatch(column, key) {
    const columnMatches = column === key;
    const colDefMatches = column.getColDef() === key;
    const idMatches = column.getColId() == key;
    return columnMatches || colDefMatches || idMatches;
}
function $7b57b57eaf5a9648$var$areColIdsEqual(colsA, colsB) {
    return $7b57b57eaf5a9648$export$893967cdb9833fdd(colsA, colsB, (a, b)=>a.getColId() === b.getColId());
}
// community-modules/core/src/columns/columnAutosizeService.ts
var $7b57b57eaf5a9648$export$2c779e47c90a0605 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnAutosizeService";
        this.timesDelayed = 0;
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
        this.animationFrameService = beans.animationFrameService;
        this.autoWidthCalculator = beans.autoWidthCalculator;
        this.eventDispatcher = beans.columnEventDispatcher;
        this.ctrlsService = beans.ctrlsService;
        this.renderStatusService = beans.renderStatusService;
    }
    autoSizeCols(params) {
        if (this.columnModel.isShouldQueueResizeOperations()) {
            this.columnModel.pushResizeOperation(()=>this.autoSizeCols(params));
            return;
        }
        const { colKeys: colKeys , skipHeader: skipHeader , skipHeaderGroups: skipHeaderGroups , stopAtGroup: stopAtGroup , source: source = "api"  } = params;
        this.animationFrameService.flushAllFrames();
        if (this.timesDelayed < 5 && this.renderStatusService && !this.renderStatusService.areHeaderCellsRendered()) {
            this.timesDelayed++;
            setTimeout(()=>this.autoSizeCols(params));
            return;
        }
        this.timesDelayed = 0;
        const columnsAutosized = [];
        let changesThisTimeAround = -1;
        const shouldSkipHeader = skipHeader != null ? skipHeader : this.gos.get("skipHeaderOnAutoSize");
        const shouldSkipHeaderGroups = skipHeaderGroups != null ? skipHeaderGroups : shouldSkipHeader;
        while(changesThisTimeAround !== 0){
            changesThisTimeAround = 0;
            const updatedColumns = [];
            colKeys.forEach((key)=>{
                if (!key) return;
                const column = this.columnModel.getCol(key);
                if (!column) return;
                if (columnsAutosized.indexOf(column) >= 0) return;
                const preferredWidth = this.autoWidthCalculator.getPreferredWidthForColumn(column, shouldSkipHeader);
                if (preferredWidth > 0) {
                    const newWidth = this.normaliseColumnWidth(column, preferredWidth);
                    column.setActualWidth(newWidth, source);
                    columnsAutosized.push(column);
                    changesThisTimeAround++;
                }
                updatedColumns.push(column);
            });
            if (!updatedColumns.length) continue;
            this.visibleColsService.refresh(source);
        }
        if (!shouldSkipHeaderGroups) this.autoSizeColumnGroupsByColumns(colKeys, source, stopAtGroup);
        this.eventDispatcher.columnResized(columnsAutosized, true, "autosizeColumns");
    }
    autoSizeColumn(key, source, skipHeader) {
        if (key) this.autoSizeCols({
            colKeys: [
                key
            ],
            skipHeader: skipHeader,
            skipHeaderGroups: true,
            source: source
        });
    }
    autoSizeColumnGroupsByColumns(keys, source, stopAtGroup) {
        const columnGroups = /* @__PURE__ */ new Set();
        const columns = this.columnModel.getColsForKeys(keys);
        columns.forEach((col)=>{
            let parent = col.getParent();
            while(parent && parent != stopAtGroup){
                if (!parent.isPadding()) columnGroups.add(parent);
                parent = parent.getParent();
            }
        });
        let headerGroupCtrl;
        const resizedColumns = [];
        for (const columnGroup of columnGroups){
            for (const headerContainerCtrl of this.ctrlsService.getHeaderRowContainerCtrls()){
                headerGroupCtrl = headerContainerCtrl.getHeaderCtrlForColumn(columnGroup);
                if (headerGroupCtrl) break;
            }
            if (headerGroupCtrl) headerGroupCtrl.resizeLeafColumnsToFit(source);
        }
        return resizedColumns;
    }
    autoSizeAllColumns(source, skipHeader) {
        if (this.columnModel.isShouldQueueResizeOperations()) {
            this.columnModel.pushResizeOperation(()=>this.autoSizeAllColumns(source, skipHeader));
            return;
        }
        const allDisplayedColumns = this.visibleColsService.getAllCols();
        this.autoSizeCols({
            colKeys: allDisplayedColumns,
            skipHeader: skipHeader,
            source: source
        });
    }
    // returns the width we can set to this col, taking into consideration min and max widths
    normaliseColumnWidth(column, newWidth) {
        const minWidth = column.getMinWidth();
        if (newWidth < minWidth) newWidth = minWidth;
        const maxWidth = column.getMaxWidth();
        if (column.isGreaterThanMax(newWidth)) newWidth = maxWidth;
        return newWidth;
    }
};
// community-modules/core/src/columns/funcColsService.ts
var $7b57b57eaf5a9648$export$5d8918e6b11a0531 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "funcColsService";
        this.rowGroupCols = [];
        this.valueCols = [];
        this.pivotCols = [];
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.eventDispatcher = beans.columnEventDispatcher;
        this.aggFuncService = beans.aggFuncService;
        this.visibleColsService = beans.visibleColsService;
    }
    getModifyColumnsNoEventsCallbacks() {
        return {
            addGroupCol: (column)=>this.rowGroupCols.push(column),
            removeGroupCol: (column)=>$7b57b57eaf5a9648$export$83a881c8b5120679(this.rowGroupCols, column),
            addPivotCol: (column)=>this.pivotCols.push(column),
            removePivotCol: (column)=>$7b57b57eaf5a9648$export$83a881c8b5120679(this.pivotCols, column),
            addValueCol: (column)=>this.valueCols.push(column),
            removeValueCol: (column)=>$7b57b57eaf5a9648$export$83a881c8b5120679(this.valueCols, column)
        };
    }
    getSourceColumnsForGroupColumn(groupCol) {
        const sourceColumnId = groupCol.getColDef().showRowGroup;
        if (!sourceColumnId) return null;
        if (sourceColumnId === true) return this.rowGroupCols.slice(0);
        const column = this.columnModel.getColDefCol(sourceColumnId);
        return column ? [
            column
        ] : null;
    }
    sortRowGroupColumns(compareFn) {
        this.rowGroupCols.sort(compareFn);
    }
    sortPivotColumns(compareFn) {
        this.pivotCols.sort(compareFn);
    }
    // + rowController
    getValueColumns() {
        return this.valueCols ? this.valueCols : [];
    }
    // + rowController
    getPivotColumns() {
        return this.pivotCols ? this.pivotCols : [];
    }
    // + toolPanel
    getRowGroupColumns() {
        return this.rowGroupCols ? this.rowGroupCols : [];
    }
    isRowGroupEmpty() {
        return $7b57b57eaf5a9648$export$c15f339f10321853(this.rowGroupCols);
    }
    setColumnAggFunc(key, aggFunc, source) {
        if (!key) return;
        const column = this.columnModel.getColDefCol(key);
        if (!column) return;
        column.setAggFunc(aggFunc);
        this.eventDispatcher.columnChanged("columnValueChanged", [
            column
        ], source);
    }
    setRowGroupColumns(colKeys, source) {
        this.setColList(colKeys, this.rowGroupCols, "columnRowGroupChanged", true, true, (added, column)=>this.setRowGroupActive(added, column, source), source);
    }
    setRowGroupActive(active, column, source) {
        if (active === column.isRowGroupActive()) return;
        column.setRowGroupActive(active, source);
        if (active && !this.gos.get("suppressRowGroupHidesColumns")) this.columnModel.setColsVisible([
            column
        ], false, source);
        if (!active && !this.gos.get("suppressMakeColumnVisibleAfterUnGroup")) this.columnModel.setColsVisible([
            column
        ], true, source);
    }
    addRowGroupColumns(keys, source) {
        this.updateColList(keys, this.rowGroupCols, true, true, (column)=>this.setRowGroupActive(true, column, source), "columnRowGroupChanged", source);
    }
    removeRowGroupColumns(keys, source) {
        this.updateColList(keys, this.rowGroupCols, false, true, (column)=>this.setRowGroupActive(false, column, source), "columnRowGroupChanged", source);
    }
    addPivotColumns(keys, source) {
        this.updateColList(keys, this.pivotCols, true, false, (column)=>column.setPivotActive(true, source), "columnPivotChanged", source);
    }
    setPivotColumns(colKeys, source) {
        this.setColList(colKeys, this.pivotCols, "columnPivotChanged", true, false, (added, column)=>{
            column.setPivotActive(added, source);
        }, source);
    }
    removePivotColumns(keys, source) {
        this.updateColList(keys, this.pivotCols, false, false, (column)=>column.setPivotActive(false, source), "columnPivotChanged", source);
    }
    setValueColumns(colKeys, source) {
        this.setColList(colKeys, this.valueCols, "columnValueChanged", false, false, (added, column)=>this.setValueActive(added, column, source), source);
    }
    setValueActive(active, column, source) {
        if (active === column.isValueActive()) return;
        column.setValueActive(active, source);
        if (active && !column.getAggFunc() && this.aggFuncService) {
            const initialAggFunc = this.aggFuncService.getDefaultAggFunc(column);
            column.setAggFunc(initialAggFunc);
        }
    }
    addValueColumns(keys, source) {
        this.updateColList(keys, this.valueCols, true, false, (column)=>this.setValueActive(true, column, source), "columnValueChanged", source);
    }
    removeValueColumns(keys, source) {
        this.updateColList(keys, this.valueCols, false, false, (column)=>this.setValueActive(false, column, source), "columnValueChanged", source);
    }
    moveRowGroupColumn(fromIndex, toIndex, source) {
        if (this.isRowGroupEmpty()) return;
        const column = this.rowGroupCols[fromIndex];
        const impactedColumns = this.rowGroupCols.slice(fromIndex, toIndex);
        this.rowGroupCols.splice(fromIndex, 1);
        this.rowGroupCols.splice(toIndex, 0, column);
        this.eventDispatcher.rowGroupChanged(impactedColumns, source);
    }
    setColList(colKeys, masterList, eventName, detectOrderChange, autoGroupsNeedBuilding, columnCallback, source) {
        const gridColumns = this.columnModel.getCols();
        if ($7b57b57eaf5a9648$export$c15f339f10321853(gridColumns)) return;
        const changes = /* @__PURE__ */ new Map();
        masterList.forEach((col, idx)=>changes.set(col, idx));
        masterList.length = 0;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(colKeys)) colKeys.forEach((key)=>{
            const column = this.columnModel.getColDefCol(key);
            if (column) masterList.push(column);
        });
        masterList.forEach((col, idx)=>{
            const oldIndex = changes.get(col);
            if (oldIndex === void 0) {
                changes.set(col, 0);
                return;
            }
            if (detectOrderChange && oldIndex !== idx) return;
            changes.delete(col);
        });
        const primaryCols = this.columnModel.getColDefCols();
        (primaryCols || []).forEach((column)=>{
            const added = masterList.indexOf(column) >= 0;
            columnCallback(added, column);
        });
        autoGroupsNeedBuilding && this.columnModel.refreshCols();
        this.visibleColsService.refresh(source);
        this.eventDispatcher.columnChanged(eventName, [
            ...changes.keys()
        ], source);
    }
    updateColList(keys, masterList, actionIsAdd, autoGroupsNeedBuilding, columnCallback, eventType, source) {
        if (!keys || $7b57b57eaf5a9648$export$c15f339f10321853(keys)) return;
        let atLeastOne = false;
        keys.forEach((key)=>{
            if (!key) return;
            const columnToAdd = this.columnModel.getColDefCol(key);
            if (!columnToAdd) return;
            if (actionIsAdd) {
                if (masterList.indexOf(columnToAdd) >= 0) return;
                masterList.push(columnToAdd);
            } else {
                if (masterList.indexOf(columnToAdd) < 0) return;
                $7b57b57eaf5a9648$export$83a881c8b5120679(masterList, columnToAdd);
            }
            columnCallback(columnToAdd);
            atLeastOne = true;
        });
        if (!atLeastOne) return;
        if (autoGroupsNeedBuilding) this.columnModel.refreshCols();
        this.visibleColsService.refresh(source);
        this.eventDispatcher.genericColumnEvent(eventType, masterList, source);
    }
    extractCols(source, oldProvidedCols) {
        this.extractRowGroupCols(source, oldProvidedCols);
        this.extractPivotCols(source, oldProvidedCols);
        this.extractValueCols(source, oldProvidedCols);
    }
    extractValueCols(source, oldProvidedCols) {
        this.valueCols = this.extractColsCommon(oldProvidedCols, this.valueCols, (col, flag)=>col.setValueActive(flag, source), // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
        ()=>void 0, ()=>void 0, // aggFunc is a string, so return it's existence
        (colDef)=>{
            const aggFunc = colDef.aggFunc;
            if (aggFunc === null || aggFunc === "") return null;
            if (aggFunc === void 0) return;
            return !!aggFunc;
        }, (colDef)=>{
            return colDef.initialAggFunc != null && colDef.initialAggFunc != "";
        });
        this.valueCols.forEach((col)=>{
            const colDef = col.getColDef();
            if (colDef.aggFunc != null && colDef.aggFunc != "") col.setAggFunc(colDef.aggFunc);
            else if (!col.getAggFunc()) col.setAggFunc(colDef.initialAggFunc);
        });
    }
    extractRowGroupCols(source, oldProvidedCols) {
        this.rowGroupCols = this.extractColsCommon(oldProvidedCols, this.rowGroupCols, (col, flag)=>col.setRowGroupActive(flag, source), (colDef)=>colDef.rowGroupIndex, (colDef)=>colDef.initialRowGroupIndex, (colDef)=>colDef.rowGroup, (colDef)=>colDef.initialRowGroup);
    }
    extractPivotCols(source, oldProvidedCols) {
        this.pivotCols = this.extractColsCommon(oldProvidedCols, this.pivotCols, (col, flag)=>col.setPivotActive(flag, source), (colDef)=>colDef.pivotIndex, (colDef)=>colDef.initialPivotIndex, (colDef)=>colDef.pivot, (colDef)=>colDef.initialPivot);
    }
    extractColsCommon(oldProvidedCols = [], previousCols = [], setFlagFunc, getIndexFunc, getInitialIndexFunc, getValueFunc, getInitialValueFunc) {
        const colsWithIndex = [];
        const colsWithValue = [];
        const primaryCols = this.columnModel.getColDefCols() || [];
        primaryCols.forEach((col)=>{
            const colIsNew = oldProvidedCols.indexOf(col) < 0;
            const colDef = col.getColDef();
            const value = $7b57b57eaf5a9648$var$_attrToBoolean(getValueFunc(colDef));
            const initialValue = $7b57b57eaf5a9648$var$_attrToBoolean(getInitialValueFunc(colDef));
            const index = $7b57b57eaf5a9648$var$_attrToNumber(getIndexFunc(colDef));
            const initialIndex = $7b57b57eaf5a9648$var$_attrToNumber(getInitialIndexFunc(colDef));
            let include;
            const valuePresent = value !== void 0;
            const indexPresent = index !== void 0;
            const initialValuePresent = initialValue !== void 0;
            const initialIndexPresent = initialIndex !== void 0;
            if (valuePresent) include = value;
            else if (indexPresent) {
                if (index === null) include = false;
                else include = index >= 0;
            } else if (colIsNew) {
                if (initialValuePresent) include = initialValue;
                else if (initialIndexPresent) include = initialIndex != null && initialIndex >= 0;
                else include = false;
            } else include = previousCols.indexOf(col) >= 0;
            if (include) {
                const useIndex = colIsNew ? index != null || initialIndex != null : index != null;
                useIndex ? colsWithIndex.push(col) : colsWithValue.push(col);
            }
        });
        const getIndexForCol = (col)=>{
            const index = getIndexFunc(col.getColDef());
            const defaultIndex = getInitialIndexFunc(col.getColDef());
            return index != null ? index : defaultIndex;
        };
        colsWithIndex.sort((colA, colB)=>{
            const indexA = getIndexForCol(colA);
            const indexB = getIndexForCol(colB);
            if (indexA === indexB) return 0;
            if (indexA < indexB) return -1;
            return 1;
        });
        const res = [].concat(colsWithIndex);
        previousCols.forEach((col)=>{
            if (colsWithValue.indexOf(col) >= 0) res.push(col);
        });
        colsWithValue.forEach((col)=>{
            if (res.indexOf(col) < 0) res.push(col);
        });
        previousCols.forEach((col)=>{
            if (res.indexOf(col) < 0) setFlagFunc(col, false);
        });
        res.forEach((col)=>{
            if (previousCols.indexOf(col) < 0) setFlagFunc(col, true);
        });
        return res;
    }
    generateColumnStateForRowGroupAndPivotIndexes(updatedRowGroupColumnState, updatedPivotColumnState) {
        const existingColumnStateUpdates = {};
        const orderColumns = (updatedColumnState, colList, enableProp, initialEnableProp, indexProp, initialIndexProp)=>{
            const primaryCols = this.columnModel.getColDefCols();
            if (!colList.length || !primaryCols) return [];
            const updatedColIdArray = Object.keys(updatedColumnState);
            const updatedColIds = new Set(updatedColIdArray);
            const newColIds = new Set(updatedColIdArray);
            const allColIds = new Set(colList.map((column)=>{
                const colId = column.getColId();
                newColIds.delete(colId);
                return colId;
            }).concat(updatedColIdArray));
            const colIdsInOriginalOrder = [];
            const originalOrderMap = {};
            let orderIndex = 0;
            for(let i = 0; i < primaryCols.length; i++){
                const colId = primaryCols[i].getColId();
                if (allColIds.has(colId)) {
                    colIdsInOriginalOrder.push(colId);
                    originalOrderMap[colId] = orderIndex++;
                }
            }
            let index = 1e3;
            let hasAddedNewCols = false;
            let lastIndex = 0;
            const processPrecedingNewCols = (colId)=>{
                const originalOrderIndex = originalOrderMap[colId];
                for(let i = lastIndex; i < originalOrderIndex; i++){
                    const newColId = colIdsInOriginalOrder[i];
                    if (newColIds.has(newColId)) {
                        updatedColumnState[newColId][indexProp] = index++;
                        newColIds.delete(newColId);
                    }
                }
                lastIndex = originalOrderIndex;
            };
            colList.forEach((column)=>{
                const colId = column.getColId();
                if (updatedColIds.has(colId)) {
                    processPrecedingNewCols(colId);
                    updatedColumnState[colId][indexProp] = index++;
                } else {
                    const colDef = column.getColDef();
                    const missingIndex = colDef[indexProp] === null || colDef[indexProp] === void 0 && colDef[initialIndexProp] == null;
                    if (missingIndex) {
                        if (!hasAddedNewCols) {
                            const propEnabled = colDef[enableProp] || colDef[enableProp] === void 0 && colDef[initialEnableProp];
                            if (propEnabled) processPrecedingNewCols(colId);
                            else {
                                newColIds.forEach((newColId)=>{
                                    updatedColumnState[newColId][indexProp] = index + originalOrderMap[newColId];
                                });
                                index += colIdsInOriginalOrder.length;
                                hasAddedNewCols = true;
                            }
                        }
                        if (!existingColumnStateUpdates[colId]) existingColumnStateUpdates[colId] = {
                            colId: colId
                        };
                        existingColumnStateUpdates[colId][indexProp] = index++;
                    }
                }
            });
        };
        orderColumns(updatedRowGroupColumnState, this.rowGroupCols, "rowGroup", "initialRowGroup", "rowGroupIndex", "initialRowGroupIndex");
        orderColumns(updatedPivotColumnState, this.pivotCols, "pivot", "initialPivot", "pivotIndex", "initialPivotIndex");
        return Object.values(existingColumnStateUpdates);
    }
};
// community-modules/core/src/columns/columnApplyStateService.ts
var $7b57b57eaf5a9648$export$1e2d44020d94a6d1 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnApplyStateService";
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.eventDispatcher = beans.columnEventDispatcher;
        this.sortController = beans.sortController;
        this.columnGetStateService = beans.columnGetStateService;
        this.funcColsService = beans.funcColsService;
        this.visibleColsService = beans.visibleColsService;
        this.columnAnimationService = beans.columnAnimationService;
        this.pivotResultColsService = beans.pivotResultColsService;
    }
    applyColumnState(params, source) {
        const providedCols = this.columnModel.getColDefCols() || [];
        if ($7b57b57eaf5a9648$export$c15f339f10321853(providedCols)) return false;
        if (params && params.state && !params.state.forEach) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.");
            return false;
        }
        const callbacks = this.funcColsService.getModifyColumnsNoEventsCallbacks();
        const applyStates = (states, existingColumns, getById)=>{
            const dispatchEventsFunc = this.compareColumnStatesAndDispatchEvents(source);
            const columnsWithNoState = existingColumns.slice();
            const rowGroupIndexes = {};
            const pivotIndexes = {};
            const autoColStates = [];
            const unmatchedAndAutoStates2 = [];
            let unmatchedCount2 = 0;
            const previousRowGroupCols = this.funcColsService.getRowGroupColumns().slice();
            const previousPivotCols = this.funcColsService.getPivotColumns().slice();
            states.forEach((state)=>{
                const colId = state.colId || "";
                const isAutoGroupColumn = colId.startsWith($7b57b57eaf5a9648$export$a7016588c430dba6);
                if (isAutoGroupColumn) {
                    autoColStates.push(state);
                    unmatchedAndAutoStates2.push(state);
                    return;
                }
                const column = getById(colId);
                if (!column) {
                    unmatchedAndAutoStates2.push(state);
                    unmatchedCount2 += 1;
                } else {
                    this.syncColumnWithStateItem(column, state, params.defaultState, rowGroupIndexes, pivotIndexes, false, source, callbacks);
                    $7b57b57eaf5a9648$export$83a881c8b5120679(columnsWithNoState, column);
                }
            });
            const applyDefaultsFunc = (col)=>this.syncColumnWithStateItem(col, null, params.defaultState, rowGroupIndexes, pivotIndexes, false, source, callbacks);
            columnsWithNoState.forEach(applyDefaultsFunc);
            this.funcColsService.sortRowGroupColumns($7b57b57eaf5a9648$var$comparatorByIndex.bind(this, rowGroupIndexes, previousRowGroupCols));
            this.funcColsService.sortPivotColumns($7b57b57eaf5a9648$var$comparatorByIndex.bind(this, pivotIndexes, previousPivotCols));
            this.columnModel.refreshCols();
            const autoCols = this.columnModel.getAutoCols() || [];
            const autoColsCopy = autoCols.slice();
            autoColStates.forEach((stateItem)=>{
                const autoCol = this.columnModel.getAutoCol(stateItem.colId);
                $7b57b57eaf5a9648$export$83a881c8b5120679(autoColsCopy, autoCol);
                this.syncColumnWithStateItem(autoCol, stateItem, params.defaultState, null, null, true, source, callbacks);
            });
            autoColsCopy.forEach(applyDefaultsFunc);
            this.orderLiveColsLikeState(params);
            this.visibleColsService.refresh(source);
            this.eventDispatcher.everythingChanged(source);
            dispatchEventsFunc();
            return {
                unmatchedAndAutoStates: unmatchedAndAutoStates2,
                unmatchedCount: unmatchedCount2
            };
        };
        this.columnAnimationService.start();
        let { unmatchedAndAutoStates: unmatchedAndAutoStates , unmatchedCount: unmatchedCount  } = applyStates(params.state || [], providedCols, (id)=>this.columnModel.getColDefCol(id));
        if (unmatchedAndAutoStates.length > 0 || $7b57b57eaf5a9648$export$25d27f17d3af40f7(params.defaultState)) {
            const pivotResultCols = this.pivotResultColsService.getPivotResultCols();
            const pivotResultColsList = pivotResultCols?.list;
            unmatchedCount = applyStates(unmatchedAndAutoStates, pivotResultColsList || [], (id)=>this.pivotResultColsService.getPivotResultCol(id)).unmatchedCount;
        }
        this.columnAnimationService.finish();
        return unmatchedCount === 0;
    }
    resetColumnState(source) {
        const primaryCols = this.columnModel.getColDefCols();
        if ($7b57b57eaf5a9648$export$c15f339f10321853(primaryCols)) return;
        const primaryColumnTree = this.columnModel.getColDefColTree();
        const primaryColumns = $7b57b57eaf5a9648$var$getColumnsFromTree(primaryColumnTree);
        const columnStates = [];
        let letRowGroupIndex = 1e3;
        let letPivotIndex = 1e3;
        let colsToProcess = [];
        const groupAutoCols = this.columnModel.getAutoCols();
        if (groupAutoCols) colsToProcess = colsToProcess.concat(groupAutoCols);
        if (primaryColumns) colsToProcess = colsToProcess.concat(primaryColumns);
        colsToProcess.forEach((column)=>{
            const stateItem = this.getColumnStateFromColDef(column);
            if ($7b57b57eaf5a9648$export$672d9e47bc342bac(stateItem.rowGroupIndex) && stateItem.rowGroup) stateItem.rowGroupIndex = letRowGroupIndex++;
            if ($7b57b57eaf5a9648$export$672d9e47bc342bac(stateItem.pivotIndex) && stateItem.pivot) stateItem.pivotIndex = letPivotIndex++;
            columnStates.push(stateItem);
        });
        this.applyColumnState({
            state: columnStates,
            applyOrder: true
        }, source);
    }
    getColumnStateFromColDef(column) {
        const getValueOrNull = (a, b)=>a != null ? a : b != null ? b : null;
        const colDef = column.getColDef();
        const sort = getValueOrNull(colDef.sort, colDef.initialSort);
        const sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);
        const hide = getValueOrNull(colDef.hide, colDef.initialHide);
        const pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);
        const width = getValueOrNull(colDef.width, colDef.initialWidth);
        const flex = getValueOrNull(colDef.flex, colDef.initialFlex);
        let rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);
        let rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);
        if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {
            rowGroupIndex = null;
            rowGroup = null;
        }
        let pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);
        let pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);
        if (pivotIndex == null && (pivot == null || pivot == false)) {
            pivotIndex = null;
            pivot = null;
        }
        const aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);
        return {
            colId: column.getColId(),
            sort: sort,
            sortIndex: sortIndex,
            hide: hide,
            pinned: pinned,
            width: width,
            flex: flex,
            rowGroup: rowGroup,
            rowGroupIndex: rowGroupIndex,
            pivot: pivot,
            pivotIndex: pivotIndex,
            aggFunc: aggFunc
        };
    }
    syncColumnWithStateItem(column, stateItem, defaultState, rowGroupIndexes, pivotIndexes, autoCol, source, callbacks) {
        if (!column) return;
        const getValue2 = (key1, key2)=>{
            const obj = {
                value1: void 0,
                value2: void 0
            };
            let calculated = false;
            if (stateItem) {
                if (stateItem[key1] !== void 0) {
                    obj.value1 = stateItem[key1];
                    calculated = true;
                }
                if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(key2) && stateItem[key2] !== void 0) {
                    obj.value2 = stateItem[key2];
                    calculated = true;
                }
            }
            if (!calculated && defaultState) {
                if (defaultState[key1] !== void 0) obj.value1 = defaultState[key1];
                if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(key2) && defaultState[key2] !== void 0) obj.value2 = defaultState[key2];
            }
            return obj;
        };
        const hide = getValue2("hide").value1;
        if (hide !== void 0) column.setVisible(!hide, source);
        const pinned = getValue2("pinned").value1;
        if (pinned !== void 0) column.setPinned(pinned);
        const minColWidth = column.getColDef().minWidth ?? $7b57b57eaf5a9648$var$DEFAULT_COLUMN_MIN_WIDTH;
        const flex = getValue2("flex").value1;
        if (flex !== void 0) column.setFlex(flex);
        if (flex == null) {
            const width = getValue2("width").value1;
            if (width != null) {
                if (minColWidth != null && width >= minColWidth) column.setActualWidth(width, source);
            }
        }
        const sort = getValue2("sort").value1;
        if (sort !== void 0) {
            if (sort === "desc" || sort === "asc") column.setSort(sort, source);
            else column.setSort(void 0, source);
        }
        const sortIndex = getValue2("sortIndex").value1;
        if (sortIndex !== void 0) column.setSortIndex(sortIndex);
        if (autoCol || !column.isPrimary()) return;
        const aggFunc = getValue2("aggFunc").value1;
        if (aggFunc !== void 0) {
            if (typeof aggFunc === "string") {
                column.setAggFunc(aggFunc);
                if (!column.isValueActive()) {
                    column.setValueActive(true, source);
                    callbacks.addValueCol(column);
                }
            } else {
                if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(aggFunc)) $7b57b57eaf5a9648$export$2cf41453020eef66("stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.");
                if (column.isValueActive()) {
                    column.setValueActive(false, source);
                    callbacks.removeValueCol(column);
                }
            }
        }
        const { value1: rowGroup , value2: rowGroupIndex  } = getValue2("rowGroup", "rowGroupIndex");
        if (rowGroup !== void 0 || rowGroupIndex !== void 0) {
            if (typeof rowGroupIndex === "number" || rowGroup) {
                if (!column.isRowGroupActive()) {
                    column.setRowGroupActive(true, source);
                    callbacks.addGroupCol(column);
                }
                if (rowGroupIndexes && typeof rowGroupIndex === "number") rowGroupIndexes[column.getId()] = rowGroupIndex;
            } else if (column.isRowGroupActive()) {
                column.setRowGroupActive(false, source);
                callbacks.removeGroupCol(column);
            }
        }
        const { value1: pivot , value2: pivotIndex  } = getValue2("pivot", "pivotIndex");
        if (pivot !== void 0 || pivotIndex !== void 0) {
            if (typeof pivotIndex === "number" || pivot) {
                if (!column.isPivotActive()) {
                    column.setPivotActive(true, source);
                    callbacks.addPivotCol(column);
                }
                if (pivotIndexes && typeof pivotIndex === "number") pivotIndexes[column.getId()] = pivotIndex;
            } else if (column.isPivotActive()) {
                column.setPivotActive(false, source);
                callbacks.removePivotCol(column);
            }
        }
    }
    orderLiveColsLikeState(params) {
        if (!params.applyOrder || !params.state) return;
        const colIds = [];
        params.state.forEach((item)=>{
            if (item.colId != null) colIds.push(item.colId);
        });
        this.columnModel.sortColsLikeKeys(colIds);
    }
    // calculates what events to fire between column state changes. gets used when:
    // a) apply column state
    // b) apply new column definitions (so changes from old cols)
    compareColumnStatesAndDispatchEvents(source) {
        const startState = {
            rowGroupColumns: this.funcColsService.getRowGroupColumns().slice(),
            pivotColumns: this.funcColsService.getPivotColumns().slice(),
            valueColumns: this.funcColsService.getValueColumns().slice()
        };
        const columnStateBefore = this.columnGetStateService.getColumnState();
        const columnStateBeforeMap = {};
        columnStateBefore.forEach((col)=>{
            columnStateBeforeMap[col.colId] = col;
        });
        return ()=>{
            const colsForState = this.columnModel.getAllCols();
            const dispatchWhenListsDifferent = (eventType, colsBefore, colsAfter, idMapper)=>{
                const beforeList = colsBefore.map(idMapper);
                const afterList = colsAfter.map(idMapper);
                const unchanged = $7b57b57eaf5a9648$export$893967cdb9833fdd(beforeList, afterList);
                if (unchanged) return;
                const changes = new Set(colsBefore);
                colsAfter.forEach((id)=>{
                    if (!changes.delete(id)) changes.add(id);
                });
                const changesArr = [
                    ...changes
                ];
                const event = {
                    type: eventType,
                    columns: changesArr,
                    column: changesArr.length === 1 ? changesArr[0] : null,
                    source: source
                };
                this.eventService.dispatchEvent(event);
            };
            const getChangedColumns = (changedPredicate)=>{
                const changedColumns2 = [];
                colsForState.forEach((column)=>{
                    const colStateBefore = columnStateBeforeMap[column.getColId()];
                    if (colStateBefore && changedPredicate(colStateBefore, column)) changedColumns2.push(column);
                });
                return changedColumns2;
            };
            const columnIdMapper = (c)=>c.getColId();
            dispatchWhenListsDifferent("columnRowGroupChanged", startState.rowGroupColumns, this.funcColsService.getRowGroupColumns(), columnIdMapper);
            dispatchWhenListsDifferent("columnPivotChanged", startState.pivotColumns, this.funcColsService.getPivotColumns(), columnIdMapper);
            const valueChangePredicate = (cs, c)=>{
                const oldActive = cs.aggFunc != null;
                const activeChanged = oldActive != c.isValueActive();
                const aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();
                return activeChanged || aggFuncChanged;
            };
            const changedValues = getChangedColumns(valueChangePredicate);
            if (changedValues.length > 0) this.eventDispatcher.columnChanged("columnValueChanged", changedValues, source);
            const resizeChangePredicate = (cs, c)=>cs.width != c.getActualWidth();
            this.eventDispatcher.columnResized(getChangedColumns(resizeChangePredicate), true, source);
            const pinnedChangePredicate = (cs, c)=>cs.pinned != c.getPinned();
            this.eventDispatcher.columnPinned(getChangedColumns(pinnedChangePredicate), source);
            const visibilityChangePredicate = (cs, c)=>cs.hide == c.isVisible();
            this.eventDispatcher.columnVisible(getChangedColumns(visibilityChangePredicate), source);
            const sortChangePredicate = (cs, c)=>cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();
            const changedColumns = getChangedColumns(sortChangePredicate);
            if (changedColumns.length > 0) this.sortController.dispatchSortChangedEvents(source, changedColumns);
            this.normaliseColumnMovedEventForColumnState(columnStateBefore, source);
        };
    }
    normaliseColumnMovedEventForColumnState(colStateBefore, source) {
        const colStateAfter = this.columnGetStateService.getColumnState();
        const colStateAfterMapped = {};
        colStateAfter.forEach((s)=>colStateAfterMapped[s.colId] = s);
        const colsIntersectIds = {};
        colStateBefore.forEach((s)=>{
            if (colStateAfterMapped[s.colId]) colsIntersectIds[s.colId] = true;
        });
        const beforeFiltered = colStateBefore.filter((c)=>colsIntersectIds[c.colId]);
        const afterFiltered = colStateAfter.filter((c)=>colsIntersectIds[c.colId]);
        const movedColumns = [];
        afterFiltered.forEach((csAfter, index)=>{
            const csBefore = beforeFiltered && beforeFiltered[index];
            if (csBefore && csBefore.colId !== csAfter.colId) {
                const gridCol = this.columnModel.getCol(csBefore.colId);
                if (gridCol) movedColumns.push(gridCol);
            }
        });
        if (!movedColumns.length) return;
        this.eventDispatcher.columnMoved({
            movedColumns: movedColumns,
            source: source,
            finished: true
        });
    }
};
var $7b57b57eaf5a9648$var$comparatorByIndex = (indexes, oldList, colA, colB)=>{
    const indexA = indexes[colA.getId()];
    const indexB = indexes[colB.getId()];
    const aHasIndex = indexA != null;
    const bHasIndex = indexB != null;
    if (aHasIndex && bHasIndex) return indexA - indexB;
    if (aHasIndex) return -1;
    if (bHasIndex) return 1;
    const oldIndexA = oldList.indexOf(colA);
    const oldIndexB = oldList.indexOf(colB);
    const aHasOldIndex = oldIndexA >= 0;
    const bHasOldIndex = oldIndexB >= 0;
    if (aHasOldIndex && bHasOldIndex) return oldIndexA - oldIndexB;
    if (aHasOldIndex) return -1;
    return 1;
};
// community-modules/core/src/columns/columnMoveService.ts
var $7b57b57eaf5a9648$export$2690662948863ae3 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnMoveService";
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.columnAnimationService = beans.columnAnimationService;
        this.eventDispatcher = beans.columnEventDispatcher;
    }
    moveColumnByIndex(fromIndex, toIndex, source) {
        const gridColumns = this.columnModel.getCols();
        if (!gridColumns) return;
        const column = gridColumns[fromIndex];
        this.moveColumns([
            column
        ], toIndex, source);
    }
    moveColumns(columnsToMoveKeys, toIndex, source, finished = true) {
        const gridColumns = this.columnModel.getCols();
        if (!gridColumns) return;
        this.columnAnimationService.start();
        if (toIndex > gridColumns.length - columnsToMoveKeys.length) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("tried to insert columns in invalid location, toIndex = ", toIndex);
            $7b57b57eaf5a9648$export$2cf41453020eef66("remember that you should not count the moving columns when calculating the new index");
            return;
        }
        const movedColumns = this.columnModel.getColsForKeys(columnsToMoveKeys);
        const failedRules = !this.doesMovePassRules(movedColumns, toIndex);
        if (failedRules) return;
        this.columnModel.moveInCols(movedColumns, toIndex, source);
        this.eventDispatcher.columnMoved({
            movedColumns: movedColumns,
            source: source,
            toIndex: toIndex,
            finished: finished
        });
        this.columnAnimationService.finish();
    }
    doesMovePassRules(columnsToMove, toIndex) {
        const proposedColumnOrder = this.getProposedColumnOrder(columnsToMove, toIndex);
        return this.doesOrderPassRules(proposedColumnOrder);
    }
    doesOrderPassRules(gridOrder) {
        if (!this.doesMovePassMarryChildren(gridOrder)) return false;
        if (!this.doesMovePassLockedPositions(gridOrder)) return false;
        return true;
    }
    getProposedColumnOrder(columnsToMove, toIndex) {
        const gridColumns = this.columnModel.getCols();
        const proposedColumnOrder = gridColumns.slice();
        $7b57b57eaf5a9648$var$_moveInArray(proposedColumnOrder, columnsToMove, toIndex);
        return proposedColumnOrder;
    }
    doesMovePassLockedPositions(proposedColumnOrder) {
        const lockPositionToPlacement = (position)=>{
            if (!position) return 0 /* NONE */ ;
            return position === "left" || position === true ? -1 /* LEFT */  : 1 /* RIGHT */ ;
        };
        const isRtl = this.gos.get("enableRtl");
        let lastPlacement = isRtl ? 1 /* RIGHT */  : -1 /* LEFT */ ;
        let rulePassed = true;
        proposedColumnOrder.forEach((col)=>{
            const placement = lockPositionToPlacement(col.getColDef().lockPosition);
            if (isRtl) {
                if (placement > lastPlacement) rulePassed = false;
            } else if (placement < lastPlacement) rulePassed = false;
            lastPlacement = placement;
        });
        return rulePassed;
    }
    doesMovePassMarryChildren(allColumnsCopy) {
        let rulePassed = true;
        const gridBalancedTree = this.columnModel.getColTree();
        $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(null, gridBalancedTree, (child)=>{
            if (!$7b57b57eaf5a9648$export$bb4bfad2b594b78e(child)) return;
            const columnGroup = child;
            const colGroupDef = columnGroup.getColGroupDef();
            const marryChildren = colGroupDef && colGroupDef.marryChildren;
            if (!marryChildren) return;
            const newIndexes = [];
            columnGroup.getLeafColumns().forEach((col)=>{
                const newColIndex = allColumnsCopy.indexOf(col);
                newIndexes.push(newColIndex);
            });
            const maxIndex = Math.max.apply(Math, newIndexes);
            const minIndex = Math.min.apply(Math, newIndexes);
            const spread = maxIndex - minIndex;
            const maxSpread = columnGroup.getLeafColumns().length - 1;
            if (spread > maxSpread) rulePassed = false;
        });
        return rulePassed;
    }
    placeLockedColumns(cols) {
        const left = [];
        const normal = [];
        const right = [];
        cols.forEach((col)=>{
            const position = col.getColDef().lockPosition;
            if (position === "right") right.push(col);
            else if (position === "left" || position === true) left.push(col);
            else normal.push(col);
        });
        const isRtl = this.gos.get("enableRtl");
        if (isRtl) return [
            ...right,
            ...normal,
            ...left
        ];
        return [
            ...left,
            ...normal,
            ...right
        ];
    }
};
// community-modules/core/src/utils/string.ts
var $7b57b57eaf5a9648$var$reUnescapedHtml = /[&<>"']/g;
var $7b57b57eaf5a9648$var$HTML_ESCAPES = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
};
function $7b57b57eaf5a9648$export$3e99ec8a83701984(s) {
    const stringFromCharCode = String.fromCharCode;
    function ucs2decode(string) {
        const output = [];
        if (!string) return [];
        const len = string.length;
        let counter = 0;
        let value;
        let extra;
        while(counter < len){
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < len) {
                extra = string.charCodeAt(counter++);
                if ((extra & 64512) == 56320) output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                else {
                    output.push(value);
                    counter--;
                }
            } else output.push(value);
        }
        return output;
    }
    function checkScalarValue(point) {
        if (point >= 55296 && point <= 57343) throw Error("Lone surrogate U+" + point.toString(16).toUpperCase() + " is not a scalar value");
    }
    function createByte(point, shift) {
        return stringFromCharCode(point >> shift & 63 | 128);
    }
    function encodeCodePoint(point) {
        if ((point & 4294967168) == 0) return stringFromCharCode(point);
        let symbol = "";
        if ((point & 4294965248) == 0) symbol = stringFromCharCode(point >> 6 & 31 | 192);
        else if ((point & 4294901760) == 0) {
            checkScalarValue(point);
            symbol = stringFromCharCode(point >> 12 & 15 | 224);
            symbol += createByte(point, 6);
        } else if ((point & 4292870144) == 0) {
            symbol = stringFromCharCode(point >> 18 & 7 | 240);
            symbol += createByte(point, 12);
            symbol += createByte(point, 6);
        }
        symbol += stringFromCharCode(point & 63 | 128);
        return symbol;
    }
    const codePoints = ucs2decode(s);
    const length = codePoints.length;
    let index = -1;
    let codePoint;
    let byteString = "";
    while(++index < length){
        codePoint = codePoints[index];
        byteString += encodeCodePoint(codePoint);
    }
    return byteString;
}
function $7b57b57eaf5a9648$export$693b73c80dea56c4(str) {
    return str[0].toUpperCase() + str.substring(1).toLowerCase();
}
function $7b57b57eaf5a9648$export$3df06b741968da82(toEscape, skipEscapingHtmlChars) {
    if (toEscape == null) return null;
    const stringResult = toEscape.toString().toString();
    if (skipEscapingHtmlChars) return stringResult;
    return stringResult.replace($7b57b57eaf5a9648$var$reUnescapedHtml, (chr)=>$7b57b57eaf5a9648$var$HTML_ESCAPES[chr]);
}
function $7b57b57eaf5a9648$var$_camelCaseToHumanText(camelCase) {
    if (!camelCase || camelCase == null) return null;
    const rex = /([a-z])([A-Z])/g;
    const rexCaps = /([A-Z]+)([A-Z])([a-z])/g;
    const words = camelCase.replace(rex, "$1 $2").replace(rexCaps, "$1 $2$3").replace(/\./g, " ").split(" ");
    return words.map((word)=>word.substring(0, 1).toUpperCase() + (word.length > 1 ? word.substring(1, word.length) : "")).join(" ");
}
function $7b57b57eaf5a9648$var$_camelCaseToHyphenated(camelCase) {
    return camelCase.replace(/[A-Z]/g, (s)=>`-${s.toLocaleLowerCase()}`);
}
// community-modules/core/src/columns/columnNameService.ts
var $7b57b57eaf5a9648$export$a71857df571f7d7d = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnNameService";
    }
    wireBeans(beans) {
        this.expressionService = beans.expressionService;
        this.funcColsService = beans.funcColsService;
        this.columnModel = beans.columnModel;
    }
    getDisplayNameForColumn(column, location, includeAggFunc = false) {
        if (!column) return null;
        const headerName = this.getHeaderName(column.getColDef(), column, null, null, location);
        if (includeAggFunc) return this.wrapHeaderNameWithAggFunc(column, headerName);
        return headerName;
    }
    getDisplayNameForProvidedColumnGroup(columnGroup, providedColumnGroup, location) {
        const colGroupDef = providedColumnGroup ? providedColumnGroup.getColGroupDef() : null;
        if (colGroupDef) return this.getHeaderName(colGroupDef, null, columnGroup, providedColumnGroup, location);
        return null;
    }
    getDisplayNameForColumnGroup(columnGroup, location) {
        return this.getDisplayNameForProvidedColumnGroup(columnGroup, columnGroup.getProvidedColumnGroup(), location);
    }
    // location is where the column is going to appear, ie who is calling us
    getHeaderName(colDef, column, columnGroup, providedColumnGroup, location) {
        const headerValueGetter = colDef.headerValueGetter;
        if (headerValueGetter) {
            const params = this.gos.addGridCommonParams({
                colDef: colDef,
                column: column,
                columnGroup: columnGroup,
                providedColumnGroup: providedColumnGroup,
                location: location
            });
            if (typeof headerValueGetter === "function") return headerValueGetter(params);
            else if (typeof headerValueGetter === "string") return this.expressionService.evaluate(headerValueGetter, params);
            $7b57b57eaf5a9648$export$2cf41453020eef66("headerValueGetter must be a function or a string");
            return "";
        } else if (colDef.headerName != null) return colDef.headerName;
        else if (colDef.field) return $7b57b57eaf5a9648$var$_camelCaseToHumanText(colDef.field);
        return "";
    }
    wrapHeaderNameWithAggFunc(column, headerName) {
        if (this.gos.get("suppressAggFuncInHeader")) return headerName;
        const pivotValueColumn = column.getColDef().pivotValueColumn;
        const pivotActiveOnThisColumn = $7b57b57eaf5a9648$export$25d27f17d3af40f7(pivotValueColumn);
        let aggFunc = null;
        let aggFuncFound;
        if (pivotActiveOnThisColumn) {
            const valueColumns = this.funcColsService.getValueColumns();
            const isCollapsedHeaderEnabled = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && valueColumns.length === 1;
            const isTotalColumn = column.getColDef().pivotTotalColumnIds !== void 0;
            if (isCollapsedHeaderEnabled && !isTotalColumn) return headerName;
            aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;
            aggFuncFound = true;
        } else {
            const measureActive = column.isValueActive();
            const aggregationPresent = this.columnModel.isPivotMode() || !this.funcColsService.isRowGroupEmpty();
            if (measureActive && aggregationPresent) {
                aggFunc = column.getAggFunc();
                aggFuncFound = true;
            } else aggFuncFound = false;
        }
        if (aggFuncFound) {
            const aggFuncString = typeof aggFunc === "string" ? aggFunc : "func";
            const localeTextFunc = this.localeService.getLocaleTextFunc();
            const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);
            return `${aggFuncStringTranslated}(${headerName})`;
        }
        return headerName;
    }
};
// community-modules/core/src/columns/pivotResultColsService.ts
var $7b57b57eaf5a9648$export$2ac7359cc75159ed = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "pivotResultColsService";
    }
    wireBeans(beans) {
        this.context = beans.context;
        this.columnModel = beans.columnModel;
        this.columnFactory = beans.columnFactory;
        this.visibleColsService = beans.visibleColsService;
    }
    destroy() {
        $7b57b57eaf5a9648$var$destroyColumnTree(this.context, this.pivotResultCols?.tree);
        super.destroy();
    }
    isPivotResultColsPresent() {
        return this.pivotResultCols != null;
    }
    lookupPivotResultCol(pivotKeys, valueColKey) {
        if (this.pivotResultCols == null) return null;
        const valueColumnToFind = this.columnModel.getColDefCol(valueColKey);
        let foundColumn = null;
        this.pivotResultCols.list.forEach((column)=>{
            const thisPivotKeys = column.getColDef().pivotKeys;
            const pivotValueColumn = column.getColDef().pivotValueColumn;
            const pivotKeyMatches = $7b57b57eaf5a9648$export$893967cdb9833fdd(thisPivotKeys, pivotKeys);
            const pivotValueMatches = pivotValueColumn === valueColumnToFind;
            if (pivotKeyMatches && pivotValueMatches) foundColumn = column;
        });
        return foundColumn;
    }
    getPivotResultCols() {
        return this.pivotResultCols;
    }
    getPivotResultCol(key) {
        if (!this.pivotResultCols) return null;
        return this.columnModel.getColFromCollection(key, this.pivotResultCols);
    }
    setPivotResultCols(colDefs, source) {
        if (!this.columnModel.isReady()) return;
        if (colDefs == null && this.pivotResultCols == null) return;
        if (colDefs) {
            this.processPivotResultColDef(colDefs);
            const balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false, this.pivotResultCols?.tree || this.previousPivotResultCols || void 0, source);
            $7b57b57eaf5a9648$var$destroyColumnTree(this.context, this.pivotResultCols?.tree, balancedTreeResult.columnTree);
            const tree = balancedTreeResult.columnTree;
            const treeDepth = balancedTreeResult.treeDept;
            const list = $7b57b57eaf5a9648$var$getColumnsFromTree(tree);
            const map = {};
            this.pivotResultCols = {
                tree: tree,
                treeDepth: treeDepth,
                list: list,
                map: map
            };
            this.pivotResultCols.list.forEach((col)=>this.pivotResultCols.map[col.getId()] = col);
            this.previousPivotResultCols = null;
        } else {
            this.previousPivotResultCols = this.pivotResultCols ? this.pivotResultCols.tree : null;
            this.pivotResultCols = null;
        }
        this.columnModel.refreshCols();
        this.visibleColsService.refresh(source);
    }
    processPivotResultColDef(colDefs) {
        const columnCallback = this.gos.get("processPivotResultColDef");
        const groupCallback = this.gos.get("processPivotResultColGroupDef");
        if (!columnCallback && !groupCallback) return void 0;
        const searchForColDefs = (colDefs2)=>{
            colDefs2.forEach((abstractColDef)=>{
                const isGroup = $7b57b57eaf5a9648$export$25d27f17d3af40f7(abstractColDef.children);
                if (isGroup) {
                    const colGroupDef = abstractColDef;
                    if (groupCallback) groupCallback(colGroupDef);
                    searchForColDefs(colGroupDef.children);
                } else {
                    const colDef = abstractColDef;
                    if (columnCallback) columnCallback(colDef);
                }
            });
        };
        if (colDefs) searchForColDefs(colDefs);
    }
};
// community-modules/core/src/columns/columnSizeService.ts
var $7b57b57eaf5a9648$export$7ca43c2c3fd3ccb4 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnSizeService";
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.columnViewportService = beans.columnViewportService;
        this.eventDispatcher = beans.columnEventDispatcher;
        this.visibleColsService = beans.visibleColsService;
        this.ctrlsService = beans.ctrlsService;
    }
    setColumnWidths(columnWidths, shiftKey, finished, source) {
        const sets = [];
        columnWidths.forEach((columnWidth)=>{
            const col = this.columnModel.getColDefCol(columnWidth.key) || this.columnModel.getCol(columnWidth.key);
            if (!col) return;
            sets.push({
                width: columnWidth.newWidth,
                ratios: [
                    1
                ],
                columns: [
                    col
                ]
            });
            const defaultIsShift = this.gos.get("colResizeDefault") === "shift";
            if (defaultIsShift) shiftKey = !shiftKey;
            if (shiftKey) {
                const otherCol = this.visibleColsService.getColAfter(col);
                if (!otherCol) return;
                const widthDiff = col.getActualWidth() - columnWidth.newWidth;
                const otherColWidth = otherCol.getActualWidth() + widthDiff;
                sets.push({
                    width: otherColWidth,
                    ratios: [
                        1
                    ],
                    columns: [
                        otherCol
                    ]
                });
            }
        });
        if (sets.length === 0) return;
        this.resizeColumnSets({
            resizeSets: sets,
            finished: finished,
            source: source
        });
    }
    // method takes sets of columns and resizes them. either all sets will be resized, or nothing
    // be resized. this is used for example when user tries to resize a group and holds shift key,
    // then both the current group (grows), and the adjacent group (shrinks), will get resized,
    // so that's two sets for this method.
    resizeColumnSets(params) {
        const { resizeSets: resizeSets , finished: finished , source: source  } = params;
        const passMinMaxCheck = !resizeSets || resizeSets.every((columnResizeSet)=>this.checkMinAndMaxWidthsForSet(columnResizeSet));
        if (!passMinMaxCheck) {
            if (finished) {
                const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;
                this.eventDispatcher.columnResized(columns, finished, source);
            }
            return;
        }
        const changedCols = [];
        const allResizedCols = [];
        resizeSets.forEach((set)=>{
            const { width: width , columns: columns , ratios: ratios  } = set;
            const newWidths = {};
            const finishedCols = {};
            columns.forEach((col)=>allResizedCols.push(col));
            let finishedColsGrew = true;
            let loopCount = 0;
            while(finishedColsGrew){
                loopCount++;
                if (loopCount > 1e3) {
                    $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("infinite loop in resizeColumnSets");
                    break;
                }
                finishedColsGrew = false;
                const subsetCols = [];
                let subsetRatioTotal = 0;
                let pixelsToDistribute = width;
                columns.forEach((col, index)=>{
                    const thisColFinished = finishedCols[col.getId()];
                    if (thisColFinished) pixelsToDistribute -= newWidths[col.getId()];
                    else {
                        subsetCols.push(col);
                        const ratioThisCol = ratios[index];
                        subsetRatioTotal += ratioThisCol;
                    }
                });
                const ratioScale = 1 / subsetRatioTotal;
                subsetCols.forEach((col, index)=>{
                    const lastCol = index === subsetCols.length - 1;
                    let colNewWidth;
                    if (lastCol) colNewWidth = pixelsToDistribute;
                    else {
                        colNewWidth = Math.round(ratios[index] * width * ratioScale);
                        pixelsToDistribute -= colNewWidth;
                    }
                    const minWidth = col.getMinWidth();
                    const maxWidth = col.getMaxWidth();
                    if (colNewWidth < minWidth) {
                        colNewWidth = minWidth;
                        finishedCols[col.getId()] = true;
                        finishedColsGrew = true;
                    } else if (maxWidth > 0 && colNewWidth > maxWidth) {
                        colNewWidth = maxWidth;
                        finishedCols[col.getId()] = true;
                        finishedColsGrew = true;
                    }
                    newWidths[col.getId()] = colNewWidth;
                });
            }
            columns.forEach((col)=>{
                const newWidth = newWidths[col.getId()];
                const actualWidth = col.getActualWidth();
                if (actualWidth !== newWidth) {
                    col.setActualWidth(newWidth, source);
                    changedCols.push(col);
                }
            });
        });
        const atLeastOneColChanged = changedCols.length > 0;
        let flexedCols = [];
        if (atLeastOneColChanged) {
            flexedCols = this.refreshFlexedColumns({
                resizingCols: allResizedCols,
                skipSetLeft: true
            });
            this.visibleColsService.setLeftValues(source);
            this.visibleColsService.updateBodyWidths();
            this.columnViewportService.checkViewportColumns();
        }
        const colsForEvent = allResizedCols.concat(flexedCols);
        if (atLeastOneColChanged || finished) this.eventDispatcher.columnResized(colsForEvent, finished, source, flexedCols);
    }
    checkMinAndMaxWidthsForSet(columnResizeSet) {
        const { columns: columns , width: width  } = columnResizeSet;
        let minWidthAccumulated = 0;
        let maxWidthAccumulated = 0;
        let maxWidthActive = true;
        columns.forEach((col)=>{
            const minWidth = col.getMinWidth();
            minWidthAccumulated += minWidth || 0;
            const maxWidth = col.getMaxWidth();
            if (maxWidth > 0) maxWidthAccumulated += maxWidth;
            else maxWidthActive = false;
        });
        const minWidthPasses = width >= minWidthAccumulated;
        const maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;
        return minWidthPasses && maxWidthPasses;
    }
    refreshFlexedColumns(params = {}) {
        const source = params.source ? params.source : "flex";
        if (params.viewportWidth != null) this.flexViewportWidth = params.viewportWidth;
        if (!this.flexViewportWidth) return [];
        const displayedCenterCols = this.visibleColsService.getCenterCols();
        let flexAfterDisplayIndex = -1;
        if (params.resizingCols) {
            const allResizingCols = new Set(params.resizingCols);
            for(let i = displayedCenterCols.length - 1; i >= 0; i--)if (allResizingCols.has(displayedCenterCols[i])) {
                flexAfterDisplayIndex = i;
                break;
            }
        }
        let knownColumnsWidth = 0;
        let flexingColumns = [];
        let minimumFlexedWidth = 0;
        let totalFlex = 0;
        for(let i = 0; i < displayedCenterCols.length; i++){
            const isFlex = displayedCenterCols[i].getFlex() && i > flexAfterDisplayIndex;
            if (isFlex) {
                flexingColumns.push(displayedCenterCols[i]);
                totalFlex += displayedCenterCols[i].getFlex();
                minimumFlexedWidth += displayedCenterCols[i].getMinWidth();
            } else knownColumnsWidth += displayedCenterCols[i].getActualWidth();
        }
        if (!flexingColumns.length) return [];
        let changedColumns = [];
        if (knownColumnsWidth + minimumFlexedWidth > this.flexViewportWidth) {
            flexingColumns.forEach((col)=>col.setActualWidth(col.getMinWidth(), source));
            changedColumns = flexingColumns;
            flexingColumns = [];
        }
        const flexingColumnSizes = [];
        let spaceForFlexingColumns;
        outer: while(true){
            spaceForFlexingColumns = this.flexViewportWidth - knownColumnsWidth;
            const spacePerFlex = spaceForFlexingColumns / totalFlex;
            for(let i = 0; i < flexingColumns.length; i++){
                const col = flexingColumns[i];
                const widthByFlexRule = spacePerFlex * col.getFlex();
                let constrainedWidth = 0;
                const minWidth = col.getMinWidth();
                const maxWidth = col.getMaxWidth();
                if (widthByFlexRule < minWidth) constrainedWidth = minWidth;
                else if (widthByFlexRule > maxWidth) constrainedWidth = maxWidth;
                if (constrainedWidth) {
                    col.setActualWidth(constrainedWidth, source);
                    $7b57b57eaf5a9648$var$_removeFromUnorderedArray(flexingColumns, col);
                    totalFlex -= col.getFlex();
                    changedColumns.push(col);
                    knownColumnsWidth += col.getActualWidth();
                    continue outer;
                }
                flexingColumnSizes[i] = Math.round(widthByFlexRule);
            }
            break;
        }
        let remainingSpace = spaceForFlexingColumns;
        flexingColumns.forEach((col, i)=>{
            col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);
            changedColumns.push(col);
            remainingSpace -= flexingColumnSizes[i];
        });
        if (!params.skipSetLeft) this.visibleColsService.setLeftValues(source);
        if (params.updateBodyWidths) this.visibleColsService.updateBodyWidths();
        if (params.fireResizedEvent) this.eventDispatcher.columnResized(changedColumns, true, source, flexingColumns);
        return flexingColumns;
    }
    // called from api
    sizeColumnsToFit(gridWidth, source = "sizeColumnsToFit", silent, params) {
        if (this.columnModel.isShouldQueueResizeOperations()) {
            this.columnModel.pushResizeOperation(()=>this.sizeColumnsToFit(gridWidth, source, silent, params));
            return;
        }
        const limitsMap = {};
        if (params) params?.columnLimits?.forEach(({ key: key , ...dimensions })=>{
            limitsMap[typeof key === "string" ? key : key.getColId()] = dimensions;
        });
        const allDisplayedColumns = this.visibleColsService.getAllCols();
        const doColumnsAlreadyFit = gridWidth === $7b57b57eaf5a9648$var$getWidthOfColsInList(allDisplayedColumns);
        if (gridWidth <= 0 || !allDisplayedColumns.length || doColumnsAlreadyFit) return;
        const colsToSpread = [];
        const colsToNotSpread = [];
        allDisplayedColumns.forEach((column)=>{
            if (column.getColDef().suppressSizeToFit === true) colsToNotSpread.push(column);
            else colsToSpread.push(column);
        });
        const colsToDispatchEventFor = colsToSpread.slice(0);
        let finishedResizing = false;
        const moveToNotSpread = (column)=>{
            $7b57b57eaf5a9648$export$83a881c8b5120679(colsToSpread, column);
            colsToNotSpread.push(column);
        };
        colsToSpread.forEach((column)=>{
            column.resetActualWidth(source);
            const widthOverride = limitsMap?.[column.getId()];
            const minOverride = widthOverride?.minWidth ?? params?.defaultMinWidth;
            const maxOverride = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
            const colWidth = column.getActualWidth();
            if (typeof minOverride === "number" && colWidth < minOverride) column.setActualWidth(minOverride, source, true);
            else if (typeof maxOverride === "number" && colWidth > maxOverride) column.setActualWidth(maxOverride, source, true);
        });
        while(!finishedResizing){
            finishedResizing = true;
            const availablePixels = gridWidth - $7b57b57eaf5a9648$var$getWidthOfColsInList(colsToNotSpread);
            if (availablePixels <= 0) colsToSpread.forEach((column)=>{
                const widthOverride = limitsMap?.[column.getId()]?.minWidth ?? params?.defaultMinWidth;
                if (typeof widthOverride === "number") {
                    column.setActualWidth(widthOverride, source, true);
                    return;
                }
                column.setMinimum(source);
            });
            else {
                const scale = availablePixels / $7b57b57eaf5a9648$var$getWidthOfColsInList(colsToSpread);
                let pixelsForLastCol = availablePixels;
                for(let i = colsToSpread.length - 1; i >= 0; i--){
                    const column = colsToSpread[i];
                    const widthOverride = limitsMap?.[column.getId()];
                    const minOverride = widthOverride?.minWidth ?? params?.defaultMinWidth;
                    const maxOverride = widthOverride?.maxWidth ?? params?.defaultMaxWidth;
                    const colMinWidth = column.getMinWidth();
                    const colMaxWidth = column.getMaxWidth();
                    const minWidth = typeof minOverride === "number" && minOverride > colMinWidth ? minOverride : colMinWidth;
                    const maxWidth = typeof maxOverride === "number" && maxOverride < colMaxWidth ? maxOverride : colMaxWidth;
                    let newWidth = Math.round(column.getActualWidth() * scale);
                    if (newWidth < minWidth) {
                        newWidth = minWidth;
                        moveToNotSpread(column);
                        finishedResizing = false;
                    } else if (newWidth > maxWidth) {
                        newWidth = maxWidth;
                        moveToNotSpread(column);
                        finishedResizing = false;
                    } else if (i === 0) newWidth = pixelsForLastCol;
                    column.setActualWidth(newWidth, source, true);
                    pixelsForLastCol -= newWidth;
                }
            }
        }
        colsToDispatchEventFor.forEach((col)=>{
            col.fireColumnWidthChangedEvent(source);
        });
        this.visibleColsService.setLeftValues(source);
        this.visibleColsService.updateBodyWidths();
        if (silent) return;
        this.eventDispatcher.columnResized(colsToDispatchEventFor, true, source);
    }
    applyAutosizeStrategy() {
        const autoSizeStrategy = this.gos.get("autoSizeStrategy");
        if (!autoSizeStrategy) return;
        const { type: type  } = autoSizeStrategy;
        setTimeout(()=>{
            if (type === "fitGridWidth") {
                const { columnLimits: propColumnLimits , defaultMinWidth: defaultMinWidth , defaultMaxWidth: defaultMaxWidth  } = autoSizeStrategy;
                const columnLimits = propColumnLimits?.map(({ colId: key , minWidth: minWidth , maxWidth: maxWidth  })=>({
                        key: key,
                        minWidth: minWidth,
                        maxWidth: maxWidth
                    }));
                this.ctrlsService.getGridBodyCtrl().sizeColumnsToFit({
                    defaultMinWidth: defaultMinWidth,
                    defaultMaxWidth: defaultMaxWidth,
                    columnLimits: columnLimits
                });
            } else if (type === "fitProvidedWidth") this.sizeColumnsToFit(autoSizeStrategy.width, "sizeColumnsToFit");
        });
    }
};
// community-modules/core/src/entities/agColumnGroup.ts
function $7b57b57eaf5a9648$var$createUniqueColumnGroupId(groupId, instanceId) {
    return groupId + "_" + instanceId;
}
function $7b57b57eaf5a9648$export$1f44a60fc23f9028(col) {
    return col instanceof $7b57b57eaf5a9648$export$273c80940a54c770;
}
var $7b57b57eaf5a9648$export$273c80940a54c770 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(providedColumnGroup, groupId, partId, pinned){
        super();
        this.isColumn = false;
        // depends on the open/closed state of the group, only displaying columns are stored here
        this.displayedChildren = [];
        this.parent = null;
        this.groupId = groupId;
        this.partId = partId;
        this.providedColumnGroup = providedColumnGroup;
        this.pinned = pinned;
    }
    // as the user is adding and removing columns, the groups are recalculated.
    // this reset clears out all children, ready for children to be added again
    reset() {
        this.parent = null;
        this.children = null;
        this.displayedChildren = null;
    }
    getParent() {
        return this.parent;
    }
    setParent(parent) {
        this.parent = parent;
    }
    getUniqueId() {
        return $7b57b57eaf5a9648$var$createUniqueColumnGroupId(this.groupId, this.partId);
    }
    isEmptyGroup() {
        return this.displayedChildren.length === 0;
    }
    isMoving() {
        const allLeafColumns = this.getProvidedColumnGroup().getLeafColumns();
        if (!allLeafColumns || allLeafColumns.length === 0) return false;
        return allLeafColumns.every((col)=>col.isMoving());
    }
    checkLeft() {
        this.displayedChildren.forEach((child)=>{
            if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(child)) child.checkLeft();
        });
        if (this.displayedChildren.length > 0) {
            if (this.gos.get("enableRtl")) {
                const lastChild = $7b57b57eaf5a9648$export$236389741107357f(this.displayedChildren);
                const lastChildLeft = lastChild.getLeft();
                this.setLeft(lastChildLeft);
            } else {
                const firstChildLeft = this.displayedChildren[0].getLeft();
                this.setLeft(firstChildLeft);
            }
        } else this.setLeft(null);
    }
    getLeft() {
        return this.left;
    }
    getOldLeft() {
        return this.oldLeft;
    }
    setLeft(left) {
        this.oldLeft = this.left;
        if (this.left !== left) {
            this.left = left;
            this.dispatchLocalEvent({
                type: "leftChanged"
            });
        }
    }
    getPinned() {
        return this.pinned;
    }
    getGroupId() {
        return this.groupId;
    }
    getPartId() {
        return this.partId;
    }
    getActualWidth() {
        let groupActualWidth = 0;
        if (this.displayedChildren) this.displayedChildren.forEach((child)=>{
            groupActualWidth += child.getActualWidth();
        });
        return groupActualWidth;
    }
    isResizable() {
        if (!this.displayedChildren) return false;
        let result = false;
        this.displayedChildren.forEach((child)=>{
            if (child.isResizable()) result = true;
        });
        return result;
    }
    getMinWidth() {
        let result = 0;
        this.displayedChildren.forEach((groupChild)=>{
            result += groupChild.getMinWidth();
        });
        return result;
    }
    addChild(child) {
        if (!this.children) this.children = [];
        this.children.push(child);
    }
    getDisplayedChildren() {
        return this.displayedChildren;
    }
    getLeafColumns() {
        const result = [];
        this.addLeafColumns(result);
        return result;
    }
    getDisplayedLeafColumns() {
        const result = [];
        this.addDisplayedLeafColumns(result);
        return result;
    }
    getDefinition() {
        return this.providedColumnGroup.getColGroupDef();
    }
    getColGroupDef() {
        return this.providedColumnGroup.getColGroupDef();
    }
    isPadding() {
        return this.providedColumnGroup.isPadding();
    }
    isExpandable() {
        return this.providedColumnGroup.isExpandable();
    }
    isExpanded() {
        return this.providedColumnGroup.isExpanded();
    }
    setExpanded(expanded) {
        this.providedColumnGroup.setExpanded(expanded);
    }
    addDisplayedLeafColumns(leafColumns) {
        this.displayedChildren.forEach((child)=>{
            if ($7b57b57eaf5a9648$export$891484e65a02ec71(child)) leafColumns.push(child);
            else if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(child)) child.addDisplayedLeafColumns(leafColumns);
        });
    }
    addLeafColumns(leafColumns) {
        this.children.forEach((child)=>{
            if ($7b57b57eaf5a9648$export$891484e65a02ec71(child)) leafColumns.push(child);
            else if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(child)) child.addLeafColumns(leafColumns);
        });
    }
    getChildren() {
        return this.children;
    }
    getColumnGroupShow() {
        return this.providedColumnGroup.getColumnGroupShow();
    }
    getProvidedColumnGroup() {
        return this.providedColumnGroup;
    }
    getPaddingLevel() {
        const parent = this.getParent();
        if (!this.isPadding() || !parent || !parent.isPadding()) return 0;
        return 1 + parent.getPaddingLevel();
    }
    calculateDisplayedColumns() {
        this.displayedChildren = [];
        let parentWithExpansion = this;
        while(parentWithExpansion != null && parentWithExpansion.isPadding())parentWithExpansion = parentWithExpansion.getParent();
        const isExpandable = parentWithExpansion ? parentWithExpansion.getProvidedColumnGroup().isExpandable() : false;
        if (!isExpandable) {
            this.displayedChildren = this.children;
            this.dispatchLocalEvent({
                type: "displayedChildrenChanged"
            });
            return;
        }
        this.children.forEach((child)=>{
            const emptyGroup = $7b57b57eaf5a9648$export$1f44a60fc23f9028(child) && (!child.displayedChildren || !child.displayedChildren.length);
            if (emptyGroup) return;
            const headerGroupShow = child.getColumnGroupShow();
            switch(headerGroupShow){
                case "open":
                    if (parentWithExpansion.getProvidedColumnGroup().isExpanded()) this.displayedChildren.push(child);
                    break;
                case "closed":
                    if (!parentWithExpansion.getProvidedColumnGroup().isExpanded()) this.displayedChildren.push(child);
                    break;
                default:
                    this.displayedChildren.push(child);
                    break;
            }
        });
        this.dispatchLocalEvent({
            type: "displayedChildrenChanged"
        });
    }
};
// community-modules/core/src/columns/groupInstanceIdCreator.ts
var $7b57b57eaf5a9648$export$b3b24737a74261fb = class {
    constructor(){
        // this map contains keys to numbers, so we remember what the last call was
        this.existingIds = {};
    }
    getInstanceIdForKey(key) {
        const lastResult = this.existingIds[key];
        let result;
        if (typeof lastResult !== "number") result = 0;
        else result = lastResult + 1;
        this.existingIds[key] = result;
        return result;
    }
};
// community-modules/core/src/columns/visibleColsService.ts
var $7b57b57eaf5a9648$export$c550a8370fd215d9 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "visibleColsService";
        // for fast lookup, to see if a column or group is still visible
        this.colsAndGroupsMap = {};
        // leave level columns of the displayed trees
        this.columnsLeft = [];
        this.columnsRight = [];
        this.columnsCenter = [];
        // all three lists above combined
        this.columns = [];
        this.bodyWidth = 0;
        this.leftWidth = 0;
        this.rightWidth = 0;
        this.bodyWidthDirty = true;
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.columnSizeService = beans.columnSizeService;
        this.columnViewportService = beans.columnViewportService;
        this.eventDispatcher = beans.columnEventDispatcher;
    }
    refresh(source, skipTreeBuild = false) {
        if (!skipTreeBuild) this.buildTrees();
        this.updateOpenClosedVisibilityInColumnGroups();
        this.columnsLeft = $7b57b57eaf5a9648$var$pickDisplayedCols(this.treeLeft);
        this.columnsCenter = $7b57b57eaf5a9648$var$pickDisplayedCols(this.treeCenter);
        this.columnsRight = $7b57b57eaf5a9648$var$pickDisplayedCols(this.treeRight);
        this.joinColsAriaOrder();
        this.joinCols();
        this.setLeftValues(source);
        this.autoHeightCols = this.columns.filter((col)=>col.isAutoHeight());
        this.columnSizeService.refreshFlexedColumns();
        this.updateBodyWidths();
        this.columnViewportService.checkViewportColumns(false);
        this.setFirstRightAndLastLeftPinned(source);
        this.eventDispatcher.visibleCols();
    }
    // after setColumnWidth or updateGroupsAndPresentedCols
    updateBodyWidths() {
        const newBodyWidth = $7b57b57eaf5a9648$var$getWidthOfColsInList(this.columnsCenter);
        const newLeftWidth = $7b57b57eaf5a9648$var$getWidthOfColsInList(this.columnsLeft);
        const newRightWidth = $7b57b57eaf5a9648$var$getWidthOfColsInList(this.columnsRight);
        this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;
        const atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;
        if (atLeastOneChanged) {
            this.bodyWidth = newBodyWidth;
            this.leftWidth = newLeftWidth;
            this.rightWidth = newRightWidth;
            const evt = {
                type: "columnContainerWidthChanged"
            };
            this.eventService.dispatchEvent(evt);
            const event = {
                type: "displayedColumnsWidthChanged"
            };
            this.eventService.dispatchEvent(event);
        }
    }
    // sets the left pixel position of each column
    setLeftValues(source) {
        this.setLeftValuesOfCols(source);
        this.setLeftValuesOfGroups();
    }
    setFirstRightAndLastLeftPinned(source) {
        let lastLeft;
        let firstRight;
        if (this.gos.get("enableRtl")) {
            lastLeft = this.columnsLeft ? this.columnsLeft[0] : null;
            firstRight = this.columnsRight ? $7b57b57eaf5a9648$export$236389741107357f(this.columnsRight) : null;
        } else {
            lastLeft = this.columnsLeft ? $7b57b57eaf5a9648$export$236389741107357f(this.columnsLeft) : null;
            firstRight = this.columnsRight ? this.columnsRight[0] : null;
        }
        this.columnModel.getCols().forEach((col)=>{
            col.setLastLeftPinned(col === lastLeft, source);
            col.setFirstRightPinned(col === firstRight, source);
        });
    }
    buildTrees() {
        const cols = this.columnModel.getColsToShow();
        const leftCols = cols.filter((col)=>col.getPinned() == "left");
        const rightCols = cols.filter((col)=>col.getPinned() == "right");
        const centerCols = cols.filter((col)=>col.getPinned() != "left" && col.getPinned() != "right");
        const idCreator = new $7b57b57eaf5a9648$export$b3b24737a74261fb();
        this.treeLeft = this.createGroups({
            columns: leftCols,
            idCreator: idCreator,
            pinned: "left",
            oldDisplayedGroups: this.treeLeft
        });
        this.treeRight = this.createGroups({
            columns: rightCols,
            idCreator: idCreator,
            pinned: "right",
            oldDisplayedGroups: this.treeRight
        });
        this.treeCenter = this.createGroups({
            columns: centerCols,
            idCreator: idCreator,
            pinned: null,
            oldDisplayedGroups: this.treeCenter
        });
        this.updateColsAndGroupsMap();
    }
    clear() {
        this.columnsLeft = [];
        this.columnsRight = [];
        this.columnsCenter = [];
        this.columns = [];
        this.ariaOrderColumns = [];
    }
    joinColsAriaOrder() {
        const allColumns = this.columnModel.getCols();
        const pinnedLeft = [];
        const center = [];
        const pinnedRight = [];
        for (const col of allColumns){
            const pinned = col.getPinned();
            if (!pinned) center.push(col);
            else if (pinned === true || pinned === "left") pinnedLeft.push(col);
            else pinnedRight.push(col);
        }
        this.ariaOrderColumns = pinnedLeft.concat(center).concat(pinnedRight);
    }
    getAriaColIndex(colOrGroup) {
        let col;
        if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(colOrGroup)) col = colOrGroup.getLeafColumns()[0];
        else col = colOrGroup;
        return this.ariaOrderColumns.indexOf(col) + 1;
    }
    getAllAutoHeightCols() {
        return this.autoHeightCols;
    }
    setLeftValuesOfGroups() {
        [
            this.treeLeft,
            this.treeRight,
            this.treeCenter
        ].forEach((columns)=>{
            columns.forEach((column)=>{
                if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(column)) {
                    const columnGroup = column;
                    columnGroup.checkLeft();
                }
            });
        });
    }
    setLeftValuesOfCols(source) {
        const primaryCols = this.columnModel.getColDefCols();
        if (!primaryCols) return;
        const allColumns = this.columnModel.getCols().slice(0);
        const doingRtl = this.gos.get("enableRtl");
        [
            this.columnsLeft,
            this.columnsRight,
            this.columnsCenter
        ].forEach((columns)=>{
            if (doingRtl) {
                let left = $7b57b57eaf5a9648$var$getWidthOfColsInList(columns);
                columns.forEach((column)=>{
                    left -= column.getActualWidth();
                    column.setLeft(left, source);
                });
            } else {
                let left = 0;
                columns.forEach((column)=>{
                    column.setLeft(left, source);
                    left += column.getActualWidth();
                });
            }
            $7b57b57eaf5a9648$var$_removeAllFromUnorderedArray(allColumns, columns);
        });
        allColumns.forEach((column)=>{
            column.setLeft(null, source);
        });
    }
    joinCols() {
        if (this.gos.get("enableRtl")) this.columns = this.columnsRight.concat(this.columnsCenter).concat(this.columnsLeft);
        else this.columns = this.columnsLeft.concat(this.columnsCenter).concat(this.columnsRight);
    }
    getColsCenter() {
        return this.columnsCenter;
    }
    getAllTrees() {
        if (this.treeLeft && this.treeRight && this.treeCenter) return this.treeLeft.concat(this.treeCenter).concat(this.treeRight);
        return null;
    }
    // + headerRenderer -> setting pinned body width
    getTreeLeft() {
        return this.treeLeft;
    }
    // + headerRenderer -> setting pinned body width
    getTreeRight() {
        return this.treeRight;
    }
    // + headerRenderer -> setting pinned body width
    getTreeCenter() {
        return this.treeCenter;
    }
    // + csvCreator
    getAllCols() {
        return this.columns;
    }
    // gridPanel -> ensureColumnVisible
    isColDisplayed(column) {
        return this.getAllCols().indexOf(column) >= 0;
    }
    getLeftColsForRow(rowNode) {
        const colSpanActive = this.columnModel.isColSpanActive();
        if (!colSpanActive) return this.columnsLeft;
        return this.getColsForRow(rowNode, this.columnsLeft);
    }
    getRightColsForRow(rowNode) {
        const colSpanActive = this.columnModel.isColSpanActive();
        if (!colSpanActive) return this.columnsRight;
        return this.getColsForRow(rowNode, this.columnsRight);
    }
    getColsForRow(rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {
        const result = [];
        let lastConsideredCol = null;
        for(let i = 0; i < displayedColumns.length; i++){
            const col = displayedColumns[i];
            const maxAllowedColSpan = displayedColumns.length - i;
            const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);
            const columnsToCheckFilter = [
                col
            ];
            if (colSpan > 1) {
                const colsToRemove = colSpan - 1;
                for(let j = 1; j <= colsToRemove; j++)columnsToCheckFilter.push(displayedColumns[i + j]);
                i += colsToRemove;
            }
            let filterPasses;
            if (filterCallback) {
                filterPasses = false;
                columnsToCheckFilter.forEach((colForFilter)=>{
                    if (filterCallback(colForFilter)) filterPasses = true;
                });
            } else filterPasses = true;
            if (filterPasses) {
                if (result.length === 0 && lastConsideredCol) {
                    const gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;
                    if (gapBeforeColumn) result.push(lastConsideredCol);
                }
                result.push(col);
            }
            lastConsideredCol = col;
        }
        return result;
    }
    // used by:
    // + angularGrid -> for setting body width
    // + rowController -> setting main row widths (when inserting and resizing)
    // need to cache this
    getBodyContainerWidth() {
        return this.bodyWidth;
    }
    getContainerWidth(pinned) {
        switch(pinned){
            case "left":
                return this.leftWidth;
            case "right":
                return this.rightWidth;
            default:
                return this.bodyWidth;
        }
    }
    // + rowController -> while inserting rows
    getCenterCols() {
        return this.columnsCenter;
    }
    // + rowController -> while inserting rows
    getLeftCols() {
        return this.columnsLeft;
    }
    getRightCols() {
        return this.columnsRight;
    }
    getColBefore(col) {
        const allDisplayedColumns = this.getAllCols();
        const oldIndex = allDisplayedColumns.indexOf(col);
        if (oldIndex > 0) return allDisplayedColumns[oldIndex - 1];
        return null;
    }
    getGroupAtDirection(columnGroup, direction) {
        const requiredLevel = columnGroup.getProvidedColumnGroup().getLevel() + columnGroup.getPaddingLevel();
        const colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();
        const col = direction === "After" ? $7b57b57eaf5a9648$export$236389741107357f(colGroupLeafColumns) : colGroupLeafColumns[0];
        const getDisplayColMethod = `getCol${direction}`;
        while(true){
            const column = this[getDisplayColMethod](col);
            if (!column) return null;
            const groupPointer = this.getColGroupAtLevel(column, requiredLevel);
            if (groupPointer !== columnGroup) return groupPointer;
        }
    }
    getColGroupAtLevel(column, level) {
        let groupPointer = column.getParent();
        let originalGroupLevel;
        let groupPointerLevel;
        while(true){
            const groupPointerProvidedColumnGroup = groupPointer.getProvidedColumnGroup();
            originalGroupLevel = groupPointerProvidedColumnGroup.getLevel();
            groupPointerLevel = groupPointer.getPaddingLevel();
            if (originalGroupLevel + groupPointerLevel <= level) break;
            groupPointer = groupPointer.getParent();
        }
        return groupPointer;
    }
    isPinningLeft() {
        return this.columnsLeft.length > 0;
    }
    isPinningRight() {
        return this.columnsRight.length > 0;
    }
    updateColsAndGroupsMap() {
        this.colsAndGroupsMap = {};
        const func = (child)=>{
            this.colsAndGroupsMap[child.getUniqueId()] = child;
        };
        $7b57b57eaf5a9648$var$depthFirstAllColumnTreeSearch(this.treeCenter, false, func);
        $7b57b57eaf5a9648$var$depthFirstAllColumnTreeSearch(this.treeLeft, false, func);
        $7b57b57eaf5a9648$var$depthFirstAllColumnTreeSearch(this.treeRight, false, func);
    }
    isVisible(item) {
        const fromMap = this.colsAndGroupsMap[item.getUniqueId()];
        return fromMap === item;
    }
    updateOpenClosedVisibilityInColumnGroups() {
        const allColumnGroups = this.getAllTrees();
        $7b57b57eaf5a9648$var$depthFirstAllColumnTreeSearch(allColumnGroups, false, (child)=>{
            if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(child)) child.calculateDisplayedColumns();
        });
    }
    getFirstColumn() {
        const isRtl = this.gos.get("enableRtl");
        const queryOrder = [
            "getLeftCols",
            "getCenterCols",
            "getRightCols"
        ];
        if (isRtl) queryOrder.reverse();
        for(let i = 0; i < queryOrder.length; i++){
            const container = this[queryOrder[i]]();
            if (container.length) return isRtl ? $7b57b57eaf5a9648$export$236389741107357f(container) : container[0];
        }
        return null;
    }
    // returns the group with matching colId and instanceId. If instanceId is missing,
    // matches only on the colId.
    getColumnGroup(colId, partId) {
        if (!colId) return null;
        if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(colId)) return colId;
        const allColumnGroups = this.getAllTrees();
        const checkPartId = typeof partId === "number";
        let result = null;
        $7b57b57eaf5a9648$var$depthFirstAllColumnTreeSearch(allColumnGroups, false, (child)=>{
            if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(child)) {
                const columnGroup = child;
                let matched;
                if (checkPartId) matched = colId === columnGroup.getGroupId() && partId === columnGroup.getPartId();
                else matched = colId === columnGroup.getGroupId();
                if (matched) result = columnGroup;
            }
        });
        return result;
    }
    // used by:
    // + rowRenderer -> for navigation
    getColAfter(col) {
        const allDisplayedColumns = this.getAllCols();
        const oldIndex = allDisplayedColumns.indexOf(col);
        if (oldIndex < allDisplayedColumns.length - 1) return allDisplayedColumns[oldIndex + 1];
        return null;
    }
    isBodyWidthDirty() {
        return this.bodyWidthDirty;
    }
    setBodyWidthDirty() {
        this.bodyWidthDirty = true;
    }
    // used by:
    // + angularGrid -> setting pinned body width
    // note: this should be cached
    getColsLeftWidth() {
        return $7b57b57eaf5a9648$var$getWidthOfColsInList(this.columnsLeft);
    }
    // note: this should be cached
    getDisplayedColumnsRightWidth() {
        return $7b57b57eaf5a9648$var$getWidthOfColsInList(this.columnsRight);
    }
    isColAtEdge(col, edge) {
        const allColumns = this.getAllCols();
        if (!allColumns.length) return false;
        const isFirst = edge === "first";
        let columnToCompare;
        if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(col)) {
            const leafColumns = col.getDisplayedLeafColumns();
            if (!leafColumns.length) return false;
            columnToCompare = isFirst ? leafColumns[0] : $7b57b57eaf5a9648$export$236389741107357f(leafColumns);
        } else columnToCompare = col;
        return (isFirst ? allColumns[0] : $7b57b57eaf5a9648$export$236389741107357f(allColumns)) === columnToCompare;
    }
    createGroups(params) {
        const { columns: columns , idCreator: idCreator , pinned: pinned , oldDisplayedGroups: oldDisplayedGroups , isStandaloneStructure: isStandaloneStructure  } = params;
        const oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);
        const topLevelResultCols = [];
        let groupsOrColsAtCurrentLevel = columns;
        while(groupsOrColsAtCurrentLevel.length){
            const currentlyIterating = groupsOrColsAtCurrentLevel;
            groupsOrColsAtCurrentLevel = [];
            let lastGroupedColIdx = 0;
            const createGroupToIndex = (to)=>{
                const from = lastGroupedColIdx;
                lastGroupedColIdx = to;
                const previousNode = currentlyIterating[from];
                const previousNodeProvided = $7b57b57eaf5a9648$export$1f44a60fc23f9028(previousNode) ? previousNode.getProvidedColumnGroup() : previousNode;
                const previousNodeParent = previousNodeProvided.getOriginalParent();
                if (previousNodeParent == null) {
                    for(let i = from; i < to; i++)topLevelResultCols.push(currentlyIterating[i]);
                    return;
                }
                const newGroup = this.createColGroup(previousNodeParent, idCreator, oldColumnsMapped, pinned, isStandaloneStructure);
                for(let i = from; i < to; i++)newGroup.addChild(currentlyIterating[i]);
                groupsOrColsAtCurrentLevel.push(newGroup);
            };
            for(let i = 1; i < currentlyIterating.length; i++){
                const thisNode = currentlyIterating[i];
                const thisNodeProvided = $7b57b57eaf5a9648$export$1f44a60fc23f9028(thisNode) ? thisNode.getProvidedColumnGroup() : thisNode;
                const thisNodeParent = thisNodeProvided.getOriginalParent();
                const previousNode = currentlyIterating[lastGroupedColIdx];
                const previousNodeProvided = $7b57b57eaf5a9648$export$1f44a60fc23f9028(previousNode) ? previousNode.getProvidedColumnGroup() : previousNode;
                const previousNodeParent = previousNodeProvided.getOriginalParent();
                if (thisNodeParent !== previousNodeParent) createGroupToIndex(i);
            }
            if (lastGroupedColIdx < currentlyIterating.length) createGroupToIndex(currentlyIterating.length);
        }
        if (!isStandaloneStructure) this.setupParentsIntoCols(topLevelResultCols, null);
        return topLevelResultCols;
    }
    createColGroup(providedGroup, groupInstanceIdCreator, oldColumnsMapped, pinned, isStandaloneStructure) {
        const groupId = providedGroup.getGroupId();
        const instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
        const uniqueId = $7b57b57eaf5a9648$var$createUniqueColumnGroupId(groupId, instanceId);
        let columnGroup = oldColumnsMapped[uniqueId];
        if (columnGroup && columnGroup.getProvidedColumnGroup() !== providedGroup) columnGroup = null;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(columnGroup)) columnGroup.reset();
        else {
            columnGroup = new $7b57b57eaf5a9648$export$273c80940a54c770(providedGroup, groupId, instanceId, pinned);
            if (!isStandaloneStructure) this.createBean(columnGroup);
        }
        return columnGroup;
    }
    // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
    mapOldGroupsById(displayedGroups) {
        const result = {};
        const recursive = (columnsOrGroups)=>{
            columnsOrGroups.forEach((columnOrGroup)=>{
                if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(columnOrGroup)) {
                    const columnGroup = columnOrGroup;
                    result[columnOrGroup.getUniqueId()] = columnGroup;
                    recursive(columnGroup.getChildren());
                }
            });
        };
        if (displayedGroups) recursive(displayedGroups);
        return result;
    }
    setupParentsIntoCols(columnsOrGroups, parent) {
        columnsOrGroups.forEach((columnsOrGroup)=>{
            columnsOrGroup.setParent(parent);
            if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(columnsOrGroup)) {
                const columnGroup = columnsOrGroup;
                this.setupParentsIntoCols(columnGroup.getChildren(), columnGroup);
            }
        });
    }
};
function $7b57b57eaf5a9648$var$depthFirstAllColumnTreeSearch(tree, useDisplayedChildren, callback) {
    if (!tree) return;
    for(let i = 0; i < tree.length; i++){
        const child = tree[i];
        if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(child)) {
            const childTree = useDisplayedChildren ? child.getDisplayedChildren() : child.getChildren();
            $7b57b57eaf5a9648$var$depthFirstAllColumnTreeSearch(childTree, useDisplayedChildren, callback);
        }
        callback(child);
    }
}
function $7b57b57eaf5a9648$var$pickDisplayedCols(tree) {
    const res = [];
    $7b57b57eaf5a9648$var$depthFirstAllColumnTreeSearch(tree, true, (child)=>{
        if ($7b57b57eaf5a9648$export$891484e65a02ec71(child)) res.push(child);
    });
    return res;
}
// community-modules/core/src/eventTypes.ts
var $7b57b57eaf5a9648$var$PUBLIC_EVENTS = [
    "columnEverythingChanged",
    "newColumnsLoaded",
    "columnPivotModeChanged",
    "pivotMaxColumnsExceeded",
    "columnRowGroupChanged",
    "expandOrCollapseAll",
    "columnPivotChanged",
    "gridColumnsChanged",
    "columnValueChanged",
    "columnMoved",
    "columnVisible",
    "columnPinned",
    "columnGroupOpened",
    "columnResized",
    "displayedColumnsChanged",
    "virtualColumnsChanged",
    "columnHeaderMouseOver",
    "columnHeaderMouseLeave",
    "columnHeaderClicked",
    "columnHeaderContextMenu",
    "asyncTransactionsFlushed",
    "rowGroupOpened",
    "rowDataUpdated",
    "pinnedRowDataChanged",
    "rangeSelectionChanged",
    "chartCreated",
    "chartRangeSelectionChanged",
    "chartOptionsChanged",
    "chartDestroyed",
    "toolPanelVisibleChanged",
    "toolPanelSizeChanged",
    "modelUpdated",
    "cutStart",
    "cutEnd",
    "pasteStart",
    "pasteEnd",
    "fillStart",
    "fillEnd",
    "rangeDeleteStart",
    "rangeDeleteEnd",
    "undoStarted",
    "undoEnded",
    "redoStarted",
    "redoEnded",
    "cellClicked",
    "cellDoubleClicked",
    "cellMouseDown",
    "cellContextMenu",
    "cellValueChanged",
    "cellEditRequest",
    "rowValueChanged",
    "headerFocused",
    "cellFocused",
    "rowSelected",
    "selectionChanged",
    "tooltipShow",
    "tooltipHide",
    "cellKeyDown",
    "cellMouseOver",
    "cellMouseOut",
    "filterChanged",
    "filterModified",
    "filterOpened",
    "advancedFilterBuilderVisibleChanged",
    "sortChanged",
    "virtualRowRemoved",
    "rowClicked",
    "rowDoubleClicked",
    "gridReady",
    "gridPreDestroyed",
    "gridSizeChanged",
    "viewportChanged",
    "firstDataRendered",
    "dragStarted",
    "dragStopped",
    "rowEditingStarted",
    "rowEditingStopped",
    "cellEditingStarted",
    "cellEditingStopped",
    "bodyScroll",
    "bodyScrollEnd",
    "paginationChanged",
    "componentStateChanged",
    "storeRefreshed",
    "stateUpdated",
    "columnMenuVisibleChanged",
    "contextMenuVisibleChanged",
    "rowDragEnter",
    "rowDragMove",
    "rowDragLeave",
    "rowDragEnd"
];
var $7b57b57eaf5a9648$var$INTERNAL_EVENTS = [
    "scrollbarWidthChanged",
    "keyShortcutChangedCellStart",
    "keyShortcutChangedCellEnd",
    "pinnedHeightChanged",
    "cellFocusCleared",
    "fullWidthRowFocused",
    "checkboxChanged",
    "heightScaleChanged",
    "suppressMovableColumns",
    "suppressMenuHide",
    "suppressFieldDotNotation",
    "columnPanelItemDragStart",
    "columnPanelItemDragEnd",
    "bodyHeightChanged",
    "columnContainerWidthChanged",
    "displayedColumnsWidthChanged",
    "scrollVisibilityChanged",
    "columnHoverChanged",
    "flashCells",
    "paginationPixelOffsetChanged",
    "displayedRowsChanged",
    "leftPinnedWidthChanged",
    "rightPinnedWidthChanged",
    "rowContainerHeightChanged",
    "headerHeightChanged",
    "columnHeaderHeightChanged",
    "gridStylesChanged",
    "storeUpdated",
    "filterDestroyed",
    "rowDataUpdateStarted",
    "rowCountReady",
    "advancedFilterEnabledChanged",
    "dataTypesInferred",
    "fieldValueChanged",
    "fieldPickerValueSelected",
    "richSelectListRowSelected",
    "sideBarUpdated",
    "alignedGridScroll",
    "alignedGridColumn",
    "gridOptionsChanged",
    "chartTitleEdit",
    "recalculateRowBounds",
    "stickyTopOffsetChanged"
];
var $7b57b57eaf5a9648$var$ALL_EVENTS = [
    ...$7b57b57eaf5a9648$var$PUBLIC_EVENTS,
    ...$7b57b57eaf5a9648$var$INTERNAL_EVENTS
];
// community-modules/core/src/propertyKeys.ts
var $7b57b57eaf5a9648$var$INITIAL_GRID_OPTION_KEYS = {
    enableBrowserTooltips: true,
    tooltipTrigger: true,
    tooltipMouseTrack: true,
    tooltipShowMode: true,
    tooltipInteraction: true,
    defaultColGroupDef: true,
    suppressAutoSize: true,
    skipHeaderOnAutoSize: true,
    autoSizeStrategy: true,
    components: true,
    stopEditingWhenCellsLoseFocus: true,
    undoRedoCellEditing: true,
    undoRedoCellEditingLimit: true,
    excelStyles: true,
    cacheQuickFilter: true,
    advancedFilterModel: true,
    customChartThemes: true,
    chartThemeOverrides: true,
    chartToolPanelsDef: true,
    loadingCellRendererSelector: true,
    localeText: true,
    keepDetailRows: true,
    keepDetailRowsCount: true,
    detailRowHeight: true,
    detailRowAutoHeight: true,
    tabIndex: true,
    valueCache: true,
    valueCacheNeverExpires: true,
    enableCellExpressions: true,
    suppressTouch: true,
    suppressAsyncEvents: true,
    suppressBrowserResizeObserver: true,
    suppressPropertyNamesCheck: true,
    debug: true,
    loadingOverlayComponent: true,
    suppressLoadingOverlay: true,
    noRowsOverlayComponent: true,
    paginationPageSizeSelector: true,
    paginateChildRows: true,
    pivotPanelShow: true,
    pivotSuppressAutoColumn: true,
    suppressExpandablePivotGroups: true,
    aggFuncs: true,
    suppressAggFuncInHeader: true,
    removePivotHeaderRowWhenSingleValueColumn: true,
    allowShowChangeAfterFilter: true,
    ensureDomOrder: true,
    enableRtl: true,
    suppressColumnVirtualisation: true,
    suppressMaxRenderedRowRestriction: true,
    suppressRowVirtualisation: true,
    rowDragText: true,
    suppressGroupMaintainValueType: true,
    groupLockGroupColumns: true,
    rowGroupPanelSuppressSort: true,
    suppressGroupRowsSticky: true,
    rowModelType: true,
    cacheOverflowSize: true,
    infiniteInitialRowCount: true,
    serverSideInitialRowCount: true,
    suppressServerSideInfiniteScroll: true,
    maxBlocksInCache: true,
    maxConcurrentDatasourceRequests: true,
    blockLoadDebounceMillis: true,
    serverSideOnlyRefreshFilteredGroups: true,
    serverSidePivotResultFieldSeparator: true,
    viewportRowModelPageSize: true,
    viewportRowModelBufferSize: true,
    debounceVerticalScrollbar: true,
    suppressAnimationFrame: true,
    suppressPreventDefaultOnMouseWheel: true,
    scrollbarWidth: true,
    icons: true,
    suppressRowTransform: true,
    gridId: true,
    enableGroupEdit: true,
    initialState: true,
    processUnpinnedColumns: true,
    createChartContainer: true,
    getLocaleText: true,
    getRowId: true,
    reactiveCustomComponents: true,
    columnMenu: true
};
var $7b57b57eaf5a9648$var$_PropertyKeys = class _PropertyKeys {
};
$7b57b57eaf5a9648$var$_PropertyKeys.STRING_PROPERTIES = [
    "rowSelection",
    "overlayLoadingTemplate",
    "overlayNoRowsTemplate",
    "gridId",
    "quickFilterText",
    "rowModelType",
    "editType",
    "domLayout",
    "clipboardDelimiter",
    "rowGroupPanelShow",
    "multiSortKey",
    "pivotColumnGroupTotals",
    "pivotRowTotals",
    "pivotPanelShow",
    "fillHandleDirection",
    "groupDisplayType",
    "treeDataDisplayType",
    "colResizeDefault",
    "tooltipTrigger",
    "serverSidePivotResultFieldSeparator",
    "columnMenu",
    "tooltipShowMode",
    "grandTotalRow"
];
$7b57b57eaf5a9648$var$_PropertyKeys.OBJECT_PROPERTIES = [
    "components",
    "rowStyle",
    "context",
    "autoGroupColumnDef",
    "localeText",
    "icons",
    "datasource",
    "serverSideDatasource",
    "viewportDatasource",
    "groupRowRendererParams",
    "aggFuncs",
    "fullWidthCellRendererParams",
    "defaultColGroupDef",
    "defaultColDef",
    "defaultCsvExportParams",
    "defaultExcelExportParams",
    "columnTypes",
    "rowClassRules",
    "detailCellRendererParams",
    "loadingCellRendererParams",
    "loadingOverlayComponentParams",
    "noRowsOverlayComponentParams",
    "popupParent",
    "statusBar",
    "sideBar",
    "chartThemeOverrides",
    "customChartThemes",
    "chartToolPanelsDef",
    "dataTypeDefinitions",
    "advancedFilterModel",
    "advancedFilterParent",
    "advancedFilterBuilderParams",
    "initialState",
    "autoSizeStrategy"
];
$7b57b57eaf5a9648$var$_PropertyKeys.ARRAY_PROPERTIES = [
    "sortingOrder",
    "alignedGrids",
    "rowData",
    "columnDefs",
    "excelStyles",
    "pinnedTopRowData",
    "pinnedBottomRowData",
    "chartThemes",
    "rowClass",
    "paginationPageSizeSelector"
];
// These properties are coerced at runtime, do not do union types
$7b57b57eaf5a9648$var$_PropertyKeys.NUMBER_PROPERTIES = [
    "rowHeight",
    "detailRowHeight",
    "rowBuffer",
    "headerHeight",
    "groupHeaderHeight",
    "groupLockGroupColumns",
    "floatingFiltersHeight",
    "pivotHeaderHeight",
    "pivotGroupHeaderHeight",
    "groupDefaultExpanded",
    "pivotDefaultExpanded",
    "viewportRowModelPageSize",
    "viewportRowModelBufferSize",
    "autoSizePadding",
    "maxBlocksInCache",
    "maxConcurrentDatasourceRequests",
    "tooltipShowDelay",
    "tooltipHideDelay",
    "cacheOverflowSize",
    "paginationPageSize",
    "cacheBlockSize",
    "infiniteInitialRowCount",
    "serverSideInitialRowCount",
    "scrollbarWidth",
    "asyncTransactionWaitMillis",
    "blockLoadDebounceMillis",
    "keepDetailRowsCount",
    "undoRedoCellEditingLimit",
    "cellFlashDelay",
    "cellFadeDelay",
    "cellFlashDuration",
    "cellFadeDuration",
    "tabIndex",
    "pivotMaxGeneratedColumns"
];
// These properties are coerced at runtime, do not do union types
$7b57b57eaf5a9648$var$_PropertyKeys.BOOLEAN_PROPERTIES = [
    "suppressMakeColumnVisibleAfterUnGroup",
    "suppressRowClickSelection",
    "suppressCellFocus",
    "suppressHeaderFocus",
    "suppressHorizontalScroll",
    "groupSelectsChildren",
    "alwaysShowHorizontalScroll",
    "alwaysShowVerticalScroll",
    "debug",
    "enableBrowserTooltips",
    "enableCellExpressions",
    "groupIncludeTotalFooter",
    "groupSuppressBlankHeader",
    "suppressMenuHide",
    "suppressRowDeselection",
    "unSortIcon",
    "suppressMultiSort",
    "alwaysMultiSort",
    "singleClickEdit",
    "suppressLoadingOverlay",
    "suppressNoRowsOverlay",
    "suppressAutoSize",
    "skipHeaderOnAutoSize",
    "suppressColumnMoveAnimation",
    "suppressMovableColumns",
    "suppressFieldDotNotation",
    "enableRangeSelection",
    "enableRangeHandle",
    "enableFillHandle",
    "suppressClearOnFillReduction",
    "deltaSort",
    "suppressTouch",
    "suppressAsyncEvents",
    "allowContextMenuWithControlKey",
    "suppressContextMenu",
    "enableCellChangeFlash",
    "suppressDragLeaveHidesColumns",
    "suppressRowGroupHidesColumns",
    "suppressMiddleClickScrolls",
    "suppressPreventDefaultOnMouseWheel",
    "suppressCopyRowsToClipboard",
    "copyHeadersToClipboard",
    "copyGroupHeadersToClipboard",
    "pivotMode",
    "suppressAggFuncInHeader",
    "suppressColumnVirtualisation",
    "alwaysAggregateAtRootLevel",
    "suppressFocusAfterRefresh",
    "functionsReadOnly",
    "animateRows",
    "groupSelectsFiltered",
    "groupRemoveSingleChildren",
    "groupRemoveLowestSingleChildren",
    "enableRtl",
    "suppressClickEdit",
    "rowDragEntireRow",
    "rowDragManaged",
    "suppressRowDrag",
    "suppressMoveWhenRowDragging",
    "rowDragMultiRow",
    "enableGroupEdit",
    "embedFullWidthRows",
    "suppressPaginationPanel",
    "groupHideOpenParents",
    "groupAllowUnbalanced",
    "pagination",
    "paginationAutoPageSize",
    "suppressScrollOnNewData",
    "suppressScrollWhenPopupsAreOpen",
    "purgeClosedRowNodes",
    "cacheQuickFilter",
    "includeHiddenColumnsInQuickFilter",
    "ensureDomOrder",
    "accentedSort",
    "suppressChangeDetection",
    "valueCache",
    "valueCacheNeverExpires",
    "aggregateOnlyChangedColumns",
    "suppressAnimationFrame",
    "suppressExcelExport",
    "suppressCsvExport",
    "includeHiddenColumnsInAdvancedFilter",
    "suppressMultiRangeSelection",
    "enterNavigatesVerticallyAfterEdit",
    "enterNavigatesVertically",
    "suppressPropertyNamesCheck",
    "rowMultiSelectWithClick",
    "suppressRowHoverHighlight",
    "suppressRowTransform",
    "suppressClipboardPaste",
    "suppressLastEmptyLineOnPaste",
    "enableCharts",
    "suppressMaintainUnsortedOrder",
    "enableCellTextSelection",
    "suppressBrowserResizeObserver",
    "suppressMaxRenderedRowRestriction",
    "excludeChildrenWhenTreeDataFiltering",
    "tooltipMouseTrack",
    "tooltipInteraction",
    "keepDetailRows",
    "paginateChildRows",
    "preventDefaultOnContextMenu",
    "undoRedoCellEditing",
    "allowDragFromColumnsToolPanel",
    "pivotSuppressAutoColumn",
    "suppressExpandablePivotGroups",
    "debounceVerticalScrollbar",
    "detailRowAutoHeight",
    "serverSideSortAllLevels",
    "serverSideEnableClientSideSort",
    "serverSideOnlyRefreshFilteredGroups",
    "serverSideSortOnServer",
    "serverSideFilterOnServer",
    "suppressAggFilteredOnly",
    "showOpenedGroup",
    "suppressClipboardApi",
    "suppressModelUpdateAfterUpdateTransaction",
    "stopEditingWhenCellsLoseFocus",
    "maintainColumnOrder",
    "groupMaintainOrder",
    "columnHoverHighlight",
    "readOnlyEdit",
    "suppressRowVirtualisation",
    "enableCellEditingOnBackspace",
    "resetRowDataOnUpdate",
    "removePivotHeaderRowWhenSingleValueColumn",
    "suppressCopySingleCellRanges",
    "suppressGroupRowsSticky",
    "suppressCutToClipboard",
    "suppressServerSideInfiniteScroll",
    "rowGroupPanelSuppressSort",
    "allowShowChangeAfterFilter",
    "enableAdvancedFilter",
    "masterDetail",
    "treeData",
    "suppressGroupMaintainValueType",
    "reactiveCustomComponents",
    "applyQuickFilterBeforePivotOrAgg",
    "suppressServerSideFullWidthLoadingRow",
    "suppressAdvancedFilterEval",
    "loading"
];
// If property does not fit above, i.e union that should not be coerced.
$7b57b57eaf5a9648$var$_PropertyKeys.OTHER_PROPERTIES = [
    "suppressStickyTotalRow"
];
$7b57b57eaf5a9648$var$_PropertyKeys.FUNCTION_PROPERTIES = [
    "doesExternalFilterPass",
    "processPivotResultColDef",
    "processPivotResultColGroupDef",
    "getBusinessKeyForNode",
    "isRowSelectable",
    "rowDragText",
    "groupRowRenderer",
    "fullWidthCellRenderer",
    "loadingCellRenderer",
    "loadingOverlayComponent",
    "noRowsOverlayComponent",
    "detailCellRenderer",
    "quickFilterParser",
    "quickFilterMatcher",
    "getLocaleText",
    "isExternalFilterPresent",
    "getRowHeight",
    "getRowClass",
    "getRowStyle",
    "getContextMenuItems",
    "getMainMenuItems",
    "processRowPostCreate",
    "processCellForClipboard",
    "getGroupRowAgg",
    "isFullWidthRow",
    "sendToClipboard",
    "focusGridInnerElement",
    "navigateToNextHeader",
    "tabToNextHeader",
    "navigateToNextCell",
    "tabToNextCell",
    "processCellFromClipboard",
    "getDocument",
    "postProcessPopup",
    "getChildCount",
    "getDataPath",
    "isRowMaster",
    "postSortRows",
    "processHeaderForClipboard",
    "processUnpinnedColumns",
    "processGroupHeaderForClipboard",
    "paginationNumberFormatter",
    "processDataFromClipboard",
    "getServerSideGroupKey",
    "isServerSideGroup",
    "createChartContainer",
    "getChartToolbarItems",
    "fillOperation",
    "isApplyServerSideTransaction",
    "getServerSideGroupLevelParams",
    "isServerSideGroupOpenByDefault",
    "isGroupOpenByDefault",
    "initialGroupOrderComparator",
    "groupIncludeFooter",
    "loadingCellRendererSelector",
    "getRowId",
    "groupAggFiltering",
    "chartMenuItems",
    "groupTotalRow"
];
$7b57b57eaf5a9648$var$_PropertyKeys.ALL_PROPERTIES = [
    ...$7b57b57eaf5a9648$var$_PropertyKeys.ARRAY_PROPERTIES,
    ...$7b57b57eaf5a9648$var$_PropertyKeys.OBJECT_PROPERTIES,
    ...$7b57b57eaf5a9648$var$_PropertyKeys.STRING_PROPERTIES,
    ...$7b57b57eaf5a9648$var$_PropertyKeys.NUMBER_PROPERTIES,
    ...$7b57b57eaf5a9648$var$_PropertyKeys.FUNCTION_PROPERTIES,
    ...$7b57b57eaf5a9648$var$_PropertyKeys.BOOLEAN_PROPERTIES,
    ...$7b57b57eaf5a9648$var$_PropertyKeys.OTHER_PROPERTIES
];
var $7b57b57eaf5a9648$export$4d1a0127671c9c1f = $7b57b57eaf5a9648$var$_PropertyKeys;
// community-modules/core/src/components/componentUtil.ts
var $7b57b57eaf5a9648$var$_ComponentUtil = class _ComponentUtil {
    static getCallbackForEvent(eventName) {
        if (!eventName || eventName.length < 2) return eventName;
        return "on" + eventName[0].toUpperCase() + eventName.substring(1);
    }
};
$7b57b57eaf5a9648$var$_ComponentUtil.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY";
$7b57b57eaf5a9648$var$_ComponentUtil.PUBLIC_EVENTS = $7b57b57eaf5a9648$var$PUBLIC_EVENTS;
// onXXX methods, based on the above events
$7b57b57eaf5a9648$var$_ComponentUtil.EVENT_CALLBACKS = $7b57b57eaf5a9648$var$ALL_EVENTS.map((event)=>$7b57b57eaf5a9648$var$_ComponentUtil.getCallbackForEvent(event));
$7b57b57eaf5a9648$var$_ComponentUtil.BOOLEAN_PROPERTIES = $7b57b57eaf5a9648$export$4d1a0127671c9c1f.BOOLEAN_PROPERTIES;
$7b57b57eaf5a9648$var$_ComponentUtil.ALL_PROPERTIES = $7b57b57eaf5a9648$export$4d1a0127671c9c1f.ALL_PROPERTIES;
$7b57b57eaf5a9648$var$_ComponentUtil.ALL_PROPERTIES_AND_CALLBACKS = [
    ...$7b57b57eaf5a9648$var$_ComponentUtil.ALL_PROPERTIES,
    ...$7b57b57eaf5a9648$var$_ComponentUtil.EVENT_CALLBACKS
];
$7b57b57eaf5a9648$var$_ComponentUtil.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set($7b57b57eaf5a9648$var$_ComponentUtil.ALL_PROPERTIES_AND_CALLBACKS);
var $7b57b57eaf5a9648$export$1f1b72b628161f7c = $7b57b57eaf5a9648$var$_ComponentUtil;
function $7b57b57eaf5a9648$export$bfe37fc2d3c03134(gridOptions, component) {
    if (typeof gridOptions !== "object") gridOptions = {};
    const mergedOptions = {
        ...gridOptions
    };
    const keys = $7b57b57eaf5a9648$export$1f1b72b628161f7c.ALL_PROPERTIES_AND_CALLBACKS;
    keys.forEach((key)=>{
        const value = component[key];
        if (typeof value !== "undefined" && value !== $7b57b57eaf5a9648$export$1f1b72b628161f7c.VUE_OMITTED_PROPERTY) mergedOptions[key] = value;
    });
    return mergedOptions;
}
function $7b57b57eaf5a9648$export$52208033bd24c2b2(changes, api) {
    if (!changes) return;
    const gridChanges = {};
    let hasChanges = false;
    Object.keys(changes).filter((key)=>$7b57b57eaf5a9648$export$1f1b72b628161f7c.ALL_PROPERTIES_AND_CALLBACKS_SET.has(key)).forEach((key)=>{
        gridChanges[key] = changes[key];
        hasChanges = true;
    });
    if (!hasChanges) return;
    const internalUpdateEvent = {
        type: "gridOptionsChanged",
        options: gridChanges
    };
    api.dispatchEvent(internalUpdateEvent);
    const event = {
        type: "componentStateChanged"
    };
    $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(gridChanges, (key, value)=>{
        event[key] = value;
    });
    api.dispatchEvent(event);
}
// community-modules/core/src/rendering/cssClassManager.ts
var $7b57b57eaf5a9648$export$a7053cb7eb605bd2 = class {
    constructor(getGui){
        // to minimise DOM hits, we only apply CSS classes if they have changed. as adding a CSS class that is already
        // there, or removing one that wasn't present, all takes CPU.
        this.cssClassStates = {};
        this.getGui = getGui;
    }
    addCssClass(className) {
        const list = (className || "").split(" ");
        if (list.length > 1) {
            list.forEach((cls)=>this.addCssClass(cls));
            return;
        }
        const updateNeeded = this.cssClassStates[className] !== true;
        if (updateNeeded && className.length) {
            const eGui = this.getGui();
            if (eGui) eGui.classList.add(className);
            this.cssClassStates[className] = true;
        }
    }
    removeCssClass(className) {
        const list = (className || "").split(" ");
        if (list.length > 1) {
            list.forEach((cls)=>this.removeCssClass(cls));
            return;
        }
        const updateNeeded = this.cssClassStates[className] !== false;
        if (updateNeeded && className.length) {
            const eGui = this.getGui();
            if (eGui) eGui.classList.remove(className);
            this.cssClassStates[className] = false;
        }
    }
    containsCssClass(className) {
        const eGui = this.getGui();
        if (!eGui) return false;
        return eGui.classList.contains(className);
    }
    addOrRemoveCssClass(className, addOrRemove) {
        if (!className) return;
        if (className.indexOf(" ") >= 0) {
            const list = (className || "").split(" ");
            if (list.length > 1) {
                list.forEach((cls)=>this.addOrRemoveCssClass(cls, addOrRemove));
                return;
            }
        }
        const updateNeeded = this.cssClassStates[className] !== addOrRemove;
        if (updateNeeded && className.length) {
            const eGui = this.getGui();
            if (eGui) eGui.classList.toggle(className, addOrRemove);
            this.cssClassStates[className] = addOrRemove;
        }
    }
};
// community-modules/core/src/utils/aria.ts
function $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, attribute, value) {
    if (value == null || typeof value === "string" && value == "") $7b57b57eaf5a9648$var$_removeAriaAttribute(element, attribute);
    else $7b57b57eaf5a9648$var$_setAriaAttribute(element, attribute, value);
}
function $7b57b57eaf5a9648$var$_setAriaAttribute(element, attribute, value) {
    element.setAttribute($7b57b57eaf5a9648$var$_ariaAttributeName(attribute), value.toString());
}
function $7b57b57eaf5a9648$var$_removeAriaAttribute(element, attribute) {
    element.removeAttribute($7b57b57eaf5a9648$var$_ariaAttributeName(attribute));
}
function $7b57b57eaf5a9648$var$_ariaAttributeName(attribute) {
    return `aria-${attribute}`;
}
function $7b57b57eaf5a9648$export$f8d01fa01787902(element, role) {
    if (role) element.setAttribute("role", role);
    else element.removeAttribute("role");
}
function $7b57b57eaf5a9648$var$_getAriaSortState(sortDirection) {
    let sort;
    if (sortDirection === "asc") sort = "ascending";
    else if (sortDirection === "desc") sort = "descending";
    else if (sortDirection === "mixed") sort = "other";
    else sort = "none";
    return sort;
}
function $7b57b57eaf5a9648$export$70c3a20563598672(element) {
    return parseInt(element.getAttribute("aria-posinset"), 10);
}
function $7b57b57eaf5a9648$var$_getAriaLabel(element) {
    return element.getAttribute("aria-label");
}
function $7b57b57eaf5a9648$export$e81cb0dd07f289f6(element, label) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "label", label);
}
function $7b57b57eaf5a9648$export$84233c40c4c74001(element, labelledBy) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "labelledby", labelledBy);
}
function $7b57b57eaf5a9648$export$3c2bc877474a7797(element, describedby) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "describedby", describedby);
}
function $7b57b57eaf5a9648$var$_setAriaLive(element, live) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "live", live);
}
function $7b57b57eaf5a9648$var$_setAriaAtomic(element, atomic) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "atomic", atomic);
}
function $7b57b57eaf5a9648$var$_setAriaRelevant(element, relevant) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "relevant", relevant);
}
function $7b57b57eaf5a9648$export$9eaf1f20171625e8(element, level) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "level", level);
}
function $7b57b57eaf5a9648$export$7ed376f43c6f2bbd(element, disabled) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "disabled", disabled);
}
function $7b57b57eaf5a9648$export$ee52c2b3744c455d(element, hidden) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "hidden", hidden);
}
function $7b57b57eaf5a9648$export$5db804730c3c8346(element, descendantId) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "activedescendant", descendantId);
}
function $7b57b57eaf5a9648$export$3ad3518dddf15485(element, expanded) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "expanded", expanded);
}
function $7b57b57eaf5a9648$export$2254dfb132f01330(element) {
    $7b57b57eaf5a9648$var$_removeAriaAttribute(element, "expanded");
}
function $7b57b57eaf5a9648$export$3d494c2007bbcac1(element, setsize) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "setsize", setsize);
}
function $7b57b57eaf5a9648$export$c3d3aede41065a84(element, position) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "posinset", position);
}
function $7b57b57eaf5a9648$var$_setAriaMultiSelectable(element, multiSelectable) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "multiselectable", multiSelectable);
}
function $7b57b57eaf5a9648$export$1ad8496b26b660f8(element, rowCount) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "rowcount", rowCount);
}
function $7b57b57eaf5a9648$export$ba731dedf9d88615(element, rowIndex) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "rowindex", rowIndex);
}
function $7b57b57eaf5a9648$export$56744a26086b5898(element, colCount) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "colcount", colCount);
}
function $7b57b57eaf5a9648$export$84b73ecd0b234e89(element, colIndex) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "colindex", colIndex);
}
function $7b57b57eaf5a9648$export$371d80f0281454ce(element, colSpan) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "colspan", colSpan);
}
function $7b57b57eaf5a9648$export$c8dd030b968c6fd2(element, sort) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "sort", sort);
}
function $7b57b57eaf5a9648$export$26c7aa61eda05134(element) {
    $7b57b57eaf5a9648$var$_removeAriaAttribute(element, "sort");
}
function $7b57b57eaf5a9648$export$c22e3722e8a33469(element, selected) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(element, "selected", selected);
}
function $7b57b57eaf5a9648$export$43b4d6c0ec0fa4c7(element, checked) {
    $7b57b57eaf5a9648$var$_setAriaAttribute(element, "checked", checked === void 0 ? "mixed" : checked);
}
function $7b57b57eaf5a9648$export$26fd6a3f123d4e67(controllerElement, controlledElement) {
    $7b57b57eaf5a9648$var$_toggleAriaAttribute(controllerElement, "controls", controlledElement.id);
    $7b57b57eaf5a9648$export$84233c40c4c74001(controlledElement, controllerElement.id);
}
function $7b57b57eaf5a9648$var$_getAriaCheckboxStateName(translate, state) {
    return state === void 0 ? translate("ariaIndeterminate", "indeterminate") : state === true ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
}
// community-modules/core/src/utils/browser.ts
var $7b57b57eaf5a9648$var$isSafari;
var $7b57b57eaf5a9648$var$safariVersion;
var $7b57b57eaf5a9648$var$isChrome;
var $7b57b57eaf5a9648$var$isFirefox;
var $7b57b57eaf5a9648$var$isMacOs;
var $7b57b57eaf5a9648$var$isIOS;
var $7b57b57eaf5a9648$var$invisibleScrollbar;
var $7b57b57eaf5a9648$var$browserScrollbarWidth;
function $7b57b57eaf5a9648$var$_isBrowserSafari() {
    if ($7b57b57eaf5a9648$var$isSafari === void 0) $7b57b57eaf5a9648$var$isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    return $7b57b57eaf5a9648$var$isSafari;
}
function $7b57b57eaf5a9648$var$_getSafariVersion() {
    if ($7b57b57eaf5a9648$var$safariVersion === void 0) {
        if ($7b57b57eaf5a9648$var$_isBrowserSafari()) {
            const versionMatch = navigator.userAgent.match(/version\/(\d+)/i);
            if (versionMatch) $7b57b57eaf5a9648$var$safariVersion = versionMatch[1] != null ? parseFloat(versionMatch[1]) : 0;
        } else $7b57b57eaf5a9648$var$safariVersion = 0;
    }
    return $7b57b57eaf5a9648$var$safariVersion;
}
function $7b57b57eaf5a9648$var$_isBrowserChrome() {
    if ($7b57b57eaf5a9648$var$isChrome === void 0) {
        const win = window;
        $7b57b57eaf5a9648$var$isChrome = !!win.chrome && (!!win.chrome.webstore || !!win.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }
    return $7b57b57eaf5a9648$var$isChrome;
}
function $7b57b57eaf5a9648$var$_isBrowserFirefox() {
    if ($7b57b57eaf5a9648$var$isFirefox === void 0) $7b57b57eaf5a9648$var$isFirefox = /(firefox)/i.test(navigator.userAgent);
    return $7b57b57eaf5a9648$var$isFirefox;
}
function $7b57b57eaf5a9648$var$_isMacOsUserAgent() {
    if ($7b57b57eaf5a9648$var$isMacOs === void 0) $7b57b57eaf5a9648$var$isMacOs = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
    return $7b57b57eaf5a9648$var$isMacOs;
}
function $7b57b57eaf5a9648$export$6b6034a68325bd8a() {
    if ($7b57b57eaf5a9648$var$isIOS === void 0) $7b57b57eaf5a9648$var$isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
    return $7b57b57eaf5a9648$var$isIOS;
}
function $7b57b57eaf5a9648$var$_browserSupportsPreventScroll() {
    return !$7b57b57eaf5a9648$var$_isBrowserSafari() || $7b57b57eaf5a9648$var$_getSafariVersion() >= 15;
}
function $7b57b57eaf5a9648$var$_getTabIndex(el) {
    if (!el) return null;
    const numberTabIndex = el.tabIndex;
    const tabIndex = el.getAttribute("tabIndex");
    if (numberTabIndex === -1 && (tabIndex === null || tabIndex === "" && !$7b57b57eaf5a9648$var$_isBrowserFirefox())) return null;
    return numberTabIndex.toString();
}
function $7b57b57eaf5a9648$var$_getMaxDivHeight() {
    if (!document.body) return -1;
    let res = 1e6;
    const testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9;
    const div = document.createElement("div");
    document.body.appendChild(div);
    while(true){
        const test = res * 2;
        div.style.height = test + "px";
        if (test > testUpTo || div.clientHeight !== test) break;
        else res = test;
    }
    document.body.removeChild(div);
    return res;
}
function $7b57b57eaf5a9648$var$_getBodyWidth() {
    return document.body?.clientWidth ?? (window.innerHeight || document.documentElement?.clientWidth || -1);
}
function $7b57b57eaf5a9648$var$_getBodyHeight() {
    return document.body?.clientHeight ?? (window.innerHeight || document.documentElement?.clientHeight || -1);
}
function $7b57b57eaf5a9648$var$_getScrollbarWidth() {
    if ($7b57b57eaf5a9648$var$browserScrollbarWidth == null) $7b57b57eaf5a9648$var$initScrollbarWidthAndVisibility();
    return $7b57b57eaf5a9648$var$browserScrollbarWidth;
}
function $7b57b57eaf5a9648$var$initScrollbarWidthAndVisibility() {
    const body = document.body;
    const div = document.createElement("div");
    div.style.width = div.style.height = "100px";
    div.style.opacity = "0";
    div.style.overflow = "scroll";
    div.style.msOverflowStyle = "scrollbar";
    div.style.position = "absolute";
    body.appendChild(div);
    let width = div.offsetWidth - div.clientWidth;
    if (width === 0 && div.clientWidth === 0) width = null;
    if (div.parentNode) div.parentNode.removeChild(div);
    if (width != null) {
        $7b57b57eaf5a9648$var$browserScrollbarWidth = width;
        $7b57b57eaf5a9648$var$invisibleScrollbar = width === 0;
    }
}
function $7b57b57eaf5a9648$var$_isInvisibleScrollbar() {
    if ($7b57b57eaf5a9648$var$invisibleScrollbar == null) $7b57b57eaf5a9648$var$initScrollbarWidthAndVisibility();
    return $7b57b57eaf5a9648$var$invisibleScrollbar;
}
// community-modules/core/src/utils/dom.ts
var $7b57b57eaf5a9648$var$rtlNegativeScroll;
function $7b57b57eaf5a9648$export$605571c1b2992cfe(element, elementClass, otherElementClass) {
    const parent = element.parentElement;
    let sibling = parent && parent.firstChild;
    while(sibling){
        if (elementClass) sibling.classList.toggle(elementClass, sibling === element);
        if (otherElementClass) sibling.classList.toggle(otherElementClass, sibling !== element);
        sibling = sibling.nextSibling;
    }
}
var $7b57b57eaf5a9648$var$FOCUSABLE_SELECTOR = "[tabindex], input, select, button, textarea, [href]";
var $7b57b57eaf5a9648$var$FOCUSABLE_EXCLUDE = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function $7b57b57eaf5a9648$var$_isFocusableFormField(element) {
    const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
    const inputSelector = "input, select, button, textarea";
    const isFocusable = matches.call(element, inputSelector);
    const isNotFocusable = matches.call(element, $7b57b57eaf5a9648$var$FOCUSABLE_EXCLUDE);
    const isElementVisible = $7b57b57eaf5a9648$export$2badf4aa566524cb(element);
    const focusable = isFocusable && !isNotFocusable && isElementVisible;
    return focusable;
}
function $7b57b57eaf5a9648$export$9405f1cbb4e2383f(element, displayed, options = {}) {
    const { skipAriaHidden: skipAriaHidden  } = options;
    element.classList.toggle("ag-hidden", !displayed);
    if (!skipAriaHidden) $7b57b57eaf5a9648$export$ee52c2b3744c455d(element, !displayed);
}
function $7b57b57eaf5a9648$export$a6c2c477cd60daa8(element, visible, options = {}) {
    const { skipAriaHidden: skipAriaHidden  } = options;
    element.classList.toggle("ag-invisible", !visible);
    if (!skipAriaHidden) $7b57b57eaf5a9648$export$ee52c2b3744c455d(element, !visible);
}
function $7b57b57eaf5a9648$export$b6b4f08392e9bfaf(element, disabled) {
    const attributeName = "disabled";
    const addOrRemoveDisabledAttribute = disabled ? (e)=>e.setAttribute(attributeName, "") : (e)=>e.removeAttribute(attributeName);
    addOrRemoveDisabledAttribute(element);
    $7b57b57eaf5a9648$var$_nodeListForEach(element.querySelectorAll("input"), (input)=>addOrRemoveDisabledAttribute(input));
}
function $7b57b57eaf5a9648$var$_isElementChildOfClass(element, cls, maxNest) {
    let counter = 0;
    while(element){
        if (element.classList.contains(cls)) return true;
        element = element.parentElement;
        if (typeof maxNest == "number") {
            if (++counter > maxNest) break;
        } else if (element === maxNest) break;
    }
    return false;
}
function $7b57b57eaf5a9648$var$_getElementSize(el) {
    const { height: height , width: width , borderTopWidth: borderTopWidth , borderRightWidth: borderRightWidth , borderBottomWidth: borderBottomWidth , borderLeftWidth: borderLeftWidth , paddingTop: paddingTop , paddingRight: paddingRight , paddingBottom: paddingBottom , paddingLeft: paddingLeft , marginTop: marginTop , marginRight: marginRight , marginBottom: marginBottom , marginLeft: marginLeft , boxSizing: boxSizing  } = window.getComputedStyle(el);
    return {
        height: parseFloat(height || "0"),
        width: parseFloat(width || "0"),
        borderTopWidth: parseFloat(borderTopWidth || "0"),
        borderRightWidth: parseFloat(borderRightWidth || "0"),
        borderBottomWidth: parseFloat(borderBottomWidth || "0"),
        borderLeftWidth: parseFloat(borderLeftWidth || "0"),
        paddingTop: parseFloat(paddingTop || "0"),
        paddingRight: parseFloat(paddingRight || "0"),
        paddingBottom: parseFloat(paddingBottom || "0"),
        paddingLeft: parseFloat(paddingLeft || "0"),
        marginTop: parseFloat(marginTop || "0"),
        marginRight: parseFloat(marginRight || "0"),
        marginBottom: parseFloat(marginBottom || "0"),
        marginLeft: parseFloat(marginLeft || "0"),
        boxSizing: boxSizing
    };
}
function $7b57b57eaf5a9648$export$c20e968103d9c16e(el) {
    const size = $7b57b57eaf5a9648$var$_getElementSize(el);
    if (size.boxSizing === "border-box") return size.height - size.paddingTop - size.paddingBottom;
    return size.height;
}
function $7b57b57eaf5a9648$export$cc615e4191ec3e0c(el) {
    const size = $7b57b57eaf5a9648$var$_getElementSize(el);
    if (size.boxSizing === "border-box") return size.width - size.paddingLeft - size.paddingRight;
    return size.width;
}
function $7b57b57eaf5a9648$export$d23c22492e0f7c0c(el) {
    const { height: height , marginBottom: marginBottom , marginTop: marginTop  } = $7b57b57eaf5a9648$var$_getElementSize(el);
    return Math.floor(height + marginBottom + marginTop);
}
function $7b57b57eaf5a9648$export$642efcb17474eb51(el) {
    const { width: width , marginLeft: marginLeft , marginRight: marginRight  } = $7b57b57eaf5a9648$var$_getElementSize(el);
    return Math.floor(width + marginLeft + marginRight);
}
function $7b57b57eaf5a9648$var$_getElementRectWithOffset(el) {
    const offsetElementRect = el.getBoundingClientRect();
    const { borderTopWidth: borderTopWidth , borderLeftWidth: borderLeftWidth , borderRightWidth: borderRightWidth , borderBottomWidth: borderBottomWidth  } = $7b57b57eaf5a9648$var$_getElementSize(el);
    return {
        top: offsetElementRect.top + (borderTopWidth || 0),
        left: offsetElementRect.left + (borderLeftWidth || 0),
        right: offsetElementRect.right + (borderRightWidth || 0),
        bottom: offsetElementRect.bottom + (borderBottomWidth || 0)
    };
}
function $7b57b57eaf5a9648$var$_isRtlNegativeScroll() {
    if (typeof $7b57b57eaf5a9648$var$rtlNegativeScroll === "boolean") return $7b57b57eaf5a9648$var$rtlNegativeScroll;
    const template = document.createElement("div");
    template.style.direction = "rtl";
    template.style.width = "1px";
    template.style.height = "1px";
    template.style.position = "fixed";
    template.style.top = "0px";
    template.style.overflow = "hidden";
    template.dir = "rtl";
    template.innerHTML = /* html */ `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`;
    document.body.appendChild(template);
    template.scrollLeft = 1;
    $7b57b57eaf5a9648$var$rtlNegativeScroll = Math.floor(template.scrollLeft) === 0;
    document.body.removeChild(template);
    return $7b57b57eaf5a9648$var$rtlNegativeScroll;
}
function $7b57b57eaf5a9648$var$_getScrollLeft(element, rtl) {
    let scrollLeft = element.scrollLeft;
    if (rtl) {
        scrollLeft = Math.abs(scrollLeft);
        if ($7b57b57eaf5a9648$var$_isBrowserChrome() && !$7b57b57eaf5a9648$var$_isRtlNegativeScroll()) scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
    }
    return scrollLeft;
}
function $7b57b57eaf5a9648$var$_setScrollLeft(element, value, rtl) {
    if (rtl) {
        if ($7b57b57eaf5a9648$var$_isRtlNegativeScroll()) value *= -1;
        else if ($7b57b57eaf5a9648$var$_isBrowserSafari() || $7b57b57eaf5a9648$var$_isBrowserChrome()) value = element.scrollWidth - element.clientWidth - value;
    }
    element.scrollLeft = value;
}
function $7b57b57eaf5a9648$export$69e6e10709eabd91(el) {
    while(el && el.firstChild)el.removeChild(el.firstChild);
}
function $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(node) {
    if (node && node.parentNode) node.parentNode.removeChild(node);
}
function $7b57b57eaf5a9648$var$_isInDOM(element) {
    return !!element.offsetParent;
}
function $7b57b57eaf5a9648$export$2badf4aa566524cb(element) {
    const el = element;
    if (el.checkVisibility) return el.checkVisibility({
        checkVisibilityCSS: true
    });
    const isHidden = !$7b57b57eaf5a9648$var$_isInDOM(element) || window.getComputedStyle(element).visibility !== "visible";
    return !isHidden;
}
function $7b57b57eaf5a9648$export$b1f57d075ca6d5fb(template) {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = (template || "").trim();
    return tempDiv.firstChild;
}
function $7b57b57eaf5a9648$var$_ensureDomOrder(eContainer, eChild, eChildBefore) {
    if (eChildBefore && eChildBefore.nextSibling === eChild) return;
    if (eChildBefore) {
        if (eChildBefore.nextSibling) eContainer.insertBefore(eChild, eChildBefore.nextSibling);
        else eContainer.appendChild(eChild);
    } else if (eContainer.firstChild && eContainer.firstChild !== eChild) eContainer.insertAdjacentElement("afterbegin", eChild);
}
function $7b57b57eaf5a9648$var$_setDomChildOrder(eContainer, orderedChildren) {
    for(let i = 0; i < orderedChildren.length; i++){
        const correctCellAtIndex = orderedChildren[i];
        const actualCellAtIndex = eContainer.children[i];
        if (actualCellAtIndex !== correctCellAtIndex) eContainer.insertBefore(correctCellAtIndex, actualCellAtIndex);
    }
}
function $7b57b57eaf5a9648$var$_insertWithDomOrder(eContainer, eToInsert, eChildBefore) {
    if (eChildBefore) eChildBefore.insertAdjacentElement("afterend", eToInsert);
    else if (eContainer.firstChild) eContainer.insertAdjacentElement("afterbegin", eToInsert);
    else eContainer.appendChild(eToInsert);
}
function $7b57b57eaf5a9648$var$_addStylesToElement(eElement, styles) {
    if (!styles) return;
    for (const [key, value] of Object.entries(styles)){
        if (!key || !key.length || value == null) continue;
        const parsedKey = $7b57b57eaf5a9648$var$_camelCaseToHyphenated(key);
        const valueAsString = value.toString();
        const parsedValue = valueAsString.replace(/\s*!important/g, "");
        const priority = parsedValue.length != valueAsString.length ? "important" : void 0;
        eElement.style.setProperty(parsedKey, parsedValue, priority);
    }
}
function $7b57b57eaf5a9648$var$_isHorizontalScrollShowing(element) {
    return element.clientWidth < element.scrollWidth;
}
function $7b57b57eaf5a9648$var$_isVerticalScrollShowing(element) {
    return element.clientHeight < element.scrollHeight;
}
function $7b57b57eaf5a9648$var$_setElementWidth(element, width) {
    if (width === "flex") {
        element.style.removeProperty("width");
        element.style.removeProperty("minWidth");
        element.style.removeProperty("maxWidth");
        element.style.flex = "1 1 auto";
    } else $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(element, width);
}
function $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(element, width) {
    width = $7b57b57eaf5a9648$var$_formatSize(width);
    element.style.width = width.toString();
    element.style.maxWidth = width.toString();
    element.style.minWidth = width.toString();
}
function $7b57b57eaf5a9648$var$_setFixedHeight(element, height) {
    height = $7b57b57eaf5a9648$var$_formatSize(height);
    element.style.height = height.toString();
    element.style.maxHeight = height.toString();
    element.style.minHeight = height.toString();
}
function $7b57b57eaf5a9648$var$_formatSize(size) {
    if (typeof size === "number") return `${size}px`;
    return size;
}
function $7b57b57eaf5a9648$export$6e6303ef478b0c94(o) {
    return o instanceof Node || o instanceof HTMLElement;
}
function $7b57b57eaf5a9648$var$_copyNodeList(nodeList) {
    if (nodeList == null) return [];
    const result = [];
    $7b57b57eaf5a9648$var$_nodeListForEach(nodeList, (node)=>result.push(node));
    return result;
}
function $7b57b57eaf5a9648$var$_iterateNamedNodeMap(map, callback) {
    if (!map) return;
    for(let i = 0; i < map.length; i++){
        const attr = map[i];
        callback(attr.name, attr.value);
    }
}
function $7b57b57eaf5a9648$var$_addOrRemoveAttribute(element, name, value) {
    if (value == null) element.removeAttribute(name);
    else element.setAttribute(name, value.toString());
}
function $7b57b57eaf5a9648$var$_nodeListForEach(nodeList, action) {
    if (nodeList == null) return;
    for(let i = 0; i < nodeList.length; i++)action(nodeList[i]);
}
function $7b57b57eaf5a9648$export$3187e3cba99ad25f(cellRendererPromise, eTarget) {
    cellRendererPromise.then((cellRenderer)=>{
        const gui = cellRenderer.getGui();
        if (gui != null) {
            if (typeof gui === "object") eTarget.appendChild(gui);
            else eTarget.innerHTML = gui;
        }
    });
}
// community-modules/core/src/utils/numberSequence.ts
var $7b57b57eaf5a9648$export$9bbf3cc62ef6fcad = class {
    constructor(initValue = 0, step = 1){
        this.nextValue = initValue;
        this.step = step;
    }
    next() {
        const valToReturn = this.nextValue;
        this.nextValue += this.step;
        return valToReturn;
    }
    peek() {
        return this.nextValue;
    }
    skip(count) {
        this.nextValue += count;
    }
};
// community-modules/core/src/widgets/tooltipStateManager.ts
var $7b57b57eaf5a9648$var$SHOW_QUICK_TOOLTIP_DIFF = 1e3;
var $7b57b57eaf5a9648$var$FADE_OUT_TOOLTIP_TIMEOUT = 1e3;
var $7b57b57eaf5a9648$var$INTERACTIVE_HIDE_DELAY = 100;
var $7b57b57eaf5a9648$var$_TooltipStateManager = class _TooltipStateManager extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(parentComp, tooltipShowDelayOverride, tooltipHideDelayOverride, shouldDisplayTooltip){
        super();
        this.parentComp = parentComp;
        this.tooltipShowDelayOverride = tooltipShowDelayOverride;
        this.tooltipHideDelayOverride = tooltipHideDelayOverride;
        this.shouldDisplayTooltip = shouldDisplayTooltip;
        this.interactionEnabled = false;
        this.isInteractingWithTooltip = false;
        this.state = 0 /* NOTHING */ ;
        // when showing the tooltip, we need to make sure it's the most recent instance we request, as due to
        // async we could request two tooltips before the first instance returns, in which case we should
        // disregard the second instance.
        this.tooltipInstanceCount = 0;
        this.tooltipMouseTrack = false;
    }
    wireBeans(beans) {
        this.popupService = beans.popupService;
        this.userComponentFactory = beans.userComponentFactory;
    }
    postConstruct() {
        if (this.gos.get("tooltipInteraction")) this.interactionEnabled = true;
        this.tooltipTrigger = this.getTooltipTrigger();
        this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
        const el = this.parentComp.getGui();
        if (this.tooltipTrigger === 0 /* HOVER */ ) this.addManagedListeners(el, {
            mouseenter: this.onMouseEnter.bind(this),
            mouseleave: this.onMouseLeave.bind(this)
        });
        if (this.tooltipTrigger === 1 /* FOCUS */ ) this.addManagedListeners(el, {
            focusin: this.onFocusIn.bind(this),
            focusout: this.onFocusOut.bind(this)
        });
        this.addManagedListeners(el, {
            mousemove: this.onMouseMove.bind(this)
        });
        if (!this.interactionEnabled) this.addManagedListeners(el, {
            mousedown: this.onMouseDown.bind(this),
            keydown: this.onKeyDown.bind(this)
        });
    }
    getGridOptionsTooltipDelay(delayOption) {
        const delay = this.gos.get(delayOption);
        if (delay < 0) $7b57b57eaf5a9648$export$2cf41453020eef66(`${delayOption} should not be lower than 0`);
        return Math.max(200, delay);
    }
    getTooltipDelay(type) {
        if (type === "show") return this.tooltipShowDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipShowDelay");
        return this.tooltipHideDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
    }
    destroy() {
        this.setToDoNothing();
        super.destroy();
    }
    getTooltipTrigger() {
        const trigger = this.gos.get("tooltipTrigger");
        if (!trigger || trigger === "hover") return 0 /* HOVER */ ;
        return 1 /* FOCUS */ ;
    }
    onMouseEnter(e) {
        if (this.interactionEnabled && this.interactiveTooltipTimeoutId) {
            this.unlockService();
            this.startHideTimeout();
        }
        if ($7b57b57eaf5a9648$export$6b6034a68325bd8a()) return;
        if (_TooltipStateManager.isLocked) this.showTooltipTimeoutId = window.setTimeout(()=>{
            this.prepareToShowTooltip(e);
        }, $7b57b57eaf5a9648$var$INTERACTIVE_HIDE_DELAY);
        else this.prepareToShowTooltip(e);
    }
    onMouseMove(e) {
        if (this.lastMouseEvent) this.lastMouseEvent = e;
        if (this.tooltipMouseTrack && this.state === 2 /* SHOWING */  && this.tooltipComp) this.positionTooltip();
    }
    onMouseDown() {
        this.setToDoNothing();
    }
    onMouseLeave() {
        if (this.interactionEnabled) this.lockService();
        else this.setToDoNothing();
    }
    onFocusIn() {
        this.prepareToShowTooltip();
    }
    onFocusOut(e) {
        const relatedTarget = e.relatedTarget;
        const parentCompGui = this.parentComp.getGui();
        const tooltipGui = this.tooltipComp?.getGui();
        if (this.isInteractingWithTooltip || parentCompGui.contains(relatedTarget) || this.interactionEnabled && tooltipGui?.contains(relatedTarget)) return;
        this.setToDoNothing();
    }
    onKeyDown() {
        this.setToDoNothing();
    }
    prepareToShowTooltip(mouseEvent) {
        if (this.state != 0 /* NOTHING */  || _TooltipStateManager.isLocked) return;
        let delay = 0;
        if (mouseEvent) delay = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show");
        this.lastMouseEvent = mouseEvent || null;
        this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), delay);
        this.state = 1 /* WAITING_TO_SHOW */ ;
    }
    isLastTooltipHiddenRecently() {
        const now = /* @__PURE__ */ new Date().getTime();
        const then = _TooltipStateManager.lastTooltipHideTime;
        return now - then < $7b57b57eaf5a9648$var$SHOW_QUICK_TOOLTIP_DIFF;
    }
    setToDoNothing() {
        if (this.state === 2 /* SHOWING */ ) this.hideTooltip();
        if (this.onBodyScrollEventCallback) {
            this.onBodyScrollEventCallback();
            this.onBodyScrollEventCallback = void 0;
        }
        if (this.onColumnMovedEventCallback) {
            this.onColumnMovedEventCallback();
            this.onColumnMovedEventCallback = void 0;
        }
        this.clearTimeouts();
        this.state = 0 /* NOTHING */ ;
        this.lastMouseEvent = null;
    }
    showTooltip() {
        const params = {
            ...this.parentComp.getTooltipParams()
        };
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(params.value) || this.shouldDisplayTooltip && !this.shouldDisplayTooltip()) {
            this.setToDoNothing();
            return;
        }
        this.state = 2 /* SHOWING */ ;
        this.tooltipInstanceCount++;
        const callback = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
        const userDetails = this.userComponentFactory.getTooltipCompDetails(params);
        userDetails.newAgStackInstance().then(callback);
    }
    hideTooltip(forceHide) {
        if (!forceHide && this.isInteractingWithTooltip) return;
        if (this.tooltipComp) {
            this.destroyTooltipComp();
            _TooltipStateManager.lastTooltipHideTime = /* @__PURE__ */ new Date().getTime();
        }
        const event = {
            type: "tooltipHide",
            parentGui: this.parentComp.getGui()
        };
        this.eventService.dispatchEvent(event);
        if (forceHide) this.isInteractingWithTooltip = false;
        this.state = 0 /* NOTHING */ ;
    }
    newTooltipComponentCallback(tooltipInstanceCopy, tooltipComp) {
        const compNoLongerNeeded = this.state !== 2 /* SHOWING */  || this.tooltipInstanceCount !== tooltipInstanceCopy;
        if (compNoLongerNeeded) {
            this.destroyBean(tooltipComp);
            return;
        }
        const eGui = tooltipComp.getGui();
        this.tooltipComp = tooltipComp;
        if (!eGui.classList.contains("ag-tooltip")) eGui.classList.add("ag-tooltip-custom");
        if (this.tooltipTrigger === 0 /* HOVER */ ) eGui.classList.add("ag-tooltip-animate");
        if (this.interactionEnabled) eGui.classList.add("ag-tooltip-interactive");
        const translate = this.localeService.getLocaleTextFunc();
        const addPopupRes = this.popupService.addPopup({
            eChild: eGui,
            ariaLabel: translate("ariaLabelTooltip", "Tooltip")
        });
        if (addPopupRes) this.tooltipPopupDestroyFunc = addPopupRes.hideFunc;
        this.positionTooltip();
        if (this.tooltipTrigger === 1 /* FOCUS */ ) {
            const listener = this.setToDoNothing.bind(this);
            [this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({
                bodyScroll: listener,
                columnMoved: listener
            });
        }
        if (this.interactionEnabled) {
            if (this.tooltipTrigger === 0 /* HOVER */ ) [this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(eGui, {
                mouseenter: this.onTooltipMouseEnter.bind(this),
                mouseleave: this.onTooltipMouseLeave.bind(this)
            });
            else [this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(eGui, {
                focusin: this.onTooltipFocusIn.bind(this),
                focusout: this.onTooltipFocusOut.bind(this)
            });
        }
        const event = {
            type: "tooltipShow",
            tooltipGui: eGui,
            parentGui: this.parentComp.getGui()
        };
        this.eventService.dispatchEvent(event);
        this.startHideTimeout();
    }
    onTooltipMouseEnter() {
        this.isInteractingWithTooltip = true;
        this.unlockService();
    }
    onTooltipMouseLeave() {
        this.isInteractingWithTooltip = false;
        this.lockService();
    }
    onTooltipFocusIn() {
        this.isInteractingWithTooltip = true;
    }
    onTooltipFocusOut(e) {
        const parentGui = this.parentComp.getGui();
        const tooltipGui = this.tooltipComp?.getGui();
        const relatedTarget = e.relatedTarget;
        if (tooltipGui?.contains(relatedTarget)) return;
        this.isInteractingWithTooltip = false;
        if (parentGui.contains(relatedTarget)) this.startHideTimeout();
        else this.hideTooltip();
    }
    positionTooltip() {
        const params = {
            type: "tooltip",
            ePopup: this.tooltipComp.getGui(),
            nudgeY: 18,
            skipObserver: this.tooltipMouseTrack
        };
        if (this.lastMouseEvent) this.popupService.positionPopupUnderMouseEvent({
            ...params,
            mouseEvent: this.lastMouseEvent
        });
        else this.popupService.positionPopupByComponent({
            ...params,
            eventSource: this.parentComp.getGui(),
            position: "under",
            keepWithinBounds: true,
            nudgeY: 5
        });
    }
    destroyTooltipComp() {
        this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
        const tooltipPopupDestroyFunc = this.tooltipPopupDestroyFunc;
        const tooltipComp = this.tooltipComp;
        const delay = this.tooltipTrigger === 0 /* HOVER */  ? $7b57b57eaf5a9648$var$FADE_OUT_TOOLTIP_TIMEOUT : 0;
        window.setTimeout(()=>{
            tooltipPopupDestroyFunc();
            this.destroyBean(tooltipComp);
        }, delay);
        this.clearTooltipListeners();
        this.tooltipPopupDestroyFunc = void 0;
        this.tooltipComp = void 0;
    }
    clearTooltipListeners() {
        [
            this.tooltipMouseEnterListener,
            this.tooltipMouseLeaveListener,
            this.tooltipFocusInListener,
            this.tooltipFocusOutListener
        ].forEach((listener)=>{
            if (listener) listener();
        });
        this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
    }
    lockService() {
        _TooltipStateManager.isLocked = true;
        this.interactiveTooltipTimeoutId = window.setTimeout(()=>{
            this.unlockService();
            this.setToDoNothing();
        }, $7b57b57eaf5a9648$var$INTERACTIVE_HIDE_DELAY);
    }
    unlockService() {
        _TooltipStateManager.isLocked = false;
        this.clearInteractiveTimeout();
    }
    startHideTimeout() {
        this.clearHideTimeout();
        this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
    }
    clearShowTimeout() {
        if (!this.showTooltipTimeoutId) return;
        window.clearTimeout(this.showTooltipTimeoutId);
        this.showTooltipTimeoutId = void 0;
    }
    clearHideTimeout() {
        if (!this.hideTooltipTimeoutId) return;
        window.clearTimeout(this.hideTooltipTimeoutId);
        this.hideTooltipTimeoutId = void 0;
    }
    clearInteractiveTimeout() {
        if (!this.interactiveTooltipTimeoutId) return;
        window.clearTimeout(this.interactiveTooltipTimeoutId);
        this.interactiveTooltipTimeoutId = void 0;
    }
    clearTimeouts() {
        this.clearShowTimeout();
        this.clearHideTimeout();
        this.clearInteractiveTimeout();
    }
};
$7b57b57eaf5a9648$var$_TooltipStateManager.isLocked = false;
var $7b57b57eaf5a9648$export$e3d1279ac5e83a0 = $7b57b57eaf5a9648$var$_TooltipStateManager;
// community-modules/core/src/widgets/tooltipFeature.ts
var $7b57b57eaf5a9648$export$e5073a590d24815c = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(ctrl, beans){
        super();
        this.ctrl = ctrl;
        if (beans) this.beans = beans;
    }
    wireBeans(beans) {
        this.beans = beans;
    }
    postConstruct() {
        this.refreshToolTip();
    }
    setBrowserTooltip(tooltip) {
        const name = "title";
        const eGui = this.ctrl.getGui();
        if (!eGui) return;
        if (tooltip != null && tooltip != "") eGui.setAttribute(name, tooltip);
        else eGui.removeAttribute(name);
    }
    updateTooltipText() {
        this.tooltip = this.ctrl.getTooltipValue();
    }
    createTooltipFeatureIfNeeded() {
        if (this.tooltipManager != null) return;
        const parent = {
            getTooltipParams: ()=>this.getTooltipParams(),
            getGui: ()=>this.ctrl.getGui()
        };
        this.tooltipManager = this.createBean(new $7b57b57eaf5a9648$export$e3d1279ac5e83a0(parent, this.ctrl.getTooltipShowDelayOverride?.(), this.ctrl.getTooltipHideDelayOverride?.(), this.ctrl.shouldDisplayTooltip), this.beans.context);
    }
    refreshToolTip() {
        this.browserTooltips = this.beans.gos.get("enableBrowserTooltips");
        this.updateTooltipText();
        if (this.browserTooltips) {
            this.setBrowserTooltip(this.tooltip);
            if (this.tooltipManager) this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
        } else {
            this.setBrowserTooltip(null);
            this.createTooltipFeatureIfNeeded();
        }
    }
    getTooltipParams() {
        const ctrl = this.ctrl;
        const column = ctrl.getColumn ? ctrl.getColumn() : void 0;
        const colDef = ctrl.getColDef ? ctrl.getColDef() : void 0;
        const rowNode = ctrl.getRowNode ? ctrl.getRowNode() : void 0;
        return {
            location: ctrl.getLocation(),
            colDef: //'cell',
            colDef,
            column: column,
            rowIndex: ctrl.getRowIndex ? ctrl.getRowIndex() : void 0,
            node: rowNode,
            data: rowNode ? rowNode.data : void 0,
            value: this.getTooltipText(),
            valueFormatted: ctrl.getValueFormatted ? ctrl.getValueFormatted() : void 0,
            hideTooltipCallback: ()=>this.tooltipManager?.hideTooltip(true)
        };
    }
    getTooltipText() {
        return this.tooltip;
    }
    // overriding to make public, as we don't dispose this bean via context
    destroy() {
        if (this.tooltipManager) this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context);
        super.destroy();
    }
};
// community-modules/core/src/widgets/component.ts
var $7b57b57eaf5a9648$var$compIdSequence = new $7b57b57eaf5a9648$export$9bbf3cc62ef6fcad();
var $7b57b57eaf5a9648$export$6c811454646ed8be = null;
var $7b57b57eaf5a9648$export$16fa2f45be04daa8 = class _Component extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(template, componentSelectors){
        super();
        this.suppressDataRefValidation = false;
        // if false, then CSS class "ag-hidden" is applied, which sets "display: none"
        this.displayed = true;
        // if false, then CSS class "ag-invisible" is applied, which sets "visibility: hidden"
        this.visible = true;
        // unique id for this row component. this is used for getting a reference to the HTML dom.
        // we cannot use the RowNode id as this is not unique (due to animation, old rows can be lying
        // around as we create a new rowComp instance for the same row node).
        this.compId = $7b57b57eaf5a9648$var$compIdSequence.next();
        this.cssClassManager = new $7b57b57eaf5a9648$export$a7053cb7eb605bd2(()=>this.eGui);
        this.componentSelectors = new Map((componentSelectors ?? []).map((comp)=>[
                comp.selector,
                comp
            ]));
        if (template) this.setTemplate(template);
    }
    preWireBeans(beans) {
        super.preWireBeans(beans);
    }
    preConstruct() {
        this.usingBrowserTooltips = this.gos.get("enableBrowserTooltips");
        this.wireTemplate(this.getGui());
    }
    wireTemplate(element, paramsMap) {
        if (element && this.gos) {
            this.applyElementsToComponent(element);
            this.createChildComponentsFromTags(element, paramsMap);
        }
    }
    getCompId() {
        return this.compId;
    }
    getTooltipParams() {
        return {
            value: this.tooltipText,
            location: "UNKNOWN"
        };
    }
    setTooltip(params) {
        const { newTooltipText: newTooltipText , showDelayOverride: showDelayOverride , hideDelayOverride: hideDelayOverride , location: location , shouldDisplayTooltip: shouldDisplayTooltip  } = params || {};
        if (this.tooltipFeature) this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        if (this.tooltipText !== newTooltipText) this.tooltipText = newTooltipText;
        const getTooltipValue = ()=>this.tooltipText;
        if (newTooltipText != null) this.tooltipFeature = this.createBean(new $7b57b57eaf5a9648$export$e5073a590d24815c({
            getTooltipValue: getTooltipValue,
            getGui: ()=>this.getGui(),
            getLocation: ()=>location ?? "UNKNOWN",
            getColDef: params?.getColDef,
            getColumn: params?.getColumn,
            getTooltipShowDelayOverride: showDelayOverride != null ? ()=>showDelayOverride : void 0,
            getTooltipHideDelayOverride: hideDelayOverride != null ? ()=>hideDelayOverride : void 0,
            shouldDisplayTooltip: shouldDisplayTooltip
        }));
    }
    getDataRefAttribute(element) {
        if (element.getAttribute) return element.getAttribute("data-ref");
        return null;
    }
    applyElementsToComponent(element, elementRef, paramsMap, newComponent = null) {
        if (elementRef === void 0) elementRef = this.getDataRefAttribute(element);
        if (elementRef) {
            const current = this[elementRef];
            if (current === $7b57b57eaf5a9648$export$6c811454646ed8be) this[elementRef] = newComponent ?? element;
            else {
                const usedAsParamRef = paramsMap && paramsMap[elementRef];
                if (!this.suppressDataRefValidation && !usedAsParamRef) $7b57b57eaf5a9648$export$2cf41453020eef66(`Issue with data-ref: ${elementRef} on ${this.constructor.name} with ${current}`);
            }
        }
    }
    // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
    createChildComponentsFromTags(parentNode, paramsMap) {
        const childNodeList = $7b57b57eaf5a9648$var$_copyNodeList(parentNode.childNodes);
        childNodeList.forEach((childNode)=>{
            if (!(childNode instanceof HTMLElement)) return;
            const childComp = this.createComponentFromElement(childNode, (childComp2)=>{
                const childGui = childComp2.getGui();
                if (childGui) this.copyAttributesFromNode(childNode, childComp2.getGui());
            }, paramsMap);
            if (childComp) {
                if (childComp.addItems && childNode.children.length) {
                    this.createChildComponentsFromTags(childNode, paramsMap);
                    const items = Array.prototype.slice.call(childNode.children);
                    childComp.addItems(items);
                }
                this.swapComponentForNode(childComp, parentNode, childNode);
            } else if (childNode.childNodes) this.createChildComponentsFromTags(childNode, paramsMap);
        });
    }
    createComponentFromElement(element, afterPreCreateCallback, paramsMap) {
        const key = element.nodeName;
        const elementRef = this.getDataRefAttribute(element);
        const isAgGridComponent = key.indexOf("AG-") === 0;
        const componentSelector = isAgGridComponent ? this.componentSelectors.get(key) : null;
        let newComponent = null;
        if (componentSelector) {
            _Component.elementGettingCreated = element;
            const componentParams = paramsMap && elementRef ? paramsMap[elementRef] : void 0;
            newComponent = new componentSelector.component(componentParams);
            newComponent.setParentComponent(this);
            this.createBean(newComponent, null, afterPreCreateCallback);
        } else if (isAgGridComponent) $7b57b57eaf5a9648$export$2cf41453020eef66(`Missing selector: ${key}`);
        this.applyElementsToComponent(element, elementRef, paramsMap, newComponent);
        return newComponent;
    }
    copyAttributesFromNode(source, dest) {
        $7b57b57eaf5a9648$var$_iterateNamedNodeMap(source.attributes, (name, value)=>dest.setAttribute(name, value));
    }
    swapComponentForNode(newComponent, parentNode, childNode) {
        const eComponent = newComponent.getGui();
        parentNode.replaceChild(eComponent, childNode);
        parentNode.insertBefore(document.createComment(childNode.nodeName), eComponent);
        this.addDestroyFunc(this.destroyBean.bind(this, newComponent));
    }
    activateTabIndex(elements) {
        const tabIndex = this.gos.get("tabIndex");
        if (!elements) elements = [];
        if (!elements.length) elements.push(this.getGui());
        elements.forEach((el)=>el.setAttribute("tabindex", tabIndex.toString()));
    }
    setTemplate(template, componentSelectors, paramsMap) {
        const eGui = $7b57b57eaf5a9648$export$b1f57d075ca6d5fb(template);
        this.setTemplateFromElement(eGui, componentSelectors, paramsMap);
    }
    setTemplateFromElement(element, components, paramsMap, suppressDataRefValidation = false) {
        this.eGui = element;
        this.suppressDataRefValidation = suppressDataRefValidation;
        if (components) for(let i = 0; i < components.length; i++){
            const component = components[i];
            this.componentSelectors.set(component.selector, component);
        }
        this.wireTemplate(element, paramsMap);
    }
    getGui() {
        return this.eGui;
    }
    getFocusableElement() {
        return this.eGui;
    }
    getAriaElement() {
        return this.getFocusableElement();
    }
    setParentComponent(component) {
        this.parentComponent = component;
    }
    getParentComponent() {
        return this.parentComponent;
    }
    // this method is for older code, that wants to provide the gui element,
    // it is not intended for this to be in ag-Stack
    setGui(eGui) {
        this.eGui = eGui;
    }
    queryForHtmlElement(cssSelector) {
        return this.eGui.querySelector(cssSelector);
    }
    getContainerAndElement(newChild, container) {
        let parent = container;
        if (newChild == null) return null;
        if (!parent) parent = this.eGui;
        if ($7b57b57eaf5a9648$export$6e6303ef478b0c94(newChild)) return {
            element: newChild,
            parent: parent
        };
        return {
            element: newChild.getGui(),
            parent: parent
        };
    }
    prependChild(newChild, container) {
        const { element: element , parent: parent  } = this.getContainerAndElement(newChild, container) || {};
        if (!element || !parent) return;
        parent.insertAdjacentElement("afterbegin", element);
    }
    appendChild(newChild, container) {
        const { element: element , parent: parent  } = this.getContainerAndElement(newChild, container) || {};
        if (!element || !parent) return;
        parent.appendChild(element);
    }
    isDisplayed() {
        return this.displayed;
    }
    setVisible(visible, options = {}) {
        if (visible !== this.visible) {
            this.visible = visible;
            const { skipAriaHidden: skipAriaHidden  } = options;
            $7b57b57eaf5a9648$export$a6c2c477cd60daa8(this.eGui, visible, {
                skipAriaHidden: skipAriaHidden
            });
        }
    }
    setDisplayed(displayed, options = {}) {
        if (displayed !== this.displayed) {
            this.displayed = displayed;
            const { skipAriaHidden: skipAriaHidden  } = options;
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eGui, displayed, {
                skipAriaHidden: skipAriaHidden
            });
            const event = {
                type: "displayChanged",
                visible: this.displayed
            };
            this.dispatchLocalEvent(event);
        }
    }
    destroy() {
        if (this.parentComponent) this.parentComponent = void 0;
        if (this.tooltipFeature) this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        super.destroy();
    }
    addGuiEventListener(event, listener, options) {
        this.eGui.addEventListener(event, listener, options);
        this.addDestroyFunc(()=>this.eGui.removeEventListener(event, listener));
    }
    addCssClass(className) {
        this.cssClassManager.addCssClass(className);
    }
    removeCssClass(className) {
        this.cssClassManager.removeCssClass(className);
    }
    containsCssClass(className) {
        return this.cssClassManager.containsCssClass(className);
    }
    addOrRemoveCssClass(className, addOrRemove) {
        this.cssClassManager.addOrRemoveCssClass(className, addOrRemove);
    }
};
// community-modules/core/src/utils/icon.ts
var $7b57b57eaf5a9648$var$iconNameClassMap = {
    // header column group shown when expanded (click to contract)
    columnGroupOpened: "expanded",
    // header column group shown when contracted (click to expand)
    columnGroupClosed: "contracted",
    // tool panel column group contracted (click to expand)
    columnSelectClosed: "tree-closed",
    // tool panel column group expanded (click to contract)
    columnSelectOpen: "tree-open",
    // column tool panel header expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    columnSelectIndeterminate: "tree-indeterminate",
    // shown on ghost icon while dragging column to the side of the grid to pin
    columnMovePin: "pin",
    // shown on ghost icon while dragging over part of the page that is not a drop zone
    columnMoveHide: "eye-slash",
    // shown on ghost icon while dragging columns to reorder
    columnMoveMove: "arrows",
    // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
    columnMoveLeft: "left",
    // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
    columnMoveRight: "right",
    // shown on ghost icon while dragging over Row Groups drop zone
    columnMoveGroup: "group",
    // shown on ghost icon while dragging over Values drop zone
    columnMoveValue: "aggregation",
    // shown on ghost icon while dragging over pivot drop zone
    columnMovePivot: "pivot",
    // shown on ghost icon while dragging over drop zone that doesn't support it, e.g.
    //     string column over aggregation drop zone
    dropNotAllowed: "not-allowed",
    // shown on row group when contracted (click to expand)
    groupContracted: "tree-closed",
    // shown on row group when expanded (click to contract)
    groupExpanded: "tree-open",
    // set filter tree list group contracted (click to expand)
    setFilterGroupClosed: "tree-closed",
    // set filter tree list group expanded (click to contract)
    setFilterGroupOpen: "tree-open",
    // set filter tree list expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    setFilterGroupIndeterminate: "tree-indeterminate",
    // context menu chart item
    chart: "chart",
    // chart window title bar
    close: "cross",
    // X (remove) on column 'pill' after adding it to a drop zone list
    cancel: "cancel",
    // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
    check: "tick",
    // "go to first" button in pagination controls
    first: "first",
    // "go to previous" button in pagination controls
    previous: "previous",
    // "go to next" button in pagination controls
    next: "next",
    // "go to last" button in pagination controls
    last: "last",
    // shown on top right of chart when chart is linked to range data (click to unlink)
    linked: "linked",
    // shown on top right of chart when chart is not linked to range data (click to link)
    unlinked: "unlinked",
    // "Choose colour" button on chart settings tab
    colorPicker: "color-picker",
    // rotating spinner shown by the loading cell renderer
    groupLoading: "loading",
    // button to launch enterprise column menu
    menu: "menu",
    menuAlt: "menu-alt",
    // filter tool panel tab
    filter: "filter",
    // column tool panel tab
    columns: "columns",
    // button in chart regular size window title bar (click to maximise)
    maximize: "maximize",
    // button in chart maximised window title bar (click to make regular size)
    minimize: "minimize",
    // "Pin column" item in column header menu
    menuPin: "pin",
    // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
    menuValue: "aggregation",
    // "Group by {column-name}" item in column header menu
    menuAddRowGroup: "group",
    // "Un-Group by {column-name}" item in column header menu
    menuRemoveRowGroup: "group",
    // context menu copy item
    clipboardCopy: "copy",
    // context menu cut item
    clipboardCut: "cut",
    // context menu paste item
    clipboardPaste: "paste",
    // identifies the pivot drop zone
    pivotPanel: "pivot",
    // "Row groups" drop zone in column tool panel
    rowGroupPanel: "group",
    // columns tool panel Values drop zone
    valuePanel: "aggregation",
    // drag handle used to pick up draggable columns
    columnDrag: "grip",
    // drag handle used to pick up draggable rows
    rowDrag: "grip",
    // context menu export item
    save: "save",
    // csv export
    csvExport: "csv",
    // excel export,
    excelExport: "excel",
    // icon on dropdown editors
    smallDown: "small-down",
    // version of small-right used in RTL mode
    smallLeft: "small-left",
    // separater between column 'pills' when you add multiple columns to the header drop zone
    smallRight: "small-right",
    smallUp: "small-up",
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
    sortUnSort: "none",
    // Builder button in Advanced Filter
    advancedFilterBuilder: "group",
    // drag handle used to pick up Advanced Filter Builder rows
    advancedFilterBuilderDrag: "grip",
    // Advanced Filter Builder row validation error
    advancedFilterBuilderInvalid: "not-allowed",
    // shown on Advanced Filter Builder rows to move them up
    advancedFilterBuilderMoveUp: "up",
    // shown on Advanced Filter Builder rows to move them down
    advancedFilterBuilderMoveDown: "down",
    // shown on Advanced Filter Builder rows to add new rows
    advancedFilterBuilderAdd: "plus",
    // shown on Advanced Filter Builder rows to remove row
    advancedFilterBuilderRemove: "minus",
    // Edit Chart menu item shown in Integrated Charts menu
    chartsMenuEdit: "chart",
    // Advanced Settings menu item shown in Integrated Charts menu
    chartsMenuAdvancedSettings: "settings",
    // shown in Integrated Charts menu add fields
    chartsMenuAdd: "plus",
    // checked checkbox
    checkboxChecked: "checkbox-checked",
    // indeterminate checkbox
    checkboxIndeterminate: "checkbox-indeterminate",
    // unchecked checkbox
    checkboxUnchecked: "checkbox-unchecked",
    // radio button on
    radioButtonOn: "radio-button-on",
    // radio button off
    radioButtonOff: "radio-button-off"
};
function $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1(iconName, gos, column) {
    const iconContents = $7b57b57eaf5a9648$export$d8feba07bf373edb(iconName, gos, column);
    if (iconContents) {
        const { className: className  } = iconContents;
        if (typeof className === "string" && className.indexOf("ag-icon") > -1 || typeof className === "object" && className["ag-icon"]) return iconContents;
    }
    const eResult = document.createElement("span");
    eResult.appendChild(iconContents);
    return eResult;
}
function $7b57b57eaf5a9648$export$d8feba07bf373edb(iconName, gos, column, forceCreate) {
    let userProvidedIcon = null;
    const icons = column && column.getColDef().icons;
    if (icons) userProvidedIcon = icons[iconName];
    if (gos && !userProvidedIcon) {
        const optionsIcons = gos.get("icons");
        if (optionsIcons) userProvidedIcon = optionsIcons[iconName];
    }
    if (userProvidedIcon) {
        let rendererResult;
        if (typeof userProvidedIcon === "function") rendererResult = userProvidedIcon();
        else if (typeof userProvidedIcon === "string") rendererResult = userProvidedIcon;
        else throw new Error("icon from grid options needs to be a string or a function");
        if (typeof rendererResult === "string") return $7b57b57eaf5a9648$export$b1f57d075ca6d5fb(rendererResult);
        if ($7b57b57eaf5a9648$export$6e6303ef478b0c94(rendererResult)) return rendererResult;
        $7b57b57eaf5a9648$export$2cf41453020eef66("iconRenderer should return back a string or a dom object");
    } else {
        const span = document.createElement("span");
        let cssClass = $7b57b57eaf5a9648$var$iconNameClassMap[iconName];
        if (!cssClass) {
            if (!forceCreate) {
                $7b57b57eaf5a9648$export$2cf41453020eef66(`Did not find icon ${iconName}`);
                cssClass = "";
            } else cssClass = iconName;
        }
        span.setAttribute("class", `ag-icon ag-icon-${cssClass}`);
        span.setAttribute("unselectable", "on");
        $7b57b57eaf5a9648$export$f8d01fa01787902(span, "presentation");
        return span;
    }
}
// community-modules/core/src/utils/mouse.ts
function $7b57b57eaf5a9648$var$_areEventsNear(e1, e2, pixelCount) {
    if (pixelCount === 0) return false;
    const diffX = Math.abs(e1.clientX - e2.clientX);
    const diffY = Math.abs(e1.clientY - e2.clientY);
    return Math.max(diffX, diffY) <= pixelCount;
}
// community-modules/core/src/widgets/touchListener.ts
var $7b57b57eaf5a9648$export$7b2e93987414b382 = class {
    constructor(eElement, preventMouseClick = false){
        this.DOUBLE_TAP_MILLIS = 500;
        this.destroyFuncs = [];
        this.touching = false;
        this.localEventService = new $7b57b57eaf5a9648$export$820da7696a401cdc();
        this.eElement = eElement;
        this.preventMouseClick = preventMouseClick;
        const startListener = this.onTouchStart.bind(this);
        const moveListener = this.onTouchMove.bind(this);
        const endListener = this.onTouchEnd.bind(this);
        this.eElement.addEventListener("touchstart", startListener, {
            passive: true
        });
        this.eElement.addEventListener("touchmove", moveListener, {
            passive: true
        });
        this.eElement.addEventListener("touchend", endListener, {
            passive: false
        });
        this.destroyFuncs.push(()=>{
            this.eElement.removeEventListener("touchstart", startListener, {
                passive: true
            });
            this.eElement.removeEventListener("touchmove", moveListener, {
                passive: true
            });
            this.eElement.removeEventListener("touchend", endListener, {
                passive: false
            });
        });
    }
    getActiveTouch(touchList) {
        for(let i = 0; i < touchList.length; i++){
            const matches = touchList[i].identifier === this.touchStart.identifier;
            if (matches) return touchList[i];
        }
        return null;
    }
    addEventListener(eventType, listener) {
        this.localEventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
        this.localEventService.removeEventListener(eventType, listener);
    }
    onTouchStart(touchEvent) {
        if (this.touching) return;
        this.touchStart = touchEvent.touches[0];
        this.touching = true;
        this.moved = false;
        const touchStartCopy = this.touchStart;
        window.setTimeout(()=>{
            const touchesMatch = this.touchStart === touchStartCopy;
            if (this.touching && touchesMatch && !this.moved) {
                this.moved = true;
                const event = {
                    type: "longTap",
                    touchStart: this.touchStart,
                    touchEvent: touchEvent
                };
                this.localEventService.dispatchEvent(event);
            }
        }, 500);
    }
    onTouchMove(touchEvent) {
        if (!this.touching) return;
        const touch = this.getActiveTouch(touchEvent.touches);
        if (!touch) return;
        const eventIsFarAway = !$7b57b57eaf5a9648$var$_areEventsNear(touch, this.touchStart, 4);
        if (eventIsFarAway) this.moved = true;
    }
    onTouchEnd(touchEvent) {
        if (!this.touching) return;
        if (!this.moved) {
            const event = {
                type: "tap",
                touchStart: this.touchStart
            };
            this.localEventService.dispatchEvent(event);
            this.checkForDoubleTap();
        }
        if (this.preventMouseClick && touchEvent.cancelable) touchEvent.preventDefault();
        this.touching = false;
    }
    checkForDoubleTap() {
        const now = /* @__PURE__ */ new Date().getTime();
        if (this.lastTapTime && this.lastTapTime > 0) {
            const interval = now - this.lastTapTime;
            if (interval > this.DOUBLE_TAP_MILLIS) {
                const event = {
                    type: "doubleTap",
                    touchStart: this.touchStart
                };
                this.localEventService.dispatchEvent(event);
                this.lastTapTime = null;
            } else this.lastTapTime = now;
        } else this.lastTapTime = now;
    }
    destroy() {
        this.destroyFuncs.forEach((func)=>func());
    }
};
// community-modules/core/src/headerRendering/cells/column/sortIndicatorComp.ts
var $7b57b57eaf5a9648$var$SortIndicatorTemplate = /* html */ `<span class="ag-sort-indicator-container">
        <span data-ref="eSortOrder" class="ag-sort-indicator-icon ag-sort-order ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortAsc" class="ag-sort-indicator-icon ag-sort-ascending-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortDesc" class="ag-sort-indicator-icon ag-sort-descending-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortMixed" class="ag-sort-indicator-icon ag-sort-mixed-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortNone" class="ag-sort-indicator-icon ag-sort-none-icon ag-hidden" aria-hidden="true"></span>
    </span>`;
var $7b57b57eaf5a9648$export$220e9505c6bd76f6 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(skipTemplate){
        super();
        this.eSortOrder = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortAsc = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortDesc = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortMixed = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortNone = $7b57b57eaf5a9648$export$6c811454646ed8be;
        if (!skipTemplate) this.setTemplate($7b57b57eaf5a9648$var$SortIndicatorTemplate);
    }
    wireBeans(beans) {
        this.sortController = beans.sortController;
    }
    attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone) {
        this.eSortOrder = eSortOrder;
        this.eSortAsc = eSortAsc;
        this.eSortDesc = eSortDesc;
        this.eSortMixed = eSortMixed;
        this.eSortNone = eSortNone;
    }
    setupSort(column, suppressOrder = false) {
        this.column = column;
        this.suppressOrder = suppressOrder;
        this.setupMultiSortIndicator();
        if (!this.column.isSortable() && !this.column.getColDef().showRowGroup) return;
        this.addInIcon("sortAscending", this.eSortAsc, column);
        this.addInIcon("sortDescending", this.eSortDesc, column);
        this.addInIcon("sortUnSort", this.eSortNone, column);
        this.addManagedPropertyListener("unSortIcon", ()=>this.updateIcons());
        this.addManagedEventListeners({
            newColumnsLoaded: this.updateIcons.bind(this),
            // Watch global events, as row group columns can effect their display column.
            sortChanged: this.onSortChanged.bind(this),
            // when grouping changes so can sort indexes and icons
            columnRowGroupChanged: this.onSortChanged.bind(this)
        });
        this.onSortChanged();
    }
    addInIcon(iconName, eParent, column) {
        if (eParent == null) return;
        const eIcon = $7b57b57eaf5a9648$export$d8feba07bf373edb(iconName, this.gos, column);
        if (eIcon) eParent.appendChild(eIcon);
    }
    onSortChanged() {
        this.updateIcons();
        if (!this.suppressOrder) this.updateSortOrder();
    }
    updateIcons() {
        const sortDirection = this.sortController.getDisplaySortForColumn(this.column);
        if (this.eSortAsc) {
            const isAscending = sortDirection === "asc";
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eSortAsc, isAscending, {
                skipAriaHidden: true
            });
        }
        if (this.eSortDesc) {
            const isDescending = sortDirection === "desc";
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eSortDesc, isDescending, {
                skipAriaHidden: true
            });
        }
        if (this.eSortNone) {
            const alwaysHideNoSort = !this.column.getColDef().unSortIcon && !this.gos.get("unSortIcon");
            const isNone = sortDirection === null || sortDirection === void 0;
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eSortNone, !alwaysHideNoSort && isNone, {
                skipAriaHidden: true
            });
        }
    }
    setupMultiSortIndicator() {
        this.addInIcon("sortUnSort", this.eSortMixed, this.column);
        const isColumnShowingRowGroup = this.column.getColDef().showRowGroup;
        const areGroupsCoupled = this.gos.isColumnsSortingCoupledToGroup();
        if (areGroupsCoupled && isColumnShowingRowGroup) {
            this.addManagedEventListeners({
                // Watch global events, as row group columns can effect their display column.
                sortChanged: this.updateMultiSortIndicator.bind(this),
                // when grouping changes so can sort indexes and icons
                columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
            });
            this.updateMultiSortIndicator();
        }
    }
    updateMultiSortIndicator() {
        if (this.eSortMixed) {
            const isMixedSort = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eSortMixed, isMixedSort, {
                skipAriaHidden: true
            });
        }
    }
    // we listen here for global sort events, NOT column sort events, as we want to do this
    // when sorting has been set on all column (if we listened just for our col (where we
    // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
    updateSortOrder() {
        if (!this.eSortOrder) return;
        const allColumnsWithSorting = this.sortController.getColumnsWithSortingOrdered();
        const indexThisCol = this.sortController.getDisplaySortIndexForColumn(this.column) ?? -1;
        const moreThanOneColSorting = allColumnsWithSorting.some((col)=>this.sortController.getDisplaySortIndexForColumn(col) ?? false);
        const showIndex = indexThisCol >= 0 && moreThanOneColSorting;
        $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eSortOrder, showIndex, {
            skipAriaHidden: true
        });
        if (indexThisCol >= 0) this.eSortOrder.textContent = (indexThisCol + 1).toString();
        else $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eSortOrder);
    }
};
var $7b57b57eaf5a9648$export$513e3f1a9502b42 = {
    selector: "AG-SORT-INDICATOR",
    component: $7b57b57eaf5a9648$export$220e9505c6bd76f6
};
// community-modules/core/src/headerRendering/cells/column/headerComp.ts
var $7b57b57eaf5a9648$var$HeaderCompTemplate = /* html */ `<div class="ag-cell-label-container" role="presentation">
        <span data-ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
        <span data-ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
        <div data-ref="eLabel" class="ag-header-cell-label" role="presentation">
            <span data-ref="eText" class="ag-header-cell-text"></span>
            <span data-ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
            <ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>
        </div>
    </div>`;
var $7b57b57eaf5a9648$var$HeaderComp = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(...arguments);
        this.eFilter = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eFilterButton = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortIndicator = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eMenu = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eLabel = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eText = $7b57b57eaf5a9648$export$6c811454646ed8be;
        /**
     * Selectors for custom headers templates
     */ this.eSortOrder = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortAsc = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortDesc = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortMixed = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eSortNone = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.lastMovingChanged = 0;
    }
    wireBeans(beans) {
        this.sortController = beans.sortController;
        this.menuService = beans.menuService;
        this.funcColsService = beans.funcColsService;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
    refresh(params) {
        const oldParams = this.params;
        this.params = params;
        if (this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort || this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || oldParams.enableFilterButton != params.enableFilterButton || oldParams.enableFilterIcon != params.enableFilterIcon) return false;
        this.setDisplayName(params);
        return true;
    }
    workOutTemplate() {
        let template = this.params.template ?? $7b57b57eaf5a9648$var$HeaderCompTemplate;
        template = template && template.trim ? template.trim() : template;
        return template;
    }
    init(params) {
        this.params = params;
        this.currentTemplate = this.workOutTemplate();
        this.setTemplate(this.currentTemplate, [
            $7b57b57eaf5a9648$export$513e3f1a9502b42
        ]);
        this.setupTap();
        this.setMenu();
        this.setupSort();
        this.setupFilterIcon();
        this.setupFilterButton();
        this.setDisplayName(params);
    }
    setDisplayName(params) {
        if (this.currentDisplayName != params.displayName) {
            this.currentDisplayName = params.displayName;
            const displayNameSanitised = $7b57b57eaf5a9648$export$3df06b741968da82(this.currentDisplayName, true);
            if (this.eText) this.eText.textContent = displayNameSanitised;
        }
    }
    addInIcon(iconName, eParent, column) {
        if (eParent == null) return;
        const eIcon = $7b57b57eaf5a9648$export$d8feba07bf373edb(iconName, this.gos, column);
        if (eIcon) eParent.appendChild(eIcon);
    }
    setupTap() {
        const { gos: gos  } = this;
        if (gos.get("suppressTouch")) return;
        const touchListener = new $7b57b57eaf5a9648$export$7b2e93987414b382(this.getGui(), true);
        const suppressMenuHide = this.shouldSuppressMenuHide();
        const tapMenuButton = suppressMenuHide && $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.eMenu);
        const menuTouchListener = tapMenuButton ? new $7b57b57eaf5a9648$export$7b2e93987414b382(this.eMenu, true) : touchListener;
        if (this.params.enableMenu) {
            const eventType = tapMenuButton ? "tap" : "longTap";
            const showMenuFn = (event)=>this.params.showColumnMenuAfterMouseClick(event.touchStart);
            this.addManagedListeners(menuTouchListener, {
                [eventType]: showMenuFn
            });
        }
        if (this.params.enableSorting) {
            const tapListener = (event)=>{
                const target = event.touchStart.target;
                if (suppressMenuHide && (this.eMenu?.contains(target) || this.eFilterButton?.contains(target))) return;
                this.sortController.progressSort(this.params.column, false, "uiColumnSorted");
            };
            this.addManagedListeners(touchListener, {
                tap: tapListener
            });
        }
        if (this.params.enableFilterButton) {
            const filterButtonTouchListener = new $7b57b57eaf5a9648$export$7b2e93987414b382(this.eFilterButton, true);
            this.addManagedListeners(filterButtonTouchListener, {
                tap: ()=>this.params.showFilter(this.eFilterButton)
            });
            this.addDestroyFunc(()=>filterButtonTouchListener.destroy());
        }
        this.addDestroyFunc(()=>touchListener.destroy());
        if (tapMenuButton) this.addDestroyFunc(()=>menuTouchListener.destroy());
    }
    workOutShowMenu() {
        return this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled();
    }
    shouldSuppressMenuHide() {
        return this.menuService.isHeaderMenuButtonAlwaysShowEnabled();
    }
    setMenu() {
        if (!this.eMenu) return;
        this.currentShowMenu = this.workOutShowMenu();
        if (!this.currentShowMenu) {
            $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(this.eMenu);
            this.eMenu = void 0;
            return;
        }
        const isLegacyMenu = this.menuService.isLegacyMenuEnabled();
        this.addInIcon(isLegacyMenu ? "menu" : "menuAlt", this.eMenu, this.params.column);
        this.eMenu.classList.toggle("ag-header-menu-icon", !isLegacyMenu);
        this.currentSuppressMenuHide = this.shouldSuppressMenuHide();
        this.addManagedElementListeners(this.eMenu, {
            click: ()=>this.params.showColumnMenu(this.eMenu)
        });
        this.eMenu.classList.toggle("ag-header-menu-always-show", this.currentSuppressMenuHide);
    }
    onMenuKeyboardShortcut(isFilterShortcut) {
        const column = this.params.column;
        const isLegacyMenuEnabled = this.menuService.isLegacyMenuEnabled();
        if (isFilterShortcut && !isLegacyMenuEnabled) {
            if (this.menuService.isFilterMenuInHeaderEnabled(column)) {
                this.params.showFilter(this.eFilterButton ?? this.eMenu ?? this.getGui());
                return true;
            }
        } else if (this.params.enableMenu) {
            this.params.showColumnMenu(this.eMenu ?? this.eFilterButton ?? this.getGui());
            return true;
        }
        return false;
    }
    workOutSort() {
        return this.params.enableSorting;
    }
    setupSort() {
        this.currentSort = this.params.enableSorting;
        if (!this.eSortIndicator) {
            this.eSortIndicator = this.createBean(new $7b57b57eaf5a9648$export$220e9505c6bd76f6(true));
            this.eSortIndicator.attachCustomElements(this.eSortOrder, this.eSortAsc, this.eSortDesc, this.eSortMixed, this.eSortNone);
        }
        this.eSortIndicator.setupSort(this.params.column);
        if (!this.currentSort) return;
        this.addManagedListeners(this.params.column, {
            movingChanged: ()=>{
                this.lastMovingChanged = /* @__PURE__ */ new Date().getTime();
            }
        });
        if (this.eLabel) this.addManagedElementListeners(this.eLabel, {
            click: (event)=>{
                const moving = this.params.column.isMoving();
                const nowTime = /* @__PURE__ */ new Date().getTime();
                const movedRecently = nowTime - this.lastMovingChanged < 50;
                const columnMoving = moving || movedRecently;
                if (!columnMoving) {
                    const sortUsingCtrl = this.gos.get("multiSortKey") === "ctrl";
                    const multiSort = sortUsingCtrl ? event.ctrlKey || event.metaKey : event.shiftKey;
                    this.params.progressSort(multiSort);
                }
            }
        });
        const onSortingChanged = ()=>{
            const sort = this.params.column.getSort();
            this.addOrRemoveCssClass("ag-header-cell-sorted-asc", sort === "asc");
            this.addOrRemoveCssClass("ag-header-cell-sorted-desc", sort === "desc");
            this.addOrRemoveCssClass("ag-header-cell-sorted-none", !sort);
            if (this.params.column.getColDef().showRowGroup) {
                const sourceColumns = this.funcColsService.getSourceColumnsForGroupColumn(this.params.column);
                const sortDirectionsMatch = sourceColumns?.every((sourceCol)=>this.params.column.getSort() == sourceCol.getSort());
                const isMultiSorting = !sortDirectionsMatch;
                this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", isMultiSorting);
            }
        };
        this.addManagedEventListeners({
            sortChanged: onSortingChanged,
            columnRowGroupChanged: onSortingChanged
        });
    }
    setupFilterIcon() {
        if (!this.eFilter) return;
        this.configureFilter(this.params.enableFilterIcon, this.eFilter, this.onFilterChangedIcon.bind(this));
    }
    setupFilterButton() {
        if (!this.eFilterButton) return;
        const configured = this.configureFilter(this.params.enableFilterButton, this.eFilterButton, this.onFilterChangedButton.bind(this));
        if (configured) this.addManagedElementListeners(this.eFilterButton, {
            click: ()=>this.params.showFilter(this.eFilterButton)
        });
        else this.eFilterButton = void 0;
    }
    configureFilter(enabled, element, filterChangedCallback) {
        if (!enabled) {
            $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(element);
            return false;
        }
        const column = this.params.column;
        this.addInIcon("filter", element, column);
        this.addManagedListeners(column, {
            filterChanged: filterChangedCallback
        });
        filterChangedCallback();
        return true;
    }
    onFilterChangedIcon() {
        const filterPresent = this.params.column.isFilterActive();
        $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eFilter, filterPresent, {
            skipAriaHidden: true
        });
    }
    onFilterChangedButton() {
        const filterPresent = this.params.column.isFilterActive();
        this.eFilterButton.classList.toggle("ag-filter-active", filterPresent);
    }
    getAnchorElementForMenu(isFilter) {
        if (isFilter) return this.eFilterButton ?? this.eMenu ?? this.getGui();
        return this.eMenu ?? this.eFilterButton ?? this.getGui();
    }
};
// community-modules/core/src/headerRendering/cells/columnGroup/headerGroupComp.ts
var $7b57b57eaf5a9648$var$HeaderGroupComp = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html */ `<div class="ag-header-group-cell-label" role="presentation">
            <span data-ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span data-ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span data-ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`);
        this.agOpened = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.agClosed = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.agLabel = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
    init(params) {
        this.params = params;
        this.checkWarnings();
        this.setupLabel();
        this.addGroupExpandIcon();
        this.setupExpandIcons();
    }
    checkWarnings() {
        const paramsAny = this.params;
        if (paramsAny.template) $7b57b57eaf5a9648$export$2cf41453020eef66(`A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)`);
    }
    setupExpandIcons() {
        this.addInIcon("columnGroupOpened", this.agOpened);
        this.addInIcon("columnGroupClosed", this.agClosed);
        const expandAction = (event)=>{
            if ($7b57b57eaf5a9648$export$9a48e23524c6d58(event)) return;
            const newExpandedValue = !this.params.columnGroup.isExpanded();
            this.columnModel.setColumnGroupOpened(this.params.columnGroup.getProvidedColumnGroup(), newExpandedValue, "uiColumnExpanded");
        };
        this.addTouchAndClickListeners(this.agClosed, expandAction);
        this.addTouchAndClickListeners(this.agOpened, expandAction);
        const stopPropagationAction = (event)=>{
            $7b57b57eaf5a9648$export$456c40e80134d72a(event);
        };
        this.addManagedElementListeners(this.agClosed, {
            dblclick: stopPropagationAction
        });
        this.addManagedElementListeners(this.agOpened, {
            dblclick: stopPropagationAction
        });
        this.addManagedElementListeners(this.getGui(), {
            dblclick: expandAction
        });
        this.updateIconVisibility();
        const providedColumnGroup = this.params.columnGroup.getProvidedColumnGroup();
        const updateIcon = this.updateIconVisibility.bind(this);
        this.addManagedListeners(providedColumnGroup, {
            expandedChanged: updateIcon,
            expandableChanged: updateIcon
        });
    }
    addTouchAndClickListeners(eElement, action) {
        const touchListener = new $7b57b57eaf5a9648$export$7b2e93987414b382(eElement, true);
        this.addManagedListeners(touchListener, {
            tap: action
        });
        this.addDestroyFunc(()=>touchListener.destroy());
        this.addManagedElementListeners(eElement, {
            click: action
        });
    }
    updateIconVisibility() {
        const columnGroup = this.params.columnGroup;
        if (columnGroup.isExpandable()) {
            const expanded = this.params.columnGroup.isExpanded();
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.agOpened, expanded);
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.agClosed, !expanded);
        } else {
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.agOpened, false);
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.agClosed, false);
        }
    }
    addInIcon(iconName, element) {
        const eIcon = $7b57b57eaf5a9648$export$d8feba07bf373edb(iconName, this.gos, null);
        if (eIcon) element.appendChild(eIcon);
    }
    addGroupExpandIcon() {
        if (!this.params.columnGroup.isExpandable()) {
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.agOpened, false);
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.agClosed, false);
            return;
        }
    }
    setupLabel() {
        const { displayName: displayName , columnGroup: columnGroup  } = this.params;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(displayName)) {
            const displayNameSanitised = $7b57b57eaf5a9648$export$3df06b741968da82(displayName, true);
            this.agLabel.textContent = displayNameSanitised;
        }
        this.addOrRemoveCssClass("ag-sticky-label", !columnGroup.getColGroupDef()?.suppressStickyLabel);
    }
};
// community-modules/core/src/modules/moduleNames.ts
var $7b57b57eaf5a9648$export$7014c4aa9a91d0eb = /* @__PURE__ */ ((ModuleNames2)=>{
    ModuleNames2["CommunityCoreModule"] = "@ag-grid-community/core";
    ModuleNames2["InfiniteRowModelModule"] = "@ag-grid-community/infinite-row-model";
    ModuleNames2["ClientSideRowModelModule"] = "@ag-grid-community/client-side-row-model";
    ModuleNames2["CsvExportModule"] = "@ag-grid-community/csv-export";
    ModuleNames2["EnterpriseCoreModule"] = "@ag-grid-enterprise/core";
    ModuleNames2["RowGroupingModule"] = "@ag-grid-enterprise/row-grouping";
    ModuleNames2["ColumnsToolPanelModule"] = "@ag-grid-enterprise/column-tool-panel";
    ModuleNames2["FiltersToolPanelModule"] = "@ag-grid-enterprise/filter-tool-panel";
    ModuleNames2["MenuModule"] = "@ag-grid-enterprise/menu";
    ModuleNames2["SetFilterModule"] = "@ag-grid-enterprise/set-filter";
    ModuleNames2["MultiFilterModule"] = "@ag-grid-enterprise/multi-filter";
    ModuleNames2["StatusBarModule"] = "@ag-grid-enterprise/status-bar";
    ModuleNames2["SideBarModule"] = "@ag-grid-enterprise/side-bar";
    ModuleNames2["RangeSelectionModule"] = "@ag-grid-enterprise/range-selection";
    ModuleNames2["MasterDetailModule"] = "@ag-grid-enterprise/master-detail";
    ModuleNames2["RichSelectModule"] = "@ag-grid-enterprise/rich-select";
    ModuleNames2["GridChartsModule"] = "@ag-grid-enterprise/charts";
    ModuleNames2["ViewportRowModelModule"] = "@ag-grid-enterprise/viewport-row-model";
    ModuleNames2["ServerSideRowModelModule"] = "@ag-grid-enterprise/server-side-row-model";
    ModuleNames2["ExcelExportModule"] = "@ag-grid-enterprise/excel-export";
    ModuleNames2["ClipboardModule"] = "@ag-grid-enterprise/clipboard";
    ModuleNames2["SparklinesModule"] = "@ag-grid-enterprise/sparklines";
    ModuleNames2["AdvancedFilterModule"] = "@ag-grid-enterprise/advanced-filter";
    ModuleNames2["AngularModule"] = "@ag-grid-community/angular";
    ModuleNames2["ReactModule"] = "@ag-grid-community/react";
    ModuleNames2["VueModule"] = "@ag-grid-community/vue";
    return ModuleNames2;
})($7b57b57eaf5a9648$export$7014c4aa9a91d0eb || {});
// community-modules/core/src/modules/moduleRegistry.ts
var $7b57b57eaf5a9648$var$_ModuleRegistry = class _ModuleRegistry {
    /**
   * Globally register the given module for all grids.
   * @param module - module to register
   */ static register(module) {
        _ModuleRegistry.__register(module, true, void 0);
    }
    /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */ static registerModules(modules) {
        _ModuleRegistry.__registerModules(modules, true, void 0);
    }
    /** AG GRID INTERNAL - Module registration helper. */ static __register(module, moduleBased, gridId) {
        _ModuleRegistry.runVersionChecks(module);
        if (gridId !== void 0) {
            _ModuleRegistry.areGridScopedModules = true;
            if (_ModuleRegistry.gridModulesMap[gridId] === void 0) _ModuleRegistry.gridModulesMap[gridId] = {};
            _ModuleRegistry.gridModulesMap[gridId][module.moduleName] = module;
        } else _ModuleRegistry.globalModulesMap[module.moduleName] = module;
        _ModuleRegistry.setModuleBased(moduleBased);
    }
    /** AG GRID INTERNAL - Unregister grid scoped module. */ static __unRegisterGridModules(gridId) {
        delete _ModuleRegistry.gridModulesMap[gridId];
    }
    /** AG GRID INTERNAL - Module registration helper. */ static __registerModules(modules, moduleBased, gridId) {
        _ModuleRegistry.setModuleBased(moduleBased);
        if (!modules) return;
        modules.forEach((module)=>_ModuleRegistry.__register(module, moduleBased, gridId));
    }
    static isValidModuleVersion(module) {
        const [moduleMajor, moduleMinor] = module.version.split(".") || [];
        const [currentModuleMajor, currentModuleMinor] = _ModuleRegistry.currentModuleVersion.split(".") || [];
        return moduleMajor === currentModuleMajor && moduleMinor === currentModuleMinor;
    }
    static runVersionChecks(module) {
        if (!_ModuleRegistry.currentModuleVersion) _ModuleRegistry.currentModuleVersion = module.version;
        const errorMsg = (details)=>`You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${details} Please update all modules to the same version.`;
        if (!module.version) $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(errorMsg(`'${module.moduleName}' is incompatible.`));
        else if (!_ModuleRegistry.isValidModuleVersion(module)) $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(errorMsg(`'${module.moduleName}' is version ${module.version} but the other modules are version ${_ModuleRegistry.currentModuleVersion}.`));
        if (module.validate) {
            const result = module.validate();
            if (!result.isValid) {
                const errorResult = result;
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`${errorResult.message}`);
            }
        }
    }
    static setModuleBased(moduleBased) {
        if (_ModuleRegistry.moduleBased === void 0) _ModuleRegistry.moduleBased = moduleBased;
        else if (_ModuleRegistry.moduleBased !== moduleBased) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms.`);
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("Please see https://www.ag-grid.com/javascript-grid/modules/ for more information.");
        }
    }
    /**
   * AG GRID INTERNAL - Set if files are being served from a single UMD bundle to provide accurate enterprise upgrade steps.
   */ static __setIsBundled() {
        _ModuleRegistry.isBundled = true;
    }
    /** AG GRID INTERNAL - Assert a given module has been register, globally or individually with this grid. */ static __assertRegistered(moduleName, reason, gridId) {
        if (this.__isRegistered(moduleName, gridId)) return true;
        let warningMessage;
        if (_ModuleRegistry.isBundled) warningMessage = `AG Grid: unable to use ${reason} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
        else if (_ModuleRegistry.moduleBased || _ModuleRegistry.moduleBased === void 0) {
            const modName = Object.entries($7b57b57eaf5a9648$export$7014c4aa9a91d0eb).find(([k, v])=>v === moduleName)?.[0];
            warningMessage = `AG Grid: unable to use ${reason} as the ${modName} is not registered${_ModuleRegistry.areGridScopedModules ? ` for gridId: ${gridId}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${modName} } from '${moduleName}';
    
    ModuleRegistry.registerModules([ ${modName} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
        } else warningMessage = `AG Grid: unable to use ${reason} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';`;
        $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(warningMessage);
        return false;
    }
    /** AG GRID INTERNAL - Is the given module registered, globally or individually with this grid. */ static __isRegistered(moduleName, gridId) {
        return !!_ModuleRegistry.globalModulesMap[moduleName] || !!_ModuleRegistry.gridModulesMap[gridId]?.[moduleName];
    }
    /** AG GRID INTERNAL - Get all registered modules globally / individually for this grid. */ static __getRegisteredModules(gridId) {
        return [
            ...$7b57b57eaf5a9648$export$3d4b197b660054d2(_ModuleRegistry.globalModulesMap),
            ...$7b57b57eaf5a9648$export$3d4b197b660054d2(_ModuleRegistry.gridModulesMap[gridId] || {})
        ];
    }
    /** AG GRID INTERNAL - Get the list of modules registered individually for this grid. */ static __getGridRegisteredModules(gridId) {
        return $7b57b57eaf5a9648$export$3d4b197b660054d2(_ModuleRegistry.gridModulesMap[gridId] ?? {}) || [];
    }
    /** INTERNAL */ static __isPackageBased() {
        return !_ModuleRegistry.moduleBased;
    }
};
// having in a map a) removes duplicates and b) allows fast lookup
$7b57b57eaf5a9648$var$_ModuleRegistry.globalModulesMap = {};
$7b57b57eaf5a9648$var$_ModuleRegistry.gridModulesMap = {};
$7b57b57eaf5a9648$var$_ModuleRegistry.areGridScopedModules = false;
var $7b57b57eaf5a9648$export$dc053975cc7f6c11 = $7b57b57eaf5a9648$var$_ModuleRegistry;
// community-modules/core/src/rendering/cellRenderers/animateShowChangeCellRenderer.ts
var $7b57b57eaf5a9648$var$ARROW_UP = "↑";
var $7b57b57eaf5a9648$var$ARROW_DOWN = "↓";
var $7b57b57eaf5a9648$export$6f4a45bae925df69 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super();
        this.refreshCount = 0;
        const template = document.createElement("span");
        const delta = document.createElement("span");
        delta.setAttribute("class", "ag-value-change-delta");
        const value = document.createElement("span");
        value.setAttribute("class", "ag-value-change-value");
        template.appendChild(delta);
        template.appendChild(value);
        this.setTemplateFromElement(template);
    }
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
    }
    init(params) {
        this.eValue = this.queryForHtmlElement(".ag-value-change-value");
        this.eDelta = this.queryForHtmlElement(".ag-value-change-delta");
        this.refresh(params, true);
    }
    showDelta(params, delta) {
        const absDelta = Math.abs(delta);
        const valueFormatted = params.formatValue(absDelta);
        const valueToUse = $7b57b57eaf5a9648$export$25d27f17d3af40f7(valueFormatted) ? valueFormatted : absDelta;
        const deltaUp = delta >= 0;
        if (deltaUp) this.eDelta.textContent = $7b57b57eaf5a9648$var$ARROW_UP + valueToUse;
        else this.eDelta.textContent = $7b57b57eaf5a9648$var$ARROW_DOWN + valueToUse;
        this.eDelta.classList.toggle("ag-value-change-delta-up", deltaUp);
        this.eDelta.classList.toggle("ag-value-change-delta-down", !deltaUp);
    }
    setTimerToRemoveDelta() {
        this.refreshCount++;
        const refreshCountCopy = this.refreshCount;
        this.getFrameworkOverrides().wrapIncoming(()=>{
            window.setTimeout(()=>{
                if (refreshCountCopy === this.refreshCount) this.hideDeltaValue();
            }, 2e3);
        });
    }
    hideDeltaValue() {
        this.eValue.classList.remove("ag-value-change-value-highlight");
        $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eDelta);
    }
    refresh(params, isInitialRender = false) {
        const value = params.value;
        if (value === this.lastValue) return false;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(params.valueFormatted)) this.eValue.textContent = params.valueFormatted;
        else if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(params.value)) this.eValue.textContent = value;
        else $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eValue);
        if (this.filterManager?.isSuppressFlashingCellsBecauseFiltering()) return false;
        if (typeof value === "number" && typeof this.lastValue === "number") {
            const delta = value - this.lastValue;
            this.showDelta(params, delta);
        }
        if (this.lastValue) this.eValue.classList.add("ag-value-change-value-highlight");
        if (!isInitialRender) this.setTimerToRemoveDelta();
        this.lastValue = value;
        return true;
    }
};
// community-modules/core/src/rendering/cellRenderers/animateSlideCellRenderer.ts
var $7b57b57eaf5a9648$export$3915b8b8c907c2a = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super();
        this.refreshCount = 0;
        const template = document.createElement("span");
        const slide = document.createElement("span");
        slide.setAttribute("class", "ag-value-slide-current");
        template.appendChild(slide);
        this.setTemplateFromElement(template);
        this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
    }
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
    }
    init(params) {
        this.refresh(params, true);
    }
    addSlideAnimation() {
        this.refreshCount++;
        const refreshCountCopy = this.refreshCount;
        if (this.ePrevious) this.getGui().removeChild(this.ePrevious);
        const prevElement = document.createElement("span");
        prevElement.setAttribute("class", "ag-value-slide-previous ag-value-slide-out");
        this.ePrevious = prevElement;
        this.ePrevious.textContent = this.eCurrent.textContent;
        this.getGui().insertBefore(this.ePrevious, this.eCurrent);
        this.getFrameworkOverrides().wrapIncoming(()=>{
            window.setTimeout(()=>{
                if (refreshCountCopy !== this.refreshCount) return;
                this.ePrevious.classList.add("ag-value-slide-out-end");
            }, 50);
            window.setTimeout(()=>{
                if (refreshCountCopy !== this.refreshCount) return;
                this.getGui().removeChild(this.ePrevious);
                this.ePrevious = null;
            }, 3e3);
        });
    }
    refresh(params, isInitialRender = false) {
        let value = params.value;
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(value)) value = "";
        if (value === this.lastValue) return false;
        if (this.filterManager?.isSuppressFlashingCellsBecauseFiltering()) return false;
        if (!isInitialRender) this.addSlideAnimation();
        this.lastValue = value;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(params.valueFormatted)) this.eCurrent.textContent = params.valueFormatted;
        else if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(params.value)) this.eCurrent.textContent = value;
        else $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eCurrent);
        return true;
    }
};
// community-modules/core/src/constants/keyCode.ts
var $7b57b57eaf5a9648$export$e9e0d96f49f57c33 = class {
};
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.BACKSPACE = "Backspace";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.TAB = "Tab";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER = "Enter";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.ESCAPE = "Escape";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.SPACE = " ";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT = "ArrowLeft";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP = "ArrowUp";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT = "ArrowRight";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN = "ArrowDown";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.DELETE = "Delete";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.F2 = "F2";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP = "PageUp";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_DOWN = "PageDown";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_HOME = "Home";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_END = "End";
// these should be used with `event.code` instead of `event.key`
// as `event.key` changes when non-latin keyboards are used
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.A = "KeyA";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.C = "KeyC";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.D = "KeyD";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.V = "KeyV";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.X = "KeyX";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.Y = "KeyY";
$7b57b57eaf5a9648$export$e9e0d96f49f57c33.Z = "KeyZ";
// community-modules/core/src/widgets/agAbstractLabel.ts
var $7b57b57eaf5a9648$export$d72ea6e1c340e03b = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(config, template, components){
        super(template, components);
        this.labelSeparator = "";
        this.labelAlignment = "left";
        this.disabled = false;
        this.label = "";
        this.config = config || {};
    }
    postConstruct() {
        this.addCssClass("ag-labeled");
        this.eLabel.classList.add("ag-label");
        const { labelSeparator: labelSeparator , label: label , labelWidth: labelWidth , labelAlignment: labelAlignment , disabled: disabled  } = this.config;
        if (disabled != null) this.setDisabled(disabled);
        if (labelSeparator != null) this.setLabelSeparator(labelSeparator);
        if (label != null) this.setLabel(label);
        if (labelWidth != null) this.setLabelWidth(labelWidth);
        this.setLabelAlignment(labelAlignment || this.labelAlignment);
        this.refreshLabel();
    }
    refreshLabel() {
        $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eLabel);
        if (typeof this.label === "string") this.eLabel.innerText = this.label + this.labelSeparator;
        else if (this.label) this.eLabel.appendChild(this.label);
        if (this.label === "") {
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eLabel, false);
            $7b57b57eaf5a9648$export$f8d01fa01787902(this.eLabel, "presentation");
        } else {
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eLabel, true);
            $7b57b57eaf5a9648$export$f8d01fa01787902(this.eLabel, null);
        }
    }
    setLabelSeparator(labelSeparator) {
        if (this.labelSeparator === labelSeparator) return this;
        this.labelSeparator = labelSeparator;
        if (this.label != null) this.refreshLabel();
        return this;
    }
    getLabelId() {
        this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`;
        return this.eLabel.id;
    }
    getLabel() {
        return this.label;
    }
    setLabel(label) {
        if (this.label === label) return this;
        this.label = label;
        this.refreshLabel();
        return this;
    }
    setLabelAlignment(alignment) {
        const eGui = this.getGui();
        const eGuiClassList = eGui.classList;
        eGuiClassList.toggle("ag-label-align-left", alignment === "left");
        eGuiClassList.toggle("ag-label-align-right", alignment === "right");
        eGuiClassList.toggle("ag-label-align-top", alignment === "top");
        return this;
    }
    setLabelEllipsis(hasEllipsis) {
        this.eLabel.classList.toggle("ag-label-ellipsis", hasEllipsis);
        return this;
    }
    setLabelWidth(width) {
        if (this.label == null) return this;
        $7b57b57eaf5a9648$var$_setElementWidth(this.eLabel, width);
        return this;
    }
    setDisabled(disabled) {
        disabled = !!disabled;
        const element = this.getGui();
        $7b57b57eaf5a9648$export$b6b4f08392e9bfaf(element, disabled);
        element.classList.toggle("ag-disabled", disabled);
        this.disabled = disabled;
        return this;
    }
    isDisabled() {
        return !!this.disabled;
    }
};
// community-modules/core/src/widgets/agAbstractField.ts
var $7b57b57eaf5a9648$export$8889445e1e1d2c89 = class extends $7b57b57eaf5a9648$export$d72ea6e1c340e03b {
    constructor(config, template, components, className){
        super(config, template, components);
        this.className = className;
    }
    postConstruct() {
        super.postConstruct();
        const { width: width , value: value , onValueChange: onValueChange  } = this.config;
        if (width != null) this.setWidth(width);
        if (value != null) this.setValue(value);
        if (onValueChange != null) this.onValueChange(onValueChange);
        if (this.className) this.addCssClass(this.className);
        this.refreshAriaLabelledBy();
    }
    setLabel(label) {
        super.setLabel(label);
        this.refreshAriaLabelledBy();
        return this;
    }
    refreshAriaLabelledBy() {
        const ariaEl = this.getAriaElement();
        const labelId = this.getLabelId();
        const label = this.getLabel();
        if (label == null || label == "" || $7b57b57eaf5a9648$var$_getAriaLabel(ariaEl) !== null) $7b57b57eaf5a9648$export$84233c40c4c74001(ariaEl, "");
        else $7b57b57eaf5a9648$export$84233c40c4c74001(ariaEl, labelId ?? "");
    }
    setAriaLabel(label) {
        $7b57b57eaf5a9648$export$e81cb0dd07f289f6(this.getAriaElement(), label);
        this.refreshAriaLabelledBy();
        return this;
    }
    onValueChange(callbackFn) {
        this.addManagedListeners(this, {
            fieldValueChanged: ()=>callbackFn(this.getValue())
        });
        return this;
    }
    getWidth() {
        return this.getGui().clientWidth;
    }
    setWidth(width) {
        $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(this.getGui(), width);
        return this;
    }
    getPreviousValue() {
        return this.previousValue;
    }
    getValue() {
        return this.value;
    }
    setValue(value, silent) {
        if (this.value === value) return this;
        this.previousValue = this.value;
        this.value = value;
        if (!silent) this.dispatchLocalEvent({
            type: "fieldValueChanged"
        });
        return this;
    }
};
// community-modules/core/src/widgets/agAbstractInputField.ts
var $7b57b57eaf5a9648$export$9671f513d4aa42e3 = class extends $7b57b57eaf5a9648$export$8889445e1e1d2c89 {
    constructor(config, className, inputType = "text", displayFieldTag = "input"){
        super(config, config?.template ?? /* html */ `
            <div role="presentation">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${displayFieldTag} data-ref="eInput" class="ag-input-field-input"></${displayFieldTag}>
                </div>
            </div>`, [], className);
        this.inputType = inputType;
        this.displayFieldTag = displayFieldTag;
        this.eLabel = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eWrapper = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eInput = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    postConstruct() {
        super.postConstruct();
        this.setInputType();
        this.eLabel.classList.add(`${this.className}-label`);
        this.eWrapper.classList.add(`${this.className}-input-wrapper`);
        this.eInput.classList.add(`${this.className}-input`);
        this.addCssClass("ag-input-field");
        this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
        const { inputName: inputName , inputWidth: inputWidth  } = this.config;
        if (inputName != null) this.setInputName(inputName);
        if (inputWidth != null) this.setInputWidth(inputWidth);
        this.addInputListeners();
        this.activateTabIndex([
            this.eInput
        ]);
    }
    addInputListeners() {
        this.addManagedElementListeners(this.eInput, {
            input: (e)=>this.setValue(e.target.value)
        });
    }
    setInputType() {
        if (this.displayFieldTag === "input") this.eInput.setAttribute("type", this.inputType);
    }
    getInputElement() {
        return this.eInput;
    }
    setInputWidth(width) {
        $7b57b57eaf5a9648$var$_setElementWidth(this.eWrapper, width);
        return this;
    }
    setInputName(name) {
        this.getInputElement().setAttribute("name", name);
        return this;
    }
    getFocusableElement() {
        return this.eInput;
    }
    setMaxLength(length) {
        const eInput = this.eInput;
        eInput.maxLength = length;
        return this;
    }
    setInputPlaceholder(placeholder) {
        $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "placeholder", placeholder);
        return this;
    }
    setInputAriaLabel(label) {
        $7b57b57eaf5a9648$export$e81cb0dd07f289f6(this.eInput, label);
        this.refreshAriaLabelledBy();
        return this;
    }
    setDisabled(disabled) {
        $7b57b57eaf5a9648$export$b6b4f08392e9bfaf(this.eInput, disabled);
        return super.setDisabled(disabled);
    }
    setAutoComplete(value) {
        if (value === true) $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "autocomplete", null);
        else {
            const autoCompleteValue = typeof value === "string" ? value : "off";
            $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "autocomplete", autoCompleteValue);
        }
        return this;
    }
};
// community-modules/core/src/widgets/agCheckbox.ts
var $7b57b57eaf5a9648$export$b00c508c1ae18d07 = class extends $7b57b57eaf5a9648$export$9671f513d4aa42e3 {
    constructor(config, className = "ag-checkbox", inputType = "checkbox"){
        super(config, className, inputType);
        this.labelAlignment = "right";
        this.selected = false;
        this.readOnly = false;
        this.passive = false;
    }
    postConstruct() {
        super.postConstruct();
        const { readOnly: readOnly , passive: passive  } = this.config;
        if (typeof readOnly === "boolean") this.setReadOnly(readOnly);
        if (typeof passive === "boolean") this.setPassive(passive);
    }
    addInputListeners() {
        this.addManagedElementListeners(this.eInput, {
            click: this.onCheckboxClick.bind(this)
        });
        this.addManagedElementListeners(this.eLabel, {
            click: this.toggle.bind(this)
        });
    }
    getNextValue() {
        return this.selected === void 0 ? true : !this.selected;
    }
    setPassive(passive) {
        this.passive = passive;
    }
    isReadOnly() {
        return this.readOnly;
    }
    setReadOnly(readOnly) {
        this.eWrapper.classList.toggle("ag-disabled", readOnly);
        this.eInput.disabled = readOnly;
        this.readOnly = readOnly;
    }
    setDisabled(disabled) {
        this.eWrapper.classList.toggle("ag-disabled", disabled);
        return super.setDisabled(disabled);
    }
    toggle() {
        if (this.eInput.disabled) return;
        const previousValue = this.isSelected();
        const nextValue = this.getNextValue();
        if (this.passive) this.dispatchChange(nextValue, previousValue);
        else this.setValue(nextValue);
    }
    getValue() {
        return this.isSelected();
    }
    setValue(value, silent) {
        this.refreshSelectedClass(value);
        this.setSelected(value, silent);
        return this;
    }
    setName(name) {
        const input = this.getInputElement();
        input.name = name;
        return this;
    }
    isSelected() {
        return this.selected;
    }
    setSelected(selected, silent) {
        if (this.isSelected() === selected) return;
        this.previousValue = this.isSelected();
        selected = this.selected = typeof selected === "boolean" ? selected : void 0;
        this.eInput.checked = selected;
        this.eInput.indeterminate = selected === void 0;
        if (!silent) this.dispatchChange(this.selected, this.previousValue);
    }
    dispatchChange(selected, previousValue, event) {
        this.dispatchLocalEvent({
            type: "fieldValueChanged",
            selected: selected,
            previousValue: previousValue,
            event: event
        });
        const input = this.getInputElement();
        const checkboxChangedEvent = {
            type: "checkboxChanged",
            id: input.id,
            name: input.name,
            selected: selected,
            previousValue: previousValue
        };
        this.eventService.dispatchEvent(checkboxChangedEvent);
    }
    onCheckboxClick(e) {
        if (this.passive || this.eInput.disabled) return;
        const previousValue = this.isSelected();
        const selected = this.selected = e.target.checked;
        this.refreshSelectedClass(selected);
        this.dispatchChange(selected, previousValue, e);
    }
    refreshSelectedClass(value) {
        this.eWrapper.classList.toggle("ag-checked", value === true);
        this.eWrapper.classList.toggle("ag-indeterminate", value == null);
    }
};
var $7b57b57eaf5a9648$export$2e2c317d2e31f2ca = {
    selector: "AG-CHECKBOX",
    component: $7b57b57eaf5a9648$export$b00c508c1ae18d07
};
// community-modules/core/src/rendering/cellRenderers/checkboxCellRenderer.ts
var $7b57b57eaf5a9648$export$c3622544a1decc94 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html*/ `
            <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`, [
            $7b57b57eaf5a9648$export$2e2c317d2e31f2ca
        ]);
        this.eCheckbox = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    init(params) {
        this.params = params;
        this.updateCheckbox(params);
        const inputEl = this.eCheckbox.getInputElement();
        inputEl.setAttribute("tabindex", "-1");
        $7b57b57eaf5a9648$var$_setAriaLive(inputEl, "polite");
        this.addManagedListeners(inputEl, {
            click: (event)=>{
                $7b57b57eaf5a9648$export$456c40e80134d72a(event);
                if (this.eCheckbox.isDisabled()) return;
                const isSelected = this.eCheckbox.getValue();
                this.onCheckboxChanged(isSelected);
            },
            dblclick: (event)=>{
                $7b57b57eaf5a9648$export$456c40e80134d72a(event);
            }
        });
        this.addManagedElementListeners(this.params.eGridCell, {
            keydown: (event)=>{
                if (event.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.SPACE && !this.eCheckbox.isDisabled()) {
                    if (this.params.eGridCell === this.gos.getActiveDomElement()) this.eCheckbox.toggle();
                    const isSelected = this.eCheckbox.getValue();
                    this.onCheckboxChanged(isSelected);
                    event.preventDefault();
                }
            }
        });
    }
    refresh(params) {
        this.params = params;
        this.updateCheckbox(params);
        return true;
    }
    updateCheckbox(params) {
        let isSelected;
        let displayed = true;
        if (params.node.group && params.column) {
            const colId = params.column.getColId();
            if (colId.startsWith($7b57b57eaf5a9648$export$a7016588c430dba6)) isSelected = params.value == null || params.value === "" ? void 0 : params.value === "true";
            else if (params.node.aggData && params.node.aggData[colId] !== void 0) isSelected = params.value ?? void 0;
            else displayed = false;
        } else isSelected = params.value ?? void 0;
        if (!displayed) {
            this.eCheckbox.setDisplayed(false);
            return;
        }
        this.eCheckbox.setValue(isSelected);
        const disabled = params.disabled != null ? params.disabled : !params.column?.isCellEditable(params.node);
        this.eCheckbox.setDisabled(disabled);
        const translate = this.localeService.getLocaleTextFunc();
        const stateName = $7b57b57eaf5a9648$var$_getAriaCheckboxStateName(translate, isSelected);
        const ariaLabel = disabled ? stateName : `${translate("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${stateName})`;
        this.eCheckbox.setInputAriaLabel(ariaLabel);
    }
    onCheckboxChanged(isSelected) {
        const { column: column , node: node , value: value  } = this.params;
        const eventStarted = {
            type: "cellEditingStarted",
            column: column,
            colDef: column?.getColDef(),
            data: node.data,
            node: node,
            rowIndex: node.rowIndex,
            rowPinned: node.rowPinned,
            value: value
        };
        this.eventService.dispatchEvent(eventStarted);
        const valueChanged = this.params.node.setDataValue(this.params.column, isSelected, "edit");
        const eventStopped = {
            type: "cellEditingStopped",
            column: column,
            colDef: column?.getColDef(),
            data: node.data,
            node: node,
            rowIndex: node.rowIndex,
            rowPinned: node.rowPinned,
            value: value,
            oldValue: value,
            newValue: isSelected,
            valueChanged: valueChanged
        };
        this.eventService.dispatchEvent(eventStopped);
    }
};
// community-modules/core/src/rendering/cellRenderers/loadingCellRenderer.ts
var $7b57b57eaf5a9648$var$LoadingCellRenderer = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html */ `<div class="ag-loading">
            <span class="ag-loading-icon" data-ref="eLoadingIcon"></span>
            <span class="ag-loading-text" data-ref="eLoadingText"></span>
        </div>`);
        this.eLoadingIcon = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eLoadingText = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    init(params) {
        params.node.failedLoad ? this.setupFailed() : this.setupLoading();
    }
    setupFailed() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        this.eLoadingText.innerText = localeTextFunc("loadingError", "ERR");
    }
    setupLoading() {
        const eLoadingIcon = $7b57b57eaf5a9648$export$d8feba07bf373edb("groupLoading", this.gos, null);
        if (eLoadingIcon) this.eLoadingIcon.appendChild(eLoadingIcon);
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        this.eLoadingText.innerText = localeTextFunc("loadingOoo", "Loading");
    }
    refresh(params) {
        return false;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
};
// community-modules/core/src/rendering/cellRenderers/skeletonCellRenderer.ts
var $7b57b57eaf5a9648$var$SkeletonCellRenderer = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html */ `<div class="ag-skeleton-container"></div>`);
    }
    init(params) {
        const id = `ag-cell-skeleton-renderer-${this.getCompId()}`;
        this.getGui().setAttribute("id", id);
        this.addDestroyFunc(()=>$7b57b57eaf5a9648$export$84233c40c4c74001(params.eParentOfValue));
        $7b57b57eaf5a9648$export$84233c40c4c74001(params.eParentOfValue, id);
        params.node.failedLoad ? this.setupFailed() : this.setupLoading(params);
    }
    setupFailed() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        this.getGui().innerText = localeTextFunc("loadingError", "ERR");
        const ariaFailed = localeTextFunc("ariaSkeletonCellLoadingFailed", "Row failed to load");
        $7b57b57eaf5a9648$export$e81cb0dd07f289f6(this.getGui(), ariaFailed);
    }
    setupLoading(params) {
        const eDocument = this.gos.getDocument();
        const skeletonEffect = eDocument.createElement("div");
        skeletonEffect.classList.add("ag-skeleton-effect");
        const rowIndex = params.node.rowIndex;
        if (rowIndex != null) {
            const width = 75 + 25 * (rowIndex % 2 === 0 ? Math.sin(rowIndex) : Math.cos(rowIndex));
            skeletonEffect.style.width = `${width}%`;
        }
        this.getGui().appendChild(skeletonEffect);
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const ariaLoading = localeTextFunc("ariaSkeletonCellLoading", "Row data is loading");
        $7b57b57eaf5a9648$export$e81cb0dd07f289f6(this.getGui(), ariaLoading);
    }
    refresh(params) {
        return false;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
};
// community-modules/core/src/rendering/overlays/overlayComponent.ts
var $7b57b57eaf5a9648$var$OverlayComponent = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super();
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
};
// community-modules/core/src/rendering/overlays/loadingOverlayComponent.ts
var $7b57b57eaf5a9648$var$LoadingOverlayComponent = class extends $7b57b57eaf5a9648$var$OverlayComponent {
    init() {
        const customTemplate = this.gos.get("overlayLoadingTemplate");
        this.setTemplate(customTemplate ?? /* html */ `<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>`);
        if (!customTemplate) {
            const localeTextFunc = this.localeService.getLocaleTextFunc();
            setTimeout(()=>{
                this.getGui().textContent = localeTextFunc("loadingOoo", "Loading...");
            });
        }
    }
};
// community-modules/core/src/rendering/overlays/noRowsOverlayComponent.ts
var $7b57b57eaf5a9648$var$NoRowsOverlayComponent = class extends $7b57b57eaf5a9648$var$OverlayComponent {
    init() {
        const customTemplate = this.gos.get("overlayNoRowsTemplate");
        this.setTemplate(customTemplate ?? /* html */ `<span class="ag-overlay-no-rows-center"></span>`);
        if (!customTemplate) {
            const localeTextFunc = this.localeService.getLocaleTextFunc();
            setTimeout(()=>{
                this.getGui().textContent = localeTextFunc("noRowsToShow", "No Rows To Show");
            });
        }
    }
};
// community-modules/core/src/widgets/popupComponent.ts
var $7b57b57eaf5a9648$export$9fac2d040f3ed438 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    isPopup() {
        return true;
    }
    setParentComponent(container) {
        container.addCssClass("ag-has-popup");
        super.setParentComponent(container);
    }
    destroy() {
        const parentComp = this.parentComponent;
        const hasParent = parentComp && parentComp.isAlive();
        if (hasParent) parentComp.getGui().classList.remove("ag-has-popup");
        super.destroy();
    }
};
// community-modules/core/src/rendering/tooltipComponent.ts
var $7b57b57eaf5a9648$var$TooltipComponent = class extends $7b57b57eaf5a9648$export$9fac2d040f3ed438 {
    constructor(){
        super(/* html */ `<div class="ag-tooltip"></div>`);
    }
    // will need to type params
    init(params) {
        const { value: value  } = params;
        this.getGui().textContent = $7b57b57eaf5a9648$export$3df06b741968da82(value, true);
    }
};
// community-modules/core/src/utils/fuzzyMatch.ts
function $7b57b57eaf5a9648$var$_fuzzyCheckStrings(inputValues, validValues, allSuggestions) {
    const fuzzyMatches = {};
    const invalidInputs = inputValues.filter((inputValue)=>!validValues.some((validValue)=>validValue === inputValue));
    if (invalidInputs.length > 0) invalidInputs.forEach((invalidInput)=>fuzzyMatches[invalidInput] = $7b57b57eaf5a9648$export$85cab1b5a4aa292c(invalidInput, allSuggestions).values);
    return fuzzyMatches;
}
function $7b57b57eaf5a9648$export$85cab1b5a4aa292c(inputValue, allSuggestions, hideIrrelevant, filterByPercentageOfBestMatch) {
    let thisSuggestions = allSuggestions.map((text, idx)=>({
            value: text,
            relevance: $7b57b57eaf5a9648$var$stringWeightedDistances(inputValue.toLowerCase(), text.toLocaleLowerCase()),
            idx: idx
        }));
    thisSuggestions.sort((a, b)=>b.relevance - a.relevance);
    if (hideIrrelevant) thisSuggestions = thisSuggestions.filter((suggestion)=>suggestion.relevance !== 0);
    if (thisSuggestions.length > 0 && filterByPercentageOfBestMatch && filterByPercentageOfBestMatch > 0) {
        const bestMatch = thisSuggestions[0].relevance;
        const limit = bestMatch * filterByPercentageOfBestMatch;
        thisSuggestions = thisSuggestions.filter((suggestion)=>limit - suggestion.relevance < 0);
    }
    const values = [];
    const indices = [];
    for (const suggestion of thisSuggestions){
        values.push(suggestion.value);
        indices.push(suggestion.idx);
    }
    return {
        values: values,
        indices: indices
    };
}
function $7b57b57eaf5a9648$var$stringWeightedDistances(str1, str2) {
    const a = str1.replace(/\s/g, "");
    const b = str2.replace(/\s/g, "");
    let weight = 0;
    let lastIndex = -1;
    for(let i = 0; i < a.length; i++){
        const idx = b.indexOf(a[i], lastIndex + 1);
        if (idx === -1) continue;
        lastIndex = idx;
        weight += 100 - lastIndex * 100 / 1e4 * 100;
    }
    return weight;
}
// community-modules/core/src/components/framework/userComponentRegistry.ts
var $7b57b57eaf5a9648$export$84607ca0a5de10d3 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "userComponentRegistry";
        this.agGridDefaults = {
            //header
            agColumnHeader: $7b57b57eaf5a9648$var$HeaderComp,
            agColumnGroupHeader: $7b57b57eaf5a9648$var$HeaderGroupComp,
            agSortIndicator: $7b57b57eaf5a9648$export$220e9505c6bd76f6,
            // renderers
            agAnimateShowChangeCellRenderer: $7b57b57eaf5a9648$export$6f4a45bae925df69,
            agAnimateSlideCellRenderer: $7b57b57eaf5a9648$export$3915b8b8c907c2a,
            agLoadingCellRenderer: $7b57b57eaf5a9648$var$LoadingCellRenderer,
            agSkeletonCellRenderer: $7b57b57eaf5a9648$var$SkeletonCellRenderer,
            agCheckboxCellRenderer: $7b57b57eaf5a9648$export$c3622544a1decc94,
            //overlays
            agLoadingOverlay: $7b57b57eaf5a9648$var$LoadingOverlayComponent,
            agNoRowsOverlay: $7b57b57eaf5a9648$var$NoRowsOverlayComponent,
            // tooltips
            agTooltipComponent: $7b57b57eaf5a9648$var$TooltipComponent
        };
        /** Used to provide useful error messages if a user is trying to use an enterprise component without loading the module. */ this.enterpriseAgDefaultCompsModule = {
            agSetColumnFilter: "@ag-grid-enterprise/set-filter" /* SetFilterModule */ ,
            agSetColumnFloatingFilter: "@ag-grid-enterprise/set-filter" /* SetFilterModule */ ,
            agMultiColumnFilter: "@ag-grid-enterprise/multi-filter" /* MultiFilterModule */ ,
            agMultiColumnFloatingFilter: "@ag-grid-enterprise/multi-filter" /* MultiFilterModule */ ,
            agGroupColumnFilter: "@ag-grid-enterprise/row-grouping" /* RowGroupingModule */ ,
            agGroupColumnFloatingFilter: "@ag-grid-enterprise/row-grouping" /* RowGroupingModule */ ,
            agGroupCellRenderer: "@ag-grid-enterprise/row-grouping" /* RowGroupingModule */ ,
            // Actually in enterprise core as used by MasterDetail too but best guess is they are grouping
            agGroupRowRenderer: "@ag-grid-enterprise/row-grouping" /* RowGroupingModule */ ,
            // Actually in enterprise core as used by MasterDetail but best guess is they are grouping
            agRichSelect: "@ag-grid-enterprise/rich-select" /* RichSelectModule */ ,
            agRichSelectCellEditor: "@ag-grid-enterprise/rich-select" /* RichSelectModule */ ,
            agDetailCellRenderer: "@ag-grid-enterprise/master-detail" /* MasterDetailModule */ ,
            agSparklineCellRenderer: "@ag-grid-enterprise/sparklines" /* SparklinesModule */ 
        };
        this.jsComps = {};
    }
    postConstruct() {
        const comps = this.gos.get("components");
        if (comps != null) $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(comps, (key, component)=>this.registerJsComponent(key, component));
    }
    registerDefaultComponent(name, component) {
        this.agGridDefaults[name] = component;
    }
    registerJsComponent(name, component) {
        this.jsComps[name] = component;
    }
    retrieve(propertyName, name) {
        const createResult = (component, componentFromFramework)=>({
                componentFromFramework: componentFromFramework,
                component: component
            });
        const registeredViaFrameworkComp = this.getFrameworkOverrides().frameworkComponent(name, this.gos.get("components"));
        if (registeredViaFrameworkComp != null) return createResult(registeredViaFrameworkComp, true);
        const jsComponent = this.jsComps[name];
        if (jsComponent) {
            const isFwkComp = this.getFrameworkOverrides().isFrameworkComponent(jsComponent);
            return createResult(jsComponent, isFwkComp);
        }
        const defaultComponent = this.agGridDefaults[name];
        if (defaultComponent) return createResult(defaultComponent, false);
        const moduleForComponent = this.enterpriseAgDefaultCompsModule[name];
        if (moduleForComponent) $7b57b57eaf5a9648$export$dc053975cc7f6c11.__assertRegistered(moduleForComponent, `AG Grid '${propertyName}' component: ${name}`, this.gridId);
        else $7b57b57eaf5a9648$export$e150fb6ea3b45c0d(()=>{
            this.warnAboutMissingComponent(propertyName, name);
        }, "MissingComp" + name);
        return null;
    }
    warnAboutMissingComponent(propertyName, componentName) {
        const validComponents = [
            // Don't include the old names / internals in potential suggestions
            ...Object.keys(this.agGridDefaults).filter((k)=>![
                    "agCellEditor",
                    "agGroupRowRenderer",
                    "agSortIndicator"
                ].includes(k)),
            ...Object.keys(this.jsComps)
        ];
        const suggestions = $7b57b57eaf5a9648$export$85cab1b5a4aa292c(componentName, validComponents, true, 0.8).values;
        $7b57b57eaf5a9648$export$2cf41453020eef66(`Could not find '${componentName}' component. It was configured as "${propertyName}: '${componentName}'" but it wasn't found in the list of registered components.`);
        if (suggestions.length > 0) $7b57b57eaf5a9648$export$2cf41453020eef66(`         Did you mean: [${suggestions.slice(0, 3)}]?`);
        $7b57b57eaf5a9648$export$2cf41453020eef66(`If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink("components/")}`);
    }
};
// community-modules/core/src/utils/promise.ts
var $7b57b57eaf5a9648$export$30ec7836a4847721 = class _AgPromise {
    constructor(callback){
        this.status = 0 /* IN_PROGRESS */ ;
        this.resolution = null;
        this.waiters = [];
        callback((value)=>this.onDone(value), (params)=>this.onReject(params));
    }
    static all(promises) {
        return promises.length ? new _AgPromise((resolve)=>{
            let remainingToResolve = promises.length;
            const combinedValues = new Array(remainingToResolve);
            promises.forEach((promise, index)=>{
                promise.then((value)=>{
                    combinedValues[index] = value;
                    remainingToResolve--;
                    if (remainingToResolve === 0) resolve(combinedValues);
                });
            });
        }) : _AgPromise.resolve();
    }
    static resolve(value = null) {
        return new _AgPromise((resolve)=>resolve(value));
    }
    then(func) {
        return new _AgPromise((resolve)=>{
            if (this.status === 1 /* RESOLVED */ ) resolve(func(this.resolution));
            else this.waiters.push((value)=>resolve(func(value)));
        });
    }
    onDone(value) {
        this.status = 1 /* RESOLVED */ ;
        this.resolution = value;
        this.waiters.forEach((waiter)=>waiter(value));
    }
    onReject(params) {}
};
// community-modules/core/src/components/framework/componentTypes.ts
var $7b57b57eaf5a9648$var$DateComponent = {
    propertyName: "dateComponent",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$HeaderComponent = {
    propertyName: "headerComponent",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$HeaderGroupComponent = {
    propertyName: "headerGroupComponent",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$CellRendererComponent = {
    propertyName: "cellRenderer",
    cellRenderer: true
};
var $7b57b57eaf5a9648$var$EditorRendererComponent = {
    propertyName: "cellRenderer",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$LoadingCellRendererComponent = {
    propertyName: "loadingCellRenderer",
    cellRenderer: true
};
var $7b57b57eaf5a9648$var$CellEditorComponent = {
    propertyName: "cellEditor",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$InnerRendererComponent = {
    propertyName: "innerRenderer",
    cellRenderer: true
};
var $7b57b57eaf5a9648$var$LoadingOverlayComponent2 = {
    propertyName: "loadingOverlayComponent",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$NoRowsOverlayComponent2 = {
    propertyName: "noRowsOverlayComponent",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$TooltipComponent2 = {
    propertyName: "tooltipComponent",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$FilterComponent = {
    propertyName: "filter",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$FloatingFilterComponent = {
    propertyName: "floatingFilterComponent",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$ToolPanelComponent = {
    propertyName: "toolPanel",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$StatusPanelComponent = {
    propertyName: "statusPanel",
    cellRenderer: false
};
var $7b57b57eaf5a9648$var$FullWidth = {
    propertyName: "fullWidthCellRenderer",
    cellRenderer: true
};
var $7b57b57eaf5a9648$var$FullWidthLoading = {
    propertyName: "loadingCellRenderer",
    cellRenderer: true
};
var $7b57b57eaf5a9648$var$FullWidthGroup = {
    propertyName: "groupRowRenderer",
    cellRenderer: true
};
var $7b57b57eaf5a9648$var$FullWidthDetail = {
    propertyName: "detailCellRenderer",
    cellRenderer: true
};
var $7b57b57eaf5a9648$var$MenuItemComponent = {
    propertyName: "menuItem",
    cellRenderer: false
};
// community-modules/core/src/components/framework/userComponentFactory.ts
var $7b57b57eaf5a9648$export$b32ef18681c5348a = class _UserComponentFactory extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "userComponentFactory";
    }
    wireBeans(beans) {
        this.agComponentUtils = beans.agComponentUtils;
        this.componentMetadataProvider = beans.componentMetadataProvider;
        this.userComponentRegistry = beans.userComponentRegistry;
        this.frameworkComponentWrapper = beans.frameworkComponentWrapper;
        this.gridOptions = beans.gridOptions;
    }
    getHeaderCompDetails(colDef, params) {
        return this.getCompDetails(colDef, $7b57b57eaf5a9648$var$HeaderComponent, "agColumnHeader", params);
    }
    getHeaderGroupCompDetails(params) {
        const colGroupDef = params.columnGroup.getColGroupDef();
        return this.getCompDetails(colGroupDef, $7b57b57eaf5a9648$var$HeaderGroupComponent, "agColumnGroupHeader", params);
    }
    // this one is unusual, as it can be LoadingCellRenderer, DetailCellRenderer, FullWidthCellRenderer or GroupRowRenderer.
    // so we have to pass the type in.
    getFullWidthCellRendererDetails(params) {
        return this.getCompDetails(this.gridOptions, $7b57b57eaf5a9648$var$FullWidth, null, params, true);
    }
    getFullWidthLoadingCellRendererDetails(params) {
        return this.getCompDetails(this.gridOptions, $7b57b57eaf5a9648$var$FullWidthLoading, "agLoadingCellRenderer", params, true);
    }
    getFullWidthGroupCellRendererDetails(params) {
        return this.getCompDetails(this.gridOptions, $7b57b57eaf5a9648$var$FullWidthGroup, "agGroupRowRenderer", params, true);
    }
    getFullWidthDetailCellRendererDetails(params) {
        return this.getCompDetails(this.gridOptions, $7b57b57eaf5a9648$var$FullWidthDetail, "agDetailCellRenderer", params, true);
    }
    // CELL RENDERER
    getInnerRendererDetails(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$InnerRendererComponent, null, params);
    }
    getFullWidthGroupRowInnerCellRenderer(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$InnerRendererComponent, null, params);
    }
    getCellRendererDetails(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$CellRendererComponent, null, params);
    }
    getEditorRendererDetails(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$EditorRendererComponent, null, params);
    }
    getLoadingCellRendererDetails(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$LoadingCellRendererComponent, "agSkeletonCellRenderer", params, true);
    }
    // CELL EDITOR
    getCellEditorDetails(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$CellEditorComponent, "agCellEditor", params, true);
    }
    // FILTER
    getFilterDetails(def, params, defaultFilter) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$FilterComponent, defaultFilter, params, true);
    }
    getDateCompDetails(params) {
        return this.getCompDetails(this.gridOptions, $7b57b57eaf5a9648$var$DateComponent, "agDateInput", params, true);
    }
    getLoadingOverlayCompDetails(params) {
        return this.getCompDetails(this.gridOptions, $7b57b57eaf5a9648$var$LoadingOverlayComponent2, "agLoadingOverlay", params, true);
    }
    getNoRowsOverlayCompDetails(params) {
        return this.getCompDetails(this.gridOptions, $7b57b57eaf5a9648$var$NoRowsOverlayComponent2, "agNoRowsOverlay", params, true);
    }
    getTooltipCompDetails(params) {
        return this.getCompDetails(params.colDef, $7b57b57eaf5a9648$var$TooltipComponent2, "agTooltipComponent", params, true);
    }
    getSetFilterCellRendererDetails(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$CellRendererComponent, null, params);
    }
    getFloatingFilterCompDetails(def, params, defaultFloatingFilter) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$FloatingFilterComponent, defaultFloatingFilter, params);
    }
    getToolPanelCompDetails(toolPanelDef, params) {
        return this.getCompDetails(toolPanelDef, $7b57b57eaf5a9648$var$ToolPanelComponent, null, params, true);
    }
    getStatusPanelCompDetails(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$StatusPanelComponent, null, params, true);
    }
    getMenuItemCompDetails(def, params) {
        return this.getCompDetails(def, $7b57b57eaf5a9648$var$MenuItemComponent, "agMenuItem", params, true);
    }
    getCompDetails(defObject, type, defaultName, params, mandatory = false) {
        const { propertyName: propertyName , cellRenderer: cellRenderer  } = type;
        let { compName: compName , jsComp: jsComp , fwComp: fwComp , paramsFromSelector: paramsFromSelector , popupFromSelector: popupFromSelector , popupPositionFromSelector: popupPositionFromSelector  } = _UserComponentFactory.getCompKeys(this.frameworkOverrides, defObject, type, params);
        const lookupFromRegistry = (key)=>{
            const item = this.userComponentRegistry.retrieve(propertyName, key);
            if (item) {
                jsComp = !item.componentFromFramework ? item.component : void 0;
                fwComp = item.componentFromFramework ? item.component : void 0;
            }
        };
        if (compName != null) lookupFromRegistry(compName);
        if (jsComp == null && fwComp == null && defaultName != null) lookupFromRegistry(defaultName);
        if (jsComp && cellRenderer && !this.agComponentUtils.doesImplementIComponent(jsComp)) jsComp = this.agComponentUtils.adaptFunction(propertyName, jsComp);
        if (!jsComp && !fwComp) {
            if (mandatory) $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`Could not find component ${compName}, did you forget to configure this component?`);
            return;
        }
        const paramsMerged = this.mergeParamsWithApplicationProvidedParams(defObject, type, params, paramsFromSelector);
        const componentFromFramework = jsComp == null;
        const componentClass = jsComp ? jsComp : fwComp;
        return {
            componentFromFramework: componentFromFramework,
            componentClass: componentClass,
            params: paramsMerged,
            type: type,
            popupFromSelector: popupFromSelector,
            popupPositionFromSelector: popupPositionFromSelector,
            newAgStackInstance: ()=>this.newAgStackInstance(componentClass, componentFromFramework, paramsMerged, type)
        };
    }
    static getCompKeys(frameworkOverrides, defObject, type, params) {
        const { propertyName: propertyName  } = type;
        let compName;
        let jsComp;
        let fwComp;
        let paramsFromSelector;
        let popupFromSelector;
        let popupPositionFromSelector;
        if (defObject) {
            const defObjectAny = defObject;
            const selectorFunc = defObjectAny[propertyName + "Selector"];
            const selectorRes = selectorFunc ? selectorFunc(params) : null;
            const assignComp = (providedJsComp)=>{
                if (typeof providedJsComp === "string") compName = providedJsComp;
                else if (providedJsComp != null && providedJsComp !== true) {
                    const isFwkComp = frameworkOverrides.isFrameworkComponent(providedJsComp);
                    if (isFwkComp) fwComp = providedJsComp;
                    else jsComp = providedJsComp;
                }
            };
            if (selectorRes) {
                assignComp(selectorRes.component);
                paramsFromSelector = selectorRes.params;
                popupFromSelector = selectorRes.popup;
                popupPositionFromSelector = selectorRes.popupPosition;
            } else assignComp(defObjectAny[propertyName]);
        }
        return {
            compName: compName,
            jsComp: jsComp,
            fwComp: fwComp,
            paramsFromSelector: paramsFromSelector,
            popupFromSelector: popupFromSelector,
            popupPositionFromSelector: popupPositionFromSelector
        };
    }
    newAgStackInstance(ComponentClass, componentFromFramework, params, type) {
        const propertyName = type.propertyName;
        const jsComponent = !componentFromFramework;
        let instance;
        if (jsComponent) instance = new ComponentClass();
        else {
            const thisComponentConfig = this.componentMetadataProvider.retrieve(propertyName);
            instance = this.frameworkComponentWrapper.wrap(ComponentClass, thisComponentConfig.mandatoryMethodList, thisComponentConfig.optionalMethodList, type);
        }
        const deferredInit = this.initComponent(instance, params);
        if (deferredInit == null) return $7b57b57eaf5a9648$export$30ec7836a4847721.resolve(instance);
        return deferredInit.then(()=>instance);
    }
    // used by Floating Filter
    mergeParamsWithApplicationProvidedParams(defObject, type, paramsFromGrid, paramsFromSelector = null) {
        const params = this.gos.getGridCommonParams();
        $7b57b57eaf5a9648$export$8ade6bd474fcde42(params, paramsFromGrid);
        const defObjectAny = defObject;
        const userParams = defObjectAny && defObjectAny[type.propertyName + "Params"];
        if (typeof userParams === "function") {
            const userParamsFromFunc = userParams(paramsFromGrid);
            $7b57b57eaf5a9648$export$8ade6bd474fcde42(params, userParamsFromFunc);
        } else if (typeof userParams === "object") $7b57b57eaf5a9648$export$8ade6bd474fcde42(params, userParams);
        $7b57b57eaf5a9648$export$8ade6bd474fcde42(params, paramsFromSelector);
        return params;
    }
    initComponent(component, params) {
        this.createBean(component);
        if (component.init == null) return;
        return component.init(params);
    }
};
// community-modules/core/src/components/framework/unwrapUserComp.ts
function $7b57b57eaf5a9648$export$213d4c63c3df47e4(comp) {
    const compAsAny = comp;
    const isProxy = compAsAny != null && compAsAny.getFrameworkComponentInstance != null;
    return isProxy ? compAsAny.getFrameworkComponentInstance() : comp;
}
// community-modules/core/src/context/genericContext.ts
var $7b57b57eaf5a9648$var$GenericContext = class {
    constructor(params){
        this.beans = {};
        this.createdBeans = [];
        this.destroyed = false;
        if (!params || !params.beanClasses) return;
        this.beanDestroyComparator = params.beanDestroyComparator;
        this.init(params);
    }
    init(params) {
        Object.entries(params.providedBeanInstances).forEach(([beanName, beanInstance])=>{
            this.beans[beanName] = beanInstance;
        });
        params.beanClasses.forEach((BeanClass)=>{
            const instance = new BeanClass();
            if (instance.beanName) this.beans[instance.beanName] = instance;
            else console.error(`Bean ${BeanClass.name} is missing beanName`);
            this.createdBeans.push(instance);
        });
        params.derivedBeans?.forEach((beanFunc)=>{
            const { beanName: beanName , bean: bean  } = beanFunc(this);
            this.beans[beanName] = bean;
            this.createdBeans.push(bean);
        });
        if (params.beanInitComparator) this.createdBeans.sort(params.beanInitComparator);
        this.initBeans(this.createdBeans);
    }
    getBeanInstances() {
        return Object.values(this.beans);
    }
    createBean(bean, afterPreCreateCallback) {
        if (!bean) throw Error(`Can't wire to bean since it is null`);
        this.initBeans([
            bean
        ], afterPreCreateCallback);
        return bean;
    }
    initBeans(beanInstances, afterPreCreateCallback) {
        beanInstances.forEach((instance)=>{
            instance.preWireBeans?.(this.beans);
            instance.wireBeans?.(this.beans);
        });
        beanInstances.forEach((instance)=>instance.preConstruct?.());
        if (afterPreCreateCallback) beanInstances.forEach(afterPreCreateCallback);
        beanInstances.forEach((instance)=>instance.postConstruct?.());
    }
    getBeans() {
        return this.beans;
    }
    getBean(name) {
        return this.beans[name];
    }
    destroy() {
        if (this.destroyed) return;
        this.destroyed = true;
        const beanInstances = this.getBeanInstances();
        if (this.beanDestroyComparator) beanInstances.sort(this.beanDestroyComparator);
        this.destroyBeans(beanInstances);
        this.beans = {};
        this.createdBeans = [];
    }
    /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */ destroyBean(bean) {
        bean?.destroy?.();
    }
    /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */ destroyBeans(beans) {
        if (beans) for(let i = 0; i < beans.length; i++)this.destroyBean(beans[i]);
        return [];
    }
    isDestroyed() {
        return this.destroyed;
    }
};
// community-modules/core/src/context/context.ts
var $7b57b57eaf5a9648$export$841858b892ce1f4c = class extends $7b57b57eaf5a9648$var$GenericContext {
    init(params) {
        this.gridId = params.gridId;
        this.beans.context = this;
        super.init(params);
    }
    destroy() {
        super.destroy();
        $7b57b57eaf5a9648$export$dc053975cc7f6c11.__unRegisterGridModules(this.gridId);
    }
    getGridId() {
        return this.gridId;
    }
};
// community-modules/core/src/interfaces/iExcelCreator.ts
var $7b57b57eaf5a9648$export$1b4f0b0d179ae7d9 = /* @__PURE__ */ ((ExcelFactoryMode2)=>{
    ExcelFactoryMode2[ExcelFactoryMode2["SINGLE_SHEET"] = 0] = "SINGLE_SHEET";
    ExcelFactoryMode2[ExcelFactoryMode2["MULTI_SHEET"] = 1] = "MULTI_SHEET";
    return ExcelFactoryMode2;
})($7b57b57eaf5a9648$export$1b4f0b0d179ae7d9 || {});
// community-modules/core/src/constants/direction.ts
var $7b57b57eaf5a9648$export$b40429d5c2dfb329 = /* @__PURE__ */ ((VerticalDirection2)=>{
    VerticalDirection2[VerticalDirection2["Up"] = 0] = "Up";
    VerticalDirection2[VerticalDirection2["Down"] = 1] = "Down";
    return VerticalDirection2;
})($7b57b57eaf5a9648$export$b40429d5c2dfb329 || {});
var $7b57b57eaf5a9648$export$2e679088785045c = /* @__PURE__ */ ((HorizontalDirection2)=>{
    HorizontalDirection2[HorizontalDirection2["Left"] = 0] = "Left";
    HorizontalDirection2[HorizontalDirection2["Right"] = 1] = "Right";
    return HorizontalDirection2;
})($7b57b57eaf5a9648$export$2e679088785045c || {});
// community-modules/core/src/dragAndDrop/dragAndDropService.ts
var $7b57b57eaf5a9648$export$46ba5a92125911d9 = /* @__PURE__ */ ((DragSourceType2)=>{
    DragSourceType2[DragSourceType2["ToolPanel"] = 0] = "ToolPanel";
    DragSourceType2[DragSourceType2["HeaderCell"] = 1] = "HeaderCell";
    DragSourceType2[DragSourceType2["RowDrag"] = 2] = "RowDrag";
    DragSourceType2[DragSourceType2["ChartPanel"] = 3] = "ChartPanel";
    DragSourceType2[DragSourceType2["AdvancedFilterBuilder"] = 4] = "AdvancedFilterBuilder";
    return DragSourceType2;
})($7b57b57eaf5a9648$export$46ba5a92125911d9 || {});
var $7b57b57eaf5a9648$var$GHOST_TEMPLATE = /* html */ `<div class="ag-dnd-ghost ag-unselectable">
<span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
<div class="ag-dnd-ghost-label"></div>
</div>`;
var $7b57b57eaf5a9648$export$3529111922becfa6 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "dragAndDropService";
        this.dragSourceAndParamsList = [];
        this.dropTargets = [];
    }
    wireBeans(beans) {
        this.dragService = beans.dragService;
        this.mouseEventService = beans.mouseEventService;
        this.environment = beans.environment;
    }
    postConstruct() {
        this.dropIconMap = {
            pinned: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("columnMovePin", this.gos, null),
            hide: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("columnMoveHide", this.gos, null),
            move: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("columnMoveMove", this.gos, null),
            left: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("columnMoveLeft", this.gos, null),
            right: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("columnMoveRight", this.gos, null),
            group: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("columnMoveGroup", this.gos, null),
            aggregate: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("columnMoveValue", this.gos, null),
            pivot: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("columnMovePivot", this.gos, null),
            notAllowed: $7b57b57eaf5a9648$export$f4e9fbdaadc5e5c1("dropNotAllowed", this.gos, null)
        };
    }
    addDragSource(dragSource, allowTouch = false) {
        const params = {
            eElement: dragSource.eElement,
            dragStartPixels: dragSource.dragStartPixels,
            onDragStart: this.onDragStart.bind(this, dragSource),
            onDragStop: this.onDragStop.bind(this),
            onDragging: this.onDragging.bind(this),
            includeTouch: allowTouch
        };
        this.dragSourceAndParamsList.push({
            params: params,
            dragSource: dragSource
        });
        this.dragService.addDragSource(params);
    }
    removeDragSource(dragSource) {
        const sourceAndParams = this.dragSourceAndParamsList.find((item)=>item.dragSource === dragSource);
        if (sourceAndParams) {
            this.dragService.removeDragSource(sourceAndParams.params);
            $7b57b57eaf5a9648$export$83a881c8b5120679(this.dragSourceAndParamsList, sourceAndParams);
        }
    }
    destroy() {
        this.dragSourceAndParamsList.forEach((sourceAndParams)=>this.dragService.removeDragSource(sourceAndParams.params));
        this.dragSourceAndParamsList.length = 0;
        this.dropTargets.length = 0;
        super.destroy();
    }
    nudge() {
        if (this.dragging) this.onDragging(this.eventLastTime, true);
    }
    onDragStart(dragSource, mouseEvent) {
        this.dragging = true;
        this.dragSource = dragSource;
        this.eventLastTime = mouseEvent;
        this.dragItem = this.dragSource.getDragItem();
        if (this.dragSource.onDragStarted) this.dragSource.onDragStarted();
        this.createGhost();
    }
    onDragStop(mouseEvent) {
        this.eventLastTime = null;
        this.dragging = false;
        if (this.dragSource.onDragStopped) this.dragSource.onDragStopped();
        if (this.lastDropTarget && this.lastDropTarget.onDragStop) {
            const draggingEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, null, null, false);
            this.lastDropTarget.onDragStop(draggingEvent);
        }
        this.lastDropTarget = void 0;
        this.dragItem = null;
        this.removeGhost();
    }
    onDragging(mouseEvent, fromNudge) {
        const hDirection = this.getHorizontalDirection(mouseEvent);
        const vDirection = this.getVerticalDirection(mouseEvent);
        this.eventLastTime = mouseEvent;
        this.positionGhost(mouseEvent);
        const validDropTargets = this.dropTargets.filter((target)=>this.isMouseOnDropTarget(mouseEvent, target));
        const dropTarget = this.findCurrentDropTarget(mouseEvent, validDropTargets);
        if (dropTarget !== this.lastDropTarget) {
            this.leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge);
            if (this.lastDropTarget !== null && dropTarget === null) this.dragSource.onGridExit?.(this.dragItem);
            if (this.lastDropTarget === null && dropTarget !== null) this.dragSource.onGridEnter?.(this.dragItem);
            this.enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            this.lastDropTarget = dropTarget;
        } else if (dropTarget && dropTarget.onDragging) {
            const draggingEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            dropTarget.onDragging(draggingEvent);
        }
    }
    getAllContainersFromDropTarget(dropTarget) {
        const secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
        const containers = [
            [
                dropTarget.getContainer()
            ]
        ];
        return secondaryContainers ? containers.concat(secondaryContainers) : containers;
    }
    allContainersIntersect(mouseEvent, containers) {
        for (const container of containers){
            const rect = container.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) return false;
            const horizontalFit = mouseEvent.clientX >= rect.left && mouseEvent.clientX < rect.right;
            const verticalFit = mouseEvent.clientY >= rect.top && mouseEvent.clientY < rect.bottom;
            if (!horizontalFit || !verticalFit) return false;
        }
        return true;
    }
    // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
    isMouseOnDropTarget(mouseEvent, dropTarget) {
        const allContainersFromDropTarget = this.getAllContainersFromDropTarget(dropTarget);
        let mouseOverTarget = false;
        for (const currentContainers of allContainersFromDropTarget)if (this.allContainersIntersect(mouseEvent, currentContainers)) {
            mouseOverTarget = true;
            break;
        }
        if (dropTarget.targetContainsSource && !dropTarget.getContainer().contains(this.dragSource.eElement)) return false;
        return mouseOverTarget && dropTarget.isInterestedIn(this.dragSource.type, this.dragSource.eElement);
    }
    findCurrentDropTarget(mouseEvent, validDropTargets) {
        const len = validDropTargets.length;
        if (len === 0) return null;
        if (len === 1) return validDropTargets[0];
        const rootNode = this.gos.getRootNode();
        const elementStack = rootNode.elementsFromPoint(mouseEvent.clientX, mouseEvent.clientY);
        for (const el of elementStack)for (const dropTarget of validDropTargets){
            const containers = $7b57b57eaf5a9648$export$5e3f39c5068e375d(this.getAllContainersFromDropTarget(dropTarget));
            if (containers.indexOf(el) !== -1) return dropTarget;
        }
        return null;
    }
    enterDragTargetIfExists(dropTarget, mouseEvent, hDirection, vDirection, fromNudge) {
        if (!dropTarget) return;
        if (dropTarget.onDragEnter) {
            const dragEnterEvent = this.createDropTargetEvent(dropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            dropTarget.onDragEnter(dragEnterEvent);
        }
        this.setGhostIcon(dropTarget.getIconName ? dropTarget.getIconName() : null);
    }
    leaveLastTargetIfExists(mouseEvent, hDirection, vDirection, fromNudge) {
        if (!this.lastDropTarget) return;
        if (this.lastDropTarget.onDragLeave) {
            const dragLeaveEvent = this.createDropTargetEvent(this.lastDropTarget, mouseEvent, hDirection, vDirection, fromNudge);
            this.lastDropTarget.onDragLeave(dragLeaveEvent);
        }
        this.setGhostIcon(null);
    }
    addDropTarget(dropTarget) {
        this.dropTargets.push(dropTarget);
    }
    removeDropTarget(dropTarget) {
        this.dropTargets = this.dropTargets.filter((target)=>target.getContainer() !== dropTarget.getContainer());
    }
    hasExternalDropZones() {
        return this.dropTargets.some((zones)=>zones.external);
    }
    findExternalZone(params) {
        const externalTargets = this.dropTargets.filter((target)=>target.external);
        return externalTargets.find((zone)=>zone.getContainer() === params.getContainer()) || null;
    }
    getHorizontalDirection(event) {
        const clientX = this.eventLastTime && this.eventLastTime.clientX;
        const eClientX = event.clientX;
        if (clientX === eClientX) return null;
        return clientX > eClientX ? 0 /* Left */  : 1 /* Right */ ;
    }
    getVerticalDirection(event) {
        const clientY = this.eventLastTime && this.eventLastTime.clientY;
        const eClientY = event.clientY;
        if (clientY === eClientY) return null;
        return clientY > eClientY ? 0 /* Up */  : 1 /* Down */ ;
    }
    createDropTargetEvent(dropTarget, event, hDirection, vDirection, fromNudge) {
        const dropZoneTarget = dropTarget.getContainer();
        const rect = dropZoneTarget.getBoundingClientRect();
        const { dragItem: dragItem , dragSource: dragSource  } = this;
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        return this.gos.addGridCommonParams({
            event: event,
            x: x,
            y: y,
            vDirection: vDirection,
            hDirection: hDirection,
            dragSource: dragSource,
            fromNudge: fromNudge,
            dragItem: dragItem,
            dropZoneTarget: dropZoneTarget
        });
    }
    positionGhost(event) {
        const ghost = this.eGhost;
        if (!ghost) return;
        const ghostRect = ghost.getBoundingClientRect();
        const ghostHeight = ghostRect.height;
        const browserWidth = $7b57b57eaf5a9648$var$_getBodyWidth() - 2;
        const browserHeight = $7b57b57eaf5a9648$var$_getBodyHeight() - 2;
        const offsetParentSize = $7b57b57eaf5a9648$var$_getElementRectWithOffset(ghost.offsetParent);
        const { clientY: clientY , clientX: clientX  } = event;
        let top = clientY - offsetParentSize.top - ghostHeight / 2;
        let left = clientX - offsetParentSize.left - 10;
        const eDocument = this.gos.getDocument();
        const win = eDocument.defaultView || window;
        const windowScrollY = win.pageYOffset || eDocument.documentElement.scrollTop;
        const windowScrollX = win.pageXOffset || eDocument.documentElement.scrollLeft;
        if (browserWidth > 0 && left + ghost.clientWidth > browserWidth + windowScrollX) left = browserWidth + windowScrollX - ghost.clientWidth;
        if (left < 0) left = 0;
        if (browserHeight > 0 && top + ghost.clientHeight > browserHeight + windowScrollY) top = browserHeight + windowScrollY - ghost.clientHeight;
        if (top < 0) top = 0;
        ghost.style.left = `${left}px`;
        ghost.style.top = `${top}px`;
    }
    removeGhost() {
        if (this.eGhost && this.eGhostParent) this.eGhostParent.removeChild(this.eGhost);
        this.eGhost = null;
    }
    createGhost() {
        this.eGhost = $7b57b57eaf5a9648$export$b1f57d075ca6d5fb($7b57b57eaf5a9648$var$GHOST_TEMPLATE);
        this.mouseEventService.stampTopLevelGridCompWithGridInstance(this.eGhost);
        this.environment.applyThemeClasses(this.eGhost);
        this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon");
        this.setGhostIcon(null);
        const eText = this.eGhost.querySelector(".ag-dnd-ghost-label");
        let dragItemName = this.dragSource.dragItemName;
        if ($7b57b57eaf5a9648$var$_isFunction(dragItemName)) dragItemName = dragItemName();
        eText.innerHTML = $7b57b57eaf5a9648$export$3df06b741968da82(dragItemName) || "";
        this.eGhost.style.height = "25px";
        this.eGhost.style.top = "20px";
        this.eGhost.style.left = "20px";
        const eDocument = this.gos.getDocument();
        let rootNode = null;
        let targetEl = null;
        try {
            rootNode = eDocument.fullscreenElement;
        } catch (e) {} finally{
            if (!rootNode) rootNode = this.gos.getRootNode();
            const body = rootNode.querySelector("body");
            if (body) targetEl = body;
            else if (rootNode instanceof ShadowRoot) targetEl = rootNode;
            else if (rootNode instanceof Document) targetEl = rootNode?.documentElement;
            else targetEl = rootNode;
        }
        this.eGhostParent = targetEl;
        if (!this.eGhostParent) $7b57b57eaf5a9648$export$2cf41453020eef66("Could not find document body, it is needed for dragging columns");
        else this.eGhostParent.appendChild(this.eGhost);
    }
    setGhostIcon(iconName, shake = false) {
        $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eGhostIcon);
        let eIcon = null;
        if (!iconName) iconName = this.dragSource.getDefaultIconName ? this.dragSource.getDefaultIconName() : "notAllowed";
        eIcon = this.dropIconMap[iconName];
        this.eGhostIcon.classList.toggle("ag-shake-left-to-right", shake);
        if (eIcon === this.dropIconMap["hide"] && this.gos.get("suppressDragLeaveHidesColumns")) return;
        if (eIcon) this.eGhostIcon.appendChild(eIcon);
    }
};
// community-modules/core/src/autoScrollService.ts
var $7b57b57eaf5a9648$export$c66bdc3d55a4f95 = class {
    constructor(params){
        this.tickingInterval = null;
        this.onScrollCallback = null;
        this.scrollContainer = params.scrollContainer;
        this.scrollHorizontally = params.scrollAxis.indexOf("x") !== -1;
        this.scrollVertically = params.scrollAxis.indexOf("y") !== -1;
        this.scrollByTick = params.scrollByTick != null ? params.scrollByTick : 20;
        if (params.onScrollCallback) this.onScrollCallback = params.onScrollCallback;
        if (this.scrollVertically) {
            this.getVerticalPosition = params.getVerticalPosition;
            this.setVerticalPosition = params.setVerticalPosition;
        }
        if (this.scrollHorizontally) {
            this.getHorizontalPosition = params.getHorizontalPosition;
            this.setHorizontalPosition = params.setHorizontalPosition;
        }
        this.shouldSkipVerticalScroll = params.shouldSkipVerticalScroll || (()=>false);
        this.shouldSkipHorizontalScroll = params.shouldSkipHorizontalScroll || (()=>false);
    }
    check(mouseEvent, forceSkipVerticalScroll = false) {
        const skipVerticalScroll = forceSkipVerticalScroll || this.shouldSkipVerticalScroll();
        if (skipVerticalScroll && this.shouldSkipHorizontalScroll()) return;
        const rect = this.scrollContainer.getBoundingClientRect();
        const scrollTick = this.scrollByTick;
        this.tickLeft = mouseEvent.clientX < rect.left + scrollTick;
        this.tickRight = mouseEvent.clientX > rect.right - scrollTick;
        this.tickUp = mouseEvent.clientY < rect.top + scrollTick && !skipVerticalScroll;
        this.tickDown = mouseEvent.clientY > rect.bottom - scrollTick && !skipVerticalScroll;
        if (this.tickLeft || this.tickRight || this.tickUp || this.tickDown) this.ensureTickingStarted();
        else this.ensureCleared();
    }
    ensureTickingStarted() {
        if (this.tickingInterval === null) {
            this.tickingInterval = window.setInterval(this.doTick.bind(this), 100);
            this.tickCount = 0;
        }
    }
    doTick() {
        this.tickCount++;
        const tickAmount = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
        if (this.scrollVertically) {
            const vScrollPosition = this.getVerticalPosition();
            if (this.tickUp) this.setVerticalPosition(vScrollPosition - tickAmount);
            if (this.tickDown) this.setVerticalPosition(vScrollPosition + tickAmount);
        }
        if (this.scrollHorizontally) {
            const hScrollPosition = this.getHorizontalPosition();
            if (this.tickLeft) this.setHorizontalPosition(hScrollPosition - tickAmount);
            if (this.tickRight) this.setHorizontalPosition(hScrollPosition + tickAmount);
        }
        if (this.onScrollCallback) this.onScrollCallback();
    }
    ensureCleared() {
        if (this.tickingInterval) {
            window.clearInterval(this.tickingInterval);
            this.tickingInterval = null;
        }
    }
};
// community-modules/core/src/interfaces/iRowNode.ts
var $7b57b57eaf5a9648$export$e879772ad3c0a0e = /* @__PURE__ */ ((RowHighlightPosition2)=>{
    RowHighlightPosition2[RowHighlightPosition2["Above"] = 0] = "Above";
    RowHighlightPosition2[RowHighlightPosition2["Below"] = 1] = "Below";
    return RowHighlightPosition2;
})($7b57b57eaf5a9648$export$e879772ad3c0a0e || {});
// community-modules/core/src/gridBodyComp/rowDragFeature.ts
var $7b57b57eaf5a9648$var$RowDragFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.dragAndDropService = beans.dragAndDropService;
        this.rowModel = beans.rowModel;
        this.pageBoundsService = beans.pageBoundsService;
        this.focusService = beans.focusService;
        this.sortController = beans.sortController;
        this.filterManager = beans.filterManager;
        this.selectionService = beans.selectionService;
        this.mouseEventService = beans.mouseEventService;
        this.ctrlsService = beans.ctrlsService;
        this.funcColsService = beans.funcColsService;
        this.rangeService = beans.rangeService;
    }
    constructor(eContainer){
        super();
        this.eContainer = eContainer;
    }
    postConstruct() {
        if (this.gos.isRowModelType("clientSide")) this.clientSideRowModel = this.rowModel;
        this.ctrlsService.whenReady((p)=>{
            const gridBodyCon = p.gridBodyCtrl;
            this.autoScrollService = new $7b57b57eaf5a9648$export$c66bdc3d55a4f95({
                scrollContainer: gridBodyCon.getBodyViewportElement(),
                scrollAxis: "y",
                getVerticalPosition: ()=>gridBodyCon.getScrollFeature().getVScrollPosition().top,
                setVerticalPosition: (position)=>gridBodyCon.getScrollFeature().setVerticalScrollPosition(position),
                onScrollCallback: ()=>{
                    this.onDragging(this.lastDraggingEvent);
                }
            });
        });
    }
    getContainer() {
        return this.eContainer;
    }
    isInterestedIn(type) {
        return type === 2 /* RowDrag */ ;
    }
    getIconName() {
        const managedDrag = this.gos.get("rowDragManaged");
        if (managedDrag && this.shouldPreventRowMove()) return "notAllowed";
        return "move";
    }
    shouldPreventRowMove() {
        const rowGroupCols = this.funcColsService.getRowGroupColumns();
        if (rowGroupCols.length) return true;
        const isFilterPresent = this.filterManager?.isAnyFilterPresent();
        if (isFilterPresent) return true;
        const isSortActive = this.sortController.isSortActive();
        if (isSortActive) return true;
        return false;
    }
    getRowNodes(draggingEvent) {
        if (!this.isFromThisGrid(draggingEvent)) return draggingEvent.dragItem.rowNodes || [];
        const currentNode = draggingEvent.dragItem.rowNode;
        const isRowDragMultiRow = this.gos.get("rowDragMultiRow");
        if (isRowDragMultiRow) {
            const selectedNodes = [
                ...this.selectionService.getSelectedNodes()
            ].sort((a, b)=>{
                if (a.rowIndex == null || b.rowIndex == null) return 0;
                return this.getRowIndexNumber(a) - this.getRowIndexNumber(b);
            });
            if (selectedNodes.indexOf(currentNode) !== -1) return selectedNodes;
        }
        return [
            currentNode
        ];
    }
    onDragEnter(draggingEvent) {
        draggingEvent.dragItem.rowNodes = this.getRowNodes(draggingEvent);
        this.dispatchGridEvent("rowDragEnter", draggingEvent);
        this.getRowNodes(draggingEvent).forEach((rowNode)=>{
            rowNode.setDragging(true);
        });
        this.onEnterOrDragging(draggingEvent);
    }
    onDragging(draggingEvent) {
        this.onEnterOrDragging(draggingEvent);
    }
    isFromThisGrid(draggingEvent) {
        const { dragSourceDomDataKey: dragSourceDomDataKey  } = draggingEvent.dragSource;
        return dragSourceDomDataKey === this.gos.getDomDataKey();
    }
    isDropZoneWithinThisGrid(draggingEvent) {
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        const gridGui = gridBodyCon.getGui();
        const { dropZoneTarget: dropZoneTarget  } = draggingEvent;
        return !gridGui.contains(dropZoneTarget);
    }
    onEnterOrDragging(draggingEvent) {
        this.dispatchGridEvent("rowDragMove", draggingEvent);
        this.lastDraggingEvent = draggingEvent;
        const pixel = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
        const managedDrag = this.gos.get("rowDragManaged");
        if (managedDrag) this.doManagedDrag(draggingEvent, pixel);
        this.autoScrollService.check(draggingEvent.event);
    }
    doManagedDrag(draggingEvent, pixel) {
        const isFromThisGrid = this.isFromThisGrid(draggingEvent);
        const managedDrag = this.gos.get("rowDragManaged");
        const rowNodes = draggingEvent.dragItem.rowNodes;
        if (managedDrag && this.shouldPreventRowMove()) return;
        if (this.gos.get("suppressMoveWhenRowDragging") || !isFromThisGrid) {
            if (!this.isDropZoneWithinThisGrid(draggingEvent)) this.clientSideRowModel.highlightRowAtPixel(rowNodes[0], pixel);
        } else this.moveRows(rowNodes, pixel);
    }
    getRowIndexNumber(rowNode) {
        const rowIndexStr = rowNode.getRowIndexString();
        return parseInt($7b57b57eaf5a9648$export$236389741107357f(rowIndexStr.split("-")), 10);
    }
    moveRowAndClearHighlight(draggingEvent) {
        const lastHighlightedRowNode = this.clientSideRowModel.getLastHighlightedRowNode();
        const isBelow = lastHighlightedRowNode && lastHighlightedRowNode.highlighted === 1 /* Below */ ;
        const pixel = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
        const rowNodes = draggingEvent.dragItem.rowNodes;
        let increment = isBelow ? 1 : 0;
        if (this.isFromThisGrid(draggingEvent)) {
            rowNodes.forEach((rowNode)=>{
                if (rowNode.rowTop < pixel) increment -= 1;
            });
            this.moveRows(rowNodes, pixel, increment);
        } else {
            const getRowIdFunc = this.gos.getRowIdCallback();
            let addIndex = this.clientSideRowModel.getRowIndexAtPixel(pixel) + 1;
            if (this.clientSideRowModel.getHighlightPosition(pixel) === 0 /* Above */ ) addIndex--;
            this.clientSideRowModel.updateRowData({
                add: rowNodes.filter((node)=>!this.clientSideRowModel.getRowNode(getRowIdFunc?.({
                        data: node.data,
                        level: 0,
                        rowPinned: node.rowPinned
                    }) ?? node.data.id)).map((node)=>node.data),
                addIndex: addIndex
            });
        }
        this.clearRowHighlight();
    }
    clearRowHighlight() {
        this.clientSideRowModel.highlightRowAtPixel(null);
    }
    moveRows(rowNodes, pixel, increment = 0) {
        const rowWasMoved = this.clientSideRowModel.ensureRowsAtPixel(rowNodes, pixel, increment);
        if (rowWasMoved) {
            this.focusService.clearFocusedCell();
            this.rangeService?.removeAllCellRanges();
        }
    }
    addRowDropZone(params) {
        if (!params.getContainer()) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("addRowDropZone - A container target needs to be provided");
            return;
        }
        if (this.dragAndDropService.findExternalZone(params)) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.");
            return;
        }
        let processedParams = {
            getContainer: params.getContainer
        };
        if (params.fromGrid) processedParams = params;
        else {
            if (params.onDragEnter) processedParams.onDragEnter = (e)=>{
                params.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", e));
            };
            if (params.onDragLeave) processedParams.onDragLeave = (e)=>{
                params.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", e));
            };
            if (params.onDragging) processedParams.onDragging = (e)=>{
                params.onDragging(this.draggingToRowDragEvent("rowDragMove", e));
            };
            if (params.onDragStop) processedParams.onDragStop = (e)=>{
                params.onDragStop(this.draggingToRowDragEvent("rowDragEnd", e));
            };
        }
        this.dragAndDropService.addDropTarget({
            isInterestedIn: (type)=>type === 2 /* RowDrag */ ,
            getIconName: ()=>"move",
            external: true,
            ...processedParams
        });
    }
    getRowDropZone(events) {
        const getContainer = this.getContainer.bind(this);
        const onDragEnter = this.onDragEnter.bind(this);
        const onDragLeave = this.onDragLeave.bind(this);
        const onDragging = this.onDragging.bind(this);
        const onDragStop = this.onDragStop.bind(this);
        if (!events) return {
            getContainer: getContainer,
            onDragEnter: onDragEnter,
            onDragLeave: onDragLeave,
            onDragging: onDragging,
            onDragStop: onDragStop,
            /* @private */ fromGrid: true
        };
        return {
            getContainer: getContainer,
            onDragEnter: events.onDragEnter ? (e)=>{
                onDragEnter(e);
                events.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", e));
            } : onDragEnter,
            onDragLeave: events.onDragLeave ? (e)=>{
                onDragLeave(e);
                events.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", e));
            } : onDragLeave,
            onDragging: events.onDragging ? (e)=>{
                onDragging(e);
                events.onDragging(this.draggingToRowDragEvent("rowDragMove", e));
            } : onDragging,
            onDragStop: events.onDragStop ? (e)=>{
                onDragStop(e);
                events.onDragStop(this.draggingToRowDragEvent("rowDragEnd", e));
            } : onDragStop,
            fromGrid: true
        };
    }
    draggingToRowDragEvent(type, draggingEvent) {
        const yNormalised = this.mouseEventService.getNormalisedPosition(draggingEvent).y;
        const mouseIsPastLastRow = yNormalised > this.pageBoundsService.getCurrentPageHeight();
        let overIndex = -1;
        let overNode;
        if (!mouseIsPastLastRow) {
            overIndex = this.rowModel.getRowIndexAtPixel(yNormalised);
            overNode = this.rowModel.getRow(overIndex);
        }
        let vDirectionString;
        switch(draggingEvent.vDirection){
            case 1 /* Down */ :
                vDirectionString = "down";
                break;
            case 0 /* Up */ :
                vDirectionString = "up";
                break;
            default:
                vDirectionString = null;
                break;
        }
        const event = this.gos.addGridCommonParams({
            type: type,
            event: draggingEvent.event,
            node: draggingEvent.dragItem.rowNode,
            nodes: draggingEvent.dragItem.rowNodes,
            overIndex: overIndex,
            overNode: overNode,
            y: yNormalised,
            vDirection: vDirectionString
        });
        return event;
    }
    dispatchGridEvent(type, draggingEvent) {
        const event = this.draggingToRowDragEvent(type, draggingEvent);
        this.eventService.dispatchEvent(event);
    }
    onDragLeave(draggingEvent) {
        this.dispatchGridEvent("rowDragLeave", draggingEvent);
        this.stopDragging(draggingEvent);
        if (this.gos.get("rowDragManaged")) this.clearRowHighlight();
    }
    onDragStop(draggingEvent) {
        this.dispatchGridEvent("rowDragEnd", draggingEvent);
        this.stopDragging(draggingEvent);
        if (this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(draggingEvent)) && !this.isDropZoneWithinThisGrid(draggingEvent)) this.moveRowAndClearHighlight(draggingEvent);
    }
    stopDragging(draggingEvent) {
        this.autoScrollService.ensureCleared();
        this.getRowNodes(draggingEvent).forEach((rowNode)=>{
            rowNode.setDragging(false);
        });
    }
};
// community-modules/core/src/dragAndDrop/dragService.ts
var $7b57b57eaf5a9648$export$590729638d17528a = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "dragService";
        this.dragEndFunctions = [];
        this.dragSources = [];
    }
    wireBeans(beans) {
        this.mouseEventService = beans.mouseEventService;
    }
    destroy() {
        this.dragSources.forEach(this.removeListener.bind(this));
        this.dragSources.length = 0;
        super.destroy();
    }
    removeListener(dragSourceAndListener) {
        const element = dragSourceAndListener.dragSource.eElement;
        const mouseDownListener = dragSourceAndListener.mouseDownListener;
        element.removeEventListener("mousedown", mouseDownListener);
        if (dragSourceAndListener.touchEnabled) {
            const touchStartListener = dragSourceAndListener.touchStartListener;
            element.removeEventListener("touchstart", touchStartListener, {
                passive: true
            });
        }
    }
    removeDragSource(params) {
        const dragSourceAndListener = this.dragSources.find((item)=>item.dragSource === params);
        if (!dragSourceAndListener) return;
        this.removeListener(dragSourceAndListener);
        $7b57b57eaf5a9648$export$83a881c8b5120679(this.dragSources, dragSourceAndListener);
    }
    isDragging() {
        return this.dragging;
    }
    addDragSource(params) {
        const mouseListener = this.onMouseDown.bind(this, params);
        const { eElement: eElement , includeTouch: includeTouch , stopPropagationForTouch: stopPropagationForTouch  } = params;
        eElement.addEventListener("mousedown", mouseListener);
        let touchListener = null;
        const suppressTouch = this.gos.get("suppressTouch");
        if (includeTouch && !suppressTouch) {
            touchListener = (touchEvent)=>{
                if ($7b57b57eaf5a9648$var$_isFocusableFormField(touchEvent.target)) return;
                if (touchEvent.cancelable) {
                    touchEvent.preventDefault();
                    if (stopPropagationForTouch) touchEvent.stopPropagation();
                }
                this.onTouchStart(params, touchEvent);
            };
            eElement.addEventListener("touchstart", touchListener, {
                passive: false
            });
        }
        this.dragSources.push({
            dragSource: params,
            mouseDownListener: mouseListener,
            touchStartListener: touchListener,
            touchEnabled: !!includeTouch
        });
    }
    getStartTarget() {
        return this.startTarget;
    }
    // gets called whenever mouse down on any drag source
    onTouchStart(params, touchEvent) {
        this.currentDragParams = params;
        this.dragging = false;
        const touch = touchEvent.touches[0];
        this.touchLastTime = touch;
        this.touchStart = touch;
        const touchMoveEvent = (e)=>this.onTouchMove(e, params.eElement);
        const touchEndEvent = (e)=>this.onTouchUp(e, params.eElement);
        const documentTouchMove = (e)=>{
            if (e.cancelable) e.preventDefault();
        };
        const target = touchEvent.target;
        const events = [
            // Prevents the page document from moving while we are dragging items around.
            // preventDefault needs to be called in the touchmove listener and never inside the
            // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
            {
                target: this.gos.getRootNode(),
                type: "touchmove",
                listener: documentTouchMove,
                options: {
                    passive: false
                }
            },
            {
                target: target,
                type: "touchmove",
                listener: touchMoveEvent,
                options: {
                    passive: true
                }
            },
            {
                target: target,
                type: "touchend",
                listener: touchEndEvent,
                options: {
                    passive: true
                }
            },
            {
                target: target,
                type: "touchcancel",
                listener: touchEndEvent,
                options: {
                    passive: true
                }
            }
        ];
        this.addTemporaryEvents(events);
        if (params.dragStartPixels === 0) this.onCommonMove(touch, this.touchStart, params.eElement);
    }
    // gets called whenever mouse down on any drag source
    onMouseDown(params, mouseEvent) {
        const e = mouseEvent;
        if (params.skipMouseEvent && params.skipMouseEvent(mouseEvent)) return;
        if (e._alreadyProcessedByDragService) return;
        e._alreadyProcessedByDragService = true;
        if (mouseEvent.button !== 0) return;
        if (this.shouldPreventMouseEvent(mouseEvent)) mouseEvent.preventDefault();
        this.currentDragParams = params;
        this.dragging = false;
        this.mouseStartEvent = mouseEvent;
        this.startTarget = mouseEvent.target;
        const mouseMoveEvent = (event)=>this.onMouseMove(event, params.eElement);
        const mouseUpEvent = (event)=>this.onMouseUp(event, params.eElement);
        const contextEvent = (event)=>event.preventDefault();
        const target = this.gos.getRootNode();
        const events = [
            {
                target: target,
                type: "mousemove",
                listener: mouseMoveEvent
            },
            {
                target: target,
                type: "mouseup",
                listener: mouseUpEvent
            },
            {
                target: target,
                type: "contextmenu",
                listener: contextEvent
            }
        ];
        this.addTemporaryEvents(events);
        if (params.dragStartPixels === 0) this.onMouseMove(mouseEvent, params.eElement);
    }
    addTemporaryEvents(events) {
        events.forEach((currentEvent)=>{
            const { target: target , type: type , listener: listener , options: options  } = currentEvent;
            target.addEventListener(type, listener, options);
        });
        this.dragEndFunctions.push(()=>{
            events.forEach((currentEvent)=>{
                const { target: target , type: type , listener: listener , options: options  } = currentEvent;
                target.removeEventListener(type, listener, options);
            });
        });
    }
    // returns true if the event is close to the original event by X pixels either vertically or horizontally.
    // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
    isEventNearStartEvent(currentEvent, startEvent) {
        const { dragStartPixels: dragStartPixels  } = this.currentDragParams;
        const requiredPixelDiff = $7b57b57eaf5a9648$export$25d27f17d3af40f7(dragStartPixels) ? dragStartPixels : 4;
        return $7b57b57eaf5a9648$var$_areEventsNear(currentEvent, startEvent, requiredPixelDiff);
    }
    getFirstActiveTouch(touchList) {
        for(let i = 0; i < touchList.length; i++){
            if (touchList[i].identifier === this.touchStart.identifier) return touchList[i];
        }
        return null;
    }
    onCommonMove(currentEvent, startEvent, el) {
        if (!this.dragging) {
            if (!this.dragging && this.isEventNearStartEvent(currentEvent, startEvent)) return;
            this.dragging = true;
            const event = {
                type: "dragStarted",
                target: el
            };
            this.eventService.dispatchEvent(event);
            this.currentDragParams.onDragStart(startEvent);
            this.currentDragParams.onDragging(startEvent);
        }
        this.currentDragParams.onDragging(currentEvent);
    }
    onTouchMove(touchEvent, el) {
        const touch = this.getFirstActiveTouch(touchEvent.touches);
        if (!touch) return;
        this.onCommonMove(touch, this.touchStart, el);
    }
    // only gets called after a mouse down - as this is only added after mouseDown
    // and is removed when mouseUp happens
    onMouseMove(mouseEvent, el) {
        if ($7b57b57eaf5a9648$var$_isBrowserSafari()) {
            const eDocument = this.gos.getDocument();
            eDocument.getSelection()?.removeAllRanges();
        }
        if (this.shouldPreventMouseEvent(mouseEvent)) mouseEvent.preventDefault();
        this.onCommonMove(mouseEvent, this.mouseStartEvent, el);
    }
    shouldPreventMouseEvent(mouseEvent) {
        const isEnableCellTextSelect = this.gos.get("enableCellTextSelection");
        const isMouseMove = mouseEvent.type === "mousemove";
        return(// when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
        // to avoid the grid text being selected while dragging components.
        isEnableCellTextSelect && isMouseMove && mouseEvent.cancelable && this.mouseEventService.isEventFromThisGrid(mouseEvent) && !this.isOverFormFieldElement(mouseEvent));
    }
    isOverFormFieldElement(mouseEvent) {
        const el = mouseEvent.target;
        const tagName = el?.tagName.toLocaleLowerCase();
        return !!tagName?.match("^a$|textarea|input|select|button");
    }
    onTouchUp(touchEvent, el) {
        let touch = this.getFirstActiveTouch(touchEvent.changedTouches);
        if (!touch) touch = this.touchLastTime;
        this.onUpCommon(touch, el);
    }
    onMouseUp(mouseEvent, el) {
        this.onUpCommon(mouseEvent, el);
    }
    onUpCommon(eventOrTouch, el) {
        if (this.dragging) {
            this.dragging = false;
            this.currentDragParams.onDragStop(eventOrTouch);
            const event = {
                type: "dragStopped",
                target: el
            };
            this.eventService.dispatchEvent(event);
        }
        this.mouseStartEvent = null;
        this.startTarget = null;
        this.touchStart = null;
        this.touchLastTime = null;
        this.currentDragParams = null;
        this.dragEndFunctions.forEach((func)=>func());
        this.dragEndFunctions.length = 0;
    }
};
// community-modules/core/src/rendering/row/rowDragComp.ts
var $7b57b57eaf5a9648$export$10f7d2f62fe74867 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(cellValueFn, rowNode, column, customGui, dragStartPixels, suppressVisibilityChange){
        super();
        this.cellValueFn = cellValueFn;
        this.rowNode = rowNode;
        this.column = column;
        this.customGui = customGui;
        this.dragStartPixels = dragStartPixels;
        this.suppressVisibilityChange = suppressVisibilityChange;
        this.dragSource = null;
    }
    wireBeans(beans) {
        this.beans = beans;
    }
    isCustomGui() {
        return this.customGui != null;
    }
    postConstruct() {
        if (!this.customGui) {
            this.setTemplate(/* html */ `<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>`);
            this.getGui().appendChild($7b57b57eaf5a9648$export$d8feba07bf373edb("rowDrag", this.gos, null));
            this.addDragSource();
        } else this.setDragElement(this.customGui, this.dragStartPixels);
        this.checkCompatibility();
        if (!this.suppressVisibilityChange) {
            const strategy = this.gos.get("rowDragManaged") ? new $7b57b57eaf5a9648$var$ManagedVisibilityStrategy(this, this.beans, this.rowNode, this.column) : new $7b57b57eaf5a9648$var$NonManagedVisibilityStrategy(this, this.beans, this.rowNode, this.column);
            this.createManagedBean(strategy, this.beans.context);
        }
    }
    setDragElement(dragElement, dragStartPixels) {
        this.setTemplateFromElement(dragElement);
        this.addDragSource(dragStartPixels);
    }
    getSelectedNodes() {
        const isRowDragMultiRow = this.gos.get("rowDragMultiRow");
        if (!isRowDragMultiRow) return [
            this.rowNode
        ];
        const selection = this.beans.selectionService.getSelectedNodes();
        return selection.indexOf(this.rowNode) !== -1 ? selection : [
            this.rowNode
        ];
    }
    // returns true if all compatibility items work out
    checkCompatibility() {
        const managed = this.gos.get("rowDragManaged");
        const treeData = this.gos.get("treeData");
        if (treeData && managed) $7b57b57eaf5a9648$export$2cf41453020eef66("If using row drag with tree data, you cannot have rowDragManaged=true");
    }
    getDragItem() {
        return {
            rowNode: this.rowNode,
            rowNodes: this.getSelectedNodes(),
            columns: this.column ? [
                this.column
            ] : void 0,
            defaultTextValue: this.cellValueFn()
        };
    }
    getRowDragText(column) {
        if (column) {
            const colDef = column.getColDef();
            if (colDef.rowDragText) return colDef.rowDragText;
        }
        return this.gos.get("rowDragText");
    }
    addDragSource(dragStartPixels = 4) {
        if (this.dragSource) this.removeDragSource();
        const eGui = this.getGui();
        if (this.gos.get("enableCellTextSelection")) {
            this.removeMouseDownListener();
            this.mouseDownListener = this.addManagedElementListeners(eGui, {
                mousedown: (e)=>{
                    e?.preventDefault();
                }
            })[0];
        }
        const translate = this.localeService.getLocaleTextFunc();
        this.dragSource = {
            type: 2 /* RowDrag */ ,
            eElement: eGui,
            dragItemName: ()=>{
                const dragItem = this.getDragItem();
                const dragItemCount = dragItem.rowNodes?.length || 1;
                const rowDragText = this.getRowDragText(this.column);
                if (rowDragText) return rowDragText(dragItem, dragItemCount);
                return dragItemCount === 1 ? this.cellValueFn() : `${dragItemCount} ${translate("rowDragRows", "rows")}`;
            },
            getDragItem: ()=>this.getDragItem(),
            dragStartPixels: dragStartPixels,
            dragSourceDomDataKey: this.gos.getDomDataKey()
        };
        this.beans.dragAndDropService.addDragSource(this.dragSource, true);
    }
    destroy() {
        this.removeDragSource();
        this.removeMouseDownListener();
        super.destroy();
    }
    removeDragSource() {
        if (!this.dragSource) return;
        this.beans.dragAndDropService.removeDragSource(this.dragSource);
        this.dragSource = null;
    }
    removeMouseDownListener() {
        if (!this.mouseDownListener) return;
        this.mouseDownListener();
        this.mouseDownListener = void 0;
    }
};
var $7b57b57eaf5a9648$var$VisibilityStrategy = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(parent, rowNode, column){
        super();
        this.parent = parent;
        this.rowNode = rowNode;
        this.column = column;
    }
    setDisplayedOrVisible(neverDisplayed) {
        const displayedOptions = {
            skipAriaHidden: true
        };
        if (neverDisplayed) this.parent.setDisplayed(false, displayedOptions);
        else {
            let shown = true;
            let isShownSometimes = false;
            if (this.column) {
                shown = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui();
                isShownSometimes = $7b57b57eaf5a9648$var$_isFunction(this.column.getColDef().rowDrag);
            }
            if (isShownSometimes) {
                this.parent.setDisplayed(true, displayedOptions);
                this.parent.setVisible(shown, displayedOptions);
            } else {
                this.parent.setDisplayed(shown, displayedOptions);
                this.parent.setVisible(true, displayedOptions);
            }
        }
    }
};
var $7b57b57eaf5a9648$var$NonManagedVisibilityStrategy = class extends $7b57b57eaf5a9648$var$VisibilityStrategy {
    constructor(parent, beans, rowNode, column){
        super(parent, rowNode, column);
        this.beans = beans;
    }
    postConstruct() {
        this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
        const listener = this.workOutVisibility.bind(this);
        this.addManagedListeners(this.rowNode, {
            dataChanged: listener,
            cellChanged: listener
        });
        this.addManagedListeners(this.beans.eventService, {
            newColumnsLoaded: listener
        });
        this.workOutVisibility();
    }
    onSuppressRowDrag() {
        this.workOutVisibility();
    }
    workOutVisibility() {
        const neverDisplayed = this.gos.get("suppressRowDrag");
        this.setDisplayedOrVisible(neverDisplayed);
    }
};
var $7b57b57eaf5a9648$var$ManagedVisibilityStrategy = class extends $7b57b57eaf5a9648$var$VisibilityStrategy {
    constructor(parent, beans, rowNode, column){
        super(parent, rowNode, column);
        this.beans = beans;
    }
    postConstruct() {
        const listener = this.workOutVisibility.bind(this);
        this.addManagedListeners(this.beans.eventService, {
            sortChanged: listener,
            filterChanged: listener,
            columnRowGroupChanged: listener,
            newColumnsLoaded: listener
        });
        this.addManagedListeners(this.rowNode, {
            dataChanged: listener,
            cellChanged: listener
        });
        this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
        this.workOutVisibility();
    }
    onSuppressRowDrag() {
        this.workOutVisibility();
    }
    workOutVisibility() {
        const gridBodyCon = this.beans.ctrlsService.getGridBodyCtrl();
        const rowDragFeature = gridBodyCon.getRowDragFeature();
        const shouldPreventRowMove = rowDragFeature && rowDragFeature.shouldPreventRowMove();
        const suppressRowDrag = this.gos.get("suppressRowDrag");
        const hasExternalDropZones = this.beans.dragAndDropService.hasExternalDropZones();
        const neverDisplayed = shouldPreventRowMove && !hasExternalDropZones || suppressRowDrag;
        this.setDisplayedOrVisible(neverDisplayed);
    }
};
// community-modules/core/src/entities/rowNode.ts
var $7b57b57eaf5a9648$var$_RowNode = class _RowNode {
    constructor(beans){
        /** The current row index. If the row is filtered out or in a collapsed group, this value will be `null`. */ this.rowIndex = null;
        /** The key for the group eg Ireland, UK, USA */ this.key = null;
        /** Children mapped by the pivot columns. */ this.childrenMapped = {};
        /**
     * This will be `true` if it has a rowIndex assigned, otherwise `false`.
     */ this.displayed = false;
        /** The row top position in pixels. */ this.rowTop = null;
        /** The top pixel for this row last time, makes sense if data set was ordered or filtered,
     * it is used so new rows can animate in from their old position. */ this.oldRowTop = null;
        /** `true` by default - can be overridden via gridOptions.isRowSelectable(rowNode) */ this.selectable = true;
        /** Used by sorting service - to give deterministic sort to groups. Previously we
     * just id for this, however id is a string and had slower sorting compared to numbers. */ this.__objectId = _RowNode.OBJECT_ID_SEQUENCE++;
        /** When one or more Columns are using autoHeight, this keeps track of height of each autoHeight Cell,
     * indexed by the Column ID. */ this.__autoHeights = {};
        /** `true` when nodes with the same id are being removed and added as part of the same batch transaction */ this.alreadyRendered = false;
        this.highlighted = null;
        this.hovered = false;
        this.selected = false;
        this.beans = beans;
    }
    /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */ setData(data) {
        this.setDataCommon(data, false);
    }
    // similar to setRowData, however it is expected that the data is the same data item. this
    // is intended to be used with Redux type stores, where the whole data can be changed. we are
    // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
    // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
    // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
    /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */ updateData(data) {
        this.setDataCommon(data, true);
    }
    setDataCommon(data, update) {
        const oldData = this.data;
        this.data = data;
        this.beans.valueCache.onDataChanged();
        this.updateDataOnDetailNode();
        this.checkRowSelectable();
        this.resetQuickFilterAggregateText();
        const event = this.createDataChangedEvent(data, oldData, update);
        this.localEventService?.dispatchEvent(event);
    }
    // when we are doing master / detail, the detail node is lazy created, but then kept around.
    // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
    // in sync, otherwise expand/collapse of the detail would still show the old values.
    updateDataOnDetailNode() {
        if (this.detailNode) this.detailNode.data = this.data;
    }
    createDataChangedEvent(newData, oldData, update) {
        return {
            type: "dataChanged",
            node: this,
            oldData: oldData,
            newData: newData,
            update: update
        };
    }
    getRowIndexString() {
        if (this.rowIndex == null) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.");
            return null;
        }
        if (this.rowPinned === "top") return "t-" + this.rowIndex;
        if (this.rowPinned === "bottom") return "b-" + this.rowIndex;
        return this.rowIndex.toString();
    }
    createDaemonNode() {
        const oldNode = new _RowNode(this.beans);
        oldNode.id = this.id;
        oldNode.data = this.data;
        oldNode.__daemon = true;
        oldNode.selected = this.selected;
        oldNode.level = this.level;
        return oldNode;
    }
    setDataAndId(data, id) {
        const oldNode = $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.id) ? this.createDaemonNode() : null;
        const oldData = this.data;
        this.data = data;
        this.updateDataOnDetailNode();
        this.setId(id);
        this.checkRowSelectable();
        this.beans.selectionService.syncInRowNode(this, oldNode);
        const event = this.createDataChangedEvent(data, oldData, false);
        this.localEventService?.dispatchEvent(event);
    }
    checkRowSelectable() {
        const isRowSelectableFunc = this.beans.gos.get("isRowSelectable");
        this.setRowSelectable(isRowSelectableFunc ? isRowSelectableFunc(this) : true);
    }
    setRowSelectable(newVal, suppressSelectionUpdate) {
        if (this.selectable !== newVal) {
            this.selectable = newVal;
            this.dispatchRowEvent("selectableChanged");
            if (suppressSelectionUpdate) return;
            const isGroupSelectsChildren = this.beans.gos.get("groupSelectsChildren");
            if (isGroupSelectsChildren) {
                const selected = this.calculateSelectedFromChildren();
                this.setSelectedParams({
                    newValue: selected ?? false,
                    source: "selectableChanged"
                });
                return;
            }
            if (this.isSelected() && !this.selectable) this.setSelectedParams({
                newValue: false,
                source: "selectableChanged"
            });
        }
    }
    setId(id) {
        const getRowIdFunc = this.beans.gos.getRowIdCallback();
        if (getRowIdFunc) {
            if (this.data) {
                const parentKeys = this.getGroupKeys(true);
                this.id = getRowIdFunc({
                    data: this.data,
                    parentKeys: parentKeys.length > 0 ? parentKeys : void 0,
                    level: this.level,
                    rowPinned: this.rowPinned
                });
                if (this.id.startsWith(_RowNode.ID_PREFIX_ROW_GROUP)) $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`Row IDs cannot start with ${_RowNode.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`);
            } else this.id = void 0;
        } else this.id = id;
    }
    getGroupKeys(excludeSelf = false) {
        const keys = [];
        let pointer = this;
        if (excludeSelf) pointer = pointer.parent;
        while(pointer && pointer.level >= 0){
            keys.push(pointer.key);
            pointer = pointer.parent;
        }
        keys.reverse();
        return keys;
    }
    isPixelInRange(pixel) {
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(this.rowTop) || !$7b57b57eaf5a9648$export$25d27f17d3af40f7(this.rowHeight)) return false;
        return pixel >= this.rowTop && pixel < this.rowTop + this.rowHeight;
    }
    updateIfDifferent(key, value, eventName) {
        if (this[key] === value) return;
        this[key] = value;
        this.dispatchRowEvent(eventName);
    }
    setFirstChild(firstChild) {
        this.updateIfDifferent("firstChild", firstChild, "firstChildChanged");
    }
    setLastChild(lastChild) {
        this.updateIfDifferent("lastChild", lastChild, "lastChildChanged");
    }
    setChildIndex(childIndex) {
        this.updateIfDifferent("childIndex", childIndex, "childIndexChanged");
    }
    setRowTop(rowTop) {
        this.oldRowTop = this.rowTop;
        if (this.rowTop === rowTop) return;
        this.rowTop = rowTop;
        this.dispatchRowEvent("topChanged");
        this.setDisplayed(rowTop !== null);
    }
    clearRowTopAndRowIndex() {
        this.oldRowTop = null;
        this.setRowTop(null);
        this.setRowIndex(null);
    }
    setDisplayed(displayed) {
        this.updateIfDifferent("displayed", displayed, "displayedChanged");
    }
    setDragging(dragging) {
        this.updateIfDifferent("dragging", dragging, "draggingChanged");
    }
    setHighlighted(highlighted) {
        this.updateIfDifferent("highlighted", highlighted, "rowHighlightChanged");
    }
    setHovered(hovered) {
        if (this.hovered === hovered) return;
        this.hovered = hovered;
    }
    isHovered() {
        return this.hovered;
    }
    setAllChildrenCount(allChildrenCount) {
        this.updateIfDifferent("allChildrenCount", allChildrenCount, "allChildrenCountChanged");
    }
    setMaster(master) {
        if (this.master === master) return;
        if (this.master && !master) this.expanded = false;
        this.master = master;
        this.dispatchRowEvent("masterChanged");
    }
    setGroup(group) {
        if (this.group === group) return;
        if (this.group && !group) this.expanded = false;
        this.group = group;
        this.updateHasChildren();
        this.checkRowSelectable();
        this.dispatchRowEvent("groupChanged");
    }
    /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */ setRowHeight(rowHeight, estimated = false) {
        this.rowHeight = rowHeight;
        this.rowHeightEstimated = estimated;
        this.dispatchRowEvent("heightChanged");
    }
    setRowAutoHeight(cellHeight, column) {
        if (!this.__autoHeights) this.__autoHeights = {};
        this.__autoHeights[column.getId()] = cellHeight;
        if (cellHeight != null) {
            if (this.checkAutoHeightsDebounced == null) this.checkAutoHeightsDebounced = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.checkAutoHeights.bind(this), 1);
            this.checkAutoHeightsDebounced();
        }
    }
    checkAutoHeights() {
        let notAllPresent = false;
        let nonePresent = true;
        let newRowHeight = 0;
        const autoHeights = this.__autoHeights;
        if (autoHeights == null) return;
        const displayedAutoHeightCols = this.beans.visibleColsService.getAllAutoHeightCols();
        displayedAutoHeightCols.forEach((col)=>{
            let cellHeight = autoHeights[col.getId()];
            if (cellHeight == null) {
                if (this.beans.columnModel.isColSpanActive()) {
                    let activeColsForRow = [];
                    switch(col.getPinned()){
                        case "left":
                            activeColsForRow = this.beans.visibleColsService.getLeftColsForRow(this);
                            break;
                        case "right":
                            activeColsForRow = this.beans.visibleColsService.getRightColsForRow(this);
                            break;
                        case null:
                            activeColsForRow = this.beans.columnViewportService.getColsWithinViewport(this);
                            break;
                    }
                    if (activeColsForRow.includes(col)) {
                        notAllPresent = true;
                        return;
                    }
                    cellHeight = -1;
                } else {
                    notAllPresent = true;
                    return;
                }
            } else nonePresent = false;
            if (cellHeight > newRowHeight) newRowHeight = cellHeight;
        });
        if (notAllPresent) return;
        if (nonePresent || newRowHeight < 10) newRowHeight = this.beans.gos.getRowHeightForNode(this).height;
        if (newRowHeight == this.rowHeight) return;
        this.setRowHeight(newRowHeight);
        const rowModel = this.beans.rowModel;
        if (rowModel.onRowHeightChangedDebounced) rowModel.onRowHeightChangedDebounced();
    }
    setRowIndex(rowIndex) {
        this.updateIfDifferent("rowIndex", rowIndex, "rowIndexChanged");
    }
    setUiLevel(uiLevel) {
        this.updateIfDifferent("uiLevel", uiLevel, "uiLevelChanged");
    }
    /**
   * Set the expanded state of this rowNode. Pass `true` to expand and `false` to collapse.
   */ setExpanded(expanded, e, forceSync) {
        if (this.expanded === expanded) return;
        this.expanded = expanded;
        this.dispatchRowEvent("expandedChanged");
        const event = {
            ...this.createGlobalRowEvent("rowGroupOpened"),
            expanded: expanded,
            event: e || null
        };
        this.beans.rowNodeEventThrottle.dispatchExpanded(event, forceSync);
        this.beans.rowRenderer.refreshCells({
            rowNodes: [
                this
            ]
        });
    }
    createGlobalRowEvent(type) {
        return this.beans.gos.addGridCommonParams({
            type: type,
            node: this,
            data: this.data,
            rowIndex: this.rowIndex,
            rowPinned: this.rowPinned
        });
    }
    /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */ setDataValue(colKey, newValue, eventSource) {
        const getColumnFromKey = ()=>{
            if (typeof colKey !== "string") return colKey;
            return this.beans.columnModel.getCol(colKey) ?? this.beans.columnModel.getColDefCol(colKey);
        };
        const column = getColumnFromKey();
        const oldValue = this.getValueFromValueService(column);
        if (this.beans.gos.get("readOnlyEdit")) {
            this.dispatchEventForSaveValueReadOnly(column, oldValue, newValue, eventSource);
            return false;
        }
        const valueChanged = this.beans.valueService.setValue(this, column, newValue, eventSource);
        this.dispatchCellChangedEvent(column, newValue, oldValue);
        this.checkRowSelectable();
        return valueChanged;
    }
    getValueFromValueService(column) {
        const lockedClosedGroup = this.leafGroup && this.beans.columnModel.isPivotMode();
        const isOpenGroup = this.group && this.expanded && !this.footer && !lockedClosedGroup;
        let includeFooter = false;
        const groupIncludeFooterOpt = this.beans.gos.get("groupTotalRow") ?? this.beans.gos.get("groupIncludeFooter");
        if (typeof groupIncludeFooterOpt !== "function") includeFooter = !!groupIncludeFooterOpt;
        else {
            const groupIncludeFooterCb = this.beans.gos.getCallback("groupTotalRow") ?? this.beans.gos.getCallback("groupIncludeFooter");
            includeFooter = !!groupIncludeFooterCb({
                node: this
            });
        }
        const groupAlwaysShowAggData = this.beans.gos.get("groupSuppressBlankHeader");
        const ignoreAggData = isOpenGroup && includeFooter && !groupAlwaysShowAggData;
        const value = this.beans.valueService.getValue(column, this, false, ignoreAggData);
        return value;
    }
    dispatchEventForSaveValueReadOnly(column, oldValue, newValue, eventSource) {
        const event = this.beans.gos.addGridCommonParams({
            type: "cellEditRequest",
            event: null,
            rowIndex: this.rowIndex,
            rowPinned: this.rowPinned,
            column: column,
            colDef: column.getColDef(),
            data: this.data,
            node: this,
            oldValue: oldValue,
            newValue: newValue,
            value: newValue,
            source: eventSource
        });
        this.beans.eventService.dispatchEvent(event);
    }
    setGroupValue(colKey, newValue) {
        const column = this.beans.columnModel.getCol(colKey);
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(this.groupData)) this.groupData = {};
        const columnId = column.getColId();
        const oldValue = this.groupData[columnId];
        if (oldValue === newValue) return;
        this.groupData[columnId] = newValue;
        this.dispatchCellChangedEvent(column, newValue, oldValue);
    }
    // sets the data for an aggregation
    setAggData(newAggData) {
        const oldAggData = this.aggData;
        this.aggData = newAggData;
        if (this.localEventService) {
            const eventFunc = (colId)=>{
                const value = this.aggData ? this.aggData[colId] : void 0;
                const oldValue = oldAggData ? oldAggData[colId] : void 0;
                if (value === oldValue) return;
                const column = this.beans.columnModel.getCol(colId);
                if (!column) return;
                this.dispatchCellChangedEvent(column, value, oldValue);
            };
            for(const key in this.aggData)eventFunc(key);
            for(const key in newAggData){
                if (key in this.aggData) continue;
                eventFunc(key);
            }
        }
    }
    updateHasChildren() {
        let newValue = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
        const isSsrm = this.beans.gos.isRowModelType("serverSide");
        if (isSsrm) {
            const isTreeData = this.beans.gos.get("treeData");
            const isGroupFunc = this.beans.gos.get("isServerSideGroup");
            newValue = !this.stub && !this.footer && (isTreeData ? !!isGroupFunc && isGroupFunc(this.data) : !!this.group);
        }
        if (newValue !== this.__hasChildren) {
            this.__hasChildren = !!newValue;
            this.dispatchRowEvent("hasChildrenChanged");
        }
    }
    hasChildren() {
        if (this.__hasChildren == null) this.updateHasChildren();
        return this.__hasChildren;
    }
    isEmptyRowGroupNode() {
        return (this.group && $7b57b57eaf5a9648$export$c15f339f10321853(this.childrenAfterGroup)) ?? false;
    }
    dispatchCellChangedEvent(column, newValue, oldValue) {
        const cellChangedEvent = {
            type: "cellChanged",
            node: this,
            column: column,
            newValue: newValue,
            oldValue: oldValue
        };
        this.localEventService?.dispatchEvent(cellChangedEvent);
    }
    /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */ resetQuickFilterAggregateText() {
        this.quickFilterAggregateText = null;
    }
    /** Returns:
   * - `true` if the node can be expanded, i.e it is a group or master row.
   * - `false` if the node cannot be expanded
   */ isExpandable() {
        if (this.footer) return false;
        if (this.beans.columnModel.isPivotMode()) return this.hasChildren() && !this.leafGroup;
        return this.hasChildren() || !!this.master;
    }
    /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */ isSelected() {
        if (this.footer) return this.sibling.isSelected();
        return this.selected;
    }
    /** Perform a depth-first search of this node and its children. */ depthFirstSearch(callback) {
        if (this.childrenAfterGroup) this.childrenAfterGroup.forEach((child)=>child.depthFirstSearch(callback));
        callback(this);
    }
    // + selectionController.calculatedSelectedForAllGroupNodes()
    calculateSelectedFromChildren() {
        let atLeastOneSelected = false;
        let atLeastOneDeSelected = false;
        let atLeastOneMixed = false;
        if (!this.childrenAfterGroup?.length) return this.selectable ? this.selected : null;
        for(let i = 0; i < this.childrenAfterGroup.length; i++){
            const child = this.childrenAfterGroup[i];
            let childState = child.isSelected();
            if (!child.selectable) {
                const selectable = child.calculateSelectedFromChildren();
                if (selectable === null) continue;
                childState = selectable;
            }
            switch(childState){
                case true:
                    atLeastOneSelected = true;
                    break;
                case false:
                    atLeastOneDeSelected = true;
                    break;
                default:
                    atLeastOneMixed = true;
                    break;
            }
        }
        if (atLeastOneMixed || atLeastOneSelected && atLeastOneDeSelected) return void 0;
        if (atLeastOneSelected) return true;
        if (atLeastOneDeSelected) return false;
        if (!this.selectable) return null;
        return this.selected;
    }
    setSelectedInitialValue(selected) {
        this.selected = selected;
    }
    dispatchRowEvent(type) {
        const event = {
            type: type,
            node: this
        };
        this.localEventService?.dispatchEvent(event);
    }
    selectThisNode(newValue, e, source = "api") {
        const selectionNotAllowed = !this.selectable && newValue;
        const selectionNotChanged = this.selected === newValue;
        if (selectionNotAllowed || selectionNotChanged) return false;
        this.selected = newValue;
        this.dispatchRowEvent("rowSelected");
        const sibling = this.sibling;
        if (sibling && sibling.footer && sibling.localEventService) sibling.dispatchRowEvent("rowSelected");
        const event = {
            ...this.createGlobalRowEvent("rowSelected"),
            event: e || null,
            source: source
        };
        this.beans.eventService.dispatchEvent(event);
        return true;
    }
    /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */ setSelected(newValue, clearSelection = false, source = "api") {
        if (typeof source === "boolean") {
            $7b57b57eaf5a9648$export$2cf41453020eef66("since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead.");
            return;
        }
        this.setSelectedParams({
            newValue: newValue,
            clearSelection: clearSelection,
            rangeSelect: false,
            source: source
        });
    }
    // this is for internal use only. To make calling code more readable, this is the same method as setSelected except it takes names parameters
    setSelectedParams(params) {
        if (this.rowPinned) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("cannot select pinned rows");
            return 0;
        }
        if (this.id === void 0) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("cannot select node until id for node is known");
            return 0;
        }
        return this.beans.selectionService.setNodesSelected({
            ...params,
            nodes: [
                this.footer ? this.sibling : this
            ]
        });
    }
    /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */ isRowPinned() {
        return this.rowPinned === "top" || this.rowPinned === "bottom";
    }
    isParentOfNode(potentialParent) {
        let parentNode = this.parent;
        while(parentNode){
            if (parentNode === potentialParent) return true;
            parentNode = parentNode.parent;
        }
        return false;
    }
    /** Add an event listener. */ addEventListener(eventType, userListener) {
        if (!this.localEventService) this.localEventService = new $7b57b57eaf5a9648$export$820da7696a401cdc();
        if (this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService) {
            this.localEventService.setFrameworkOverrides(this.beans.frameworkOverrides);
            this.frameworkEventListenerService = new $7b57b57eaf5a9648$var$FrameworkEventListenerService(this.beans.frameworkOverrides);
        }
        const listener = this.frameworkEventListenerService?.wrap(userListener) ?? userListener;
        this.localEventService.addEventListener(eventType, listener);
    }
    /** Remove event listener. */ removeEventListener(eventType, userListener) {
        if (!this.localEventService) return;
        const listener = this.frameworkEventListenerService?.unwrap(userListener) ?? userListener;
        this.localEventService.removeEventListener(eventType, listener);
        if (this.localEventService.noRegisteredListenersExist()) this.localEventService = null;
    }
    onMouseEnter() {
        this.dispatchRowEvent("mouseEnter");
    }
    onMouseLeave() {
        this.dispatchRowEvent("mouseLeave");
    }
    getFirstChildOfFirstChild(rowGroupColumn) {
        let currentRowNode = this;
        let isCandidate = true;
        let foundFirstChildPath = false;
        let nodeToSwapIn = null;
        while(isCandidate && !foundFirstChildPath){
            const parentRowNode = currentRowNode.parent;
            const firstChild = $7b57b57eaf5a9648$export$25d27f17d3af40f7(parentRowNode) && currentRowNode.firstChild;
            if (firstChild) {
                if (parentRowNode.rowGroupColumn === rowGroupColumn) {
                    foundFirstChildPath = true;
                    nodeToSwapIn = parentRowNode;
                }
            } else isCandidate = false;
            currentRowNode = parentRowNode;
        }
        return foundFirstChildPath ? nodeToSwapIn : null;
    }
    /**
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */ isFullWidthCell() {
        if (this.detail) return true;
        const isFullWidthCellFunc = this.beans.gos.getCallback("isFullWidthRow");
        return isFullWidthCellFunc ? isFullWidthCellFunc({
            rowNode: this
        }) : false;
    }
    /**
   * Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.
   * If the Row Node is not a group, it returns `undefined`.
   */ getRoute() {
        if (this.key == null) return;
        const res = [];
        let pointer = this;
        while(pointer && pointer.key != null){
            res.push(pointer.key);
            pointer = pointer.parent;
        }
        return res.reverse();
    }
    createFooter() {
        if (this.sibling) return;
        const ignoredProperties = /* @__PURE__ */ new Set([
            "eventService",
            "__objectId",
            "sticky"
        ]);
        const footerNode = new _RowNode(this.beans);
        Object.keys(this).forEach((key)=>{
            if (ignoredProperties.has(key)) return;
            footerNode[key] = this[key];
        });
        footerNode.footer = true;
        footerNode.setRowTop(null);
        footerNode.setRowIndex(null);
        footerNode.oldRowTop = null;
        footerNode.id = "rowGroupFooter_" + this.id;
        footerNode.sibling = this;
        this.sibling = footerNode;
    }
    // Only used by SSRM. In CSRM this is never used as footers should always be present for
    // the purpose of exporting collapsed groups. In SSRM it is not possible to export collapsed
    // groups anyway, so can destroy footers.
    destroyFooter() {
        if (!this.sibling) return;
        this.sibling.setRowTop(null);
        this.sibling.setRowIndex(null);
        this.sibling = void 0;
    }
};
$7b57b57eaf5a9648$var$_RowNode.ID_PREFIX_ROW_GROUP = "row-group-";
$7b57b57eaf5a9648$var$_RowNode.ID_PREFIX_TOP_PINNED = "t-";
$7b57b57eaf5a9648$var$_RowNode.ID_PREFIX_BOTTOM_PINNED = "b-";
$7b57b57eaf5a9648$var$_RowNode.OBJECT_ID_SEQUENCE = 0;
var $7b57b57eaf5a9648$export$6af91cd58ec2edf9 = $7b57b57eaf5a9648$var$_RowNode;
// community-modules/core/src/filter/filterManager.ts
var $7b57b57eaf5a9648$export$4c85e4ca0d95642f = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "filterManager";
        // when we're waiting for cell data types to be inferred, we need to defer filter model updates
        this.advancedFilterModelUpdateQueue = [];
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.dataTypeService = beans.dataTypeService;
        this.quickFilterService = beans.quickFilterService;
        this.advancedFilterService = beans.advancedFilterService;
        this.columnFilterService = beans.columnFilterService;
    }
    postConstruct() {
        this.addManagedEventListeners({
            columnValueChanged: this.refreshFiltersForAggregations.bind(this),
            columnPivotChanged: this.refreshFiltersForAggregations.bind(this),
            columnPivotModeChanged: this.refreshFiltersForAggregations.bind(this),
            newColumnsLoaded: this.updateAdvancedFilterColumns.bind(this),
            columnVisible: this.updateAdvancedFilterColumns.bind(this),
            advancedFilterEnabledChanged: ({ enabled: enabled  })=>this.onAdvancedFilterEnabledChanged(enabled),
            dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
        });
        this.externalFilterPresent = this.isExternalFilterPresentCallback();
        this.addManagedPropertyListeners([
            "isExternalFilterPresent",
            "doesExternalFilterPass"
        ], ()=>{
            this.onFilterChanged({
                source: "api"
            });
        });
        this.updateAggFiltering();
        this.addManagedPropertyListener("groupAggFiltering", ()=>{
            this.updateAggFiltering();
            this.onFilterChanged();
        });
        this.addManagedPropertyListener("advancedFilterModel", (event)=>this.setAdvancedFilterModel(event.currentValue));
        if (this.quickFilterService) this.addManagedListeners(this.quickFilterService, {
            quickFilterChanged: ()=>this.onFilterChanged({
                    source: "quickFilter"
                })
        });
    }
    isExternalFilterPresentCallback() {
        const isFilterPresent = this.gos.getCallback("isExternalFilterPresent");
        if (typeof isFilterPresent === "function") return isFilterPresent({});
        return false;
    }
    doesExternalFilterPass(node) {
        const doesFilterPass = this.gos.get("doesExternalFilterPass");
        if (typeof doesFilterPass === "function") return doesFilterPass(node);
        return false;
    }
    setFilterModel(model, source = "api") {
        if (this.isAdvancedFilterEnabled()) {
            this.warnAdvancedFilters();
            return;
        }
        this.columnFilterService?.setFilterModel(model, source);
    }
    getFilterModel() {
        return this.columnFilterService?.getFilterModel() ?? {};
    }
    isColumnFilterPresent() {
        return !!this.columnFilterService?.isColumnFilterPresent();
    }
    isAggregateFilterPresent() {
        return !!this.columnFilterService?.isAggregateFilterPresent();
    }
    isExternalFilterPresent() {
        return this.externalFilterPresent;
    }
    isChildFilterPresent() {
        return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
    }
    isAdvancedFilterPresent() {
        return this.isAdvancedFilterEnabled() && this.advancedFilterService.isFilterPresent();
    }
    onAdvancedFilterEnabledChanged(enabled) {
        if (enabled) {
            if (this.columnFilterService?.disableColumnFilters()) this.onFilterChanged({
                source: "advancedFilter"
            });
        } else if (this.advancedFilterService?.isFilterPresent()) {
            this.advancedFilterService.setModel(null);
            this.onFilterChanged({
                source: "advancedFilter"
            });
        }
    }
    isAdvancedFilterEnabled() {
        return !!this.advancedFilterService?.isEnabled();
    }
    isAdvancedFilterHeaderActive() {
        return this.isAdvancedFilterEnabled() && this.advancedFilterService.isHeaderActive();
    }
    isAnyFilterPresent() {
        return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
    }
    resetQuickFilterCache() {
        this.quickFilterService?.resetQuickFilterCache();
    }
    refreshFiltersForAggregations() {
        const isAggFiltering = this.gos.getGroupAggFiltering();
        if (isAggFiltering) this.onFilterChanged();
    }
    onFilterChanged(params = {}) {
        const { source: source , additionalEventAttributes: additionalEventAttributes , columns: columns = []  } = params;
        this.externalFilterPresent = this.isExternalFilterPresentCallback();
        (this.columnFilterService ? this.columnFilterService.updateBeforeFilterChanged(params) : $7b57b57eaf5a9648$export$30ec7836a4847721.resolve()).then(()=>{
            const filterChangedEvent = {
                source: source,
                type: "filterChanged",
                columns: columns
            };
            if (additionalEventAttributes) $7b57b57eaf5a9648$export$8ade6bd474fcde42(filterChangedEvent, additionalEventAttributes);
            this.eventService.dispatchEvent(filterChangedEvent);
            this.columnFilterService?.updateAfterFilterChanged();
        });
    }
    isSuppressFlashingCellsBecauseFiltering() {
        return !!this.columnFilterService?.isSuppressFlashingCellsBecauseFiltering();
    }
    isQuickFilterPresent() {
        return !!this.quickFilterService?.isQuickFilterPresent();
    }
    updateAggFiltering() {
        this.aggFiltering = !!this.gos.getGroupAggFiltering();
    }
    isAggregateQuickFilterPresent() {
        return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
    }
    isNonAggregateQuickFilterPresent() {
        return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
    }
    shouldApplyQuickFilterAfterAgg() {
        return (this.aggFiltering || this.columnModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
    }
    doesRowPassOtherFilters(filterToSkip, node) {
        return this.doesRowPassFilter({
            rowNode: node,
            filterInstanceToSkip: filterToSkip
        });
    }
    doesRowPassAggregateFilters(params) {
        if (this.isAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(params.rowNode)) return false;
        if (this.isAggregateFilterPresent() && !this.columnFilterService.doAggregateFiltersPass(params.rowNode, params.filterInstanceToSkip)) return false;
        return true;
    }
    doesRowPassFilter(params) {
        if (this.isNonAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(params.rowNode)) return false;
        if (this.isExternalFilterPresent() && !this.doesExternalFilterPass(params.rowNode)) return false;
        if (this.isColumnFilterPresent() && !this.columnFilterService.doColumnFiltersPass(params.rowNode, params.filterInstanceToSkip)) return false;
        if (this.isAdvancedFilterPresent() && !this.advancedFilterService.doesFilterPass(params.rowNode)) return false;
        return true;
    }
    isFilterActive(column) {
        return !!this.columnFilterService?.isFilterActive(column);
    }
    getOrCreateFilterWrapper(column) {
        return this.columnFilterService?.getOrCreateFilterWrapper(column) ?? null;
    }
    getDefaultFloatingFilter(column) {
        return this.columnFilterService.getDefaultFloatingFilter(column);
    }
    createFilterParams(column, colDef) {
        return this.columnFilterService.createFilterParams(column, colDef);
    }
    // for group filters, can change dynamically whether they are allowed or not
    isFilterAllowed(column) {
        if (this.isAdvancedFilterEnabled()) return false;
        return !!this.columnFilterService?.isFilterAllowed(column);
    }
    getFloatingFilterCompDetails(column, showParentFilter) {
        return this.columnFilterService?.getFloatingFilterCompDetails(column, showParentFilter);
    }
    getCurrentFloatingFilterParentModel(column) {
        return this.columnFilterService?.getCurrentFloatingFilterParentModel(column);
    }
    // destroys the filter, so it no longer takes part
    destroyFilter(column, source = "api") {
        this.columnFilterService?.destroyFilter(column, source);
    }
    areFilterCompsDifferent(oldCompDetails, newCompDetails) {
        return !!this.columnFilterService?.areFilterCompsDifferent(oldCompDetails, newCompDetails);
    }
    getAdvancedFilterModel() {
        return this.isAdvancedFilterEnabled() ? this.advancedFilterService.getModel() : null;
    }
    setAdvancedFilterModel(expression) {
        if (!this.isAdvancedFilterEnabled()) return;
        if (this.dataTypeService?.isPendingInference()) {
            this.advancedFilterModelUpdateQueue.push(expression);
            return;
        }
        this.advancedFilterService.setModel(expression ?? null);
        this.onFilterChanged({
            source: "advancedFilter"
        });
    }
    toggleAdvancedFilterBuilder(show, source) {
        if (!this.isAdvancedFilterEnabled()) return;
        this.advancedFilterService.getCtrl().toggleFilterBuilder(source, show);
    }
    updateAdvancedFilterColumns() {
        if (!this.isAdvancedFilterEnabled()) return;
        if (this.advancedFilterService.updateValidity()) this.onFilterChanged({
            source: "advancedFilter"
        });
    }
    hasFloatingFilters() {
        if (this.isAdvancedFilterEnabled()) return false;
        return !!this.columnFilterService?.hasFloatingFilters();
    }
    getFilterInstance(key, callback) {
        if (this.isAdvancedFilterEnabled()) {
            this.warnAdvancedFilters();
            return void 0;
        }
        return this.columnFilterService?.getFilterInstance(key, callback);
    }
    getColumnFilterInstance(key) {
        if (this.isAdvancedFilterEnabled()) {
            this.warnAdvancedFilters();
            return Promise.resolve(void 0);
        }
        return this.columnFilterService?.getColumnFilterInstance(key) ?? Promise.resolve(void 0);
    }
    warnAdvancedFilters() {
        $7b57b57eaf5a9648$export$2cf41453020eef66("Column Filter API methods have been disabled as Advanced Filters are enabled.");
    }
    setupAdvancedFilterHeaderComp(eCompToInsertBefore) {
        this.advancedFilterService?.getCtrl().setupHeaderComp(eCompToInsertBefore);
    }
    getHeaderRowCount() {
        return this.isAdvancedFilterHeaderActive() ? 1 : 0;
    }
    getHeaderHeight() {
        return this.isAdvancedFilterHeaderActive() ? this.advancedFilterService.getCtrl().getHeaderHeight() : 0;
    }
    processFilterModelUpdateQueue() {
        this.advancedFilterModelUpdateQueue.forEach((model)=>this.setAdvancedFilterModel(model));
        this.advancedFilterModelUpdateQueue = [];
    }
    getColumnFilterModel(key) {
        return this.columnFilterService?.getColumnFilterModel(key);
    }
    setColumnFilterModel(key, model) {
        if (this.isAdvancedFilterEnabled()) {
            this.warnAdvancedFilters();
            return Promise.resolve();
        }
        return this.columnFilterService?.setColumnFilterModel(key, model) ?? Promise.resolve();
    }
};
// community-modules/core/src/filter/filterWrapperComp.ts
var $7b57b57eaf5a9648$export$70acaf0e0e30e7d = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(column, source){
        super(/* html */ `<div class="ag-filter"></div>`);
        this.column = column;
        this.source = source;
        this.filterWrapper = null;
    }
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
        this.columnModel = beans.columnModel;
    }
    postConstruct() {
        this.createFilter(true);
        this.addManagedEventListeners({
            filterDestroyed: this.onFilterDestroyed.bind(this)
        });
    }
    hasFilter() {
        return !!this.filterWrapper;
    }
    getFilter() {
        return this.filterWrapper?.filterPromise ?? null;
    }
    afterInit() {
        return this.filterWrapper?.filterPromise?.then(()=>{}) ?? $7b57b57eaf5a9648$export$30ec7836a4847721.resolve();
    }
    afterGuiAttached(params) {
        this.filterWrapper?.filterPromise?.then((filter)=>{
            filter?.afterGuiAttached?.(params);
        });
    }
    afterGuiDetached() {
        this.filterWrapper?.filterPromise?.then((filter)=>{
            filter?.afterGuiDetached?.();
        });
    }
    createFilter(init) {
        const { column: column , source: source  } = this;
        this.filterWrapper = this.filterManager?.getOrCreateFilterWrapper(column) ?? null;
        if (!this.filterWrapper?.filterPromise) return;
        this.filterWrapper.filterPromise.then((filter)=>{
            const guiFromFilter = filter.getGui();
            if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(guiFromFilter)) $7b57b57eaf5a9648$export$2cf41453020eef66(`getGui method from filter returned ${guiFromFilter}; it should be a DOM element.`);
            this.appendChild(guiFromFilter);
            if (init) {
                const event = {
                    type: "filterOpened",
                    column: column,
                    source: source,
                    eGui: this.getGui()
                };
                this.eventService.dispatchEvent(event);
            }
        });
    }
    onFilterDestroyed(event) {
        if ((event.source === "api" || event.source === "paramsUpdated") && event.column.getId() === this.column.getId() && this.columnModel.getColDefCol(this.column)) {
            $7b57b57eaf5a9648$export$69e6e10709eabd91(this.getGui());
            this.createFilter();
        }
    }
    destroy() {
        this.filterWrapper = null;
        super.destroy();
    }
};
// community-modules/core/src/rendering/features/positionableFeature.ts
var $7b57b57eaf5a9648$var$RESIZE_CONTAINER_STYLE = "ag-resizer-wrapper";
var $7b57b57eaf5a9648$var$RESIZE_TEMPLATE = /* html */ `<div class="${$7b57b57eaf5a9648$var$RESIZE_CONTAINER_STYLE}">
        <div data-ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div data-ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div data-ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div data-ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div data-ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div data-ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div data-ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div data-ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`;
var $7b57b57eaf5a9648$export$c53a5d9f1fb0f7f6 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(element, config){
        super();
        this.element = element;
        this.dragStartPosition = {
            x: 0,
            y: 0
        };
        this.position = {
            x: 0,
            y: 0
        };
        this.lastSize = {
            width: -1,
            height: -1
        };
        this.positioned = false;
        this.resizersAdded = false;
        this.resizeListeners = [];
        this.boundaryEl = null;
        this.isResizing = false;
        this.isMoving = false;
        this.resizable = {};
        this.movable = false;
        this.currentResizer = null;
        this.config = Object.assign({}, {
            popup: false
        }, config);
    }
    wireBeans(beans) {
        this.popupService = beans.popupService;
        this.resizeObserverService = beans.resizeObserverService;
        this.dragService = beans.dragService;
    }
    center() {
        const { clientHeight: clientHeight , clientWidth: clientWidth  } = this.offsetParent;
        const x = clientWidth / 2 - this.getWidth() / 2;
        const y = clientHeight / 2 - this.getHeight() / 2;
        this.offsetElement(x, y);
    }
    initialisePosition() {
        if (this.positioned) return;
        const { centered: centered , forcePopupParentAsOffsetParent: forcePopupParentAsOffsetParent , minWidth: minWidth , width: width , minHeight: minHeight , height: height , x: x , y: y  } = this.config;
        if (!this.offsetParent) this.setOffsetParent();
        let computedMinHeight = 0;
        let computedMinWidth = 0;
        const isElementVisible = $7b57b57eaf5a9648$export$2badf4aa566524cb(this.element);
        if (isElementVisible) {
            const boundaryEl = this.findBoundaryElement();
            const offsetParentComputedStyles = window.getComputedStyle(boundaryEl);
            if (offsetParentComputedStyles.minWidth != null) {
                const paddingWidth = boundaryEl.offsetWidth - this.element.offsetWidth;
                computedMinWidth = parseInt(offsetParentComputedStyles.minWidth, 10) - paddingWidth;
            }
            if (offsetParentComputedStyles.minHeight != null) {
                const paddingHeight = boundaryEl.offsetHeight - this.element.offsetHeight;
                computedMinHeight = parseInt(offsetParentComputedStyles.minHeight, 10) - paddingHeight;
            }
        }
        this.minHeight = minHeight || computedMinHeight;
        this.minWidth = minWidth || computedMinWidth;
        if (width) this.setWidth(width);
        if (height) this.setHeight(height);
        if (!width || !height) this.refreshSize();
        if (centered) this.center();
        else if (x || y) this.offsetElement(x, y);
        else if (isElementVisible && forcePopupParentAsOffsetParent) {
            let boundaryEl = this.boundaryEl;
            let initialisedDuringPositioning = true;
            if (!boundaryEl) {
                boundaryEl = this.findBoundaryElement();
                initialisedDuringPositioning = false;
            }
            if (boundaryEl) {
                const top = parseFloat(boundaryEl.style.top);
                const left = parseFloat(boundaryEl.style.left);
                if (initialisedDuringPositioning) this.offsetElement(isNaN(left) ? 0 : left, isNaN(top) ? 0 : top);
                else this.setPosition(left, top);
            }
        }
        this.positioned = !!this.offsetParent;
    }
    isPositioned() {
        return this.positioned;
    }
    getPosition() {
        return this.position;
    }
    setMovable(movable, moveElement) {
        if (!this.config.popup || movable === this.movable) return;
        this.movable = movable;
        const params = this.moveElementDragListener || {
            eElement: moveElement,
            onDragStart: this.onMoveStart.bind(this),
            onDragging: this.onMove.bind(this),
            onDragStop: this.onMoveEnd.bind(this)
        };
        if (movable) {
            this.dragService.addDragSource(params);
            this.moveElementDragListener = params;
        } else {
            this.dragService.removeDragSource(params);
            this.moveElementDragListener = void 0;
        }
    }
    setResizable(resizable) {
        this.clearResizeListeners();
        if (resizable) this.addResizers();
        else this.removeResizers();
        if (typeof resizable === "boolean") {
            if (resizable === false) return;
            resizable = {
                topLeft: resizable,
                top: resizable,
                topRight: resizable,
                right: resizable,
                bottomRight: resizable,
                bottom: resizable,
                bottomLeft: resizable,
                left: resizable
            };
        }
        Object.keys(resizable).forEach((side)=>{
            const resizableStructure = resizable;
            const isSideResizable = !!resizableStructure[side];
            const resizerEl = this.getResizerElement(side);
            const params = {
                dragStartPixels: 0,
                eElement: resizerEl,
                onDragStart: (e)=>this.onResizeStart(e, side),
                onDragging: this.onResize.bind(this),
                onDragStop: (e)=>this.onResizeEnd(e, side)
            };
            if (isSideResizable || !this.isAlive() && !isSideResizable) {
                if (isSideResizable) {
                    this.dragService.addDragSource(params);
                    this.resizeListeners.push(params);
                    resizerEl.style.pointerEvents = "all";
                } else resizerEl.style.pointerEvents = "none";
                this.resizable[side] = isSideResizable;
            }
        });
    }
    removeSizeFromEl() {
        this.element.style.removeProperty("height");
        this.element.style.removeProperty("width");
        this.element.style.removeProperty("flex");
    }
    restoreLastSize() {
        this.element.style.flex = "0 0 auto";
        const { height: height , width: width  } = this.lastSize;
        if (width !== -1) this.element.style.width = `${width}px`;
        if (height !== -1) this.element.style.height = `${height}px`;
    }
    getHeight() {
        return this.element.offsetHeight;
    }
    setHeight(height) {
        const { popup: popup  } = this.config;
        const eGui = this.element;
        let isPercent = false;
        if (typeof height === "string" && height.indexOf("%") !== -1) {
            $7b57b57eaf5a9648$var$_setFixedHeight(eGui, height);
            height = $7b57b57eaf5a9648$export$d23c22492e0f7c0c(eGui);
            isPercent = true;
        } else {
            height = Math.max(this.minHeight, height);
            if (this.positioned) {
                const availableHeight = this.getAvailableHeight();
                if (availableHeight && height > availableHeight) height = availableHeight;
            }
        }
        if (this.getHeight() === height) return;
        if (!isPercent) {
            if (popup) $7b57b57eaf5a9648$var$_setFixedHeight(eGui, height);
            else {
                eGui.style.height = `${height}px`;
                eGui.style.flex = "0 0 auto";
                this.lastSize.height = typeof height === "number" ? height : parseFloat(height);
            }
        } else {
            eGui.style.maxHeight = "unset";
            eGui.style.minHeight = "unset";
        }
    }
    getAvailableHeight() {
        const { popup: popup , forcePopupParentAsOffsetParent: forcePopupParentAsOffsetParent  } = this.config;
        if (!this.positioned) this.initialisePosition();
        const { clientHeight: clientHeight  } = this.offsetParent;
        if (!clientHeight) return null;
        const elRect = this.element.getBoundingClientRect();
        const offsetParentRect = this.offsetParent.getBoundingClientRect();
        const yPosition = popup ? this.position.y : elRect.top;
        const parentTop = popup ? 0 : offsetParentRect.top;
        let additionalHeight = 0;
        if (forcePopupParentAsOffsetParent) {
            const parentEl = this.element.parentElement;
            if (parentEl) {
                const { bottom: bottom  } = parentEl.getBoundingClientRect();
                additionalHeight = bottom - elRect.bottom;
            }
        }
        const availableHeight = clientHeight + parentTop - yPosition - additionalHeight;
        return availableHeight;
    }
    getWidth() {
        return this.element.offsetWidth;
    }
    setWidth(width) {
        const eGui = this.element;
        const { popup: popup  } = this.config;
        let isPercent = false;
        if (typeof width === "string" && width.indexOf("%") !== -1) {
            $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(eGui, width);
            width = $7b57b57eaf5a9648$export$642efcb17474eb51(eGui);
            isPercent = true;
        } else if (this.positioned) {
            width = Math.max(this.minWidth, width);
            const { clientWidth: clientWidth  } = this.offsetParent;
            const xPosition = popup ? this.position.x : this.element.getBoundingClientRect().left;
            if (clientWidth && width + xPosition > clientWidth) width = clientWidth - xPosition;
        }
        if (this.getWidth() === width) return;
        if (!isPercent) {
            if (this.config.popup) $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(eGui, width);
            else {
                eGui.style.width = `${width}px`;
                eGui.style.flex = " unset";
                this.lastSize.width = typeof width === "number" ? width : parseFloat(width);
            }
        } else {
            eGui.style.maxWidth = "unset";
            eGui.style.minWidth = "unset";
        }
    }
    offsetElement(x = 0, y = 0) {
        const { forcePopupParentAsOffsetParent: forcePopupParentAsOffsetParent  } = this.config;
        const ePopup = forcePopupParentAsOffsetParent ? this.boundaryEl : this.element;
        if (!ePopup) return;
        this.popupService.positionPopup({
            ePopup: ePopup,
            keepWithinBounds: true,
            skipObserver: this.movable || this.isResizable(),
            updatePosition: ()=>({
                    x: x,
                    y: y
                })
        });
        this.setPosition(parseFloat(ePopup.style.left), parseFloat(ePopup.style.top));
    }
    constrainSizeToAvailableHeight(constrain) {
        if (!this.config.forcePopupParentAsOffsetParent) return;
        const applyMaxHeightToElement = ()=>{
            const availableHeight = this.getAvailableHeight();
            this.element.style.setProperty("max-height", `${availableHeight}px`);
        };
        if (constrain) this.resizeObserverSubscriber = this.resizeObserverService.observeResize(this.popupService.getPopupParent(), applyMaxHeightToElement);
        else {
            this.element.style.removeProperty("max-height");
            if (this.resizeObserverSubscriber) {
                this.resizeObserverSubscriber();
                this.resizeObserverSubscriber = void 0;
            }
        }
    }
    setPosition(x, y) {
        this.position.x = x;
        this.position.y = y;
    }
    updateDragStartPosition(x, y) {
        this.dragStartPosition = {
            x: x,
            y: y
        };
    }
    calculateMouseMovement(params) {
        const { e: e , isLeft: isLeft , isTop: isTop , anywhereWithin: anywhereWithin , topBuffer: topBuffer  } = params;
        const xDiff = e.clientX - this.dragStartPosition.x;
        const yDiff = e.clientY - this.dragStartPosition.y;
        const movementX = this.shouldSkipX(e, !!isLeft, !!anywhereWithin, xDiff) ? 0 : xDiff;
        const movementY = this.shouldSkipY(e, !!isTop, topBuffer, yDiff) ? 0 : yDiff;
        return {
            movementX: movementX,
            movementY: movementY
        };
    }
    shouldSkipX(e, isLeft, anywhereWithin, diff) {
        const elRect = this.element.getBoundingClientRect();
        const parentRect = this.offsetParent.getBoundingClientRect();
        const boundaryElRect = this.boundaryEl.getBoundingClientRect();
        const xPosition = this.config.popup ? this.position.x : elRect.left;
        let skipX = xPosition <= 0 && parentRect.left >= e.clientX || parentRect.right <= e.clientX && parentRect.right <= boundaryElRect.right;
        if (skipX) return true;
        if (isLeft) skipX = // is positioned to the right of the left side anchor
        diff < 0 && e.clientX > xPosition + parentRect.left || // skip if we are moving to the right and the cursor
        // is positioned to the left of the dialog
        diff > 0 && e.clientX < xPosition + parentRect.left;
        else if (anywhereWithin) skipX = diff < 0 && e.clientX > boundaryElRect.right || diff > 0 && e.clientX < xPosition + parentRect.left;
        else skipX = // we skip if we are moving to the left and the cursor
        // is to the right of the dialog
        diff < 0 && e.clientX > boundaryElRect.right || // or skip if we are moving to the right and the cursor
        // is to the left of the right side anchor
        diff > 0 && e.clientX < boundaryElRect.right;
        return skipX;
    }
    shouldSkipY(e, isTop, topBuffer = 0, diff) {
        const elRect = this.element.getBoundingClientRect();
        const parentRect = this.offsetParent.getBoundingClientRect();
        const boundaryElRect = this.boundaryEl.getBoundingClientRect();
        const yPosition = this.config.popup ? this.position.y : elRect.top;
        let skipY = yPosition <= 0 && parentRect.top >= e.clientY || parentRect.bottom <= e.clientY && parentRect.bottom <= boundaryElRect.bottom;
        if (skipY) return true;
        if (isTop) skipY = // below the top anchor + topBuffer
        // note: topBuffer is used when moving the dialog using the title bar
        diff < 0 && e.clientY > yPosition + parentRect.top + topBuffer || // skip if we are moving to the bottom and the cursor is
        // above the top anchor
        diff > 0 && e.clientY < yPosition + parentRect.top;
        else skipY = // is below the bottom anchor
        diff < 0 && e.clientY > boundaryElRect.bottom || // skip if we are moving towards the bottom and the cursor
        // is above the bottom anchor
        diff > 0 && e.clientY < boundaryElRect.bottom;
        return skipY;
    }
    createResizeMap() {
        const eGui = this.element;
        this.resizerMap = {
            topLeft: {
                element: eGui.querySelector("[data-ref=eTopLeftResizer]")
            },
            top: {
                element: eGui.querySelector("[data-ref=eTopResizer]")
            },
            topRight: {
                element: eGui.querySelector("[data-ref=eTopRightResizer]")
            },
            right: {
                element: eGui.querySelector("[data-ref=eRightResizer]")
            },
            bottomRight: {
                element: eGui.querySelector("[data-ref=eBottomRightResizer]")
            },
            bottom: {
                element: eGui.querySelector("[data-ref=eBottomResizer]")
            },
            bottomLeft: {
                element: eGui.querySelector("[data-ref=eBottomLeftResizer]")
            },
            left: {
                element: eGui.querySelector("[data-ref=eLeftResizer]")
            }
        };
    }
    addResizers() {
        if (this.resizersAdded) return;
        const eGui = this.element;
        if (!eGui) return;
        const parser = new DOMParser();
        const resizers = parser.parseFromString($7b57b57eaf5a9648$var$RESIZE_TEMPLATE, "text/html").body;
        eGui.appendChild(resizers.firstChild);
        this.createResizeMap();
        this.resizersAdded = true;
    }
    removeResizers() {
        this.resizerMap = void 0;
        const resizerEl = this.element.querySelector(`.${$7b57b57eaf5a9648$var$RESIZE_CONTAINER_STYLE}`);
        if (resizerEl) this.element.removeChild(resizerEl);
        this.resizersAdded = false;
    }
    getResizerElement(side) {
        return this.resizerMap[side].element;
    }
    onResizeStart(e, side) {
        this.boundaryEl = this.findBoundaryElement();
        if (!this.positioned) this.initialisePosition();
        this.currentResizer = {
            isTop: !!side.match(/top/i),
            isRight: !!side.match(/right/i),
            isBottom: !!side.match(/bottom/i),
            isLeft: !!side.match(/left/i)
        };
        this.element.classList.add("ag-resizing");
        this.resizerMap[side].element.classList.add("ag-active");
        const { popup: popup , forcePopupParentAsOffsetParent: forcePopupParentAsOffsetParent  } = this.config;
        if (!popup && !forcePopupParentAsOffsetParent) this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop);
        this.isResizing = true;
        this.updateDragStartPosition(e.clientX, e.clientY);
    }
    getSiblings() {
        const element = this.element;
        const parent = element.parentElement;
        if (!parent) return null;
        return Array.prototype.slice.call(parent.children).filter((el)=>!el.classList.contains("ag-hidden"));
    }
    getMinSizeOfSiblings() {
        const siblings = this.getSiblings() || [];
        let height = 0;
        let width = 0;
        for(let i = 0; i < siblings.length; i++){
            const currentEl = siblings[i];
            const isFlex = !!currentEl.style.flex && currentEl.style.flex !== "0 0 auto";
            if (currentEl === this.element) continue;
            let nextHeight = this.minHeight || 0;
            let nextWidth = this.minWidth || 0;
            if (isFlex) {
                const computedStyle = window.getComputedStyle(currentEl);
                if (computedStyle.minHeight) nextHeight = parseInt(computedStyle.minHeight, 10);
                if (computedStyle.minWidth) nextWidth = parseInt(computedStyle.minWidth, 10);
            } else {
                nextHeight = currentEl.offsetHeight;
                nextWidth = currentEl.offsetWidth;
            }
            height += nextHeight;
            width += nextWidth;
        }
        return {
            height: height,
            width: width
        };
    }
    applySizeToSiblings(vertical) {
        let containerToFlex = null;
        const siblings = this.getSiblings();
        if (!siblings) return;
        for(let i = 0; i < siblings.length; i++){
            const el = siblings[i];
            if (el === containerToFlex) continue;
            if (vertical) el.style.height = `${el.offsetHeight}px`;
            else el.style.width = `${el.offsetWidth}px`;
            el.style.flex = "0 0 auto";
            if (el === this.element) containerToFlex = siblings[i + 1];
        }
        if (containerToFlex) {
            containerToFlex.style.removeProperty("height");
            containerToFlex.style.removeProperty("min-height");
            containerToFlex.style.removeProperty("max-height");
            containerToFlex.style.flex = "1 1 auto";
        }
    }
    isResizable() {
        return Object.values(this.resizable).some((value)=>value);
    }
    onResize(e) {
        if (!this.isResizing || !this.currentResizer) return;
        const { popup: popup , forcePopupParentAsOffsetParent: forcePopupParentAsOffsetParent  } = this.config;
        const { isTop: isTop , isRight: isRight , isBottom: isBottom , isLeft: isLeft  } = this.currentResizer;
        const isHorizontal = isRight || isLeft;
        const isVertical = isBottom || isTop;
        const { movementX: movementX , movementY: movementY  } = this.calculateMouseMovement({
            e: e,
            isLeft: isLeft,
            isTop: isTop
        });
        const xPosition = this.position.x;
        const yPosition = this.position.y;
        let offsetLeft = 0;
        let offsetTop = 0;
        if (isHorizontal && movementX) {
            const direction = isLeft ? -1 : 1;
            const oldWidth = this.getWidth();
            const newWidth = oldWidth + movementX * direction;
            let skipWidth = false;
            if (isLeft) {
                offsetLeft = oldWidth - newWidth;
                if (xPosition + offsetLeft <= 0 || newWidth <= this.minWidth) {
                    skipWidth = true;
                    offsetLeft = 0;
                }
            }
            if (!skipWidth) this.setWidth(newWidth);
        }
        if (isVertical && movementY) {
            const direction = isTop ? -1 : 1;
            const oldHeight = this.getHeight();
            const newHeight = oldHeight + movementY * direction;
            let skipHeight = false;
            if (isTop) {
                offsetTop = oldHeight - newHeight;
                if (yPosition + offsetTop <= 0 || newHeight <= this.minHeight) {
                    skipHeight = true;
                    offsetTop = 0;
                }
            } else if (!this.config.popup && !this.config.forcePopupParentAsOffsetParent && oldHeight < newHeight && this.getMinSizeOfSiblings().height + newHeight > this.element.parentElement.offsetHeight) skipHeight = true;
            if (!skipHeight) this.setHeight(newHeight);
        }
        this.updateDragStartPosition(e.clientX, e.clientY);
        if ((popup || forcePopupParentAsOffsetParent) && offsetLeft || offsetTop) this.offsetElement(xPosition + offsetLeft, yPosition + offsetTop);
    }
    onResizeEnd(e, side) {
        this.isResizing = false;
        this.currentResizer = null;
        this.boundaryEl = null;
        this.element.classList.remove("ag-resizing");
        this.resizerMap[side].element.classList.remove("ag-active");
        this.dispatchLocalEvent({
            type: "resize"
        });
    }
    refreshSize() {
        const eGui = this.element;
        if (this.config.popup) {
            if (!this.config.width) this.setWidth(eGui.offsetWidth);
            if (!this.config.height) this.setHeight(eGui.offsetHeight);
        }
    }
    onMoveStart(e) {
        this.boundaryEl = this.findBoundaryElement();
        if (!this.positioned) this.initialisePosition();
        this.isMoving = true;
        this.element.classList.add("ag-moving");
        this.updateDragStartPosition(e.clientX, e.clientY);
    }
    onMove(e) {
        if (!this.isMoving) return;
        const { x: x , y: y  } = this.position;
        let topBuffer;
        if (this.config.calculateTopBuffer) topBuffer = this.config.calculateTopBuffer();
        const { movementX: movementX , movementY: movementY  } = this.calculateMouseMovement({
            e: e,
            isTop: true,
            anywhereWithin: true,
            topBuffer: topBuffer
        });
        this.offsetElement(x + movementX, y + movementY);
        this.updateDragStartPosition(e.clientX, e.clientY);
    }
    onMoveEnd() {
        this.isMoving = false;
        this.boundaryEl = null;
        this.element.classList.remove("ag-moving");
    }
    setOffsetParent() {
        if (this.config.forcePopupParentAsOffsetParent) this.offsetParent = this.popupService.getPopupParent();
        else this.offsetParent = this.element.offsetParent;
    }
    findBoundaryElement() {
        let el = this.element;
        while(el){
            if (window.getComputedStyle(el).position !== "static") return el;
            el = el.parentElement;
        }
        return this.element;
    }
    clearResizeListeners() {
        while(this.resizeListeners.length){
            const params = this.resizeListeners.pop();
            this.dragService.removeDragSource(params);
        }
    }
    destroy() {
        super.destroy();
        if (this.moveElementDragListener) this.dragService.removeDragSource(this.moveElementDragListener);
        this.constrainSizeToAvailableHeight(false);
        this.clearResizeListeners();
        this.removeResizers();
    }
};
// community-modules/core/src/widgets/managedFocusFeature.ts
var $7b57b57eaf5a9648$var$_ManagedFocusFeature = class _ManagedFocusFeature extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(eFocusableElement, callbacks = {}){
        super();
        this.eFocusableElement = eFocusableElement;
        this.callbacks = callbacks;
        this.callbacks = {
            shouldStopEventPropagation: ()=>false,
            onTabKeyDown: (e)=>{
                if (e.defaultPrevented) return;
                const nextRoot = this.focusService.findNextFocusableElement(this.eFocusableElement, false, e.shiftKey);
                if (!nextRoot) return;
                nextRoot.focus();
                e.preventDefault();
            },
            ...callbacks
        };
    }
    wireBeans(beans) {
        this.focusService = beans.focusService;
    }
    postConstruct() {
        this.eFocusableElement.classList.add(_ManagedFocusFeature.FOCUS_MANAGED_CLASS);
        this.addKeyDownListeners(this.eFocusableElement);
        if (this.callbacks.onFocusIn) this.addManagedElementListeners(this.eFocusableElement, {
            focusin: this.callbacks.onFocusIn
        });
        if (this.callbacks.onFocusOut) this.addManagedElementListeners(this.eFocusableElement, {
            focusout: this.callbacks.onFocusOut
        });
    }
    addKeyDownListeners(eGui) {
        this.addManagedElementListeners(eGui, {
            keydown: (e)=>{
                if (e.defaultPrevented || $7b57b57eaf5a9648$export$9a48e23524c6d58(e)) return;
                if (this.callbacks.shouldStopEventPropagation(e)) {
                    $7b57b57eaf5a9648$export$456c40e80134d72a(e);
                    return;
                }
                if (e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.TAB) this.callbacks.onTabKeyDown(e);
                else if (this.callbacks.handleKeyDown) this.callbacks.handleKeyDown(e);
            }
        });
    }
};
$7b57b57eaf5a9648$var$_ManagedFocusFeature.FOCUS_MANAGED_CLASS = "ag-focus-managed";
var $7b57b57eaf5a9648$export$5510e53ed3962582 = $7b57b57eaf5a9648$var$_ManagedFocusFeature;
// community-modules/core/src/filter/filterLocaleText.ts
var $7b57b57eaf5a9648$var$FILTER_LOCALE_TEXT = {
    applyFilter: "Apply",
    clearFilter: "Clear",
    resetFilter: "Reset",
    cancelFilter: "Cancel",
    textFilter: "Text Filter",
    numberFilter: "Number Filter",
    dateFilter: "Date Filter",
    setFilter: "Set Filter",
    filterOoo: "Filter...",
    empty: "Choose one",
    equals: "Equals",
    notEqual: "Does not equal",
    lessThan: "Less than",
    greaterThan: "Greater than",
    inRange: "Between",
    inRangeStart: "From",
    inRangeEnd: "To",
    lessThanOrEqual: "Less than or equal to",
    greaterThanOrEqual: "Greater than or equal to",
    contains: "Contains",
    notContains: "Does not contain",
    startsWith: "Begins with",
    endsWith: "Ends with",
    blank: "Blank",
    notBlank: "Not blank",
    before: "Before",
    after: "After",
    andCondition: "AND",
    orCondition: "OR",
    dateFormatOoo: "yyyy-mm-dd"
};
// community-modules/core/src/filter/floating/provided/providedFilterUtils.ts
function $7b57b57eaf5a9648$var$getDebounceMs(params, debounceDefault) {
    if ($7b57b57eaf5a9648$var$isUseApplyButton(params)) {
        if (params.debounceMs != null) $7b57b57eaf5a9648$export$2cf41453020eef66("debounceMs is ignored when apply button is present");
        return 0;
    }
    return params.debounceMs != null ? params.debounceMs : debounceDefault;
}
function $7b57b57eaf5a9648$var$isUseApplyButton(params) {
    return !!params.buttons && params.buttons.indexOf("apply") >= 0;
}
// community-modules/core/src/filter/provided/providedFilter.ts
var $7b57b57eaf5a9648$export$a927a1327c2cc7f0 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(filterNameKey){
        super();
        this.filterNameKey = filterNameKey;
        this.applyActive = false;
        this.hidePopup = null;
        this.debouncePending = false;
        // after the user hits 'apply' the model gets copied to here. this is then the model that we use for
        // all filtering. so if user changes UI but doesn't hit apply, then the UI will be out of sync with this model.
        // this is what we want, as the UI should only become the 'active' filter once it's applied. when apply is
        // inactive, this model will be in sync (following the debounce ms). if the UI is not a valid filter
        // (eg the value is missing so nothing to filter on, or for set filter all checkboxes are checked so filter
        // not active) then this appliedModel will be null/undefined.
        this.appliedModel = null;
        this.eFilterBody = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.buttonListeners = [];
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
    }
    postConstruct() {
        this.resetTemplate();
        this.createManagedBean(new $7b57b57eaf5a9648$export$5510e53ed3962582(this.getFocusableElement(), {
            handleKeyDown: this.handleKeyDown.bind(this)
        }));
        this.positionableFeature = new $7b57b57eaf5a9648$export$c53a5d9f1fb0f7f6(this.getPositionableElement(), {
            forcePopupParentAsOffsetParent: true
        });
        this.createBean(this.positionableFeature);
    }
    // override
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    handleKeyDown(e) {}
    getFilterTitle() {
        return this.translate(this.filterNameKey);
    }
    isFilterActive() {
        return !!this.appliedModel;
    }
    resetTemplate(paramsMap) {
        let eGui = this.getGui();
        if (eGui) eGui.removeEventListener("submit", this.onFormSubmit);
        const templateString = /* html */ `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" data-ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`;
        this.setTemplate(templateString, this.getAgComponents(), paramsMap);
        eGui = this.getGui();
        if (eGui) eGui.addEventListener("submit", this.onFormSubmit);
    }
    isReadOnly() {
        return !!this.providedFilterParams.readOnly;
    }
    init(params) {
        this.setParams(params);
        this.resetUiToDefaults(true).then(()=>{
            this.updateUiVisibility();
            this.setupOnBtApplyDebounce();
        });
    }
    setParams(params) {
        this.providedFilterParams = params;
        this.applyActive = $7b57b57eaf5a9648$var$isUseApplyButton(params);
        this.resetButtonsPanel();
    }
    updateParams(params) {
        this.providedFilterParams = params;
        this.applyActive = $7b57b57eaf5a9648$var$isUseApplyButton(params);
        this.resetUiToActiveModel(this.getModel(), ()=>{
            this.updateUiVisibility();
            this.setupOnBtApplyDebounce();
        });
    }
    resetButtonsPanel() {
        const { buttons: buttons  } = this.providedFilterParams;
        const hasButtons = buttons && buttons.length > 0 && !this.isReadOnly();
        if (!this.eButtonsPanel) {
            if (hasButtons) {
                this.eButtonsPanel = document.createElement("div");
                this.eButtonsPanel.classList.add("ag-filter-apply-panel");
            }
        } else {
            $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eButtonsPanel);
            this.buttonListeners.forEach((destroyFunc)=>destroyFunc());
            this.buttonListeners = [];
        }
        if (!hasButtons) {
            if (this.eButtonsPanel) $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(this.eButtonsPanel);
            return;
        }
        const fragment = document.createDocumentFragment();
        const addButton = (type)=>{
            let text;
            let clickListener;
            switch(type){
                case "apply":
                    text = this.translate("applyFilter");
                    clickListener = (e)=>this.onBtApply(false, false, e);
                    break;
                case "clear":
                    text = this.translate("clearFilter");
                    clickListener = ()=>this.onBtClear();
                    break;
                case "reset":
                    text = this.translate("resetFilter");
                    clickListener = ()=>this.onBtReset();
                    break;
                case "cancel":
                    text = this.translate("cancelFilter");
                    clickListener = (e)=>{
                        this.onBtCancel(e);
                    };
                    break;
                default:
                    $7b57b57eaf5a9648$export$2cf41453020eef66("Unknown button type specified");
                    return;
            }
            const buttonType = type === "apply" ? "submit" : "button";
            const button = $7b57b57eaf5a9648$export$b1f57d075ca6d5fb(/* html */ `<button
                    type="${buttonType}"
                    data-ref="${type}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${text}
                </button>`);
            this.buttonListeners.push(...this.addManagedElementListeners(button, {
                click: clickListener
            }));
            fragment.append(button);
        };
        buttons.forEach((type)=>addButton(type));
        this.eButtonsPanel.append(fragment);
        this.getGui().appendChild(this.eButtonsPanel);
    }
    // subclasses can override this to provide alternative debounce defaults
    getDefaultDebounceMs() {
        return 0;
    }
    setupOnBtApplyDebounce() {
        const debounceMs = $7b57b57eaf5a9648$var$getDebounceMs(this.providedFilterParams, this.getDefaultDebounceMs());
        const debounceFunc = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.checkApplyDebounce.bind(this), debounceMs);
        this.onBtApplyDebounce = ()=>{
            this.debouncePending = true;
            debounceFunc();
        };
    }
    checkApplyDebounce() {
        if (this.debouncePending) {
            this.debouncePending = false;
            this.onBtApply();
        }
    }
    getModel() {
        return this.appliedModel ? this.appliedModel : null;
    }
    setModel(model) {
        const promise = model != null ? this.setModelIntoUi(model) : this.resetUiToDefaults();
        return promise.then(()=>{
            this.updateUiVisibility();
            this.applyModel("api");
        });
    }
    onBtCancel(e) {
        this.resetUiToActiveModel(this.getModel(), ()=>{
            this.handleCancelEnd(e);
        });
    }
    handleCancelEnd(e) {
        if (this.providedFilterParams.closeOnApply) this.close(e);
    }
    resetUiToActiveModel(currentModel, afterUiUpdatedFunc) {
        const afterAppliedFunc = ()=>{
            this.onUiChanged(false, "prevent");
            afterUiUpdatedFunc?.();
        };
        if (currentModel != null) this.setModelIntoUi(currentModel).then(afterAppliedFunc);
        else this.resetUiToDefaults().then(afterAppliedFunc);
    }
    onBtClear() {
        this.resetUiToDefaults().then(()=>this.onUiChanged());
    }
    onBtReset() {
        this.onBtClear();
        this.onBtApply();
    }
    /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    applyModel(source = "api") {
        const newModel = this.getModelFromUi();
        if (!this.isModelValid(newModel)) return false;
        const previousModel = this.appliedModel;
        this.appliedModel = newModel;
        return !this.areModelsEqual(previousModel, newModel);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isModelValid(model) {
        return true;
    }
    onFormSubmit(e) {
        e.preventDefault();
    }
    onBtApply(afterFloatingFilter = false, afterDataChange = false, e) {
        if (e) e.preventDefault();
        if (this.applyModel(afterDataChange ? "rowDataUpdated" : "ui")) {
            const source = "columnFilter";
            this.providedFilterParams.filterChangedCallback({
                afterFloatingFilter: afterFloatingFilter,
                afterDataChange: afterDataChange,
                source: source
            });
        }
        const { closeOnApply: closeOnApply  } = this.providedFilterParams;
        if (closeOnApply && this.applyActive && !afterFloatingFilter && !afterDataChange) this.close(e);
    }
    onNewRowsLoaded() {}
    close(e) {
        if (!this.hidePopup) return;
        const keyboardEvent = e;
        const key = keyboardEvent && keyboardEvent.key;
        let params;
        if (key === "Enter" || key === "Space") params = {
            keyboardEvent: keyboardEvent
        };
        this.hidePopup(params);
        this.hidePopup = null;
    }
    /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */ onUiChanged(fromFloatingFilter = false, apply) {
        this.updateUiVisibility();
        this.providedFilterParams.filterModifiedCallback();
        if (this.applyActive && !this.isReadOnly()) {
            const isValid = this.isModelValid(this.getModelFromUi());
            const applyFilterButton = this.queryForHtmlElement(`[data-ref="applyFilterButton"]`);
            if (applyFilterButton) $7b57b57eaf5a9648$export$b6b4f08392e9bfaf(applyFilterButton, !isValid);
        }
        if (fromFloatingFilter && !apply || apply === "immediately") this.onBtApply(fromFloatingFilter);
        else if (!this.applyActive && !apply || apply === "debounce") this.onBtApplyDebounce();
    }
    afterGuiAttached(params) {
        if (params) this.hidePopup = params.hidePopup;
        this.refreshFilterResizer(params?.container);
    }
    refreshFilterResizer(containerType) {
        if (!this.positionableFeature || containerType === "toolPanel") return;
        const isResizable = containerType === "floatingFilter" || containerType === "columnFilter";
        const { positionableFeature: positionableFeature , gos: gos  } = this;
        if (isResizable) {
            positionableFeature.restoreLastSize();
            positionableFeature.setResizable(gos.get("enableRtl") ? {
                bottom: true,
                bottomLeft: true,
                left: true
            } : {
                bottom: true,
                bottomRight: true,
                right: true
            });
        } else {
            this.positionableFeature.removeSizeFromEl();
            this.positionableFeature.setResizable(false);
        }
        this.positionableFeature.constrainSizeToAvailableHeight(true);
    }
    afterGuiDetached() {
        this.checkApplyDebounce();
        if (this.positionableFeature) this.positionableFeature.constrainSizeToAvailableHeight(false);
    }
    refresh(newParams) {
        this.providedFilterParams = newParams;
        return true;
    }
    destroy() {
        const eGui = this.getGui();
        if (eGui) eGui.removeEventListener("submit", this.onFormSubmit);
        this.hidePopup = null;
        if (this.positionableFeature) this.positionableFeature = this.destroyBean(this.positionableFeature);
        this.appliedModel = null;
        super.destroy();
    }
    translate(key) {
        const translate = this.localeService.getLocaleTextFunc();
        return translate(key, $7b57b57eaf5a9648$var$FILTER_LOCALE_TEXT[key]);
    }
    getCellValue(rowNode) {
        return this.providedFilterParams.getValue(rowNode);
    }
    // override to control positionable feature
    getPositionableElement() {
        return this.eFilterBody;
    }
};
// community-modules/core/src/widgets/agRadioButton.ts
var $7b57b57eaf5a9648$export$5caa9ea96bbb722 = class extends $7b57b57eaf5a9648$export$b00c508c1ae18d07 {
    constructor(config){
        super(config, "ag-radio-button", "radio");
    }
    isSelected() {
        return this.eInput.checked;
    }
    toggle() {
        if (this.eInput.disabled) return;
        if (!this.isSelected()) this.setValue(true);
    }
    addInputListeners() {
        super.addInputListeners();
        this.addManagedEventListeners({
            checkboxChanged: this.onChange.bind(this)
        });
    }
    /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */ onChange(event) {
        if (event.selected && event.name && this.eInput.name && this.eInput.name === event.name && event.id && this.eInput.id !== event.id) this.setValue(false, true);
    }
};
// community-modules/core/src/widgets/agList.ts
var $7b57b57eaf5a9648$var$AgList = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(cssIdentifier = "default", unFocusable = false){
        super(/* html */ `<div class="ag-list ag-${cssIdentifier}-list" role="listbox"></div>`);
        this.cssIdentifier = cssIdentifier;
        this.unFocusable = unFocusable;
        this.activeClass = "ag-active-item";
        this.options = [];
        this.itemEls = [];
    }
    postConstruct() {
        const eGui = this.getGui();
        this.addManagedElementListeners(eGui, {
            mouseleave: ()=>this.clearHighlighted()
        });
        if (this.unFocusable) return;
        this.addManagedElementListeners(eGui, {
            keydown: this.handleKeyDown.bind(this)
        });
    }
    handleKeyDown(e) {
        const key = e.key;
        switch(key){
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER:
                if (!this.highlightedEl) this.setValue(this.getValue());
                else {
                    const pos = this.itemEls.indexOf(this.highlightedEl);
                    this.setValueByIndex(pos);
                }
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
                e.preventDefault();
                this.navigate(key);
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_DOWN:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_HOME:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_END:
                e.preventDefault();
                this.navigateToPage(key);
                break;
        }
    }
    navigate(key) {
        const isDown = key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN;
        let itemToHighlight;
        if (!this.highlightedEl) itemToHighlight = this.itemEls[isDown ? 0 : this.itemEls.length - 1];
        else {
            const currentIdx = this.itemEls.indexOf(this.highlightedEl);
            let nextPos = currentIdx + (isDown ? 1 : -1);
            nextPos = Math.min(Math.max(nextPos, 0), this.itemEls.length - 1);
            itemToHighlight = this.itemEls[nextPos];
        }
        this.highlightItem(itemToHighlight);
    }
    navigateToPage(key) {
        if (!this.highlightedEl || this.itemEls.length === 0) return;
        const currentIdx = this.itemEls.indexOf(this.highlightedEl);
        const rowCount = this.options.length - 1;
        const itemHeight = this.itemEls[0].clientHeight;
        const pageSize = Math.floor(this.getGui().clientHeight / itemHeight);
        let newIndex = -1;
        if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_HOME) newIndex = 0;
        else if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_END) newIndex = rowCount;
        else if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_DOWN) newIndex = Math.min(currentIdx + pageSize, rowCount);
        else if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP) newIndex = Math.max(currentIdx - pageSize, 0);
        if (newIndex === -1) return;
        this.highlightItem(this.itemEls[newIndex]);
    }
    addOptions(listOptions) {
        listOptions.forEach((listOption)=>this.addOption(listOption));
        return this;
    }
    addOption(listOption) {
        const { value: value , text: text  } = listOption;
        const valueToRender = text || value;
        this.options.push({
            value: value,
            text: valueToRender
        });
        this.renderOption(value, valueToRender);
        this.updateIndices();
        return this;
    }
    clearOptions() {
        this.options = [];
        this.reset(true);
        this.itemEls.forEach((itemEl)=>{
            $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(itemEl);
        });
        this.itemEls = [];
    }
    updateIndices() {
        const options = this.getGui().querySelectorAll(".ag-list-item");
        options.forEach((option, idx)=>{
            $7b57b57eaf5a9648$export$c3d3aede41065a84(option, idx + 1);
            $7b57b57eaf5a9648$export$3d494c2007bbcac1(option, options.length);
        });
    }
    renderOption(value, text) {
        const eDocument = this.gos.getDocument();
        const itemEl = eDocument.createElement("div");
        $7b57b57eaf5a9648$export$f8d01fa01787902(itemEl, "option");
        itemEl.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
        const span = eDocument.createElement("span");
        itemEl.appendChild(span);
        span.textContent = text;
        if (!this.unFocusable) itemEl.tabIndex = -1;
        this.itemEls.push(itemEl);
        this.addManagedListeners(itemEl, {
            mouseover: ()=>this.highlightItem(itemEl),
            mousedown: (e)=>{
                e.preventDefault();
                e.stopPropagation();
                this.setValue(value);
            }
        });
        this.createManagedBean(new $7b57b57eaf5a9648$export$e5073a590d24815c({
            getTooltipValue: ()=>text,
            getGui: ()=>itemEl,
            getLocation: ()=>"UNKNOWN",
            // only show tooltips for items where the text cannot be fully displayed
            shouldDisplayTooltip: ()=>span.scrollWidth > span.clientWidth
        }));
        this.getGui().appendChild(itemEl);
    }
    setValue(value, silent) {
        if (this.value === value) {
            this.fireItemSelected();
            return this;
        }
        if (value == null) {
            this.reset(silent);
            return this;
        }
        const idx = this.options.findIndex((option)=>option.value === value);
        if (idx !== -1) {
            const option = this.options[idx];
            this.value = option.value;
            this.displayValue = option.text;
            this.highlightItem(this.itemEls[idx]);
            if (!silent) this.fireChangeEvent();
        }
        return this;
    }
    setValueByIndex(idx) {
        return this.setValue(this.options[idx].value);
    }
    getValue() {
        return this.value;
    }
    getDisplayValue() {
        return this.displayValue;
    }
    refreshHighlighted() {
        this.clearHighlighted();
        const idx = this.options.findIndex((option)=>option.value === this.value);
        if (idx !== -1) this.highlightItem(this.itemEls[idx]);
    }
    reset(silent) {
        this.value = null;
        this.displayValue = null;
        this.clearHighlighted();
        if (!silent) this.fireChangeEvent();
    }
    highlightItem(el) {
        if (!$7b57b57eaf5a9648$export$2badf4aa566524cb(el)) return;
        this.clearHighlighted();
        this.highlightedEl = el;
        this.highlightedEl.classList.add(this.activeClass);
        $7b57b57eaf5a9648$export$c22e3722e8a33469(this.highlightedEl, true);
        const eGui = this.getGui();
        const { scrollTop: scrollTop , clientHeight: clientHeight  } = eGui;
        const { offsetTop: offsetTop , offsetHeight: offsetHeight  } = el;
        if (offsetTop + offsetHeight > scrollTop + clientHeight || offsetTop < scrollTop) this.highlightedEl.scrollIntoView({
            block: "nearest"
        });
        if (!this.unFocusable) this.highlightedEl.focus();
    }
    clearHighlighted() {
        if (!this.highlightedEl || !$7b57b57eaf5a9648$export$2badf4aa566524cb(this.highlightedEl)) return;
        this.highlightedEl.classList.remove(this.activeClass);
        $7b57b57eaf5a9648$export$c22e3722e8a33469(this.highlightedEl, false);
        this.highlightedEl = null;
    }
    fireChangeEvent() {
        this.dispatchLocalEvent({
            type: "fieldValueChanged"
        });
        this.fireItemSelected();
    }
    fireItemSelected() {
        this.dispatchLocalEvent({
            type: "selectedItem"
        });
    }
};
// community-modules/core/src/widgets/agPickerField.ts
var $7b57b57eaf5a9648$export$1f14489b6fdeb99b = class extends $7b57b57eaf5a9648$export$8889445e1e1d2c89 {
    constructor(config){
        super(config, config?.template || /* html */ `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                    <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
                    <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`, config?.agComponents || [], config?.className);
        this.isPickerDisplayed = false;
        this.skipClick = false;
        this.pickerGap = 4;
        this.hideCurrentPicker = null;
        this.eLabel = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eWrapper = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eDisplayField = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eIcon = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.ariaRole = config?.ariaRole;
        this.onPickerFocusIn = this.onPickerFocusIn.bind(this);
        this.onPickerFocusOut = this.onPickerFocusOut.bind(this);
        if (!config) return;
        const { pickerGap: pickerGap , maxPickerHeight: maxPickerHeight , variableWidth: variableWidth , minPickerWidth: minPickerWidth , maxPickerWidth: maxPickerWidth  } = config;
        if (pickerGap != null) this.pickerGap = pickerGap;
        this.variableWidth = !!variableWidth;
        if (maxPickerHeight != null) this.setPickerMaxHeight(maxPickerHeight);
        if (minPickerWidth != null) this.setPickerMinWidth(minPickerWidth);
        if (maxPickerWidth != null) this.setPickerMaxWidth(maxPickerWidth);
    }
    wireBeans(beans) {
        this.popupService = beans.popupService;
    }
    postConstruct() {
        super.postConstruct();
        this.setupAria();
        const displayId = `ag-${this.getCompId()}-display`;
        this.eDisplayField.setAttribute("id", displayId);
        const ariaEl = this.getAriaElement();
        this.addManagedElementListeners(ariaEl, {
            keydown: this.onKeyDown.bind(this)
        });
        this.addManagedElementListeners(this.eLabel, {
            mousedown: this.onLabelOrWrapperMouseDown.bind(this)
        });
        this.addManagedElementListeners(this.eWrapper, {
            mousedown: this.onLabelOrWrapperMouseDown.bind(this)
        });
        const { pickerIcon: pickerIcon , inputWidth: inputWidth  } = this.config;
        if (pickerIcon) {
            const icon = $7b57b57eaf5a9648$export$d8feba07bf373edb(pickerIcon, this.gos);
            if (icon) this.eIcon.appendChild(icon);
        }
        if (inputWidth != null) this.setInputWidth(inputWidth);
    }
    setupAria() {
        const ariaEl = this.getAriaElement();
        ariaEl.setAttribute("tabindex", this.gos.get("tabIndex").toString());
        $7b57b57eaf5a9648$export$3ad3518dddf15485(ariaEl, false);
        if (this.ariaRole) $7b57b57eaf5a9648$export$f8d01fa01787902(ariaEl, this.ariaRole);
    }
    onLabelOrWrapperMouseDown(e) {
        if (e) {
            const focusableEl = this.getFocusableElement();
            if (focusableEl !== this.eWrapper && e?.target === focusableEl) return;
            e.preventDefault();
            this.getFocusableElement().focus();
        }
        if (this.skipClick) {
            this.skipClick = false;
            return;
        }
        if (this.isDisabled()) return;
        if (this.isPickerDisplayed) this.hidePicker();
        else this.showPicker();
    }
    onKeyDown(e) {
        switch(e.key){
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.SPACE:
                e.preventDefault();
                this.onLabelOrWrapperMouseDown();
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ESCAPE:
                if (this.isPickerDisplayed) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (this.hideCurrentPicker) this.hideCurrentPicker();
                }
                break;
        }
    }
    showPicker() {
        this.isPickerDisplayed = true;
        if (!this.pickerComponent) this.pickerComponent = this.createPickerComponent();
        const pickerGui = this.pickerComponent.getGui();
        pickerGui.addEventListener("focusin", this.onPickerFocusIn);
        pickerGui.addEventListener("focusout", this.onPickerFocusOut);
        this.hideCurrentPicker = this.renderAndPositionPicker();
        this.toggleExpandedStyles(true);
    }
    renderAndPositionPicker() {
        const eDocument = this.gos.getDocument();
        const ePicker = this.pickerComponent.getGui();
        if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) [this.destroyMouseWheelFunc] = this.addManagedEventListeners({
            bodyScroll: ()=>{
                this.hidePicker();
            }
        });
        const translate = this.localeService.getLocaleTextFunc();
        const { pickerAriaLabelKey: pickerAriaLabelKey , pickerAriaLabelValue: pickerAriaLabelValue , modalPicker: modalPicker = true  } = this.config;
        const popupParams = {
            modal: modalPicker,
            eChild: ePicker,
            closeOnEsc: true,
            closedCallback: ()=>{
                const activeEl = this.gos.getActiveDomElement();
                const shouldRestoreFocus = !activeEl || activeEl === eDocument.body;
                this.beforeHidePicker();
                if (shouldRestoreFocus && this.isAlive()) this.getFocusableElement().focus();
            },
            ariaLabel: translate(pickerAriaLabelKey, pickerAriaLabelValue)
        };
        const addPopupRes = this.popupService.addPopup(popupParams);
        const { maxPickerHeight: maxPickerHeight , minPickerWidth: minPickerWidth , maxPickerWidth: maxPickerWidth , variableWidth: variableWidth  } = this;
        if (variableWidth) {
            if (minPickerWidth) ePicker.style.minWidth = minPickerWidth;
            ePicker.style.width = $7b57b57eaf5a9648$var$_formatSize($7b57b57eaf5a9648$export$642efcb17474eb51(this.eWrapper));
            if (maxPickerWidth) ePicker.style.maxWidth = maxPickerWidth;
        } else $7b57b57eaf5a9648$var$_setElementWidth(ePicker, maxPickerWidth ?? $7b57b57eaf5a9648$export$642efcb17474eb51(this.eWrapper));
        const maxHeight = maxPickerHeight ?? `${$7b57b57eaf5a9648$export$c20e968103d9c16e(this.popupService.getPopupParent())}px`;
        ePicker.style.setProperty("max-height", maxHeight);
        ePicker.style.position = "absolute";
        this.alignPickerToComponent();
        return addPopupRes.hideFunc;
    }
    alignPickerToComponent() {
        if (!this.pickerComponent) return;
        const { pickerType: pickerType  } = this.config;
        const { pickerGap: pickerGap  } = this;
        const alignSide = this.gos.get("enableRtl") ? "right" : "left";
        this.popupService.positionPopupByComponent({
            type: pickerType,
            eventSource: this.eWrapper,
            ePopup: this.pickerComponent.getGui(),
            position: "under",
            alignSide: alignSide,
            keepWithinBounds: true,
            nudgeY: pickerGap
        });
    }
    beforeHidePicker() {
        if (this.destroyMouseWheelFunc) {
            this.destroyMouseWheelFunc();
            this.destroyMouseWheelFunc = void 0;
        }
        this.toggleExpandedStyles(false);
        const pickerGui = this.pickerComponent.getGui();
        pickerGui.removeEventListener("focusin", this.onPickerFocusIn);
        pickerGui.removeEventListener("focusout", this.onPickerFocusOut);
        this.isPickerDisplayed = false;
        this.pickerComponent = void 0;
        this.hideCurrentPicker = null;
    }
    toggleExpandedStyles(expanded) {
        if (!this.isAlive()) return;
        const ariaEl = this.getAriaElement();
        $7b57b57eaf5a9648$export$3ad3518dddf15485(ariaEl, expanded);
        this.eWrapper.classList.toggle("ag-picker-expanded", expanded);
        this.eWrapper.classList.toggle("ag-picker-collapsed", !expanded);
    }
    onPickerFocusIn() {
        this.togglePickerHasFocus(true);
    }
    onPickerFocusOut(e) {
        if (!this.pickerComponent?.getGui().contains(e.relatedTarget)) this.togglePickerHasFocus(false);
    }
    togglePickerHasFocus(focused) {
        if (!this.pickerComponent) return;
        this.eWrapper.classList.toggle("ag-picker-has-focus", focused);
    }
    hidePicker() {
        if (this.hideCurrentPicker) this.hideCurrentPicker();
    }
    setInputWidth(width) {
        $7b57b57eaf5a9648$var$_setElementWidth(this.eWrapper, width);
        return this;
    }
    getFocusableElement() {
        return this.eWrapper;
    }
    setPickerGap(gap) {
        this.pickerGap = gap;
        return this;
    }
    setPickerMinWidth(width) {
        if (typeof width === "number") width = `${width}px`;
        this.minPickerWidth = width == null ? void 0 : width;
        return this;
    }
    setPickerMaxWidth(width) {
        if (typeof width === "number") width = `${width}px`;
        this.maxPickerWidth = width == null ? void 0 : width;
        return this;
    }
    setPickerMaxHeight(height) {
        if (typeof height === "number") height = `${height}px`;
        this.maxPickerHeight = height == null ? void 0 : height;
        return this;
    }
    destroy() {
        this.hidePicker();
        super.destroy();
    }
};
// community-modules/core/src/widgets/agSelect.ts
var $7b57b57eaf5a9648$export$6f9c460854d56032 = class extends $7b57b57eaf5a9648$export$1f14489b6fdeb99b {
    constructor(config){
        super({
            pickerAriaLabelKey: "ariaLabelSelectField",
            pickerAriaLabelValue: "Select Field",
            pickerType: "ag-list",
            className: "ag-select",
            pickerIcon: "smallDown",
            ariaRole: "combobox",
            ...config
        });
    }
    postConstruct() {
        super.postConstruct();
        this.createListComponent();
        this.eWrapper.tabIndex = this.gos.get("tabIndex");
        const { options: options , value: value , placeholder: placeholder  } = this.config;
        if (options != null) this.addOptions(options);
        if (value != null) this.setValue(value, true);
        if (placeholder && value == null) this.eDisplayField.textContent = placeholder;
        this.addManagedElementListeners(this.eWrapper, {
            focusout: this.onWrapperFocusOut.bind(this)
        });
    }
    onWrapperFocusOut(e) {
        if (!this.eWrapper.contains(e.relatedTarget)) this.hidePicker();
    }
    createListComponent() {
        this.listComponent = this.createBean(new $7b57b57eaf5a9648$var$AgList("select", true));
        this.listComponent.setParentComponent(this);
        const eListAriaEl = this.listComponent.getAriaElement();
        const listId = `ag-select-list-${this.listComponent.getCompId()}`;
        eListAriaEl.setAttribute("id", listId);
        $7b57b57eaf5a9648$export$26fd6a3f123d4e67(this.getAriaElement(), eListAriaEl);
        this.listComponent.addManagedListeners(this.listComponent, {
            selectedItem: ()=>{
                this.hidePicker();
                this.dispatchLocalEvent({
                    type: "selectedItem"
                });
            }
        });
        this.listComponent.addManagedListeners(this.listComponent, {
            fieldValueChanged: ()=>{
                if (!this.listComponent) return;
                this.setValue(this.listComponent.getValue(), false, true);
                this.hidePicker();
            }
        });
    }
    createPickerComponent() {
        return this.listComponent;
    }
    onKeyDown(e) {
        const { key: key  } = e;
        if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.TAB) this.hidePicker();
        switch(key){
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_DOWN:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_HOME:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_END:
                e.preventDefault();
                if (this.isPickerDisplayed) this.listComponent?.handleKeyDown(e);
                else super.onKeyDown(e);
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ESCAPE:
                super.onKeyDown(e);
                break;
        }
    }
    showPicker() {
        if (!this.listComponent) return;
        super.showPicker();
        this.listComponent.refreshHighlighted();
    }
    addOptions(options) {
        options.forEach((option)=>this.addOption(option));
        return this;
    }
    addOption(option) {
        this.listComponent.addOption(option);
        return this;
    }
    clearOptions() {
        this.listComponent?.clearOptions();
        return this;
    }
    setValue(value, silent, fromPicker) {
        if (this.value === value || !this.listComponent) return this;
        if (!fromPicker) this.listComponent.setValue(value, true);
        const newValue = this.listComponent.getValue();
        if (newValue === this.getValue()) return this;
        let displayValue = this.listComponent.getDisplayValue();
        if (displayValue == null && this.config.placeholder) displayValue = this.config.placeholder;
        this.eDisplayField.textContent = displayValue;
        this.setTooltip({
            newTooltipText: displayValue ?? null,
            shouldDisplayTooltip: ()=>this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
        });
        return super.setValue(value, silent);
    }
    destroy() {
        if (this.listComponent) this.listComponent = this.destroyBean(this.listComponent);
        super.destroy();
    }
};
var $7b57b57eaf5a9648$export$e32612175ad118ef = {
    selector: "AG-SELECT",
    component: $7b57b57eaf5a9648$export$6f9c460854d56032
};
// community-modules/core/src/filter/provided/optionsFactory.ts
var $7b57b57eaf5a9648$var$OptionsFactory = class {
    constructor(){
        this.customFilterOptions = {};
    }
    init(params, defaultOptions) {
        this.filterOptions = params.filterOptions || defaultOptions;
        this.mapCustomOptions();
        this.selectDefaultItem(params);
    }
    getFilterOptions() {
        return this.filterOptions;
    }
    mapCustomOptions() {
        if (!this.filterOptions) return;
        this.filterOptions.forEach((filterOption)=>{
            if (typeof filterOption === "string") return;
            const requiredProperties = [
                [
                    "displayKey"
                ],
                [
                    "displayName"
                ],
                [
                    "predicate",
                    "test"
                ]
            ];
            const propertyCheck = (keys)=>{
                if (!keys.some((key)=>filterOption[key] != null)) {
                    $7b57b57eaf5a9648$export$2cf41453020eef66(`ignoring FilterOptionDef as it doesn't contain one of '${keys}'`);
                    return false;
                }
                return true;
            };
            if (!requiredProperties.every(propertyCheck)) {
                this.filterOptions = this.filterOptions.filter((v)=>v === filterOption) || [];
                return;
            }
            this.customFilterOptions[filterOption.displayKey] = filterOption;
        });
    }
    selectDefaultItem(params) {
        if (params.defaultOption) this.defaultOption = params.defaultOption;
        else if (this.filterOptions.length >= 1) {
            const firstFilterOption = this.filterOptions[0];
            if (typeof firstFilterOption === "string") this.defaultOption = firstFilterOption;
            else if (firstFilterOption.displayKey) this.defaultOption = firstFilterOption.displayKey;
            else $7b57b57eaf5a9648$export$2cf41453020eef66(`invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'`);
        } else $7b57b57eaf5a9648$export$2cf41453020eef66("no filter options for filter");
    }
    getDefaultOption() {
        return this.defaultOption;
    }
    getCustomOption(name) {
        return this.customFilterOptions[name];
    }
};
// community-modules/core/src/filter/provided/simpleFilter.ts
var $7b57b57eaf5a9648$export$f5377e6e4a0f88ed = class extends $7b57b57eaf5a9648$export$a927a1327c2cc7f0 {
    constructor(){
        super(...arguments);
        this.eTypes = [];
        this.eJoinOperatorPanels = [];
        this.eJoinOperatorsAnd = [];
        this.eJoinOperatorsOr = [];
        this.eConditionBodies = [];
        this.listener = ()=>this.onUiChanged();
        this.lastUiCompletePosition = null;
        this.joinOperatorId = 0;
    }
    getNumberOfInputs(type) {
        const customOpts = this.optionsFactory.getCustomOption(type);
        if (customOpts) {
            const { numberOfInputs: numberOfInputs  } = customOpts;
            return numberOfInputs != null ? numberOfInputs : 1;
        }
        const zeroInputTypes = [
            "empty",
            "notBlank",
            "blank"
        ];
        if (type && zeroInputTypes.indexOf(type) >= 0) return 0;
        else if (type === "inRange") return 2;
        return 1;
    }
    // floating filter calls this when user applies filter from floating filter
    onFloatingFilterChanged(type, value) {
        this.setTypeFromFloatingFilter(type);
        this.setValueFromFloatingFilter(value);
        this.onUiChanged(true);
    }
    setTypeFromFloatingFilter(type) {
        this.eTypes.forEach((eType, position)=>{
            if (position === 0) eType.setValue(type, true);
            else eType.setValue(this.optionsFactory.getDefaultOption(), true);
        });
    }
    getModelFromUi() {
        const conditions = this.getUiCompleteConditions();
        if (conditions.length === 0) return null;
        if (this.maxNumConditions > 1 && conditions.length > 1) return {
            filterType: this.getFilterType(),
            operator: this.getJoinOperator(),
            conditions: conditions
        };
        return conditions[0];
    }
    getConditionTypes() {
        return this.eTypes.map((eType)=>eType.getValue());
    }
    getConditionType(position) {
        return this.eTypes[position].getValue();
    }
    getJoinOperator() {
        if (this.eJoinOperatorsOr.length === 0) return this.defaultJoinOperator;
        return this.eJoinOperatorsOr[0].getValue() === true ? "OR" : "AND";
    }
    areModelsEqual(a, b) {
        if (!a && !b) return true;
        if (!a && b || a && !b) return false;
        const aIsSimple = !a.operator;
        const bIsSimple = !b.operator;
        const oneSimpleOneCombined = !aIsSimple && bIsSimple || aIsSimple && !bIsSimple;
        if (oneSimpleOneCombined) return false;
        let res;
        if (aIsSimple) {
            const aSimple = a;
            const bSimple = b;
            res = this.areSimpleModelsEqual(aSimple, bSimple);
        } else {
            const aCombined = a;
            const bCombined = b;
            res = aCombined.operator === bCombined.operator && $7b57b57eaf5a9648$export$893967cdb9833fdd(aCombined.conditions, bCombined.conditions, (aModel, bModel)=>this.areSimpleModelsEqual(aModel, bModel));
        }
        return res;
    }
    shouldRefresh(newParams) {
        const model = this.getModel();
        const conditions = model ? model.conditions ?? [
            model
        ] : null;
        const newOptionsList = newParams.filterOptions?.map((option)=>typeof option === "string" ? option : option.displayKey) ?? this.getDefaultFilterOptions();
        const allConditionsExistInNewOptionsList = !conditions || conditions.every((condition)=>newOptionsList.find((option)=>option === condition.type) !== void 0);
        if (!allConditionsExistInNewOptionsList) return false;
        if (typeof newParams.maxNumConditions === "number" && conditions && conditions.length > newParams.maxNumConditions) return false;
        return true;
    }
    refresh(newParams) {
        if (!this.shouldRefresh(newParams)) return false;
        const parentRefreshed = super.refresh(newParams);
        if (!parentRefreshed) return false;
        this.setParams(newParams);
        this.removeConditionsAndOperators(0);
        this.createOption();
        this.setModel(this.getModel());
        return true;
    }
    setModelIntoUi(model) {
        const isCombined = model.operator;
        if (isCombined) {
            const combinedModel = model;
            let conditions = combinedModel.conditions;
            if (conditions == null) {
                conditions = [];
                $7b57b57eaf5a9648$export$2cf41453020eef66(`Filter model is missing 'conditions'`);
            }
            const numConditions = this.validateAndUpdateConditions(conditions);
            const numPrevConditions = this.getNumConditions();
            if (numConditions < numPrevConditions) this.removeConditionsAndOperators(numConditions);
            else if (numConditions > numPrevConditions) for(let i = numPrevConditions; i < numConditions; i++){
                this.createJoinOperatorPanel();
                this.createOption();
            }
            const orChecked = combinedModel.operator === "OR";
            this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd)=>eJoinOperatorAnd.setValue(!orChecked, true));
            this.eJoinOperatorsOr.forEach((eJoinOperatorOr)=>eJoinOperatorOr.setValue(orChecked, true));
            conditions.forEach((condition, position)=>{
                this.eTypes[position].setValue(condition.type, true);
                this.setConditionIntoUi(condition, position);
            });
        } else {
            const simpleModel = model;
            if (this.getNumConditions() > 1) this.removeConditionsAndOperators(1);
            this.eTypes[0].setValue(simpleModel.type, true);
            this.setConditionIntoUi(simpleModel, 0);
        }
        this.lastUiCompletePosition = this.getNumConditions() - 1;
        this.createMissingConditionsAndOperators();
        this.onUiChanged();
        return $7b57b57eaf5a9648$export$30ec7836a4847721.resolve();
    }
    validateAndUpdateConditions(conditions) {
        let numConditions = conditions.length;
        if (numConditions > this.maxNumConditions) {
            conditions.splice(this.maxNumConditions);
            $7b57b57eaf5a9648$export$2cf41453020eef66('Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.');
            numConditions = this.maxNumConditions;
        }
        return numConditions;
    }
    doesFilterPass(params) {
        const model = this.getModel();
        if (model == null) return true;
        const { operator: operator  } = model;
        const models = [];
        if (operator) {
            const combinedModel = model;
            models.push(...combinedModel.conditions ?? []);
        } else models.push(model);
        const combineFunction = operator && operator === "OR" ? "some" : "every";
        return models[combineFunction]((m)=>this.individualConditionPasses(params, m));
    }
    setParams(params) {
        super.setParams(params);
        this.setNumConditions(params);
        this.defaultJoinOperator = this.getDefaultJoinOperator(params.defaultJoinOperator);
        this.filterPlaceholder = params.filterPlaceholder;
        this.optionsFactory = new $7b57b57eaf5a9648$var$OptionsFactory();
        this.optionsFactory.init(params, this.getDefaultFilterOptions());
        this.createFilterListOptions();
        this.createOption();
        this.createMissingConditionsAndOperators();
        if (this.isReadOnly()) this.eFilterBody.setAttribute("tabindex", "-1");
    }
    setNumConditions(params) {
        this.maxNumConditions = params.maxNumConditions ?? 2;
        if (this.maxNumConditions < 1) {
            $7b57b57eaf5a9648$export$2cf41453020eef66('"filterParams.maxNumConditions" must be greater than or equal to zero.');
            this.maxNumConditions = 1;
        }
        this.numAlwaysVisibleConditions = params.numAlwaysVisibleConditions ?? 1;
        if (this.numAlwaysVisibleConditions < 1) {
            $7b57b57eaf5a9648$export$2cf41453020eef66('"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.');
            this.numAlwaysVisibleConditions = 1;
        }
        if (this.numAlwaysVisibleConditions > this.maxNumConditions) {
            $7b57b57eaf5a9648$export$2cf41453020eef66('"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".');
            this.numAlwaysVisibleConditions = this.maxNumConditions;
        }
    }
    createOption() {
        const eType = this.createManagedBean(new $7b57b57eaf5a9648$export$6f9c460854d56032());
        this.eTypes.push(eType);
        eType.addCssClass("ag-filter-select");
        this.eFilterBody.appendChild(eType.getGui());
        const eConditionBody = this.createValueElement();
        this.eConditionBodies.push(eConditionBody);
        this.eFilterBody.appendChild(eConditionBody);
        this.putOptionsIntoDropdown(eType);
        this.resetType(eType);
        const position = this.getNumConditions() - 1;
        this.forEachPositionInput(position, (element)=>this.resetInput(element));
        this.addChangedListeners(eType, position);
    }
    createJoinOperatorPanel() {
        const eJoinOperatorPanel = document.createElement("div");
        this.eJoinOperatorPanels.push(eJoinOperatorPanel);
        eJoinOperatorPanel.classList.add("ag-filter-condition");
        const eJoinOperatorAnd = this.createJoinOperator(this.eJoinOperatorsAnd, eJoinOperatorPanel, "and");
        const eJoinOperatorOr = this.createJoinOperator(this.eJoinOperatorsOr, eJoinOperatorPanel, "or");
        this.eFilterBody.appendChild(eJoinOperatorPanel);
        const index = this.eJoinOperatorPanels.length - 1;
        const uniqueGroupId = this.joinOperatorId++;
        this.resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId);
        this.resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId);
        if (!this.isReadOnly()) {
            eJoinOperatorAnd.onValueChange(this.listener);
            eJoinOperatorOr.onValueChange(this.listener);
        }
    }
    createJoinOperator(eJoinOperators, eJoinOperatorPanel, andOr) {
        const eJoinOperator = this.createManagedBean(new $7b57b57eaf5a9648$export$5caa9ea96bbb722());
        eJoinOperators.push(eJoinOperator);
        eJoinOperator.addCssClass("ag-filter-condition-operator");
        eJoinOperator.addCssClass(`ag-filter-condition-operator-${andOr}`);
        eJoinOperatorPanel.appendChild(eJoinOperator.getGui());
        return eJoinOperator;
    }
    getDefaultJoinOperator(defaultJoinOperator) {
        return defaultJoinOperator === "AND" || defaultJoinOperator === "OR" ? defaultJoinOperator : "AND";
    }
    createFilterListOptions() {
        const filterOptions = this.optionsFactory.getFilterOptions();
        this.filterListOptions = filterOptions.map((option)=>typeof option === "string" ? this.createBoilerplateListOption(option) : this.createCustomListOption(option));
    }
    putOptionsIntoDropdown(eType) {
        this.filterListOptions.forEach((listOption)=>{
            eType.addOption(listOption);
        });
        eType.setDisabled(this.filterListOptions.length <= 1);
    }
    createBoilerplateListOption(option) {
        return {
            value: option,
            text: this.translate(option)
        };
    }
    createCustomListOption(option) {
        const { displayKey: displayKey  } = option;
        const customOption = this.optionsFactory.getCustomOption(option.displayKey);
        return {
            value: displayKey,
            text: customOption ? this.localeService.getLocaleTextFunc()(customOption.displayKey, customOption.displayName) : this.translate(displayKey)
        };
    }
    createBodyTemplate() {
        return "";
    }
    getAgComponents() {
        return [];
    }
    getCssIdentifier() {
        return "simple-filter";
    }
    updateUiVisibility() {
        const joinOperator = this.getJoinOperator();
        this.updateNumConditions();
        this.updateConditionStatusesAndValues(this.lastUiCompletePosition, joinOperator);
    }
    updateNumConditions() {
        let lastUiCompletePosition = -1;
        let areAllConditionsUiComplete = true;
        for(let position = 0; position < this.getNumConditions(); position++)if (this.isConditionUiComplete(position)) lastUiCompletePosition = position;
        else areAllConditionsUiComplete = false;
        if (this.shouldAddNewConditionAtEnd(areAllConditionsUiComplete)) {
            this.createJoinOperatorPanel();
            this.createOption();
        } else {
            const activePosition = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
            if (lastUiCompletePosition < activePosition) {
                this.removeConditionsAndOperators(activePosition + 1);
                const removeStartPosition = lastUiCompletePosition + 1;
                const numConditionsToRemove = activePosition - removeStartPosition;
                if (numConditionsToRemove > 0) this.removeConditionsAndOperators(removeStartPosition, numConditionsToRemove);
                this.createMissingConditionsAndOperators();
            }
        }
        this.lastUiCompletePosition = lastUiCompletePosition;
    }
    updateConditionStatusesAndValues(lastUiCompletePosition, joinOperator) {
        this.eTypes.forEach((eType, position)=>{
            const disabled = this.isConditionDisabled(position, lastUiCompletePosition);
            eType.setDisabled(disabled || this.filterListOptions.length <= 1);
            if (position === 1) {
                $7b57b57eaf5a9648$export$b6b4f08392e9bfaf(this.eJoinOperatorPanels[0], disabled);
                this.eJoinOperatorsAnd[0].setDisabled(disabled);
                this.eJoinOperatorsOr[0].setDisabled(disabled);
            }
        });
        this.eConditionBodies.forEach((element, index)=>{
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(element, this.isConditionBodyVisible(index));
        });
        const orChecked = (joinOperator ?? this.getJoinOperator()) === "OR";
        this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd)=>{
            eJoinOperatorAnd.setValue(!orChecked, true);
        });
        this.eJoinOperatorsOr.forEach((eJoinOperatorOr)=>{
            eJoinOperatorOr.setValue(orChecked, true);
        });
        this.forEachInput((element, index, position, numberOfInputs)=>{
            this.setElementDisplayed(element, index < numberOfInputs);
            this.setElementDisabled(element, this.isConditionDisabled(position, lastUiCompletePosition));
        });
        this.resetPlaceholder();
    }
    shouldAddNewConditionAtEnd(areAllConditionsUiComplete) {
        return areAllConditionsUiComplete && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
    }
    removeConditionsAndOperators(startPosition, deleteCount) {
        if (startPosition >= this.getNumConditions()) return;
        this.removeComponents(this.eTypes, startPosition, deleteCount);
        this.removeElements(this.eConditionBodies, startPosition, deleteCount);
        this.removeValueElements(startPosition, deleteCount);
        const joinOperatorIndex = Math.max(startPosition - 1, 0);
        this.removeElements(this.eJoinOperatorPanels, joinOperatorIndex, deleteCount);
        this.removeComponents(this.eJoinOperatorsAnd, joinOperatorIndex, deleteCount);
        this.removeComponents(this.eJoinOperatorsOr, joinOperatorIndex, deleteCount);
    }
    removeElements(elements, startPosition, deleteCount) {
        const removedElements = this.removeItems(elements, startPosition, deleteCount);
        removedElements.forEach((element)=>$7b57b57eaf5a9648$export$dd4d52e41fb4cef5(element));
    }
    removeComponents(components, startPosition, deleteCount) {
        const removedComponents = this.removeItems(components, startPosition, deleteCount);
        removedComponents.forEach((comp)=>{
            $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(comp.getGui());
            this.destroyBean(comp);
        });
    }
    removeItems(items, startPosition, deleteCount) {
        return deleteCount == null ? items.splice(startPosition) : items.splice(startPosition, deleteCount);
    }
    afterGuiAttached(params) {
        super.afterGuiAttached(params);
        this.resetPlaceholder();
        if (!params?.suppressFocus) {
            if (this.isReadOnly()) this.eFilterBody.focus();
            else {
                const firstInput = this.getInputs(0)[0];
                if (!firstInput) return;
                if (firstInput instanceof $7b57b57eaf5a9648$export$9671f513d4aa42e3) firstInput.getInputElement().focus();
            }
        }
    }
    afterGuiDetached() {
        super.afterGuiDetached();
        const appliedModel = this.getModel();
        this.resetUiToActiveModel(appliedModel);
        let lastUiCompletePosition = -1;
        let updatedLastUiCompletePosition = -1;
        let conditionsRemoved = false;
        const joinOperator = this.getJoinOperator();
        for(let position = this.getNumConditions() - 1; position >= 0; position--){
            if (this.isConditionUiComplete(position)) {
                if (lastUiCompletePosition === -1) {
                    lastUiCompletePosition = position;
                    updatedLastUiCompletePosition = position;
                }
            } else {
                const shouldRemovePositionAtEnd = position >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(position - 1);
                const positionBeforeLastUiCompletePosition = position < lastUiCompletePosition;
                if (shouldRemovePositionAtEnd || positionBeforeLastUiCompletePosition) {
                    this.removeConditionsAndOperators(position, 1);
                    conditionsRemoved = true;
                    if (positionBeforeLastUiCompletePosition) updatedLastUiCompletePosition--;
                }
            }
        }
        let shouldUpdateConditionStatusesAndValues = false;
        if (this.getNumConditions() < this.numAlwaysVisibleConditions) {
            this.createMissingConditionsAndOperators();
            shouldUpdateConditionStatusesAndValues = true;
        }
        if (this.shouldAddNewConditionAtEnd(updatedLastUiCompletePosition === this.getNumConditions() - 1)) {
            this.createJoinOperatorPanel();
            this.createOption();
            shouldUpdateConditionStatusesAndValues = true;
        }
        if (shouldUpdateConditionStatusesAndValues) this.updateConditionStatusesAndValues(updatedLastUiCompletePosition, joinOperator);
        if (conditionsRemoved) this.updateJoinOperatorsDisabled();
        this.lastUiCompletePosition = updatedLastUiCompletePosition;
    }
    getPlaceholderText(defaultPlaceholder, position) {
        let placeholder = this.translate(defaultPlaceholder);
        if ($7b57b57eaf5a9648$var$_isFunction(this.filterPlaceholder)) {
            const filterPlaceholderFn = this.filterPlaceholder;
            const filterOptionKey = this.eTypes[position].getValue();
            const filterOption = this.translate(filterOptionKey);
            placeholder = filterPlaceholderFn({
                filterOptionKey: filterOptionKey,
                filterOption: filterOption,
                placeholder: placeholder
            });
        } else if (typeof this.filterPlaceholder === "string") placeholder = this.filterPlaceholder;
        return placeholder;
    }
    // allow sub-classes to reset HTML placeholders after UI update.
    resetPlaceholder() {
        const globalTranslate = this.localeService.getLocaleTextFunc();
        this.forEachInput((element, index, position, numberOfInputs)=>{
            if (!(element instanceof $7b57b57eaf5a9648$export$9671f513d4aa42e3)) return;
            const placeholder = index === 0 && numberOfInputs > 1 ? "inRangeStart" : index === 0 ? "filterOoo" : "inRangeEnd";
            const ariaLabel = index === 0 && numberOfInputs > 1 ? globalTranslate("ariaFilterFromValue", "Filter from value") : index === 0 ? globalTranslate("ariaFilterValue", "Filter Value") : globalTranslate("ariaFilterToValue", "Filter to Value");
            element.setInputPlaceholder(this.getPlaceholderText(placeholder, position));
            element.setInputAriaLabel(ariaLabel);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setElementValue(element, value, fromFloatingFilter) {
        if (element instanceof $7b57b57eaf5a9648$export$9671f513d4aa42e3) element.setValue(value != null ? String(value) : null, true);
    }
    setElementDisplayed(element, displayed) {
        if (element instanceof $7b57b57eaf5a9648$export$16fa2f45be04daa8) $7b57b57eaf5a9648$export$9405f1cbb4e2383f(element.getGui(), displayed);
    }
    setElementDisabled(element, disabled) {
        if (element instanceof $7b57b57eaf5a9648$export$16fa2f45be04daa8) $7b57b57eaf5a9648$export$b6b4f08392e9bfaf(element.getGui(), disabled);
    }
    attachElementOnChange(element, listener) {
        if (element instanceof $7b57b57eaf5a9648$export$9671f513d4aa42e3) element.onValueChange(listener);
    }
    forEachInput(cb) {
        this.getConditionTypes().forEach((type, position)=>{
            this.forEachPositionTypeInput(position, type, cb);
        });
    }
    forEachPositionInput(position, cb) {
        const type = this.getConditionType(position);
        this.forEachPositionTypeInput(position, type, cb);
    }
    forEachPositionTypeInput(position, type, cb) {
        const numberOfInputs = this.getNumberOfInputs(type);
        const inputs = this.getInputs(position);
        for(let index = 0; index < inputs.length; index++){
            const input = inputs[index];
            if (input != null) cb(input, index, position, numberOfInputs);
        }
    }
    isConditionDisabled(position, lastUiCompletePosition) {
        if (this.isReadOnly()) return true;
        if (position === 0) return false;
        return position > lastUiCompletePosition + 1;
    }
    isConditionBodyVisible(position) {
        const type = this.getConditionType(position);
        const numberOfInputs = this.getNumberOfInputs(type);
        return numberOfInputs > 0;
    }
    // returns true if the UI represents a working filter, eg all parts are filled out.
    // eg if text filter and textfield blank then returns false.
    isConditionUiComplete(position) {
        if (position >= this.getNumConditions()) return false;
        const type = this.getConditionType(position);
        if (type === "empty") return false;
        if (this.getValues(position).some((v)=>v == null)) return false;
        return true;
    }
    getNumConditions() {
        return this.eTypes.length;
    }
    getUiCompleteConditions() {
        const conditions = [];
        for(let position = 0; position < this.getNumConditions(); position++)if (this.isConditionUiComplete(position)) conditions.push(this.createCondition(position));
        return conditions;
    }
    createMissingConditionsAndOperators() {
        if (this.isReadOnly()) return;
        for(let i = this.getNumConditions(); i < this.numAlwaysVisibleConditions; i++){
            this.createJoinOperatorPanel();
            this.createOption();
        }
    }
    resetUiToDefaults(silent) {
        this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions);
        this.eTypes.forEach((eType)=>this.resetType(eType));
        this.eJoinOperatorsAnd.forEach((eJoinOperatorAnd, index)=>this.resetJoinOperatorAnd(eJoinOperatorAnd, index, this.joinOperatorId + index));
        this.eJoinOperatorsOr.forEach((eJoinOperatorOr, index)=>this.resetJoinOperatorOr(eJoinOperatorOr, index, this.joinOperatorId + index));
        this.joinOperatorId++;
        this.forEachInput((element)=>this.resetInput(element));
        this.resetPlaceholder();
        this.createMissingConditionsAndOperators();
        this.lastUiCompletePosition = null;
        if (!silent) this.onUiChanged();
        return $7b57b57eaf5a9648$export$30ec7836a4847721.resolve();
    }
    resetType(eType) {
        const translate = this.localeService.getLocaleTextFunc();
        const filteringLabel = translate("ariaFilteringOperator", "Filtering operator");
        eType.setValue(this.optionsFactory.getDefaultOption(), true).setAriaLabel(filteringLabel).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
    }
    resetJoinOperatorAnd(eJoinOperatorAnd, index, uniqueGroupId) {
        this.resetJoinOperator(eJoinOperatorAnd, index, this.isDefaultOperator("AND"), this.translate("andCondition"), uniqueGroupId);
    }
    resetJoinOperatorOr(eJoinOperatorOr, index, uniqueGroupId) {
        this.resetJoinOperator(eJoinOperatorOr, index, this.isDefaultOperator("OR"), this.translate("orCondition"), uniqueGroupId);
    }
    resetJoinOperator(eJoinOperator, index, value, label, uniqueGroupId) {
        this.updateJoinOperatorDisabled(eJoinOperator.setValue(value, true).setName(`ag-simple-filter-and-or-${this.getCompId()}-${uniqueGroupId}`).setLabel(label), index);
    }
    updateJoinOperatorsDisabled() {
        this.eJoinOperatorsAnd.forEach((eJoinOperator, index)=>this.updateJoinOperatorDisabled(eJoinOperator, index));
        this.eJoinOperatorsOr.forEach((eJoinOperator, index)=>this.updateJoinOperatorDisabled(eJoinOperator, index));
    }
    updateJoinOperatorDisabled(eJoinOperator, index) {
        eJoinOperator.setDisabled(this.isReadOnly() || index > 0);
    }
    resetInput(element) {
        this.setElementValue(element, null);
        this.setElementDisabled(element, this.isReadOnly());
    }
    // puts model values into the UI
    setConditionIntoUi(model, position) {
        const values = this.mapValuesFromModel(model);
        this.forEachInput((element, index, elPosition)=>{
            if (elPosition !== position) return;
            this.setElementValue(element, values[index] != null ? values[index] : null);
        });
    }
    // after floating filter changes, this sets the 'value' section. this is implemented by the base class
    // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
    setValueFromFloatingFilter(value) {
        this.forEachInput((element, index, position)=>{
            this.setElementValue(element, index === 0 && position === 0 ? value : null, true);
        });
    }
    isDefaultOperator(operator) {
        return operator === this.defaultJoinOperator;
    }
    addChangedListeners(eType, position) {
        if (this.isReadOnly()) return;
        eType.onValueChange(this.listener);
        this.forEachPositionInput(position, (element)=>{
            this.attachElementOnChange(element, this.listener);
        });
    }
    /** returns true if the row passes the said condition */ individualConditionPasses(params, filterModel) {
        const cellValue = this.getCellValue(params.node);
        const values = this.mapValuesFromModel(filterModel);
        const customFilterOption = this.optionsFactory.getCustomOption(filterModel.type);
        const customFilterResult = this.evaluateCustomFilter(customFilterOption, values, cellValue);
        if (customFilterResult != null) return customFilterResult;
        if (cellValue == null) return this.evaluateNullValue(filterModel.type);
        return this.evaluateNonNullValue(values, cellValue, filterModel, params);
    }
    evaluateCustomFilter(customFilterOption, values, cellValue) {
        if (customFilterOption == null) return;
        const { predicate: predicate  } = customFilterOption;
        if (predicate != null && !values.some((v)=>v == null)) return predicate(values, cellValue);
        return;
    }
    isBlank(cellValue) {
        return cellValue == null || typeof cellValue === "string" && cellValue.trim().length === 0;
    }
    hasInvalidInputs() {
        return false;
    }
};
// community-modules/core/src/filter/provided/scalarFilter.ts
var $7b57b57eaf5a9648$export$804d9bd153e864e6 = class extends $7b57b57eaf5a9648$export$f5377e6e4a0f88ed {
    setParams(params) {
        super.setParams(params);
        this.scalarFilterParams = params;
    }
    evaluateNullValue(filterType) {
        switch(filterType){
            case "equals":
            case "notEqual":
                if (this.scalarFilterParams.includeBlanksInEquals) return true;
                break;
            case "greaterThan":
            case "greaterThanOrEqual":
                if (this.scalarFilterParams.includeBlanksInGreaterThan) return true;
                break;
            case "lessThan":
            case "lessThanOrEqual":
                if (this.scalarFilterParams.includeBlanksInLessThan) return true;
                break;
            case "inRange":
                if (this.scalarFilterParams.includeBlanksInRange) return true;
                break;
            case "blank":
                return true;
            case "notBlank":
                return false;
        }
        return false;
    }
    evaluateNonNullValue(values, cellValue, filterModel) {
        const comparator = this.comparator();
        const compareResult = values[0] != null ? comparator(values[0], cellValue) : 0;
        switch(filterModel.type){
            case "equals":
                return compareResult === 0;
            case "notEqual":
                return compareResult !== 0;
            case "greaterThan":
                return compareResult > 0;
            case "greaterThanOrEqual":
                return compareResult >= 0;
            case "lessThan":
                return compareResult < 0;
            case "lessThanOrEqual":
                return compareResult <= 0;
            case "inRange":
                {
                    const compareToResult = comparator(values[1], cellValue);
                    return this.scalarFilterParams.inRangeInclusive ? compareResult >= 0 && compareToResult <= 0 : compareResult > 0 && compareToResult < 0;
                }
            case "blank":
                return this.isBlank(cellValue);
            case "notBlank":
                return !this.isBlank(cellValue);
            default:
                $7b57b57eaf5a9648$export$2cf41453020eef66('Unexpected type of filter "' + filterModel.type + '", it looks like the filter was configured with incorrect Filter Options');
                return true;
        }
    }
};
// community-modules/core/src/utils/keyboard.ts
var $7b57b57eaf5a9648$var$A_KEYCODE = 65;
var $7b57b57eaf5a9648$var$C_KEYCODE = 67;
var $7b57b57eaf5a9648$var$V_KEYCODE = 86;
var $7b57b57eaf5a9648$var$D_KEYCODE = 68;
var $7b57b57eaf5a9648$var$Z_KEYCODE = 90;
var $7b57b57eaf5a9648$var$Y_KEYCODE = 89;
function $7b57b57eaf5a9648$export$33ecd6e270298858(event) {
    if (event.altKey || event.ctrlKey || event.metaKey) return false;
    const printableCharacter = event.key.length === 1;
    return printableCharacter;
}
function $7b57b57eaf5a9648$var$_isUserSuppressingKeyboardEvent(gos, keyboardEvent, rowNode, column, editing) {
    const colDefFunc = column ? column.getColDef().suppressKeyboardEvent : void 0;
    if (!colDefFunc) return false;
    const params = gos.addGridCommonParams({
        event: keyboardEvent,
        editing: editing,
        column: column,
        node: rowNode,
        data: rowNode.data,
        colDef: column.getColDef()
    });
    if (colDefFunc) {
        const colDefFuncResult = colDefFunc(params);
        if (colDefFuncResult) return true;
    }
    return false;
}
function $7b57b57eaf5a9648$var$_isUserSuppressingHeaderKeyboardEvent(gos, keyboardEvent, headerRowIndex, column) {
    const colDef = column.getDefinition();
    const colDefFunc = colDef && colDef.suppressHeaderKeyboardEvent;
    if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(colDefFunc)) return false;
    const params = gos.addGridCommonParams({
        colDef: colDef,
        column: column,
        headerRowIndex: headerRowIndex,
        event: keyboardEvent
    });
    return !!colDefFunc(params);
}
function $7b57b57eaf5a9648$var$_normaliseQwertyAzerty(keyboardEvent) {
    const { keyCode: keyCode  } = keyboardEvent;
    let code;
    switch(keyCode){
        case $7b57b57eaf5a9648$var$A_KEYCODE:
            code = $7b57b57eaf5a9648$export$e9e0d96f49f57c33.A;
            break;
        case $7b57b57eaf5a9648$var$C_KEYCODE:
            code = $7b57b57eaf5a9648$export$e9e0d96f49f57c33.C;
            break;
        case $7b57b57eaf5a9648$var$V_KEYCODE:
            code = $7b57b57eaf5a9648$export$e9e0d96f49f57c33.V;
            break;
        case $7b57b57eaf5a9648$var$D_KEYCODE:
            code = $7b57b57eaf5a9648$export$e9e0d96f49f57c33.D;
            break;
        case $7b57b57eaf5a9648$var$Z_KEYCODE:
            code = $7b57b57eaf5a9648$export$e9e0d96f49f57c33.Z;
            break;
        case $7b57b57eaf5a9648$var$Y_KEYCODE:
            code = $7b57b57eaf5a9648$export$e9e0d96f49f57c33.Y;
            break;
        default:
            code = keyboardEvent.code;
    }
    return code;
}
function $7b57b57eaf5a9648$var$_isDeleteKey(key, alwaysReturnFalseOnBackspace = false) {
    if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DELETE) return true;
    if (!alwaysReturnFalseOnBackspace && key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.BACKSPACE) return $7b57b57eaf5a9648$var$_isMacOsUserAgent();
    return false;
}
// community-modules/core/src/widgets/agInputTextField.ts
var $7b57b57eaf5a9648$export$8c027679838afd47 = class extends $7b57b57eaf5a9648$export$9671f513d4aa42e3 {
    constructor(config, className = "ag-text-field", inputType = "text"){
        super(config, className, inputType);
    }
    postConstruct() {
        super.postConstruct();
        if (this.config.allowedCharPattern) this.preventDisallowedCharacters();
    }
    setValue(value, silent) {
        if (this.eInput.value !== value) this.eInput.value = $7b57b57eaf5a9648$export$25d27f17d3af40f7(value) ? value : "";
        return super.setValue(value, silent);
    }
    /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */ setStartValue(value) {
        this.setValue(value, true);
    }
    preventDisallowedCharacters() {
        const pattern = new RegExp(`[${this.config.allowedCharPattern}]`);
        const preventCharacters = (event)=>{
            if (!$7b57b57eaf5a9648$export$33ecd6e270298858(event)) return;
            if (event.key && !pattern.test(event.key)) event.preventDefault();
        };
        this.addManagedListeners(this.eInput, {
            keydown: preventCharacters,
            paste: (e)=>{
                const text = e.clipboardData?.getData("text");
                if (text && text.split("").some((c)=>!pattern.test(c))) e.preventDefault();
            }
        });
    }
};
var $7b57b57eaf5a9648$export$31e2985be4ee06ab = {
    selector: "AG-INPUT-TEXT-FIELD",
    component: $7b57b57eaf5a9648$export$8c027679838afd47
};
// community-modules/core/src/widgets/agInputNumberField.ts
var $7b57b57eaf5a9648$export$c8aa0be99738aee = class extends $7b57b57eaf5a9648$export$8c027679838afd47 {
    constructor(config){
        super(config, "ag-number-field", "number");
    }
    postConstruct() {
        super.postConstruct();
        this.addManagedListeners(this.eInput, {
            blur: ()=>{
                const floatedValue = parseFloat(this.eInput.value);
                const value = isNaN(floatedValue) ? "" : this.normalizeValue(floatedValue.toString());
                if (this.value !== value) this.setValue(value);
            },
            wheel: this.onWheel.bind(this)
        });
        this.eInput.step = "any";
        const { precision: precision , min: min , max: max , step: step  } = this.config;
        if (typeof precision === "number") this.setPrecision(precision);
        if (typeof min === "number") this.setMin(min);
        if (typeof max === "number") this.setMax(max);
        if (typeof step === "number") this.setStep(step);
    }
    onWheel(e) {
        if (this.gos.getActiveDomElement() === this.eInput) e.preventDefault();
    }
    normalizeValue(value) {
        if (value === "") return "";
        if (this.precision != null) value = this.adjustPrecision(value);
        const val = parseFloat(value);
        if (this.min != null && val < this.min) value = this.min.toString();
        else if (this.max != null && val > this.max) value = this.max.toString();
        return value;
    }
    adjustPrecision(value, isScientificNotation) {
        if (this.precision == null) return value;
        if (isScientificNotation) {
            const floatString = parseFloat(value).toFixed(this.precision);
            return parseFloat(floatString).toString();
        }
        const parts = String(value).split(".");
        if (parts.length > 1) {
            if (parts[1].length <= this.precision) return value;
            else if (this.precision > 0) return `${parts[0]}.${parts[1].slice(0, this.precision)}`;
        }
        return parts[0];
    }
    setMin(min) {
        if (this.min === min) return this;
        this.min = min;
        $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "min", min);
        return this;
    }
    setMax(max) {
        if (this.max === max) return this;
        this.max = max;
        $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "max", max);
        return this;
    }
    setPrecision(precision) {
        this.precision = precision;
        return this;
    }
    setStep(step) {
        if (this.step === step) return this;
        this.step = step;
        $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "step", step);
        return this;
    }
    setValue(value, silent) {
        return this.setValueOrInputValue((v)=>super.setValue(v, silent), ()=>this, value);
    }
    setStartValue(value) {
        return this.setValueOrInputValue((v)=>super.setValue(v, true), (v)=>{
            this.eInput.value = v;
        }, value);
    }
    setValueOrInputValue(setValueFunc, setInputValueOnlyFunc, value) {
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(value)) {
            let setInputValueOnly = this.isScientificNotation(value);
            if (setInputValueOnly && this.eInput.validity.valid) return setValueFunc(value);
            if (!setInputValueOnly) {
                value = this.adjustPrecision(value);
                const normalizedValue = this.normalizeValue(value);
                setInputValueOnly = value != normalizedValue;
            }
            if (setInputValueOnly) return setInputValueOnlyFunc(value);
        }
        return setValueFunc(value);
    }
    getValue() {
        if (!this.eInput.validity.valid) return void 0;
        const inputValue = this.eInput.value;
        if (this.isScientificNotation(inputValue)) return this.adjustPrecision(inputValue, true);
        return super.getValue();
    }
    isScientificNotation(value) {
        return typeof value === "string" && value.includes("e");
    }
};
var $7b57b57eaf5a9648$export$c18153c9c909b7d7 = {
    selector: "AG-INPUT-NUMBER-FIELD",
    component: $7b57b57eaf5a9648$export$c8aa0be99738aee
};
// community-modules/core/src/filter/provided/number/numberFilterConstants.ts
var $7b57b57eaf5a9648$var$DEFAULT_NUMBER_FILTER_OPTIONS = [
    "equals",
    "notEqual",
    "greaterThan",
    "greaterThanOrEqual",
    "lessThan",
    "lessThanOrEqual",
    "inRange",
    "blank",
    "notBlank"
];
// community-modules/core/src/filter/provided/simpleFilterModelFormatter.ts
var $7b57b57eaf5a9648$var$SimpleFilterModelFormatter = class {
    constructor(localeService, optionsFactory, valueFormatter){
        this.localeService = localeService;
        this.optionsFactory = optionsFactory;
        this.valueFormatter = valueFormatter;
    }
    // used by:
    // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
    // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
    getModelAsString(model) {
        if (!model) return null;
        const isCombined = model.operator != null;
        const translate = this.localeService.getLocaleTextFunc();
        if (isCombined) {
            const combinedModel = model;
            const conditions = combinedModel.conditions ?? [];
            const customOptions = conditions.map((condition)=>this.getModelAsString(condition));
            const joinOperatorTranslateKey = combinedModel.operator === "AND" ? "andCondition" : "orCondition";
            return customOptions.join(` ${translate(joinOperatorTranslateKey, $7b57b57eaf5a9648$var$FILTER_LOCALE_TEXT[joinOperatorTranslateKey])} `);
        } else if (model.type === "blank" || model.type === "notBlank") return translate(model.type, model.type);
        else {
            const condition = model;
            const customOption = this.optionsFactory.getCustomOption(condition.type);
            const { displayKey: displayKey , displayName: displayName , numberOfInputs: numberOfInputs  } = customOption || {};
            if (displayKey && displayName && numberOfInputs === 0) {
                translate(displayKey, displayName);
                return displayName;
            }
            return this.conditionToString(condition, customOption);
        }
    }
    updateParams(params) {
        this.optionsFactory = params.optionsFactory;
    }
    formatValue(value) {
        return this.valueFormatter ? this.valueFormatter(value ?? null) ?? "" : String(value);
    }
};
// community-modules/core/src/filter/provided/number/numberFilterModelFormatter.ts
var $7b57b57eaf5a9648$var$NumberFilterModelFormatter = class extends $7b57b57eaf5a9648$var$SimpleFilterModelFormatter {
    conditionToString(condition, options) {
        const { numberOfInputs: numberOfInputs  } = options || {};
        const isRange = condition.type == "inRange" || numberOfInputs === 2;
        if (isRange) return `${this.formatValue(condition.filter)}-${this.formatValue(condition.filterTo)}`;
        if (condition.filter != null) return this.formatValue(condition.filter);
        return `${condition.type}`;
    }
};
// community-modules/core/src/filter/provided/number/numberFilterUtils.ts
function $7b57b57eaf5a9648$var$getAllowedCharPattern(filterParams) {
    const { allowedCharPattern: allowedCharPattern  } = filterParams ?? {};
    return allowedCharPattern ?? null;
}
// community-modules/core/src/filter/provided/number/numberFilter.ts
var $7b57b57eaf5a9648$export$db99a591a1ce9821 = class extends $7b57b57eaf5a9648$export$804d9bd153e864e6 {
    constructor(){
        super("numberFilter");
        this.eValuesFrom = [];
        this.eValuesTo = [];
    }
    refresh(params) {
        if (this.numberFilterParams.allowedCharPattern !== params.allowedCharPattern) return false;
        return super.refresh(params);
    }
    mapValuesFromModel(filterModel) {
        const { filter: filter , filterTo: filterTo , type: type  } = filterModel || {};
        return [
            this.processValue(filter),
            this.processValue(filterTo)
        ].slice(0, this.getNumberOfInputs(type));
    }
    getDefaultDebounceMs() {
        return 500;
    }
    comparator() {
        return (left, right)=>{
            if (left === right) return 0;
            return left < right ? 1 : -1;
        };
    }
    setParams(params) {
        this.numberFilterParams = params;
        super.setParams(params);
        this.filterModelFormatter = new $7b57b57eaf5a9648$var$NumberFilterModelFormatter(this.localeService, this.optionsFactory, this.numberFilterParams.numberFormatter);
    }
    getDefaultFilterOptions() {
        return $7b57b57eaf5a9648$var$DEFAULT_NUMBER_FILTER_OPTIONS;
    }
    setElementValue(element, value, fromFloatingFilter) {
        const valueToSet = !fromFloatingFilter && this.numberFilterParams.numberFormatter ? this.numberFilterParams.numberFormatter(value ?? null) : value;
        super.setElementValue(element, valueToSet);
    }
    createValueElement() {
        const allowedCharPattern = $7b57b57eaf5a9648$var$getAllowedCharPattern(this.numberFilterParams);
        const eCondition = document.createElement("div");
        eCondition.classList.add("ag-filter-body");
        $7b57b57eaf5a9648$export$f8d01fa01787902(eCondition, "presentation");
        this.createFromToElement(eCondition, this.eValuesFrom, "from", allowedCharPattern);
        this.createFromToElement(eCondition, this.eValuesTo, "to", allowedCharPattern);
        return eCondition;
    }
    createFromToElement(eCondition, eValues, fromTo, allowedCharPattern) {
        const eValue = this.createManagedBean(allowedCharPattern ? new $7b57b57eaf5a9648$export$8c027679838afd47({
            allowedCharPattern: allowedCharPattern
        }) : new $7b57b57eaf5a9648$export$c8aa0be99738aee());
        eValue.addCssClass(`ag-filter-${fromTo}`);
        eValue.addCssClass("ag-filter-filter");
        eValues.push(eValue);
        eCondition.appendChild(eValue.getGui());
    }
    removeValueElements(startPosition, deleteCount) {
        this.removeComponents(this.eValuesFrom, startPosition, deleteCount);
        this.removeComponents(this.eValuesTo, startPosition, deleteCount);
    }
    getValues(position) {
        const result = [];
        this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs)=>{
            if (index < numberOfInputs) result.push(this.processValue(this.stringToFloat(element.getValue())));
        });
        return result;
    }
    areSimpleModelsEqual(aSimple, bSimple) {
        return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
    }
    getFilterType() {
        return "number";
    }
    processValue(value) {
        if (value == null) return null;
        return isNaN(value) ? null : value;
    }
    stringToFloat(value) {
        if (typeof value === "number") return value;
        let filterText = $7b57b57eaf5a9648$export$4978424c4f7b5fc0(value);
        if (filterText != null && filterText.trim() === "") filterText = null;
        if (this.numberFilterParams.numberParser) return this.numberFilterParams.numberParser(filterText);
        return filterText == null || filterText.trim() === "-" ? null : parseFloat(filterText);
    }
    createCondition(position) {
        const type = this.getConditionType(position);
        const model = {
            filterType: this.getFilterType(),
            type: type
        };
        const values = this.getValues(position);
        if (values.length > 0) model.filter = values[0];
        if (values.length > 1) model.filterTo = values[1];
        return model;
    }
    getInputs(position) {
        if (position >= this.eValuesFrom.length) return [
            null,
            null
        ];
        return [
            this.eValuesFrom[position],
            this.eValuesTo[position]
        ];
    }
    getModelAsString(model) {
        return this.filterModelFormatter.getModelAsString(model) ?? "";
    }
    hasInvalidInputs() {
        let invalidInputs = false;
        this.forEachInput((element)=>{
            if (!element.getInputElement().validity.valid) {
                invalidInputs = true;
                return;
            }
        });
        return invalidInputs;
    }
};
// community-modules/core/src/filter/provided/text/textFilterConstants.ts
var $7b57b57eaf5a9648$var$DEFAULT_TEXT_FILTER_OPTIONS = [
    "contains",
    "notContains",
    "equals",
    "notEqual",
    "startsWith",
    "endsWith",
    "blank",
    "notBlank"
];
// community-modules/core/src/filter/provided/text/textFilterModelFormatter.ts
var $7b57b57eaf5a9648$var$TextFilterModelFormatter = class extends $7b57b57eaf5a9648$var$SimpleFilterModelFormatter {
    conditionToString(condition, options) {
        const { numberOfInputs: numberOfInputs  } = options || {};
        const isRange = condition.type == "inRange" || numberOfInputs === 2;
        if (isRange) return `${condition.filter}-${condition.filterTo}`;
        if (condition.filter != null) return `${condition.filter}`;
        return `${condition.type}`;
    }
};
// community-modules/core/src/filter/provided/text/textFilterUtils.ts
function $7b57b57eaf5a9648$var$trimInputForFilter(value) {
    const trimmedInput = value && value.trim();
    return trimmedInput === "" ? value : trimmedInput;
}
// community-modules/core/src/filter/provided/text/textFilter.ts
var $7b57b57eaf5a9648$export$bf4978b2dd458630 = class extends $7b57b57eaf5a9648$export$f5377e6e4a0f88ed {
    constructor(){
        super("textFilter");
        this.defaultFormatter = (from)=>from;
        this.defaultLowercaseFormatter = (from)=>from == null ? null : from.toString().toLowerCase();
        this.defaultMatcher = ({ filterOption: filterOption , value: value , filterText: filterText  })=>{
            if (filterText == null) return false;
            switch(filterOption){
                case "contains":
                    return value.indexOf(filterText) >= 0;
                case "notContains":
                    return value.indexOf(filterText) < 0;
                case "equals":
                    return value === filterText;
                case "notEqual":
                    return value != filterText;
                case "startsWith":
                    return value.indexOf(filterText) === 0;
                case "endsWith":
                    {
                        const index = value.lastIndexOf(filterText);
                        return index >= 0 && index === value.length - filterText.length;
                    }
                default:
                    return false;
            }
        };
        this.eValuesFrom = [];
        this.eValuesTo = [];
    }
    getDefaultDebounceMs() {
        return 500;
    }
    setParams(params) {
        this.textFilterParams = params;
        super.setParams(params);
        this.matcher = this.getTextMatcher();
        this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? this.defaultFormatter : this.defaultLowercaseFormatter);
        this.filterModelFormatter = new $7b57b57eaf5a9648$var$TextFilterModelFormatter(this.localeService, this.optionsFactory);
    }
    getTextMatcher() {
        const legacyComparator = this.textFilterParams.textCustomComparator;
        if (legacyComparator) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("textCustomComparator is deprecated, use textMatcher instead.");
            return ({ filterOption: filterOption , value: value , filterText: filterText  })=>legacyComparator(filterOption, value, filterText);
        }
        return this.textFilterParams.textMatcher || this.defaultMatcher;
    }
    createCondition(position) {
        const type = this.getConditionType(position);
        const model = {
            filterType: this.getFilterType(),
            type: type
        };
        const values = this.getValuesWithSideEffects(position, true);
        if (values.length > 0) model.filter = values[0];
        if (values.length > 1) model.filterTo = values[1];
        return model;
    }
    getFilterType() {
        return "text";
    }
    areSimpleModelsEqual(aSimple, bSimple) {
        return aSimple.filter === bSimple.filter && aSimple.filterTo === bSimple.filterTo && aSimple.type === bSimple.type;
    }
    getInputs(position) {
        if (position >= this.eValuesFrom.length) return [
            null,
            null
        ];
        return [
            this.eValuesFrom[position],
            this.eValuesTo[position]
        ];
    }
    getValues(position) {
        return this.getValuesWithSideEffects(position, false);
    }
    getValuesWithSideEffects(position, applySideEffects) {
        const result = [];
        this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs)=>{
            if (index < numberOfInputs) {
                let value = $7b57b57eaf5a9648$export$4978424c4f7b5fc0(element.getValue());
                if (applySideEffects && this.textFilterParams.trimInput) {
                    value = $7b57b57eaf5a9648$var$trimInputForFilter(value) ?? null;
                    element.setValue(value, true);
                }
                result.push(value);
            }
        });
        return result;
    }
    getDefaultFilterOptions() {
        return $7b57b57eaf5a9648$var$DEFAULT_TEXT_FILTER_OPTIONS;
    }
    createValueElement() {
        const eCondition = document.createElement("div");
        eCondition.classList.add("ag-filter-body");
        $7b57b57eaf5a9648$export$f8d01fa01787902(eCondition, "presentation");
        this.createFromToElement(eCondition, this.eValuesFrom, "from");
        this.createFromToElement(eCondition, this.eValuesTo, "to");
        return eCondition;
    }
    createFromToElement(eCondition, eValues, fromTo) {
        const eValue = this.createManagedBean(new $7b57b57eaf5a9648$export$8c027679838afd47());
        eValue.addCssClass(`ag-filter-${fromTo}`);
        eValue.addCssClass("ag-filter-filter");
        eValues.push(eValue);
        eCondition.appendChild(eValue.getGui());
    }
    removeValueElements(startPosition, deleteCount) {
        this.removeComponents(this.eValuesFrom, startPosition, deleteCount);
        this.removeComponents(this.eValuesTo, startPosition, deleteCount);
    }
    mapValuesFromModel(filterModel) {
        const { filter: filter , filterTo: filterTo , type: type  } = filterModel || {};
        return [
            filter || null,
            filterTo || null
        ].slice(0, this.getNumberOfInputs(type));
    }
    evaluateNullValue(filterType) {
        const filterTypesAllowNulls = [
            "notEqual",
            "notContains",
            "blank"
        ];
        return filterType ? filterTypesAllowNulls.indexOf(filterType) >= 0 : false;
    }
    evaluateNonNullValue(values, cellValue, filterModel, params) {
        const formattedValues = values.map((v)=>this.formatter(v)) || [];
        const cellValueFormatted = this.formatter(cellValue);
        const { api: api , colDef: colDef , column: column , context: context , textFormatter: textFormatter  } = this.textFilterParams;
        if (filterModel.type === "blank") return this.isBlank(cellValue);
        else if (filterModel.type === "notBlank") return !this.isBlank(cellValue);
        const matcherParams = {
            api: api,
            colDef: colDef,
            column: column,
            context: context,
            node: params.node,
            data: params.data,
            filterOption: filterModel.type,
            value: cellValueFormatted,
            textFormatter: textFormatter
        };
        return formattedValues.some((v)=>this.matcher({
                ...matcherParams,
                filterText: v
            }));
    }
    getModelAsString(model) {
        return this.filterModelFormatter.getModelAsString(model) ?? "";
    }
};
// community-modules/core/src/utils/number.ts
function $7b57b57eaf5a9648$var$toNumber(value) {
    if (typeof value === "number") return value;
    if (typeof value === "string") {
        const parsed = parseInt(value);
        if (isNaN(parsed)) return void 0;
        return parsed;
    }
    return void 0;
}
function $7b57b57eaf5a9648$var$toConstrainedNum(min, max = Number.MAX_VALUE) {
    return (value)=>{
        const num = $7b57b57eaf5a9648$var$toNumber(value);
        if (num == null || num < min || num > max) return void 0;
        return num;
    };
}
function $7b57b57eaf5a9648$var$_padStartWidthZeros(value, totalStringSize) {
    return value.toString().padStart(totalStringSize, "0");
}
function $7b57b57eaf5a9648$var$_createArrayOfNumbers(first, last) {
    const result = [];
    for(let i = first; i <= last; i++)result.push(i);
    return result;
}
function $7b57b57eaf5a9648$export$98a83e77b1f9f086(value, thousandSeparator, decimalSeparator) {
    if (typeof value !== "number") return "";
    return $7b57b57eaf5a9648$export$c8980add4a69422e(Math.round(value * 100) / 100, thousandSeparator, decimalSeparator);
}
function $7b57b57eaf5a9648$export$c8980add4a69422e(value, thousandSeparator, decimalSeparator) {
    if (typeof value !== "number") return "";
    return value.toString().replace(".", decimalSeparator).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${thousandSeparator}`);
}
// community-modules/core/src/utils/date.ts
function $7b57b57eaf5a9648$export$3d7fedfb21962874(date, includeTime = true, separator = "-") {
    if (!date) return null;
    let serialised = [
        date.getFullYear(),
        date.getMonth() + 1,
        date.getDate()
    ].map((part)=>$7b57b57eaf5a9648$var$_padStartWidthZeros(part, 2)).join(separator);
    if (includeTime) serialised += " " + [
        date.getHours(),
        date.getMinutes(),
        date.getSeconds()
    ].map((part)=>$7b57b57eaf5a9648$var$_padStartWidthZeros(part, 2)).join(":");
    return serialised;
}
var $7b57b57eaf5a9648$var$calculateOrdinal = (value)=>{
    if (value > 3 && value < 21) return "th";
    const remainder = value % 10;
    switch(remainder){
        case 1:
            return "st";
        case 2:
            return "nd";
        case 3:
            return "rd";
    }
    return "th";
};
function $7b57b57eaf5a9648$var$_dateToFormattedString(date, format = "YYYY-MM-DD") {
    const fullYear = $7b57b57eaf5a9648$var$_padStartWidthZeros(date.getFullYear(), 4);
    const months = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ];
    const days = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ];
    const replace = {
        YYYY: ()=>fullYear.slice(fullYear.length - 4, fullYear.length),
        YY: ()=>fullYear.slice(fullYear.length - 2, fullYear.length),
        Y: ()=>`${date.getFullYear()}`,
        MMMM: ()=>months[date.getMonth()],
        MMM: ()=>months[date.getMonth()].slice(0, 3),
        MM: ()=>$7b57b57eaf5a9648$var$_padStartWidthZeros(date.getMonth() + 1, 2),
        Mo: ()=>`${date.getMonth() + 1}${$7b57b57eaf5a9648$var$calculateOrdinal(date.getMonth() + 1)}`,
        M: ()=>`${date.getMonth() + 1}`,
        Do: ()=>`${date.getDate()}${$7b57b57eaf5a9648$var$calculateOrdinal(date.getDate())}`,
        DD: ()=>$7b57b57eaf5a9648$var$_padStartWidthZeros(date.getDate(), 2),
        D: ()=>`${date.getDate()}`,
        dddd: ()=>days[date.getDay()],
        ddd: ()=>days[date.getDay()].slice(0, 3),
        dd: ()=>days[date.getDay()].slice(0, 2),
        do: ()=>`${date.getDay()}${$7b57b57eaf5a9648$var$calculateOrdinal(date.getDay())}`,
        d: ()=>`${date.getDay()}`
    };
    const regexp = new RegExp(Object.keys(replace).join("|"), "g");
    return format.replace(regexp, (match)=>{
        if (match in replace) return replace[match]();
        return match;
    });
}
function $7b57b57eaf5a9648$export$26ded2d88c01b527(value) {
    if (!value) return null;
    const [dateStr, timeStr] = value.split(" ");
    if (!dateStr) return null;
    const fields = dateStr.split("-").map((f)=>parseInt(f, 10));
    if (fields.filter((f)=>!isNaN(f)).length !== 3) return null;
    const [year, month, day] = fields;
    const date = new Date(year, month - 1, day);
    if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) return null;
    if (!timeStr || timeStr === "00:00:00") return date;
    const [hours, minutes, seconds] = timeStr.split(":").map((part)=>parseInt(part, 10));
    if (hours >= 0 && hours < 24) date.setHours(hours);
    if (minutes >= 0 && minutes < 60) date.setMinutes(minutes);
    if (seconds >= 0 && seconds < 60) date.setSeconds(seconds);
    return date;
}
// community-modules/core/src/filter/provided/date/dateCompWrapper.ts
var $7b57b57eaf5a9648$var$DateCompWrapper = class {
    constructor(context, userComponentFactory, dateComponentParams, eParent, onReady){
        this.alive = true;
        this.context = context;
        this.eParent = eParent;
        const compDetails = userComponentFactory.getDateCompDetails(dateComponentParams);
        const promise = compDetails.newAgStackInstance();
        promise.then((dateComp)=>{
            if (!this.alive) {
                context.destroyBean(dateComp);
                return;
            }
            this.dateComp = dateComp;
            if (!dateComp) return;
            eParent.appendChild(dateComp.getGui());
            if (dateComp.afterGuiAttached) dateComp.afterGuiAttached();
            if (this.tempValue) dateComp.setDate(this.tempValue);
            if (this.disabled != null) this.setDateCompDisabled(this.disabled);
            onReady?.(this);
        });
    }
    destroy() {
        this.alive = false;
        this.dateComp = this.context.destroyBean(this.dateComp);
    }
    getDate() {
        return this.dateComp ? this.dateComp.getDate() : this.tempValue;
    }
    setDate(value) {
        if (this.dateComp) this.dateComp.setDate(value);
        else this.tempValue = value;
    }
    setDisabled(disabled) {
        if (this.dateComp) this.setDateCompDisabled(disabled);
        else this.disabled = disabled;
    }
    setDisplayed(displayed) {
        $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eParent, displayed);
    }
    setInputPlaceholder(placeholder) {
        if (this.dateComp && this.dateComp.setInputPlaceholder) this.dateComp.setInputPlaceholder(placeholder);
    }
    setInputAriaLabel(label) {
        if (this.dateComp && this.dateComp.setInputAriaLabel) this.dateComp.setInputAriaLabel(label);
    }
    afterGuiAttached(params) {
        if (this.dateComp && typeof this.dateComp.afterGuiAttached === "function") this.dateComp.afterGuiAttached(params);
    }
    updateParams(params) {
        let hasRefreshed = false;
        if (this.dateComp?.refresh && typeof this.dateComp.refresh === "function") {
            const result = this.dateComp.refresh(params);
            if (result !== null) hasRefreshed = true;
        }
        if (!hasRefreshed && this.dateComp?.onParamsUpdated && typeof this.dateComp.onParamsUpdated === "function") {
            const result = this.dateComp.onParamsUpdated(params);
            if (result !== null) $7b57b57eaf5a9648$export$2cf41453020eef66(`Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.`);
        }
    }
    setDateCompDisabled(disabled) {
        if (this.dateComp == null) return;
        if (this.dateComp.setDisabled == null) return;
        this.dateComp.setDisabled(disabled);
    }
};
// community-modules/core/src/filter/provided/date/dateFilterConstants.ts
var $7b57b57eaf5a9648$var$DEFAULT_DATE_FILTER_OPTIONS = [
    "equals",
    "notEqual",
    "lessThan",
    "greaterThan",
    "inRange",
    "blank",
    "notBlank"
];
// community-modules/core/src/filter/provided/date/dateFilterModelFormatter.ts
var $7b57b57eaf5a9648$var$DateFilterModelFormatter = class extends $7b57b57eaf5a9648$var$SimpleFilterModelFormatter {
    constructor(dateFilterParams, localeService, optionsFactory){
        super(localeService, optionsFactory);
        this.dateFilterParams = dateFilterParams;
    }
    conditionToString(condition, options) {
        const { type: type  } = condition;
        const { numberOfInputs: numberOfInputs  } = options || {};
        const isRange = type == "inRange" || numberOfInputs === 2;
        const dateFrom = $7b57b57eaf5a9648$export$26ded2d88c01b527(condition.dateFrom);
        const dateTo = $7b57b57eaf5a9648$export$26ded2d88c01b527(condition.dateTo);
        const format = this.dateFilterParams.inRangeFloatingFilterDateFormat;
        if (isRange) {
            const formattedFrom = dateFrom !== null ? $7b57b57eaf5a9648$var$_dateToFormattedString(dateFrom, format) : "null";
            const formattedTo = dateTo !== null ? $7b57b57eaf5a9648$var$_dateToFormattedString(dateTo, format) : "null";
            return `${formattedFrom}-${formattedTo}`;
        }
        if (dateFrom != null) return $7b57b57eaf5a9648$var$_dateToFormattedString(dateFrom, format);
        return `${type}`;
    }
    updateParams(params) {
        super.updateParams(params);
        this.dateFilterParams = params.dateFilterParams;
    }
};
// community-modules/core/src/filter/provided/date/dateFilter.ts
var $7b57b57eaf5a9648$var$DEFAULT_MIN_YEAR = 1e3;
var $7b57b57eaf5a9648$var$DEFAULT_MAX_YEAR = Infinity;
var $7b57b57eaf5a9648$export$45c1765a9388d778 = class extends $7b57b57eaf5a9648$export$804d9bd153e864e6 {
    constructor(){
        super("dateFilter");
        this.eConditionPanelsFrom = [];
        this.eConditionPanelsTo = [];
        this.dateConditionFromComps = [];
        this.dateConditionToComps = [];
        this.minValidYear = $7b57b57eaf5a9648$var$DEFAULT_MIN_YEAR;
        this.maxValidYear = $7b57b57eaf5a9648$var$DEFAULT_MAX_YEAR;
        this.minValidDate = null;
        this.maxValidDate = null;
    }
    wireBeans(beans) {
        super.wireBeans(beans);
        this.context = beans.context;
        this.userComponentFactory = beans.userComponentFactory;
    }
    afterGuiAttached(params) {
        super.afterGuiAttached(params);
        this.dateConditionFromComps[0].afterGuiAttached(params);
    }
    mapValuesFromModel(filterModel) {
        const { dateFrom: dateFrom , dateTo: dateTo , type: type  } = filterModel || {};
        return [
            dateFrom && $7b57b57eaf5a9648$export$26ded2d88c01b527(dateFrom) || null,
            dateTo && $7b57b57eaf5a9648$export$26ded2d88c01b527(dateTo) || null
        ].slice(0, this.getNumberOfInputs(type));
    }
    comparator() {
        return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
    }
    defaultComparator(filterDate, cellValue) {
        const cellAsDate = cellValue;
        if (cellValue == null || cellAsDate < filterDate) return -1;
        if (cellAsDate > filterDate) return 1;
        return 0;
    }
    setParams(params) {
        this.dateFilterParams = params;
        super.setParams(params);
        const yearParser = (param, fallback)=>{
            if (params[param] != null) {
                if (!isNaN(params[param])) return params[param] == null ? fallback : Number(params[param]);
                else $7b57b57eaf5a9648$export$2cf41453020eef66(`DateFilter ${param} is not a number`);
            }
            return fallback;
        };
        this.minValidYear = yearParser("minValidYear", $7b57b57eaf5a9648$var$DEFAULT_MIN_YEAR);
        this.maxValidYear = yearParser("maxValidYear", $7b57b57eaf5a9648$var$DEFAULT_MAX_YEAR);
        if (this.minValidYear > this.maxValidYear) $7b57b57eaf5a9648$export$2cf41453020eef66(`DateFilter minValidYear should be <= maxValidYear`);
        if (params.minValidDate) this.minValidDate = params.minValidDate instanceof Date ? params.minValidDate : $7b57b57eaf5a9648$export$26ded2d88c01b527(params.minValidDate);
        else this.minValidDate = null;
        if (params.maxValidDate) this.maxValidDate = params.maxValidDate instanceof Date ? params.maxValidDate : $7b57b57eaf5a9648$export$26ded2d88c01b527(params.maxValidDate);
        else this.maxValidDate = null;
        if (this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate) $7b57b57eaf5a9648$export$2cf41453020eef66(`DateFilter minValidDate should be <= maxValidDate`);
        this.filterModelFormatter = new $7b57b57eaf5a9648$var$DateFilterModelFormatter(this.dateFilterParams, this.localeService, this.optionsFactory);
    }
    createDateCompWrapper(element) {
        const dateCompWrapper = new $7b57b57eaf5a9648$var$DateCompWrapper(this.context, this.userComponentFactory, {
            onDateChanged: ()=>this.onUiChanged(),
            filterParams: this.dateFilterParams
        }, element);
        this.addDestroyFunc(()=>dateCompWrapper.destroy());
        return dateCompWrapper;
    }
    setElementValue(element, value) {
        element.setDate(value);
    }
    setElementDisplayed(element, displayed) {
        element.setDisplayed(displayed);
    }
    setElementDisabled(element, disabled) {
        element.setDisabled(disabled);
    }
    getDefaultFilterOptions() {
        return $7b57b57eaf5a9648$var$DEFAULT_DATE_FILTER_OPTIONS;
    }
    createValueElement() {
        const eDocument = this.gos.getDocument();
        const eCondition = eDocument.createElement("div");
        eCondition.classList.add("ag-filter-body");
        this.createFromToElement(eCondition, this.eConditionPanelsFrom, this.dateConditionFromComps, "from");
        this.createFromToElement(eCondition, this.eConditionPanelsTo, this.dateConditionToComps, "to");
        return eCondition;
    }
    createFromToElement(eCondition, eConditionPanels, dateConditionComps, fromTo) {
        const eDocument = this.gos.getDocument();
        const eConditionPanel = eDocument.createElement("div");
        eConditionPanel.classList.add(`ag-filter-${fromTo}`);
        eConditionPanel.classList.add(`ag-filter-date-${fromTo}`);
        eConditionPanels.push(eConditionPanel);
        eCondition.appendChild(eConditionPanel);
        dateConditionComps.push(this.createDateCompWrapper(eConditionPanel));
    }
    removeValueElements(startPosition, deleteCount) {
        this.removeDateComps(this.dateConditionFromComps, startPosition, deleteCount);
        this.removeDateComps(this.dateConditionToComps, startPosition, deleteCount);
        this.removeItems(this.eConditionPanelsFrom, startPosition, deleteCount);
        this.removeItems(this.eConditionPanelsTo, startPosition, deleteCount);
    }
    removeDateComps(components, startPosition, deleteCount) {
        const removedComponents = this.removeItems(components, startPosition, deleteCount);
        removedComponents.forEach((comp)=>comp.destroy());
    }
    isValidDateValue(value) {
        if (value === null) return false;
        if (this.minValidDate) {
            if (value < this.minValidDate) return false;
        } else {
            if (value.getUTCFullYear() < this.minValidYear) return false;
        }
        if (this.maxValidDate) {
            if (value > this.maxValidDate) return false;
        } else {
            if (value.getUTCFullYear() > this.maxValidYear) return false;
        }
        return true;
    }
    isConditionUiComplete(position) {
        if (!super.isConditionUiComplete(position)) return false;
        let valid = true;
        this.forEachInput((element, index, elPosition, numberOfInputs)=>{
            if (elPosition !== position || !valid || index >= numberOfInputs) return;
            valid = valid && this.isValidDateValue(element.getDate());
        });
        return valid;
    }
    areSimpleModelsEqual(aSimple, bSimple) {
        return aSimple.dateFrom === bSimple.dateFrom && aSimple.dateTo === bSimple.dateTo && aSimple.type === bSimple.type;
    }
    getFilterType() {
        return "date";
    }
    createCondition(position) {
        const type = this.getConditionType(position);
        const model = {};
        const values = this.getValues(position);
        if (values.length > 0) model.dateFrom = $7b57b57eaf5a9648$export$3d7fedfb21962874(values[0]);
        if (values.length > 1) model.dateTo = $7b57b57eaf5a9648$export$3d7fedfb21962874(values[1]);
        return {
            dateFrom: null,
            dateTo: null,
            filterType: this.getFilterType(),
            type: type,
            ...model
        };
    }
    resetPlaceholder() {
        const globalTranslate = this.localeService.getLocaleTextFunc();
        const placeholder = this.translate("dateFormatOoo");
        const ariaLabel = globalTranslate("ariaFilterValue", "Filter Value");
        this.forEachInput((element)=>{
            element.setInputPlaceholder(placeholder);
            element.setInputAriaLabel(ariaLabel);
        });
    }
    getInputs(position) {
        if (position >= this.dateConditionFromComps.length) return [
            null,
            null
        ];
        return [
            this.dateConditionFromComps[position],
            this.dateConditionToComps[position]
        ];
    }
    getValues(position) {
        const result = [];
        this.forEachPositionInput(position, (element, index, _elPosition, numberOfInputs)=>{
            if (index < numberOfInputs) result.push(element.getDate());
        });
        return result;
    }
    translate(key) {
        if (key === "lessThan") return super.translate("before");
        if (key === "greaterThan") return super.translate("after");
        return super.translate(key);
    }
    getModelAsString(model) {
        return this.filterModelFormatter.getModelAsString(model) ?? "";
    }
};
// community-modules/core/src/rendering/features/setLeftFeature.ts
var $7b57b57eaf5a9648$export$84c1fb51ab89c7b5 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(columnOrGroup, eCell, beans, colsSpanning){
        super();
        this.columnOrGroup = columnOrGroup;
        this.columnOrGroup = columnOrGroup;
        this.eCell = eCell;
        this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell;
        this.colsSpanning = colsSpanning;
        this.beans = beans;
    }
    setColsSpanning(colsSpanning) {
        this.colsSpanning = colsSpanning;
        this.onLeftChanged();
    }
    getColumnOrGroup() {
        if (this.beans.gos.get("enableRtl") && this.colsSpanning) return $7b57b57eaf5a9648$export$236389741107357f(this.colsSpanning);
        return this.columnOrGroup;
    }
    postConstruct() {
        const onLeftChanged = this.onLeftChanged.bind(this);
        this.addManagedListeners(this.columnOrGroup, {
            leftChanged: onLeftChanged
        });
        this.setLeftFirstTime();
        this.addManagedEventListeners({
            displayedColumnsWidthChanged: onLeftChanged
        });
        this.addManagedPropertyListener("domLayout", onLeftChanged);
    }
    setLeftFirstTime() {
        const suppressMoveAnimation = this.beans.gos.get("suppressColumnMoveAnimation");
        const oldLeftExists = $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.columnOrGroup.getOldLeft());
        const animateColumnMove = this.beans.columnAnimationService.isActive() && oldLeftExists && !suppressMoveAnimation;
        if (animateColumnMove) this.animateInLeft();
        else this.onLeftChanged();
    }
    animateInLeft() {
        const colOrGroup = this.getColumnOrGroup();
        const left = colOrGroup.getLeft();
        const oldLeft = colOrGroup.getOldLeft();
        const oldActualLeft = this.modifyLeftForPrintLayout(colOrGroup, oldLeft);
        const actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
        this.setLeft(oldActualLeft);
        this.actualLeft = actualLeft;
        this.beans.columnAnimationService.executeNextVMTurn(()=>{
            if (this.actualLeft === actualLeft) this.setLeft(actualLeft);
        });
    }
    onLeftChanged() {
        const colOrGroup = this.getColumnOrGroup();
        const left = colOrGroup.getLeft();
        this.actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
        this.setLeft(this.actualLeft);
    }
    modifyLeftForPrintLayout(colOrGroup, leftPosition) {
        const printLayout = this.beans.gos.isDomLayout("print");
        if (!printLayout) return leftPosition;
        if (colOrGroup.getPinned() === "left") return leftPosition;
        const leftWidth = this.beans.visibleColsService.getColsLeftWidth();
        if (colOrGroup.getPinned() === "right") {
            const bodyWidth = this.beans.visibleColsService.getBodyContainerWidth();
            return leftWidth + bodyWidth + leftPosition;
        }
        return leftWidth + leftPosition;
    }
    setLeft(value) {
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(value)) this.eCell.style.left = `${value}px`;
        if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(this.columnOrGroup)) {
            const children = this.columnOrGroup.getLeafColumns();
            if (!children.length) return;
            if (children.length > 1) $7b57b57eaf5a9648$export$371d80f0281454ce(this.ariaEl, children.length);
        }
    }
};
// community-modules/core/src/headerRendering/cells/cssClassApplier.ts
var $7b57b57eaf5a9648$var$CSS_FIRST_COLUMN = "ag-column-first";
var $7b57b57eaf5a9648$var$CSS_LAST_COLUMN = "ag-column-last";
function $7b57b57eaf5a9648$export$9ba3bd48c77c5e8a(abstractColDef, gos, column, columnGroup) {
    if ($7b57b57eaf5a9648$export$672d9e47bc342bac(abstractColDef)) return [];
    return $7b57b57eaf5a9648$var$getColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, gos, column, columnGroup);
}
function $7b57b57eaf5a9648$export$1784132bab54c462(abstractColDef, gos, column, columnGroup) {
    if ($7b57b57eaf5a9648$export$672d9e47bc342bac(abstractColDef)) return [];
    return $7b57b57eaf5a9648$var$getColumnClassesFromCollDef(abstractColDef.toolPanelClass, abstractColDef, gos, column, columnGroup);
}
function $7b57b57eaf5a9648$var$refreshFirstAndLastStyles(comp, column, presentedColsService) {
    comp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_FIRST_COLUMN, presentedColsService.isColAtEdge(column, "first"));
    comp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_LAST_COLUMN, presentedColsService.isColAtEdge(column, "last"));
}
function $7b57b57eaf5a9648$var$getClassParams(abstractColDef, gos, column, columnGroup) {
    return gos.addGridCommonParams({
        // bad naming, as colDef here can be a group or a column,
        // however most people won't appreciate the difference,
        // so keeping it as colDef to avoid confusion.
        colDef: abstractColDef,
        column: column,
        columnGroup: columnGroup
    });
}
function $7b57b57eaf5a9648$var$getColumnClassesFromCollDef(classesOrFunc, abstractColDef, gos, column, columnGroup) {
    if ($7b57b57eaf5a9648$export$672d9e47bc342bac(classesOrFunc)) return [];
    let classToUse;
    if (typeof classesOrFunc === "function") {
        const params = $7b57b57eaf5a9648$var$getClassParams(abstractColDef, gos, column, columnGroup);
        classToUse = classesOrFunc(params);
    } else classToUse = classesOrFunc;
    if (typeof classToUse === "string") return [
        classToUse
    ];
    if (Array.isArray(classToUse)) return [
        ...classToUse
    ];
    return [];
}
// community-modules/core/src/headerRendering/cells/abstractCell/abstractHeaderCellCtrl.ts
var $7b57b57eaf5a9648$var$instanceIdSequence2 = 0;
var $7b57b57eaf5a9648$var$_AbstractHeaderCellCtrl = class _AbstractHeaderCellCtrl extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(columnGroupChild, beans, parentRowCtrl){
        super();
        this.resizeToggleTimeout = 0;
        this.resizeMultiplier = 1;
        this.resizeFeature = null;
        this.lastFocusEvent = null;
        this.dragSource = null;
        this.columnGroupChild = columnGroupChild;
        this.parentRowCtrl = parentRowCtrl;
        this.beans = beans;
        this.instanceId = columnGroupChild.getUniqueId() + "-" + $7b57b57eaf5a9648$var$instanceIdSequence2++;
    }
    wireBeans(beans) {
        this.pinnedWidthService = beans.pinnedWidthService;
        this.focusService = beans.focusService;
        this.userComponentFactory = beans.userComponentFactory;
        this.ctrlsService = beans.ctrlsService;
        this.dragAndDropService = beans.dragAndDropService;
        this.menuService = beans.menuService;
    }
    postConstruct() {
        this.addManagedPropertyListeners([
            "suppressHeaderFocus"
        ], ()=>this.refreshTabIndex());
    }
    shouldStopEventPropagation(e) {
        const { headerRowIndex: headerRowIndex , column: column  } = this.focusService.getFocusedHeader();
        return $7b57b57eaf5a9648$var$_isUserSuppressingHeaderKeyboardEvent(this.gos, e, headerRowIndex, column);
    }
    getWrapperHasFocus() {
        const activeEl = this.gos.getActiveDomElement();
        return activeEl === this.eGui;
    }
    setGui(eGui) {
        this.eGui = eGui;
        this.addDomData();
        this.addManagedListeners(this.beans.eventService, {
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
        });
        this.addManagedElementListeners(this.eGui, {
            focus: this.onGuiFocus.bind(this)
        });
        this.onDisplayedColumnsChanged();
        this.refreshTabIndex();
    }
    onGuiFocus() {
        const event = {
            type: "headerFocused",
            column: this.column
        };
        this.eventService.dispatchEvent(event);
    }
    onDisplayedColumnsChanged() {
        if (!this.comp || !this.column) return;
        this.refreshFirstAndLastStyles();
        this.refreshAriaColIndex();
    }
    refreshFirstAndLastStyles() {
        const { comp: comp , column: column , beans: beans  } = this;
        $7b57b57eaf5a9648$var$refreshFirstAndLastStyles(comp, column, beans.visibleColsService);
    }
    refreshAriaColIndex() {
        const { beans: beans , column: column  } = this;
        const colIdx = beans.visibleColsService.getAriaColIndex(column);
        $7b57b57eaf5a9648$export$84b73ecd0b234e89(this.eGui, colIdx);
    }
    addResizeAndMoveKeyboardListeners() {
        if (!this.resizeFeature) return;
        this.addManagedListeners(this.eGui, {
            keydown: this.onGuiKeyDown.bind(this),
            keyup: this.onGuiKeyUp.bind(this)
        });
    }
    refreshTabIndex() {
        const suppressHeaderFocus = this.gos.get("suppressHeaderFocus");
        if (suppressHeaderFocus) this.eGui.removeAttribute("tabindex");
        else this.eGui.setAttribute("tabindex", "-1");
    }
    onGuiKeyDown(e) {
        const activeEl = this.gos.getActiveDomElement();
        const isLeftOrRight = e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT || e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT;
        if (this.isResizing) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }
        if (// if elements within the header are focused, we don't process the event
        activeEl !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
        !e.shiftKey && !e.altKey) return;
        if (this.isResizing || isLeftOrRight) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }
        if (!isLeftOrRight) return;
        const isLeft = e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT !== this.gos.get("enableRtl");
        const direction = $7b57b57eaf5a9648$export$2e679088785045c[isLeft ? "Left" : "Right"];
        if (e.altKey) {
            this.isResizing = true;
            this.resizeMultiplier += 1;
            const diff = this.getViewportAdjustedResizeDiff(e);
            this.resizeHeader(diff, e.shiftKey);
            this.resizeFeature?.toggleColumnResizing(true);
        } else this.moveHeader(direction);
    }
    getViewportAdjustedResizeDiff(e) {
        let diff = this.getResizeDiff(e);
        const pinned = this.column.getPinned();
        if (pinned) {
            const leftWidth = this.pinnedWidthService.getPinnedLeftWidth();
            const rightWidth = this.pinnedWidthService.getPinnedRightWidth();
            const bodyWidth = $7b57b57eaf5a9648$export$cc615e4191ec3e0c(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
            if (leftWidth + rightWidth + diff > bodyWidth) {
                if (bodyWidth > leftWidth + rightWidth) diff = bodyWidth - leftWidth - rightWidth;
                else return 0;
            }
        }
        return diff;
    }
    getResizeDiff(e) {
        let isLeft = e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT !== this.gos.get("enableRtl");
        const pinned = this.column.getPinned();
        const isRtl = this.gos.get("enableRtl");
        if (pinned) {
            if (isRtl !== (pinned === "right")) isLeft = !isLeft;
        }
        return (isLeft ? -1 : 1) * this.resizeMultiplier;
    }
    onGuiKeyUp() {
        if (!this.isResizing) return;
        if (this.resizeToggleTimeout) {
            window.clearTimeout(this.resizeToggleTimeout);
            this.resizeToggleTimeout = 0;
        }
        this.isResizing = false;
        this.resizeMultiplier = 1;
        this.resizeToggleTimeout = window.setTimeout(()=>{
            this.resizeFeature?.toggleColumnResizing(false);
        }, 150);
    }
    handleKeyDown(e) {
        const wrapperHasFocus = this.getWrapperHasFocus();
        switch(e.key){
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_DOWN:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_HOME:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_END:
                if (wrapperHasFocus) e.preventDefault();
        }
    }
    addDomData() {
        const key = _AbstractHeaderCellCtrl.DOM_DATA_KEY_HEADER_CTRL;
        this.gos.setDomData(this.eGui, key, this);
        this.addDestroyFunc(()=>this.gos.setDomData(this.eGui, key, null));
    }
    getGui() {
        return this.eGui;
    }
    focus(event) {
        if (!this.eGui) return false;
        this.lastFocusEvent = event || null;
        this.eGui.focus();
        return true;
    }
    getRowIndex() {
        return this.parentRowCtrl.getRowIndex();
    }
    getParentRowCtrl() {
        return this.parentRowCtrl;
    }
    getPinned() {
        return this.parentRowCtrl.getPinned();
    }
    getInstanceId() {
        return this.instanceId;
    }
    getColumnGroupChild() {
        return this.columnGroupChild;
    }
    removeDragSource() {
        if (this.dragSource) {
            this.dragAndDropService.removeDragSource(this.dragSource);
            this.dragSource = null;
        }
    }
    handleContextMenuMouseEvent(mouseEvent, touchEvent, column) {
        const event = mouseEvent ?? touchEvent;
        if (this.gos.get("preventDefaultOnContextMenu")) event.preventDefault();
        const columnToUse = $7b57b57eaf5a9648$export$891484e65a02ec71(column) ? column : void 0;
        if (this.menuService.isHeaderContextMenuEnabled(columnToUse)) this.menuService.showHeaderContextMenu(columnToUse, mouseEvent, touchEvent);
        this.dispatchColumnMouseEvent("columnHeaderContextMenu", column);
    }
    dispatchColumnMouseEvent(eventType, column) {
        const event = {
            type: eventType,
            column: column
        };
        this.eventService.dispatchEvent(event);
    }
    destroy() {
        super.destroy();
        this.removeDragSource();
        this.comp = null;
        this.column = null;
        this.resizeFeature = null;
        this.lastFocusEvent = null;
        this.columnGroupChild = null;
        this.parentRowCtrl = null;
        this.eGui = null;
    }
};
$7b57b57eaf5a9648$var$_AbstractHeaderCellCtrl.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
var $7b57b57eaf5a9648$export$879ff627d5a4d5c = $7b57b57eaf5a9648$var$_AbstractHeaderCellCtrl;
// community-modules/core/src/headerRendering/cells/hoverFeature.ts
var $7b57b57eaf5a9648$var$HoverFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.columnHoverService = beans.columnHoverService;
    }
    constructor(columns, element){
        super();
        this.columns = columns;
        this.element = element;
    }
    postConstruct() {
        if (this.gos.get("columnHoverHighlight")) this.addMouseHoverListeners();
    }
    addMouseHoverListeners() {
        this.addManagedListeners(this.element, {
            mouseout: this.onMouseOut.bind(this),
            mouseover: this.onMouseOver.bind(this)
        });
    }
    onMouseOut() {
        this.columnHoverService.clearMouseOver();
    }
    onMouseOver() {
        this.columnHoverService.setMouseOver(this.columns);
    }
};
// community-modules/core/src/headerRendering/cells/floatingFilter/headerFilterCellCtrl.ts
var $7b57b57eaf5a9648$export$65579fe86751e033 = class extends $7b57b57eaf5a9648$export$879ff627d5a4d5c {
    constructor(column, beans, parentRowCtrl){
        super(column, beans, parentRowCtrl);
        this.iconCreated = false;
        this.column = column;
    }
    setComp(comp, eGui, eButtonShowMainFilter, eFloatingFilterBody) {
        this.comp = comp;
        this.eButtonShowMainFilter = eButtonShowMainFilter;
        this.eFloatingFilterBody = eFloatingFilterBody;
        this.setGui(eGui);
        this.setupActive();
        this.setupWidth();
        this.setupLeft();
        this.setupHover();
        this.setupFocus();
        this.setupAria();
        this.setupFilterButton();
        this.setupUserComp();
        this.setupSyncWithFilter();
        this.setupUi();
        this.addManagedElementListeners(this.eButtonShowMainFilter, {
            click: this.showParentFilter.bind(this)
        });
        this.setupFilterChangedListener();
        this.addManagedListeners(this.column, {
            colDefChanged: this.onColDefChanged.bind(this)
        });
    }
    // empty abstract method
    resizeHeader() {}
    // empty abstract method
    moveHeader() {}
    setupActive() {
        const colDef = this.column.getColDef();
        const filterExists = !!colDef.filter;
        const floatingFilterExists = !!colDef.floatingFilter;
        this.active = filterExists && floatingFilterExists;
    }
    setupUi() {
        this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active);
        this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton);
        this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton);
        if (!this.active || this.iconCreated) return;
        const eMenuIcon = $7b57b57eaf5a9648$export$d8feba07bf373edb("filter", this.gos, this.column);
        if (eMenuIcon) {
            this.iconCreated = true;
            this.eButtonShowMainFilter.appendChild(eMenuIcon);
        }
    }
    setupFocus() {
        this.createManagedBean(new $7b57b57eaf5a9648$export$5510e53ed3962582(this.eGui, {
            shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this)
        }));
    }
    setupAria() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        $7b57b57eaf5a9648$export$e81cb0dd07f289f6(this.eButtonShowMainFilter, localeTextFunc("ariaFilterMenuOpen", "Open Filter Menu"));
    }
    onTabKeyDown(e) {
        const activeEl = this.gos.getActiveDomElement();
        const wrapperHasFocus = activeEl === this.eGui;
        if (wrapperHasFocus) return;
        const nextFocusableEl = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
        if (nextFocusableEl) {
            this.beans.headerNavigationService.scrollToColumn(this.column);
            e.preventDefault();
            nextFocusableEl.focus();
            return;
        }
        const nextFocusableColumn = this.findNextColumnWithFloatingFilter(e.shiftKey);
        if (!nextFocusableColumn) return;
        if (this.focusService.focusHeaderPosition({
            headerPosition: {
                headerRowIndex: this.getParentRowCtrl().getRowIndex(),
                column: nextFocusableColumn
            },
            event: e
        })) e.preventDefault();
    }
    findNextColumnWithFloatingFilter(backwards) {
        const presentedColsService = this.beans.visibleColsService;
        let nextCol = this.column;
        do {
            nextCol = backwards ? presentedColsService.getColBefore(nextCol) : presentedColsService.getColAfter(nextCol);
            if (!nextCol) break;
        }while (!nextCol.getColDef().filter || !nextCol.getColDef().floatingFilter);
        return nextCol;
    }
    handleKeyDown(e) {
        super.handleKeyDown(e);
        const wrapperHasFocus = this.getWrapperHasFocus();
        switch(e.key){
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
                if (!wrapperHasFocus) e.preventDefault();
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT:
                if (wrapperHasFocus) return;
                e.stopPropagation();
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER:
                if (wrapperHasFocus) {
                    if (this.focusService.focusInto(this.eGui)) e.preventDefault();
                }
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ESCAPE:
                if (!wrapperHasFocus) this.eGui.focus();
        }
    }
    onFocusIn(e) {
        const isRelatedWithin = this.eGui.contains(e.relatedTarget);
        if (isRelatedWithin) return;
        const notFromHeaderWrapper = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter");
        const fromWithinHeader = !!e.relatedTarget && $7b57b57eaf5a9648$var$_isElementChildOfClass(e.relatedTarget, "ag-floating-filter");
        if (notFromHeaderWrapper && fromWithinHeader && e.target === this.eGui) {
            const lastFocusEvent = this.lastFocusEvent;
            const fromTab = !!(lastFocusEvent && lastFocusEvent.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.TAB);
            if (lastFocusEvent && fromTab) {
                const shouldFocusLast = lastFocusEvent.shiftKey;
                this.focusService.focusInto(this.eGui, shouldFocusLast);
            }
        }
        const rowIndex = this.getRowIndex();
        this.beans.focusService.setFocusedHeader(rowIndex, this.column);
    }
    setupHover() {
        this.createManagedBean(new $7b57b57eaf5a9648$var$HoverFeature([
            this.column
        ], this.eGui));
        const listener = ()=>{
            if (!this.gos.get("columnHoverHighlight")) return;
            const hovered = this.beans.columnHoverService.isHovered(this.column);
            this.comp.addOrRemoveCssClass("ag-column-hover", hovered);
        };
        this.addManagedEventListeners({
            columnHoverChanged: listener
        });
        listener();
    }
    setupLeft() {
        const setLeftFeature = new $7b57b57eaf5a9648$export$84c1fb51ab89c7b5(this.column, this.eGui, this.beans);
        this.createManagedBean(setLeftFeature);
    }
    setupFilterButton() {
        this.suppressFilterButton = !this.menuService.isFloatingFilterButtonEnabled(this.column);
        this.highlightFilterButtonWhenActive = !this.menuService.isLegacyMenuEnabled();
    }
    setupUserComp() {
        if (!this.active) return;
        const compDetails = this.beans.filterManager?.getFloatingFilterCompDetails(this.column, ()=>this.showParentFilter());
        if (compDetails) this.setCompDetails(compDetails);
    }
    setCompDetails(compDetails) {
        this.userCompDetails = compDetails;
        this.comp.setCompDetails(compDetails);
    }
    showParentFilter() {
        const eventSource = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
        this.menuService.showFilterMenu({
            column: this.column,
            buttonElement: eventSource,
            containerType: "floatingFilter",
            positionBy: "button"
        });
    }
    setupSyncWithFilter() {
        if (!this.active) return;
        const { filterManager: filterManager  } = this.beans;
        const syncWithFilter = (event)=>{
            if (event?.source === "filterDestroyed" && !this.isAlive()) return;
            const compPromise = this.comp.getFloatingFilterComp();
            if (!compPromise) return;
            compPromise.then((comp)=>{
                if (comp) {
                    const parentModel = filterManager?.getCurrentFloatingFilterParentModel(this.column);
                    const filterChangedEvent = event ? {
                        // event can have additional params like `afterDataChange` which need to be passed through
                        ...event,
                        columns: event.columns ?? [],
                        source: event.source === "api" ? "api" : "columnFilter"
                    } : null;
                    comp.onParentModelChanged(parentModel, filterChangedEvent);
                }
            });
        };
        [this.destroySyncListener] = this.addManagedListeners(this.column, {
            filterChanged: syncWithFilter
        });
        if (filterManager?.isFilterActive(this.column)) syncWithFilter(null);
    }
    setupWidth() {
        const listener = ()=>{
            const width = `${this.column.getActualWidth()}px`;
            this.comp.setWidth(width);
        };
        this.addManagedListeners(this.column, {
            widthChanged: listener
        });
        listener();
    }
    setupFilterChangedListener() {
        if (this.active) {
            [this.destroyFilterChangedListener] = this.addManagedListeners(this.column, {
                filterChanged: this.updateFilterButton.bind(this)
            });
            this.updateFilterButton();
        }
    }
    updateFilterButton() {
        if (!this.suppressFilterButton && this.comp) {
            const isFilterAllowed = !!this.beans.filterManager?.isFilterAllowed(this.column);
            this.comp.setButtonWrapperDisplayed(isFilterAllowed);
            if (this.highlightFilterButtonWhenActive && isFilterAllowed) this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
        }
    }
    onColDefChanged() {
        const wasActive = this.active;
        this.setupActive();
        const becomeActive = !wasActive && this.active;
        if (wasActive && !this.active) {
            this.destroySyncListener();
            this.destroyFilterChangedListener();
        }
        const newCompDetails = this.active ? this.beans.filterManager?.getFloatingFilterCompDetails(this.column, ()=>this.showParentFilter()) : null;
        const compPromise = this.comp.getFloatingFilterComp();
        if (!compPromise || !newCompDetails) this.updateCompDetails(newCompDetails, becomeActive);
        else compPromise.then((compInstance)=>{
            if (!compInstance || this.beans.filterManager?.areFilterCompsDifferent(this.userCompDetails ?? null, newCompDetails)) this.updateCompDetails(newCompDetails, becomeActive);
            else this.updateFloatingFilterParams(newCompDetails);
        });
    }
    updateCompDetails(compDetails, becomeActive) {
        if (!this.isAlive()) return;
        this.setCompDetails(compDetails);
        this.setupFilterButton();
        this.setupUi();
        if (becomeActive) {
            this.setupSyncWithFilter();
            this.setupFilterChangedListener();
        }
    }
    updateFloatingFilterParams(userCompDetails) {
        if (!userCompDetails) return;
        const params = userCompDetails.params;
        this.comp.getFloatingFilterComp()?.then((floatingFilter)=>{
            let hasRefreshed = false;
            if (floatingFilter?.refresh && typeof floatingFilter.refresh === "function") {
                const result = floatingFilter.refresh(params);
                if (result !== null) hasRefreshed = true;
            }
            if (!hasRefreshed && floatingFilter?.onParamsUpdated && typeof floatingFilter.onParamsUpdated === "function") {
                const result = floatingFilter.onParamsUpdated(params);
                if (result !== null) $7b57b57eaf5a9648$export$2cf41453020eef66(`Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.`);
            }
        });
    }
    destroy() {
        super.destroy();
        this.eButtonShowMainFilter = null;
        this.eFloatingFilterBody = null;
        this.userCompDetails = null;
        this.destroySyncListener = null;
        this.destroyFilterChangedListener = null;
    }
};
// community-modules/core/src/version.ts
var $7b57b57eaf5a9648$var$VERSION = "32.0.1";
// community-modules/core/src/filter/columnFilterApi.ts
function $7b57b57eaf5a9648$var$isColumnFilterPresent(beans) {
    return !!beans.filterManager?.isColumnFilterPresent() || !!beans.filterManager?.isAggregateFilterPresent();
}
function $7b57b57eaf5a9648$var$getFilterInstance(beans, key, callback) {
    return beans.filterManager?.getFilterInstance(key, callback);
}
function $7b57b57eaf5a9648$var$getColumnFilterInstance(beans, key) {
    return beans.filterManager?.getColumnFilterInstance(key) ?? Promise.resolve(void 0);
}
function $7b57b57eaf5a9648$var$destroyFilter(beans, key) {
    const column = beans.columnModel.getColDefCol(key);
    if (column) return beans.filterManager?.destroyFilter(column, "api");
}
function $7b57b57eaf5a9648$var$setFilterModel(beans, model) {
    beans.frameworkOverrides.wrapIncoming(()=>beans.filterManager?.setFilterModel(model));
}
function $7b57b57eaf5a9648$var$getFilterModel(beans) {
    return beans.filterManager?.getFilterModel() ?? {};
}
function $7b57b57eaf5a9648$var$getColumnFilterModel(beans, column) {
    return beans.filterManager?.getColumnFilterModel(column) ?? null;
}
function $7b57b57eaf5a9648$var$setColumnFilterModel(beans, column, model) {
    return beans.filterManager?.setColumnFilterModel(column, model) ?? Promise.resolve();
}
function $7b57b57eaf5a9648$var$showColumnFilter(beans, colKey) {
    const column = beans.columnModel.getCol(colKey);
    if (!column) {
        $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`column '${colKey}' not found`);
        return;
    }
    beans.menuService.showFilterMenu({
        column: column,
        containerType: "columnFilter",
        positionBy: "auto"
    });
}
// community-modules/core/src/filter/floating/floatingFilterMapper.ts
function $7b57b57eaf5a9648$export$fe1920243c0b719(frameworkOverrides, def, getFromDefault) {
    if (def == null) return null;
    let defaultFloatingFilterType = null;
    const { compName: compName , jsComp: jsComp , fwComp: fwComp  } = $7b57b57eaf5a9648$export$b32ef18681c5348a.getCompKeys(frameworkOverrides, def, $7b57b57eaf5a9648$var$FilterComponent);
    if (compName) {
        const floatingFilterTypeMap = {
            set: "agSetColumnFloatingFilter",
            agSetColumnFilter: "agSetColumnFloatingFilter",
            multi: "agMultiColumnFloatingFilter",
            agMultiColumnFilter: "agMultiColumnFloatingFilter",
            group: "agGroupColumnFloatingFilter",
            agGroupColumnFilter: "agGroupColumnFloatingFilter",
            number: "agNumberColumnFloatingFilter",
            agNumberColumnFilter: "agNumberColumnFloatingFilter",
            date: "agDateColumnFloatingFilter",
            agDateColumnFilter: "agDateColumnFloatingFilter",
            text: "agTextColumnFloatingFilter",
            agTextColumnFilter: "agTextColumnFloatingFilter"
        };
        defaultFloatingFilterType = floatingFilterTypeMap[compName];
    } else {
        const usingDefaultFilter = jsComp == null && fwComp == null && def.filter === true;
        if (usingDefaultFilter) defaultFloatingFilterType = getFromDefault();
    }
    return defaultFloatingFilterType;
}
// community-modules/core/src/filter/columnFilterService.ts
var $7b57b57eaf5a9648$var$ColumnFilterService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnFilterService";
        this.allColumnFilters = /* @__PURE__ */ new Map();
        this.allColumnListeners = /* @__PURE__ */ new Map();
        this.activeAggregateFilters = [];
        this.activeColumnFilters = [];
        // this is true when the grid is processing the filter change. this is used by the cell comps, so that they
        // don't flash when data changes due to filter changes. there is no need to flash when filter changes as the
        // user is in control, so doesn't make sense to show flashing changes. for example, go to main demo where
        // this feature is turned off (hack code to always return false for isSuppressFlashingCellsBecauseFiltering(), put in)
        // 100,000 rows and group by country. then do some filtering. all the cells flash, which is silly.
        this.processingFilterChange = false;
        // when we're waiting for cell data types to be inferred, we need to defer filter model updates
        this.filterModelUpdateQueue = [];
        this.columnFilterModelUpdateQueue = [];
    }
    wireBeans(beans) {
        this.valueService = beans.valueService;
        this.columnModel = beans.columnModel;
        this.rowModel = beans.rowModel;
        this.userComponentFactory = beans.userComponentFactory;
        this.rowRenderer = beans.rowRenderer;
        this.dataTypeService = beans.dataTypeService;
        this.filterManager = beans.filterManager;
    }
    postConstruct() {
        this.addManagedEventListeners({
            gridColumnsChanged: this.onColumnsChanged.bind(this),
            rowDataUpdated: ()=>this.onNewRowsLoaded("rowDataUpdated"),
            dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
        });
        this.initialFilterModel = {
            ...this.gos.get("initialState")?.filter?.filterModel ?? {}
        };
    }
    setFilterModel(model, source = "api") {
        if (this.dataTypeService?.isPendingInference()) {
            this.filterModelUpdateQueue.push({
                model: model,
                source: source
            });
            return;
        }
        const allPromises = [];
        const previousModel = this.getFilterModel();
        if (model) {
            const modelKeys = new Set(Object.keys(model));
            this.allColumnFilters.forEach((filterWrapper, colId)=>{
                const newModel = model[colId];
                allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, newModel));
                modelKeys.delete(colId);
            });
            modelKeys.forEach((colId)=>{
                const column = this.columnModel.getColDefCol(colId) || this.columnModel.getCol(colId);
                if (!column) {
                    $7b57b57eaf5a9648$export$2cf41453020eef66("setFilterModel() - no column found for colId: " + colId);
                    return;
                }
                if (!column.isFilterAllowed()) {
                    $7b57b57eaf5a9648$export$2cf41453020eef66("setFilterModel() - unable to fully apply model, filtering disabled for colId: " + colId);
                    return;
                }
                const filterWrapper = this.getOrCreateFilterWrapper(column);
                if (!filterWrapper) {
                    $7b57b57eaf5a9648$export$2cf41453020eef66("setFilterModel() - unable to fully apply model, unable to create filter for colId: " + colId);
                    return;
                }
                allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, model[colId]));
            });
        } else this.allColumnFilters.forEach((filterWrapper)=>{
            allPromises.push(this.setModelOnFilterWrapper(filterWrapper.filterPromise, null));
        });
        $7b57b57eaf5a9648$export$30ec7836a4847721.all(allPromises).then(()=>{
            const currentModel = this.getFilterModel();
            const columns = [];
            this.allColumnFilters.forEach((filterWrapper, colId)=>{
                const before = previousModel ? previousModel[colId] : null;
                const after = currentModel ? currentModel[colId] : null;
                if (!$7b57b57eaf5a9648$export$dbc2068cc90f5875(before, after)) columns.push(filterWrapper.column);
            });
            if (columns.length > 0) this.filterManager?.onFilterChanged({
                columns: columns,
                source: source
            });
        });
    }
    setModelOnFilterWrapper(filterPromise, newModel) {
        return new $7b57b57eaf5a9648$export$30ec7836a4847721((resolve)=>{
            filterPromise.then((filter)=>{
                if (typeof filter.setModel !== "function") {
                    $7b57b57eaf5a9648$export$2cf41453020eef66("filter missing setModel method, which is needed for setFilterModel");
                    resolve();
                }
                (filter.setModel(newModel) || $7b57b57eaf5a9648$export$30ec7836a4847721.resolve()).then(()=>resolve());
            });
        });
    }
    getFilterModel() {
        const result = {};
        this.allColumnFilters.forEach((filterWrapper, key)=>{
            const model = this.getModelFromFilterWrapper(filterWrapper);
            if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(model)) result[key] = model;
        });
        return result;
    }
    getModelFromFilterWrapper(filterWrapper) {
        const { filter: filter  } = filterWrapper;
        if (filter) {
            if (typeof filter.getModel !== "function") {
                $7b57b57eaf5a9648$export$2cf41453020eef66("filter API missing getModel method, which is needed for getFilterModel");
                return null;
            }
            return filter.getModel();
        } else return this.getModelFromInitialState(filterWrapper.column);
    }
    getModelFromInitialState(column) {
        return this.initialFilterModel[column.getColId()] ?? null;
    }
    isColumnFilterPresent() {
        return this.activeColumnFilters.length > 0;
    }
    isAggregateFilterPresent() {
        return !!this.activeAggregateFilters.length;
    }
    disableColumnFilters() {
        if (this.allColumnFilters.size) {
            this.allColumnFilters.forEach((filterWrapper)=>this.disposeFilterWrapper(filterWrapper, "advancedFilterEnabled"));
            return true;
        }
        return false;
    }
    doAggregateFiltersPass(node, filterToSkip) {
        return this.doColumnFiltersPass(node, filterToSkip, true);
    }
    updateActiveFilters() {
        const isFilterActive = (filter)=>{
            if (!filter) return false;
            if (!filter.isFilterActive) {
                $7b57b57eaf5a9648$export$2cf41453020eef66("Filter is missing isFilterActive() method");
                return false;
            }
            return filter.isFilterActive();
        };
        const groupFilterEnabled = !!this.gos.getGroupAggFiltering();
        const isAggFilter = (column)=>{
            const isSecondary = !column.isPrimary();
            if (isSecondary) return true;
            const isShowingPrimaryColumns = !this.columnModel.isPivotActive();
            const isValueActive = column.isValueActive();
            if (!isValueActive || !isShowingPrimaryColumns) return false;
            if (this.columnModel.isPivotMode()) return true;
            return groupFilterEnabled;
        };
        const activeAggregateFilters = [];
        const activeColumnFilters = [];
        return this.forEachColumnFilter((filter, filterWrapper)=>{
            const filterActive = isFilterActive(filter);
            if (filterActive) {
                if (isAggFilter(filterWrapper.column)) activeAggregateFilters.push(filter);
                else activeColumnFilters.push(filter);
            }
        }).then(()=>{
            this.activeAggregateFilters = activeAggregateFilters;
            this.activeColumnFilters = activeColumnFilters;
        });
    }
    updateFilterFlagInColumns(source, additionalEventAttributes) {
        return this.forEachColumnFilter((filter, filterWrapper)=>filterWrapper.column.setFilterActive(filter.isFilterActive(), source, additionalEventAttributes));
    }
    forEachColumnFilter(callback) {
        return $7b57b57eaf5a9648$export$30ec7836a4847721.all(Array.from(this.allColumnFilters.values()).map((filterWrapper)=>filterWrapper.filterPromise.then((filter)=>callback(filter, filterWrapper))));
    }
    doColumnFiltersPass(node, filterToSkip, targetAggregates) {
        const { data: data , aggData: aggData  } = node;
        const targetedFilters = targetAggregates ? this.activeAggregateFilters : this.activeColumnFilters;
        const targetedData = targetAggregates ? aggData : data;
        for(let i = 0; i < targetedFilters.length; i++){
            const filter = targetedFilters[i];
            if (filter == null || filter === filterToSkip) continue;
            if (typeof filter.doesFilterPass !== "function") throw new Error("Filter is missing method doesFilterPass");
            if (!filter.doesFilterPass({
                node: node,
                data: targetedData
            })) return false;
        }
        return true;
    }
    // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
    // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
    // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
    // which results in React State getting applied in the main application, triggering a useEffect() to
    // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
    // getting it's useEffect() triggered in this way.
    callOnFilterChangedOutsideRenderCycle(params) {
        const action = ()=>this.filterManager?.onFilterChanged(params);
        if (this.rowRenderer.isRefreshInProgress()) setTimeout(action, 0);
        else action();
    }
    updateBeforeFilterChanged(params = {}) {
        const { filterInstance: filterInstance , additionalEventAttributes: additionalEventAttributes  } = params;
        this.updateDependentFilters();
        return this.updateActiveFilters().then(()=>this.updateFilterFlagInColumns("filterChanged", additionalEventAttributes).then(()=>{
                this.allColumnFilters.forEach((filterWrapper)=>{
                    if (!filterWrapper.filterPromise) return;
                    filterWrapper.filterPromise.then((filter)=>{
                        if (filter && filter !== filterInstance && filter.onAnyFilterChanged) filter.onAnyFilterChanged();
                    });
                });
                this.processingFilterChange = true;
            }));
    }
    updateAfterFilterChanged() {
        this.processingFilterChange = false;
    }
    isSuppressFlashingCellsBecauseFiltering() {
        const allowShowChangeAfterFilter = this.gos.get("allowShowChangeAfterFilter") ?? false;
        return !allowShowChangeAfterFilter && this.processingFilterChange;
    }
    onNewRowsLoaded(source) {
        this.forEachColumnFilter((filter)=>{
            if (filter.onNewRowsLoaded) filter.onNewRowsLoaded();
        }).then(()=>this.updateFilterFlagInColumns(source, {
                afterDataChange: true
            })).then(()=>this.updateActiveFilters());
    }
    createValueGetter(column) {
        return ({ node: node  })=>this.valueService.getValue(column, node, true);
    }
    createGetValue(filterColumn) {
        return (rowNode, column)=>{
            const columnToUse = column ? this.columnModel.getCol(column) : filterColumn;
            return columnToUse ? this.valueService.getValue(columnToUse, rowNode, true) : void 0;
        };
    }
    isFilterActive(column) {
        const { filter: filter  } = this.cachedFilter(column) ?? {};
        if (filter) return filter.isFilterActive();
        return this.getModelFromInitialState(column) != null;
    }
    getOrCreateFilterWrapper(column) {
        if (!column.isFilterAllowed()) return null;
        let filterWrapper = this.cachedFilter(column);
        if (!filterWrapper) {
            filterWrapper = this.createFilterWrapper(column);
            this.setColumnFilterWrapper(column, filterWrapper);
        }
        return filterWrapper;
    }
    cachedFilter(column) {
        return this.allColumnFilters.get(column.getColId());
    }
    getDefaultFilter(column) {
        let defaultFilter;
        if ($7b57b57eaf5a9648$export$dc053975cc7f6c11.__isRegistered("@ag-grid-enterprise/set-filter" /* SetFilterModule */ , this.gridId)) defaultFilter = "agSetColumnFilter";
        else {
            const cellDataType = this.dataTypeService?.getBaseDataType(column);
            if (cellDataType === "number") defaultFilter = "agNumberColumnFilter";
            else if (cellDataType === "date" || cellDataType === "dateString") defaultFilter = "agDateColumnFilter";
            else defaultFilter = "agTextColumnFilter";
        }
        return defaultFilter;
    }
    getDefaultFloatingFilter(column) {
        let defaultFloatingFilterType;
        if ($7b57b57eaf5a9648$export$dc053975cc7f6c11.__isRegistered("@ag-grid-enterprise/set-filter" /* SetFilterModule */ , this.gridId)) defaultFloatingFilterType = "agSetColumnFloatingFilter";
        else {
            const cellDataType = this.dataTypeService?.getBaseDataType(column);
            if (cellDataType === "number") defaultFloatingFilterType = "agNumberColumnFloatingFilter";
            else if (cellDataType === "date" || cellDataType === "dateString") defaultFloatingFilterType = "agDateColumnFloatingFilter";
            else defaultFloatingFilterType = "agTextColumnFloatingFilter";
        }
        return defaultFloatingFilterType;
    }
    createFilterInstance(column, filterWrapper) {
        const defaultFilter = this.getDefaultFilter(column);
        const colDef = column.getColDef();
        let filterInstance;
        const params = {
            ...this.createFilterParams(column, colDef),
            filterModifiedCallback: ()=>this.filterModifiedCallbackFactory(filterInstance, column)(),
            filterChangedCallback: (additionalEventAttributes)=>this.filterChangedCallbackFactory(filterInstance, column)(additionalEventAttributes),
            doesRowPassOtherFilter: (node)=>this.filterManager ? this.filterManager.doesRowPassOtherFilters(filterInstance, node) : true
        };
        const compDetails = this.userComponentFactory.getFilterDetails(colDef, params, defaultFilter);
        if (!compDetails) return {
            filterPromise: null,
            compDetails: null
        };
        return {
            filterPromise: ()=>{
                const filterPromise = compDetails.newAgStackInstance();
                if (filterPromise != null) filterPromise.then((r)=>{
                    filterInstance = r;
                    if (filterWrapper) filterWrapper.filter = r;
                });
                return filterPromise;
            },
            compDetails: compDetails
        };
    }
    createFilterParams(column, colDef) {
        const params = this.gos.addGridCommonParams({
            column: column,
            colDef: $7b57b57eaf5a9648$export$b0cc93169835e7eb(colDef),
            rowModel: this.rowModel,
            filterChangedCallback: ()=>{},
            filterModifiedCallback: ()=>{},
            valueGetter: this.createValueGetter(column),
            getValue: this.createGetValue(column),
            doesRowPassOtherFilter: ()=>true
        });
        return params;
    }
    createFilterWrapper(column) {
        const filterWrapper = {
            column: column,
            filterPromise: null,
            compiledElement: null,
            compDetails: null
        };
        const { filterPromise: filterPromise , compDetails: compDetails  } = this.createFilterInstance(column, filterWrapper);
        filterWrapper.filterPromise = filterPromise?.() ?? null;
        filterWrapper.compDetails = compDetails;
        return filterWrapper;
    }
    onColumnsChanged() {
        const columns = [];
        this.allColumnFilters.forEach((wrapper, colId)=>{
            let currentColumn;
            if (wrapper.column.isPrimary()) currentColumn = this.columnModel.getColDefCol(colId);
            else currentColumn = this.columnModel.getCol(colId);
            if (currentColumn && currentColumn === wrapper.column) return;
            columns.push(wrapper.column);
            this.disposeFilterWrapper(wrapper, "columnChanged");
            this.disposeColumnListener(colId);
        });
        if (columns.length > 0) this.filterManager?.onFilterChanged({
            columns: columns,
            source: "api"
        });
        else this.updateDependentFilters();
    }
    updateDependentFilters() {
        const groupColumns = this.columnModel.getAutoCols();
        groupColumns?.forEach((groupColumn)=>{
            if (groupColumn.getColDef().filter === "agGroupColumnFilter") this.getOrCreateFilterWrapper(groupColumn);
        });
    }
    // for group filters, can change dynamically whether they are allowed or not
    isFilterAllowed(column) {
        const isFilterAllowed = column.isFilterAllowed();
        if (!isFilterAllowed) return false;
        const { filter: filter  } = this.allColumnFilters.get(column.getColId()) ?? {};
        if (filter) return typeof filter?.isFilterAllowed === "function" ? filter.isFilterAllowed() : true;
        return true;
    }
    getFloatingFilterCompDetails(column, showParentFilter) {
        const parentFilterInstance = (callback)=>{
            const filterComponent = this.getOrCreateFilterWrapper(column)?.filterPromise;
            if (filterComponent == null) return;
            filterComponent.then((instance)=>{
                callback($7b57b57eaf5a9648$export$213d4c63c3df47e4(instance));
            });
        };
        const colDef = column.getColDef();
        const filterParams = {
            ...this.createFilterParams(column, colDef),
            filterChangedCallback: ()=>parentFilterInstance((filterInstance)=>this.filterChangedCallbackFactory(filterInstance, column)())
        };
        const finalFilterParams = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(colDef, $7b57b57eaf5a9648$var$FilterComponent, filterParams);
        let defaultFloatingFilterType = $7b57b57eaf5a9648$export$fe1920243c0b719(this.frameworkOverrides, colDef, ()=>this.getDefaultFloatingFilter(column));
        if (defaultFloatingFilterType == null) defaultFloatingFilterType = "agReadOnlyFloatingFilter";
        const params = {
            column: column,
            filterParams: finalFilterParams,
            currentParentModel: ()=>this.getCurrentFloatingFilterParentModel(column),
            parentFilterInstance: parentFilterInstance,
            showParentFilter: showParentFilter,
            suppressFilterButton: false
        };
        return this.userComponentFactory.getFloatingFilterCompDetails(colDef, params, defaultFloatingFilterType);
    }
    getCurrentFloatingFilterParentModel(column) {
        return this.getModelFromFilterWrapper(this.cachedFilter(column) ?? {
            column: column
        });
    }
    // destroys the filter, so it no longer takes part
    destroyFilter(column, source = "api") {
        const colId = column.getColId();
        const filterWrapper = this.allColumnFilters.get(colId);
        this.disposeColumnListener(colId);
        delete this.initialFilterModel[colId];
        if (filterWrapper) {
            this.disposeFilterWrapper(filterWrapper, source);
            this.filterManager?.onFilterChanged({
                columns: [
                    column
                ],
                source: "api"
            });
        }
    }
    disposeColumnListener(colId) {
        const columnListener = this.allColumnListeners.get(colId);
        if (columnListener) {
            this.allColumnListeners.delete(colId);
            columnListener();
        }
    }
    disposeFilterWrapper(filterWrapper, source) {
        filterWrapper.filterPromise.then((filter)=>{
            this.destroyBean(filter);
            filterWrapper.column.setFilterActive(false, "filterDestroyed");
            this.allColumnFilters.delete(filterWrapper.column.getColId());
            const event = {
                type: "filterDestroyed",
                source: source,
                column: filterWrapper.column
            };
            this.eventService.dispatchEvent(event);
        });
    }
    filterModifiedCallbackFactory(filter, column) {
        return ()=>{
            const event = {
                type: "filterModified",
                column: column,
                filterInstance: filter
            };
            this.eventService.dispatchEvent(event);
        };
    }
    filterChangedCallbackFactory(filter, column) {
        return (additionalEventAttributes)=>{
            const source = additionalEventAttributes?.source ?? "columnFilter";
            const params = {
                filter: filter,
                additionalEventAttributes: additionalEventAttributes,
                columns: [
                    column
                ],
                source: source
            };
            this.callOnFilterChangedOutsideRenderCycle(params);
        };
    }
    checkDestroyFilter(colId) {
        const filterWrapper = this.allColumnFilters.get(colId);
        if (!filterWrapper) return;
        const column = filterWrapper.column;
        const { compDetails: compDetails  } = column.isFilterAllowed() ? this.createFilterInstance(column) : {
            compDetails: null
        };
        if (this.areFilterCompsDifferent(filterWrapper.compDetails, compDetails)) {
            this.destroyFilter(column, "paramsUpdated");
            return;
        }
        const newFilterParams = column.getColDef().filterParams;
        if (!filterWrapper.filterPromise) {
            this.destroyFilter(column, "paramsUpdated");
            return;
        }
        filterWrapper.filterPromise.then((filter)=>{
            const shouldRefreshFilter = filter?.refresh ? filter.refresh({
                ...this.createFilterParams(column, column.getColDef()),
                filterModifiedCallback: this.filterModifiedCallbackFactory(filter, column),
                filterChangedCallback: this.filterChangedCallbackFactory(filter, column),
                doesRowPassOtherFilter: (node)=>this.filterManager ? this.filterManager.doesRowPassOtherFilters(filter, node) : true,
                ...newFilterParams
            }) : true;
            if (shouldRefreshFilter === false) this.destroyFilter(column, "paramsUpdated");
        });
    }
    setColumnFilterWrapper(column, filterWrapper) {
        const colId = column.getColId();
        this.allColumnFilters.set(colId, filterWrapper);
        this.allColumnListeners.set(colId, this.addManagedListeners(column, {
            colDefChanged: ()=>this.checkDestroyFilter(colId)
        })[0]);
    }
    areFilterCompsDifferent(oldCompDetails, newCompDetails) {
        if (!newCompDetails || !oldCompDetails) return true;
        const { componentClass: oldComponentClass  } = oldCompDetails;
        const { componentClass: newComponentClass  } = newCompDetails;
        const isSameComponentClass = oldComponentClass === newComponentClass || // react hooks returns new wrappers, so check nested render method
        oldComponentClass?.render && newComponentClass?.render && oldComponentClass.render === newComponentClass.render;
        return !isSameComponentClass;
    }
    hasFloatingFilters() {
        const gridColumns = this.columnModel.getCols();
        return gridColumns.some((col)=>col.getColDef().floatingFilter);
    }
    getFilterInstance(key, callback) {
        if (!callback) return void 0;
        this.getFilterInstanceImpl(key).then((filter)=>{
            const unwrapped = $7b57b57eaf5a9648$export$213d4c63c3df47e4(filter);
            callback(unwrapped);
        });
        return void 0;
    }
    getColumnFilterInstance(key) {
        return new Promise((resolve)=>{
            this.getFilterInstanceImpl(key).then((filter)=>{
                resolve($7b57b57eaf5a9648$export$213d4c63c3df47e4(filter));
            });
        });
    }
    getFilterInstanceImpl(key) {
        const column = this.columnModel.getColDefCol(key);
        if (!column) return $7b57b57eaf5a9648$export$30ec7836a4847721.resolve(void 0);
        const filterPromise = this.getOrCreateFilterWrapper(column)?.filterPromise;
        return filterPromise ?? $7b57b57eaf5a9648$export$30ec7836a4847721.resolve(null);
    }
    processFilterModelUpdateQueue() {
        this.filterModelUpdateQueue.forEach(({ model: model , source: source  })=>this.setFilterModel(model, source));
        this.filterModelUpdateQueue = [];
        this.columnFilterModelUpdateQueue.forEach(({ key: key , model: model , resolve: resolve  })=>{
            this.setColumnFilterModel(key, model).then(()=>resolve());
        });
        this.columnFilterModelUpdateQueue = [];
    }
    getColumnFilterModel(key) {
        const filterWrapper = this.getFilterWrapper(key);
        return filterWrapper ? this.getModelFromFilterWrapper(filterWrapper) : null;
    }
    setColumnFilterModel(key, model) {
        if (this.dataTypeService?.isPendingInference()) {
            let resolve = ()=>{};
            const promise = new Promise((res)=>{
                resolve = res;
            });
            this.columnFilterModelUpdateQueue.push({
                key: key,
                model: model,
                resolve: resolve
            });
            return promise;
        }
        const column = this.columnModel.getColDefCol(key);
        const filterWrapper = column ? this.getOrCreateFilterWrapper(column) : null;
        const convertPromise = (promise)=>{
            return new Promise((resolve)=>{
                promise.then((result)=>resolve(result));
            });
        };
        return filterWrapper ? convertPromise(this.setModelOnFilterWrapper(filterWrapper.filterPromise, model)) : Promise.resolve();
    }
    getFilterWrapper(key) {
        const column = this.columnModel.getColDefCol(key);
        return column ? this.cachedFilter(column) ?? null : null;
    }
    destroy() {
        super.destroy();
        this.allColumnFilters.forEach((filterWrapper)=>this.disposeFilterWrapper(filterWrapper, "gridDestroyed"));
        this.allColumnListeners.clear();
    }
};
// community-modules/core/src/filter/filterApi.ts
function $7b57b57eaf5a9648$var$isAnyFilterPresent(beans) {
    return !!beans.filterManager?.isAnyFilterPresent();
}
function $7b57b57eaf5a9648$var$onFilterChanged(beans, source = "api") {
    beans.filterManager?.onFilterChanged({
        source: source
    });
}
// community-modules/core/src/filter/floating/provided/readOnlyFloatingFilter.ts
var $7b57b57eaf5a9648$var$ReadOnlyFloatingFilter = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html */ `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`, [
            $7b57b57eaf5a9648$export$31e2985be4ee06ab
        ]);
        this.eFloatingFilterText = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    wireBeans(beans) {
        this.columnNameService = beans.columnNameService;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
    init(params) {
        this.params = params;
        const displayName = this.columnNameService.getDisplayNameForColumn(params.column, "header", true);
        const translate = this.localeService.getLocaleTextFunc();
        this.eFloatingFilterText.setDisabled(true).setInputAriaLabel(`${displayName} ${translate("ariaFilterInput", "Filter Input")}`);
    }
    onParentModelChanged(parentModel) {
        if (parentModel == null) {
            this.eFloatingFilterText.setValue("");
            return;
        }
        this.params.parentFilterInstance((filterInstance)=>{
            if (filterInstance.getModelAsString) {
                const modelAsString = filterInstance.getModelAsString(parentModel);
                this.eFloatingFilterText.setValue(modelAsString);
            }
        });
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        this.init(params);
    }
};
// community-modules/core/src/filter/floating/provided/simpleFloatingFilter.ts
var $7b57b57eaf5a9648$var$SimpleFloatingFilter = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    wireBeans(beans) {
        this.columnNameService = beans.columnNameService;
    }
    getDefaultDebounceMs() {
        return 0;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
    isEventFromFloatingFilter(event) {
        return event && event.afterFloatingFilter;
    }
    isEventFromDataChange(event) {
        return event?.afterDataChange;
    }
    getLastType() {
        return this.lastType;
    }
    isReadOnly() {
        return this.readOnly;
    }
    setLastTypeFromModel(model) {
        if (!model) {
            this.lastType = this.optionsFactory.getDefaultOption();
            return;
        }
        const isCombined = model.operator;
        let condition;
        if (isCombined) {
            const combinedModel = model;
            condition = combinedModel.conditions[0];
        } else condition = model;
        this.lastType = condition.type;
    }
    canWeEditAfterModelFromParentFilter(model) {
        if (!model) return this.isTypeEditable(this.lastType);
        const isCombined = model.operator;
        if (isCombined) return false;
        const simpleModel = model;
        return this.isTypeEditable(simpleModel.type);
    }
    init(params) {
        this.setSimpleParams(params, false);
    }
    setSimpleParams(params, update = true) {
        this.optionsFactory = new $7b57b57eaf5a9648$var$OptionsFactory();
        this.optionsFactory.init(params.filterParams, this.getDefaultFilterOptions());
        if (!update) this.lastType = this.optionsFactory.getDefaultOption();
        this.readOnly = !!params.filterParams.readOnly;
        const editable = this.isTypeEditable(this.optionsFactory.getDefaultOption());
        this.setEditable(editable);
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        this.setSimpleParams(params);
    }
    doesFilterHaveSingleInput(filterType) {
        const customFilterOption = this.optionsFactory.getCustomOption(filterType);
        const { numberOfInputs: numberOfInputs  } = customFilterOption || {};
        return numberOfInputs == null || numberOfInputs == 1;
    }
    isTypeEditable(type) {
        const uneditableTypes = [
            "inRange",
            "empty",
            "blank",
            "notBlank"
        ];
        return !!type && !this.isReadOnly() && this.doesFilterHaveSingleInput(type) && uneditableTypes.indexOf(type) < 0;
    }
    getAriaLabel(params) {
        const displayName = this.columnNameService.getDisplayNameForColumn(params.column, "header", true);
        const translate = this.localeService.getLocaleTextFunc();
        return `${displayName} ${translate("ariaFilterInput", "Filter Input")}`;
    }
};
// community-modules/core/src/filter/provided/date/dateFloatingFilter.ts
var $7b57b57eaf5a9648$var$DateFloatingFilter = class extends $7b57b57eaf5a9648$var$SimpleFloatingFilter {
    constructor(){
        super(/* html */ `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eReadOnlyText"></ag-input-text-field>
                <div data-ref="eDateWrapper" style="display: flex;"></div>
            </div>`, [
            $7b57b57eaf5a9648$export$31e2985be4ee06ab
        ]);
        this.eReadOnlyText = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eDateWrapper = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    wireBeans(beans) {
        super.wireBeans(beans);
        this.context = beans.context;
        this.userComponentFactory = beans.userComponentFactory;
    }
    getDefaultFilterOptions() {
        return $7b57b57eaf5a9648$var$DEFAULT_DATE_FILTER_OPTIONS;
    }
    init(params) {
        super.init(params);
        this.params = params;
        this.filterParams = params.filterParams;
        this.createDateComponent();
        this.filterModelFormatter = new $7b57b57eaf5a9648$var$DateFilterModelFormatter(this.filterParams, this.localeService, this.optionsFactory);
        const translate = this.localeService.getLocaleTextFunc();
        this.eReadOnlyText.setDisabled(true).setInputAriaLabel(translate("ariaDateFilterInput", "Date Filter Input"));
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        super.refresh(params);
        this.params = params;
        this.filterParams = params.filterParams;
        this.updateDateComponent();
        this.filterModelFormatter.updateParams({
            optionsFactory: this.optionsFactory,
            dateFilterParams: this.filterParams
        });
        this.updateCompOnModelChange(params.currentParentModel());
    }
    updateCompOnModelChange(model) {
        const allowEditing = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(model);
        this.setEditable(allowEditing);
        if (allowEditing) {
            if (model) {
                const dateModel = model;
                this.dateComp.setDate($7b57b57eaf5a9648$export$26ded2d88c01b527(dateModel.dateFrom));
            } else this.dateComp.setDate(null);
            this.eReadOnlyText.setValue("");
        } else {
            this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(model));
            this.dateComp.setDate(null);
        }
    }
    setEditable(editable) {
        $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eDateWrapper, editable);
        $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eReadOnlyText.getGui(), !editable);
    }
    onParentModelChanged(model, event) {
        if (this.isEventFromFloatingFilter(event) || this.isEventFromDataChange(event)) return;
        super.setLastTypeFromModel(model);
        this.updateCompOnModelChange(model);
    }
    onDateChanged() {
        const filterValueDate = this.dateComp.getDate();
        const filterValueText = $7b57b57eaf5a9648$export$3d7fedfb21962874(filterValueDate);
        this.params.parentFilterInstance((filterInstance)=>{
            if (filterInstance) {
                const date = $7b57b57eaf5a9648$export$26ded2d88c01b527(filterValueText);
                filterInstance.onFloatingFilterChanged(this.getLastType() || null, date);
            }
        });
    }
    getDateComponentParams() {
        const debounceMs = $7b57b57eaf5a9648$var$getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs());
        return {
            onDateChanged: $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.onDateChanged.bind(this), debounceMs),
            filterParams: this.params.column.getColDef().filterParams
        };
    }
    createDateComponent() {
        this.dateComp = new $7b57b57eaf5a9648$var$DateCompWrapper(this.context, this.userComponentFactory, this.getDateComponentParams(), this.eDateWrapper, (dateComp)=>{
            dateComp.setInputAriaLabel(this.getAriaLabel(this.params));
        });
        this.addDestroyFunc(()=>this.dateComp.destroy());
    }
    updateDateComponent() {
        const params = this.gos.addGridCommonParams(this.getDateComponentParams());
        this.dateComp.updateParams(params);
    }
    getFilterModelFormatter() {
        return this.filterModelFormatter;
    }
};
// community-modules/core/src/filter/provided/date/defaultDateComponent.ts
var $7b57b57eaf5a9648$var$DefaultDateComponent = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html */ `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" data-ref="eDateInput"></ag-input-text-field>
            </div>`, [
            $7b57b57eaf5a9648$export$31e2985be4ee06ab
        ]);
        this.eDateInput = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
    init(params) {
        this.params = params;
        this.setParams(params);
        const inputElement = this.eDateInput.getInputElement();
        this.addManagedListeners(inputElement, {
            // ensures that the input element is focussed when a clear button is clicked,
            // unless using safari as there is no clear button and focus does not work properly
            mouseDown: ()=>{
                if (this.eDateInput.isDisabled() || this.usingSafariDatePicker) return;
                inputElement.focus();
            },
            input: (e)=>{
                if (e.target !== this.gos.getActiveDomElement()) return;
                if (this.eDateInput.isDisabled()) return;
                this.params.onDateChanged();
            }
        });
    }
    setParams(params) {
        const inputElement = this.eDateInput.getInputElement();
        const shouldUseBrowserDatePicker = this.shouldUseBrowserDatePicker(params);
        this.usingSafariDatePicker = shouldUseBrowserDatePicker && $7b57b57eaf5a9648$var$_isBrowserSafari();
        inputElement.type = shouldUseBrowserDatePicker ? "date" : "text";
        const { minValidYear: minValidYear , maxValidYear: maxValidYear , minValidDate: minValidDate , maxValidDate: maxValidDate  } = params.filterParams || {};
        if (minValidDate && minValidYear) $7b57b57eaf5a9648$export$2cf41453020eef66("DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.");
        if (maxValidDate && maxValidYear) $7b57b57eaf5a9648$export$2cf41453020eef66("DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.");
        if (minValidDate && maxValidDate) {
            const [parsedMinValidDate, parsedMaxValidDate] = [
                minValidDate,
                maxValidDate
            ].map((v)=>v instanceof Date ? v : $7b57b57eaf5a9648$export$26ded2d88c01b527(v));
            if (parsedMinValidDate && parsedMaxValidDate && parsedMinValidDate.getTime() > parsedMaxValidDate.getTime()) $7b57b57eaf5a9648$export$2cf41453020eef66("DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.");
        }
        if (minValidDate) {
            if (minValidDate instanceof Date) inputElement.min = $7b57b57eaf5a9648$var$_dateToFormattedString(minValidDate);
            else inputElement.min = minValidDate;
        } else if (minValidYear) inputElement.min = `${minValidYear}-01-01`;
        if (maxValidDate) {
            if (maxValidDate instanceof Date) inputElement.max = $7b57b57eaf5a9648$var$_dateToFormattedString(maxValidDate);
            else inputElement.max = maxValidDate;
        } else if (maxValidYear) inputElement.max = `${maxValidYear}-12-31`;
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        this.params = params;
        this.setParams(params);
    }
    getDate() {
        return $7b57b57eaf5a9648$export$26ded2d88c01b527(this.eDateInput.getValue());
    }
    setDate(date) {
        this.eDateInput.setValue($7b57b57eaf5a9648$export$3d7fedfb21962874(date, false));
    }
    setInputPlaceholder(placeholder) {
        this.eDateInput.setInputPlaceholder(placeholder);
    }
    setInputAriaLabel(ariaLabel) {
        this.eDateInput.setAriaLabel(ariaLabel);
    }
    setDisabled(disabled) {
        this.eDateInput.setDisabled(disabled);
    }
    afterGuiAttached(params) {
        if (!params || !params.suppressFocus) this.eDateInput.getInputElement().focus();
    }
    shouldUseBrowserDatePicker(params) {
        if (params.filterParams && params.filterParams.browserDatePicker != null) return params.filterParams.browserDatePicker;
        return $7b57b57eaf5a9648$var$_isBrowserChrome() || $7b57b57eaf5a9648$var$_isBrowserFirefox() || $7b57b57eaf5a9648$var$_isBrowserSafari() && $7b57b57eaf5a9648$var$_getSafariVersion() >= 14.1;
    }
};
// community-modules/core/src/filter/floating/provided/floatingFilterTextInputService.ts
var $7b57b57eaf5a9648$var$FloatingFilterTextInputService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(params){
        super();
        this.params = params;
        this.eFloatingFilterTextInput = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.valueChangedListener = ()=>{};
    }
    setupGui(parentElement) {
        this.eFloatingFilterTextInput = this.createManagedBean(new $7b57b57eaf5a9648$export$8c027679838afd47(this.params?.config));
        const eInput = this.eFloatingFilterTextInput.getGui();
        parentElement.appendChild(eInput);
        const listener = (e)=>this.valueChangedListener(e);
        this.addManagedListeners(eInput, {
            input: listener,
            keydown: listener
        });
    }
    setEditable(editable) {
        this.eFloatingFilterTextInput.setDisabled(!editable);
    }
    setAutoComplete(autoComplete) {
        this.eFloatingFilterTextInput.setAutoComplete(autoComplete);
    }
    getValue() {
        return this.eFloatingFilterTextInput.getValue();
    }
    setValue(value, silent) {
        this.eFloatingFilterTextInput.setValue(value, silent);
    }
    setValueChangedListener(listener) {
        this.valueChangedListener = listener;
    }
    setParams(params) {
        this.setAriaLabel(params.ariaLabel);
        if (params.autoComplete !== void 0) this.setAutoComplete(params.autoComplete);
    }
    setAriaLabel(ariaLabel) {
        this.eFloatingFilterTextInput.setInputAriaLabel(ariaLabel);
    }
};
// community-modules/core/src/filter/floating/provided/textInputFloatingFilter.ts
var $7b57b57eaf5a9648$var$TextInputFloatingFilter = class extends $7b57b57eaf5a9648$var$SimpleFloatingFilter {
    constructor(){
        super(...arguments);
        this.eFloatingFilterInputContainer = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    postConstruct() {
        this.setTemplate(/* html */ `
            <div class="ag-floating-filter-input" role="presentation" data-ref="eFloatingFilterInputContainer"></div>
        `);
    }
    getDefaultDebounceMs() {
        return 500;
    }
    onParentModelChanged(model, event) {
        if (this.isEventFromFloatingFilter(event) || this.isEventFromDataChange(event)) return;
        this.setLastTypeFromModel(model);
        this.setEditable(this.canWeEditAfterModelFromParentFilter(model));
        this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(model));
    }
    init(params) {
        this.setupFloatingFilterInputService(params);
        super.init(params);
        this.setTextInputParams(params);
    }
    setupFloatingFilterInputService(params) {
        this.floatingFilterInputService = this.createFloatingFilterInputService(params);
        this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer);
    }
    setTextInputParams(params) {
        this.params = params;
        const autoComplete = params.browserAutoComplete ?? false;
        this.floatingFilterInputService.setParams({
            ariaLabel: this.getAriaLabel(params),
            autoComplete: autoComplete
        });
        this.applyActive = $7b57b57eaf5a9648$var$isUseApplyButton(this.params.filterParams);
        if (!this.isReadOnly()) {
            const debounceMs = $7b57b57eaf5a9648$var$getDebounceMs(this.params.filterParams, this.getDefaultDebounceMs());
            const toDebounce = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.syncUpWithParentFilter.bind(this), debounceMs);
            this.floatingFilterInputService.setValueChangedListener(toDebounce);
        }
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        super.refresh(params);
        this.setTextInputParams(params);
    }
    recreateFloatingFilterInputService(params) {
        const value = this.floatingFilterInputService.getValue();
        $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eFloatingFilterInputContainer);
        this.destroyBean(this.floatingFilterInputService);
        this.setupFloatingFilterInputService(params);
        this.floatingFilterInputService.setValue(value, true);
    }
    syncUpWithParentFilter(e) {
        const isEnterKey = e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER;
        if (this.applyActive && !isEnterKey) return;
        let value = this.floatingFilterInputService.getValue();
        if (this.params.filterParams.trimInput) {
            value = $7b57b57eaf5a9648$var$trimInputForFilter(value);
            this.floatingFilterInputService.setValue(value, true);
        }
        this.params.parentFilterInstance((filterInstance)=>{
            if (filterInstance) filterInstance.onFloatingFilterChanged(this.getLastType() || null, value || null);
        });
    }
    setEditable(editable) {
        this.floatingFilterInputService.setEditable(editable);
    }
};
// community-modules/core/src/filter/provided/number/numberFloatingFilter.ts
var $7b57b57eaf5a9648$var$FloatingFilterNumberInputService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.valueChangedListener = ()=>{};
        this.numberInputActive = true;
    }
    setupGui(parentElement) {
        this.eFloatingFilterNumberInput = this.createManagedBean(new $7b57b57eaf5a9648$export$c8aa0be99738aee());
        this.eFloatingFilterTextInput = this.createManagedBean(new $7b57b57eaf5a9648$export$8c027679838afd47());
        this.eFloatingFilterTextInput.setDisabled(true);
        const eNumberInput = this.eFloatingFilterNumberInput.getGui();
        const eTextInput = this.eFloatingFilterTextInput.getGui();
        parentElement.appendChild(eNumberInput);
        parentElement.appendChild(eTextInput);
        this.setupListeners(eNumberInput, (e)=>this.valueChangedListener(e));
        this.setupListeners(eTextInput, (e)=>this.valueChangedListener(e));
    }
    setEditable(editable) {
        this.numberInputActive = editable;
        this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive);
        this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
    }
    setAutoComplete(autoComplete) {
        this.eFloatingFilterNumberInput.setAutoComplete(autoComplete);
        this.eFloatingFilterTextInput.setAutoComplete(autoComplete);
    }
    getValue() {
        return this.getActiveInputElement().getValue();
    }
    setValue(value, silent) {
        this.getActiveInputElement().setValue(value, silent);
    }
    getActiveInputElement() {
        return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
    }
    setValueChangedListener(listener) {
        this.valueChangedListener = listener;
    }
    setupListeners(element, listener) {
        this.addManagedListeners(element, {
            input: listener,
            keydown: listener
        });
    }
    setParams(params) {
        this.setAriaLabel(params.ariaLabel);
        if (params.autoComplete !== void 0) this.setAutoComplete(params.autoComplete);
    }
    setAriaLabel(ariaLabel) {
        this.eFloatingFilterNumberInput.setInputAriaLabel(ariaLabel);
        this.eFloatingFilterTextInput.setInputAriaLabel(ariaLabel);
    }
};
var $7b57b57eaf5a9648$var$NumberFloatingFilter = class extends $7b57b57eaf5a9648$var$TextInputFloatingFilter {
    init(params) {
        super.init(params);
        this.filterModelFormatter = new $7b57b57eaf5a9648$var$NumberFilterModelFormatter(this.localeService, this.optionsFactory, params.filterParams?.numberFormatter);
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        const allowedCharPattern = $7b57b57eaf5a9648$var$getAllowedCharPattern(params.filterParams);
        if (allowedCharPattern !== this.allowedCharPattern) this.recreateFloatingFilterInputService(params);
        super.refresh(params);
        this.filterModelFormatter.updateParams({
            optionsFactory: this.optionsFactory
        });
    }
    getDefaultFilterOptions() {
        return $7b57b57eaf5a9648$var$DEFAULT_NUMBER_FILTER_OPTIONS;
    }
    getFilterModelFormatter() {
        return this.filterModelFormatter;
    }
    createFloatingFilterInputService(params) {
        this.allowedCharPattern = $7b57b57eaf5a9648$var$getAllowedCharPattern(params.filterParams);
        if (this.allowedCharPattern) return this.createManagedBean(new $7b57b57eaf5a9648$var$FloatingFilterTextInputService({
            config: {
                allowedCharPattern: this.allowedCharPattern
            }
        }));
        return this.createManagedBean(new $7b57b57eaf5a9648$var$FloatingFilterNumberInputService());
    }
};
// community-modules/core/src/filter/provided/text/textFloatingFilter.ts
var $7b57b57eaf5a9648$export$f856d88991b6b7f9 = class extends $7b57b57eaf5a9648$var$TextInputFloatingFilter {
    init(params) {
        super.init(params);
        this.filterModelFormatter = new $7b57b57eaf5a9648$var$TextFilterModelFormatter(this.localeService, this.optionsFactory);
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        super.refresh(params);
        this.filterModelFormatter.updateParams({
            optionsFactory: this.optionsFactory
        });
    }
    getDefaultFilterOptions() {
        return $7b57b57eaf5a9648$var$DEFAULT_TEXT_FILTER_OPTIONS;
    }
    getFilterModelFormatter() {
        return this.filterModelFormatter;
    }
    createFloatingFilterInputService() {
        return this.createManagedBean(new $7b57b57eaf5a9648$var$FloatingFilterTextInputService());
    }
};
// community-modules/core/src/filter/quickFilterApi.ts
function $7b57b57eaf5a9648$var$isQuickFilterPresent(beans) {
    return !!beans.filterManager?.isQuickFilterPresent();
}
function $7b57b57eaf5a9648$var$getQuickFilter(beans) {
    return beans.gos.get("quickFilterText");
}
function $7b57b57eaf5a9648$var$resetQuickFilter(beans) {
    beans.filterManager?.resetQuickFilterCache();
}
// community-modules/core/src/filter/quickFilterService.ts
var $7b57b57eaf5a9648$var$QuickFilterService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "quickFilterService";
        this.quickFilter = null;
        this.quickFilterParts = null;
    }
    wireBeans(beans) {
        this.valueService = beans.valueService;
        this.columnModel = beans.columnModel;
        this.rowModel = beans.rowModel;
        this.pivotResultColsService = beans.pivotResultColsService;
    }
    postConstruct() {
        const resetListener = this.resetQuickFilterCache.bind(this);
        this.addManagedEventListeners({
            columnPivotModeChanged: resetListener,
            newColumnsLoaded: resetListener,
            columnRowGroupChanged: resetListener,
            columnVisible: ()=>{
                if (!this.gos.get("includeHiddenColumnsInQuickFilter")) this.resetQuickFilterCache();
            }
        });
        this.addManagedPropertyListener("quickFilterText", (e)=>this.setQuickFilter(e.currentValue));
        this.addManagedPropertyListeners([
            "includeHiddenColumnsInQuickFilter",
            "applyQuickFilterBeforePivotOrAgg"
        ], ()=>this.onQuickFilterColumnConfigChanged());
        this.quickFilter = this.parseQuickFilter(this.gos.get("quickFilterText"));
        this.parser = this.gos.get("quickFilterParser");
        this.matcher = this.gos.get("quickFilterMatcher");
        this.setQuickFilterParts();
        this.addManagedPropertyListeners([
            "quickFilterMatcher",
            "quickFilterParser"
        ], ()=>this.setQuickFilterParserAndMatcher());
    }
    // if we are using autoGroupCols, then they should be included for quick filter. this covers the
    // following scenarios:
    // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
    // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
    //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
    refreshQuickFilterCols() {
        const pivotMode = this.columnModel.isPivotMode();
        const groupAutoCols = this.columnModel.getAutoCols();
        const providedCols = this.columnModel.getColDefCols();
        let columnsForQuickFilter = (pivotMode && !this.gos.get("applyQuickFilterBeforePivotOrAgg") ? this.pivotResultColsService.getPivotResultCols()?.list : providedCols) ?? [];
        if (groupAutoCols) columnsForQuickFilter = columnsForQuickFilter.concat(groupAutoCols);
        this.colsForQuickFilter = this.gos.get("includeHiddenColumnsInQuickFilter") ? columnsForQuickFilter : columnsForQuickFilter.filter((col)=>col.isVisible() || col.isRowGroupActive());
    }
    isQuickFilterPresent() {
        return this.quickFilter !== null;
    }
    doesRowPassQuickFilter(node) {
        const usingCache = this.gos.get("cacheQuickFilter");
        if (this.matcher) return this.doesRowPassQuickFilterMatcher(usingCache, node);
        return this.quickFilterParts.every((part)=>usingCache ? this.doesRowPassQuickFilterCache(node, part) : this.doesRowPassQuickFilterNoCache(node, part));
    }
    resetQuickFilterCache() {
        this.rowModel.forEachNode((node)=>node.quickFilterAggregateText = null);
    }
    setQuickFilterParts() {
        const { quickFilter: quickFilter , parser: parser  } = this;
        if (quickFilter) this.quickFilterParts = parser ? parser(quickFilter) : quickFilter.split(" ");
        else this.quickFilterParts = null;
    }
    parseQuickFilter(newFilter) {
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(newFilter)) return null;
        if (!this.gos.isRowModelType("clientSide")) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("Quick filtering only works with the Client-Side Row Model");
            return null;
        }
        return newFilter.toUpperCase();
    }
    setQuickFilter(newFilter) {
        if (newFilter != null && typeof newFilter !== "string") {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`Grid option quickFilterText only supports string inputs, received: ${typeof newFilter}`);
            return;
        }
        const parsedFilter = this.parseQuickFilter(newFilter);
        if (this.quickFilter !== parsedFilter) {
            this.quickFilter = parsedFilter;
            this.setQuickFilterParts();
            this.dispatchLocalEvent({
                type: "quickFilterChanged"
            });
        }
    }
    setQuickFilterParserAndMatcher() {
        const parser = this.gos.get("quickFilterParser");
        const matcher = this.gos.get("quickFilterMatcher");
        const hasChanged = parser !== this.parser || matcher !== this.matcher;
        this.parser = parser;
        this.matcher = matcher;
        if (hasChanged) {
            this.setQuickFilterParts();
            this.dispatchLocalEvent({
                type: "quickFilterChanged"
            });
        }
    }
    onQuickFilterColumnConfigChanged() {
        this.refreshQuickFilterCols();
        this.resetQuickFilterCache();
        if (this.isQuickFilterPresent()) this.dispatchLocalEvent({
            type: "quickFilterChanged"
        });
    }
    doesRowPassQuickFilterNoCache(node, filterPart) {
        return this.colsForQuickFilter.some((column)=>{
            const part = this.getQuickFilterTextForColumn(column, node);
            return $7b57b57eaf5a9648$export$25d27f17d3af40f7(part) && part.indexOf(filterPart) >= 0;
        });
    }
    doesRowPassQuickFilterCache(node, filterPart) {
        this.checkGenerateQuickFilterAggregateText(node);
        return node.quickFilterAggregateText.indexOf(filterPart) >= 0;
    }
    doesRowPassQuickFilterMatcher(usingCache, node) {
        let quickFilterAggregateText;
        if (usingCache) {
            this.checkGenerateQuickFilterAggregateText(node);
            quickFilterAggregateText = node.quickFilterAggregateText;
        } else quickFilterAggregateText = this.getQuickFilterAggregateText(node);
        const { quickFilterParts: quickFilterParts , matcher: matcher  } = this;
        return matcher(quickFilterParts, quickFilterAggregateText);
    }
    checkGenerateQuickFilterAggregateText(node) {
        if (!node.quickFilterAggregateText) node.quickFilterAggregateText = this.getQuickFilterAggregateText(node);
    }
    getQuickFilterTextForColumn(column, node) {
        let value = this.valueService.getValue(column, node, true);
        const colDef = column.getColDef();
        if (colDef.getQuickFilterText) {
            const params = this.gos.addGridCommonParams({
                value: value,
                node: node,
                data: node.data,
                column: column,
                colDef: colDef
            });
            value = colDef.getQuickFilterText(params);
        }
        return $7b57b57eaf5a9648$export$25d27f17d3af40f7(value) ? value.toString().toUpperCase() : null;
    }
    getQuickFilterAggregateText(node) {
        const stringParts = [];
        this.colsForQuickFilter.forEach((column)=>{
            const part = this.getQuickFilterTextForColumn(column, node);
            if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(part)) stringParts.push(part);
        });
        return stringParts.join("\n");
    }
};
// community-modules/core/src/filter/filterModule.ts
var $7b57b57eaf5a9648$export$b8779358eaaabc87 = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/filter-core",
    beans: [
        $7b57b57eaf5a9648$export$4c85e4ca0d95642f
    ]
};
var $7b57b57eaf5a9648$var$FilterApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/filter-api",
    apiFunctions: {
        isAnyFilterPresent: $7b57b57eaf5a9648$var$isAnyFilterPresent,
        onFilterChanged: $7b57b57eaf5a9648$var$onFilterChanged
    },
    dependantModules: [
        $7b57b57eaf5a9648$export$b8779358eaaabc87
    ]
};
var $7b57b57eaf5a9648$export$bee7a6b8183a1c61 = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/column-filter",
    beans: [
        $7b57b57eaf5a9648$var$ColumnFilterService
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$b8779358eaaabc87
    ]
};
var $7b57b57eaf5a9648$var$ColumnFilterApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/column-filter-api",
    apiFunctions: {
        isColumnFilterPresent: $7b57b57eaf5a9648$var$isColumnFilterPresent,
        getFilterInstance: $7b57b57eaf5a9648$var$getFilterInstance,
        getColumnFilterInstance: $7b57b57eaf5a9648$var$getColumnFilterInstance,
        destroyFilter: $7b57b57eaf5a9648$var$destroyFilter,
        setFilterModel: $7b57b57eaf5a9648$var$setFilterModel,
        getFilterModel: $7b57b57eaf5a9648$var$getFilterModel,
        getColumnFilterModel: $7b57b57eaf5a9648$var$getColumnFilterModel,
        setColumnFilterModel: $7b57b57eaf5a9648$var$setColumnFilterModel,
        showColumnFilter: $7b57b57eaf5a9648$var$showColumnFilter
    },
    dependantModules: [
        $7b57b57eaf5a9648$export$bee7a6b8183a1c61,
        $7b57b57eaf5a9648$var$FilterApiModule
    ]
};
var $7b57b57eaf5a9648$var$FloatingFilterCoreModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/floating-filter-core",
    controllers: [
        {
            name: "headerFilterCell",
            classImp: $7b57b57eaf5a9648$export$65579fe86751e033
        }
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$bee7a6b8183a1c61
    ]
};
var $7b57b57eaf5a9648$export$e52809a163d3cd5f = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/floating-filter",
    dependantModules: [
        $7b57b57eaf5a9648$var$FloatingFilterCoreModule,
        $7b57b57eaf5a9648$export$bee7a6b8183a1c61
    ]
};
var $7b57b57eaf5a9648$export$e81c352a760005ae = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/read-only-floating-filter",
    userComponents: [
        {
            name: "agReadOnlyFloatingFilter",
            classImp: $7b57b57eaf5a9648$var$ReadOnlyFloatingFilter
        }
    ],
    dependantModules: [
        $7b57b57eaf5a9648$var$FloatingFilterCoreModule
    ]
};
var $7b57b57eaf5a9648$var$SimpleFilterModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/simple-filter",
    dependantModules: [
        $7b57b57eaf5a9648$export$bee7a6b8183a1c61
    ],
    userComponents: [
        {
            name: "agTextColumnFilter",
            classImp: $7b57b57eaf5a9648$export$bf4978b2dd458630
        },
        {
            name: "agNumberColumnFilter",
            classImp: $7b57b57eaf5a9648$export$db99a591a1ce9821
        },
        {
            name: "agDateColumnFilter",
            classImp: $7b57b57eaf5a9648$export$45c1765a9388d778
        },
        {
            name: "agDateInput",
            classImp: $7b57b57eaf5a9648$var$DefaultDateComponent
        }
    ]
};
var $7b57b57eaf5a9648$var$SimpleFloatingFilterModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/simple-floating-filter",
    dependantModules: [
        $7b57b57eaf5a9648$var$SimpleFilterModule,
        $7b57b57eaf5a9648$var$FloatingFilterCoreModule
    ],
    userComponents: [
        {
            name: "agTextColumnFloatingFilter",
            classImp: $7b57b57eaf5a9648$export$f856d88991b6b7f9
        },
        {
            name: "agNumberColumnFloatingFilter",
            classImp: $7b57b57eaf5a9648$var$NumberFloatingFilter
        },
        {
            name: "agDateColumnFloatingFilter",
            classImp: $7b57b57eaf5a9648$var$DateFloatingFilter
        }
    ]
};
var $7b57b57eaf5a9648$var$QuickFilterCoreModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/quick-filter-core",
    beans: [
        $7b57b57eaf5a9648$var$QuickFilterService
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$b8779358eaaabc87
    ]
};
var $7b57b57eaf5a9648$var$QuickFilterApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/quick-filter-api",
    apiFunctions: {
        isQuickFilterPresent: $7b57b57eaf5a9648$var$isQuickFilterPresent,
        getQuickFilter: $7b57b57eaf5a9648$var$getQuickFilter,
        resetQuickFilter: $7b57b57eaf5a9648$var$resetQuickFilter
    },
    dependantModules: [
        $7b57b57eaf5a9648$var$QuickFilterCoreModule
    ]
};
var $7b57b57eaf5a9648$var$QuickFilterModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/quick-filter",
    dependantModules: [
        $7b57b57eaf5a9648$var$QuickFilterCoreModule,
        $7b57b57eaf5a9648$var$QuickFilterApiModule
    ]
};
var $7b57b57eaf5a9648$var$FilterModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/filter",
    dependantModules: [
        $7b57b57eaf5a9648$var$SimpleFloatingFilterModule,
        $7b57b57eaf5a9648$export$e81c352a760005ae,
        $7b57b57eaf5a9648$var$QuickFilterModule,
        $7b57b57eaf5a9648$var$ColumnFilterApiModule
    ]
};
// community-modules/core/src/headerRendering/cells/abstractCell/abstractHeaderCellComp.ts
var $7b57b57eaf5a9648$var$AbstractHeaderCellComp = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(template, ctrl){
        super(template);
        this.ctrl = ctrl;
    }
    getCtrl() {
        return this.ctrl;
    }
};
// community-modules/core/src/headerRendering/cells/floatingFilter/headerFilterCellComp.ts
var $7b57b57eaf5a9648$export$aee3d2f667fe76c1 = class extends $7b57b57eaf5a9648$var$AbstractHeaderCellComp {
    constructor(ctrl){
        super(/* html */ `<div class="ag-header-cell ag-floating-filter" role="gridcell">
            <div data-ref="eFloatingFilterBody" role="presentation"></div>
            <div class="ag-floating-filter-button ag-hidden" data-ref="eButtonWrapper" role="presentation">
                <button type="button" class="ag-button ag-floating-filter-button-button" data-ref="eButtonShowMainFilter" tabindex="-1"></button>
            </div>
        </div>`, ctrl);
        this.eFloatingFilterBody = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eButtonWrapper = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eButtonShowMainFilter = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    postConstruct() {
        const eGui = this.getGui();
        const compProxy = {
            addOrRemoveCssClass: (cssClassName, on)=>this.addOrRemoveCssClass(cssClassName, on),
            addOrRemoveBodyCssClass: (cssClassName, on)=>this.eFloatingFilterBody.classList.toggle(cssClassName, on),
            setButtonWrapperDisplayed: (displayed)=>$7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eButtonWrapper, displayed),
            setCompDetails: (compDetails)=>this.setCompDetails(compDetails),
            getFloatingFilterComp: ()=>this.compPromise,
            setWidth: (width)=>eGui.style.width = width,
            setMenuIcon: (eIcon)=>this.eButtonShowMainFilter.appendChild(eIcon)
        };
        this.ctrl.setComp(compProxy, eGui, this.eButtonShowMainFilter, this.eFloatingFilterBody);
    }
    setCompDetails(compDetails) {
        if (!compDetails) {
            this.destroyFloatingFilterComp();
            this.compPromise = null;
            return;
        }
        this.compPromise = compDetails.newAgStackInstance();
        this.compPromise.then((comp)=>this.afterCompCreated(comp));
    }
    destroy() {
        this.destroyFloatingFilterComp();
        super.destroy();
    }
    destroyFloatingFilterComp() {
        if (this.floatingFilterComp) {
            this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui());
            this.floatingFilterComp = this.destroyBean(this.floatingFilterComp);
        }
    }
    afterCompCreated(comp) {
        if (!comp) return;
        if (!this.isAlive()) {
            this.destroyBean(comp);
            return;
        }
        this.destroyFloatingFilterComp();
        this.floatingFilterComp = comp;
        this.eFloatingFilterBody.appendChild(comp.getGui());
        if (comp.afterGuiAttached) comp.afterGuiAttached();
    }
};
// community-modules/core/src/headerRendering/cells/column/headerCellComp.ts
var $7b57b57eaf5a9648$var$HeaderCellComp = class extends $7b57b57eaf5a9648$var$AbstractHeaderCellComp {
    constructor(ctrl){
        super(/* html */ `<div class="ag-header-cell" role="columnheader">
            <div data-ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
            <div data-ref="eHeaderCompWrapper" class="ag-header-cell-comp-wrapper" role="presentation"></div>
        </div>`, ctrl);
        this.eResize = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eHeaderCompWrapper = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.headerCompVersion = 0;
        this.column = ctrl.getColumnGroupChild();
        this.pinned = ctrl.getPinned();
    }
    postConstruct() {
        const eGui = this.getGui();
        const setAttribute = (name, value)=>{
            if (value != null && value != "") eGui.setAttribute(name, value);
            else eGui.removeAttribute(name);
        };
        setAttribute("col-id", this.column.getColId());
        const compProxy = {
            setWidth: (width)=>eGui.style.width = width,
            addOrRemoveCssClass: (cssClassName, on)=>this.addOrRemoveCssClass(cssClassName, on),
            setAriaSort: (sort)=>sort ? $7b57b57eaf5a9648$export$c8dd030b968c6fd2(eGui, sort) : $7b57b57eaf5a9648$export$26c7aa61eda05134(eGui),
            setUserCompDetails: (compDetails)=>this.setUserCompDetails(compDetails),
            getUserCompInstance: ()=>this.headerComp
        };
        this.ctrl.setComp(compProxy, this.getGui(), this.eResize, this.eHeaderCompWrapper);
        const selectAllGui = this.ctrl.getSelectAllGui();
        this.eResize.insertAdjacentElement("afterend", selectAllGui);
    }
    destroy() {
        this.destroyHeaderComp();
        super.destroy();
    }
    destroyHeaderComp() {
        if (this.headerComp) {
            this.eHeaderCompWrapper.removeChild(this.headerCompGui);
            this.headerComp = this.destroyBean(this.headerComp);
            this.headerCompGui = void 0;
        }
    }
    setUserCompDetails(compDetails) {
        this.headerCompVersion++;
        const versionCopy = this.headerCompVersion;
        compDetails.newAgStackInstance().then((comp)=>this.afterCompCreated(versionCopy, comp));
    }
    afterCompCreated(version, headerComp) {
        if (version != this.headerCompVersion || !this.isAlive()) {
            this.destroyBean(headerComp);
            return;
        }
        this.destroyHeaderComp();
        this.headerComp = headerComp;
        this.headerCompGui = headerComp.getGui();
        this.eHeaderCompWrapper.appendChild(this.headerCompGui);
        this.ctrl.setDragSource(this.getGui());
    }
};
// community-modules/core/src/headerRendering/cells/columnGroup/headerGroupCellComp.ts
var $7b57b57eaf5a9648$var$HeaderGroupCellComp = class extends $7b57b57eaf5a9648$var$AbstractHeaderCellComp {
    constructor(ctrl){
        super(/* html */ `<div class="ag-header-group-cell" role="columnheader">
            <div data-ref="eResize" class="ag-header-cell-resize" role="presentation"></div>
        </div>`, ctrl);
        this.eResize = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    postConstruct() {
        const eGui = this.getGui();
        const setAttribute = (key, value)=>value != void 0 ? eGui.setAttribute(key, value) : eGui.removeAttribute(key);
        eGui.setAttribute("col-id", this.ctrl.getColId());
        const compProxy = {
            addOrRemoveCssClass: (cssClassName, on)=>this.addOrRemoveCssClass(cssClassName, on),
            setResizableDisplayed: (displayed)=>$7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eResize, displayed),
            setWidth: (width)=>eGui.style.width = width,
            setAriaExpanded: (expanded)=>setAttribute("aria-expanded", expanded),
            setUserCompDetails: (details)=>this.setUserCompDetails(details),
            getUserCompInstance: ()=>this.headerGroupComp
        };
        this.ctrl.setComp(compProxy, eGui, this.eResize);
    }
    setUserCompDetails(details) {
        details.newAgStackInstance().then((comp)=>this.afterHeaderCompCreated(comp));
    }
    afterHeaderCompCreated(headerGroupComp) {
        const destroyFunc = ()=>this.destroyBean(headerGroupComp);
        if (!this.isAlive()) {
            destroyFunc();
            return;
        }
        const eGui = this.getGui();
        const eHeaderGroupGui = headerGroupComp.getGui();
        eGui.appendChild(eHeaderGroupGui);
        this.addDestroyFunc(destroyFunc);
        this.headerGroupComp = headerGroupComp;
        this.ctrl.setDragSource(eGui);
    }
};
// community-modules/core/src/headerRendering/row/headerRowComp.ts
var $7b57b57eaf5a9648$export$e37505288cf627d = /* @__PURE__ */ ((HeaderRowType2)=>{
    HeaderRowType2["COLUMN_GROUP"] = "group";
    HeaderRowType2["COLUMN"] = "column";
    HeaderRowType2["FLOATING_FILTER"] = "filter";
    return HeaderRowType2;
})($7b57b57eaf5a9648$export$e37505288cf627d || {});
var $7b57b57eaf5a9648$export$e63c63fafc55a465 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(ctrl){
        super();
        this.headerComps = {};
        this.ctrl = ctrl;
        this.setTemplate(/* html */ `<div class="${this.ctrl.getHeaderRowClass()}" role="row"></div>`);
    }
    postConstruct() {
        $7b57b57eaf5a9648$export$ba731dedf9d88615(this.getGui(), this.ctrl.getAriaRowIndex());
        const compProxy = {
            setHeight: (height)=>this.getGui().style.height = height,
            setTop: (top)=>this.getGui().style.top = top,
            setHeaderCtrls: (ctrls, forceOrder)=>this.setHeaderCtrls(ctrls, forceOrder),
            setWidth: (width)=>this.getGui().style.width = width
        };
        this.ctrl.setComp(compProxy);
    }
    destroy() {
        this.setHeaderCtrls([], false);
        super.destroy();
    }
    setHeaderCtrls(ctrls, forceOrder) {
        if (!this.isAlive()) return;
        const oldComps = this.headerComps;
        this.headerComps = {};
        ctrls.forEach((ctrl)=>{
            const id = ctrl.getInstanceId();
            let comp = oldComps[id];
            delete oldComps[id];
            if (comp == null) {
                comp = this.createHeaderComp(ctrl);
                this.getGui().appendChild(comp.getGui());
            }
            this.headerComps[id] = comp;
        });
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(oldComps, (id, comp)=>{
            this.getGui().removeChild(comp.getGui());
            this.destroyBean(comp);
        });
        if (forceOrder) {
            const comps = $7b57b57eaf5a9648$export$2f52ef471f042094(this.headerComps);
            comps.sort((a, b)=>{
                const leftA = a.getCtrl().getColumnGroupChild().getLeft();
                const leftB = b.getCtrl().getColumnGroupChild().getLeft();
                return leftA - leftB;
            });
            const elementsInOrder = comps.map((c)=>c.getGui());
            $7b57b57eaf5a9648$var$_setDomChildOrder(this.getGui(), elementsInOrder);
        }
    }
    createHeaderComp(headerCtrl) {
        let result;
        switch(this.ctrl.getType()){
            case "group" /* COLUMN_GROUP */ :
                result = new $7b57b57eaf5a9648$var$HeaderGroupCellComp(headerCtrl);
                break;
            case "filter" /* FLOATING_FILTER */ :
                result = new $7b57b57eaf5a9648$export$aee3d2f667fe76c1(headerCtrl);
                break;
            default:
                result = new $7b57b57eaf5a9648$var$HeaderCellComp(headerCtrl);
                break;
        }
        this.createBean(result);
        result.setParentComponent(this);
        return result;
    }
};
// community-modules/core/src/headerRendering/common/headerNavigationService.ts
var $7b57b57eaf5a9648$export$17290b528485e8bd = /* @__PURE__ */ ((HeaderNavigationDirection2)=>{
    HeaderNavigationDirection2[HeaderNavigationDirection2["UP"] = 0] = "UP";
    HeaderNavigationDirection2[HeaderNavigationDirection2["DOWN"] = 1] = "DOWN";
    HeaderNavigationDirection2[HeaderNavigationDirection2["LEFT"] = 2] = "LEFT";
    HeaderNavigationDirection2[HeaderNavigationDirection2["RIGHT"] = 3] = "RIGHT";
    return HeaderNavigationDirection2;
})($7b57b57eaf5a9648$export$17290b528485e8bd || {});
var $7b57b57eaf5a9648$export$ee63d8b4f36fee20 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "headerNavigationService";
        this.currentHeaderRowWithoutSpan = -1;
    }
    wireBeans(beans) {
        this.focusService = beans.focusService;
        this.headerPositionUtils = beans.headerPositionUtils;
        this.ctrlsService = beans.ctrlsService;
        this.columnModel = beans.columnModel;
        this.visibleColService = beans.visibleColsService;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            this.gridBodyCon = p.gridBodyCtrl;
        });
        const eDocument = this.gos.getDocument();
        this.addManagedElementListeners(eDocument, {
            mousedown: ()=>this.setCurrentHeaderRowWithoutSpan(-1)
        });
    }
    getHeaderRowCount() {
        const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();
        return centerHeaderContainer ? centerHeaderContainer.getRowCount() : 0;
    }
    getHeaderPositionForColumn(colKey, floatingFilter) {
        let column;
        if (typeof colKey === "string") {
            column = this.columnModel.getCol(colKey);
            if (!column) column = this.visibleColService.getColumnGroup(colKey);
        } else column = colKey;
        if (!column) return null;
        const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();
        const allCtrls = centerHeaderContainer.getAllCtrls();
        const isFloatingFilterVisible = $7b57b57eaf5a9648$export$236389741107357f(allCtrls).getType() === "filter" /* FLOATING_FILTER */ ;
        const headerRowCount = this.getHeaderRowCount() - 1;
        let row = -1;
        let col = column;
        while(col){
            row++;
            col = col.getParent();
        }
        let headerRowIndex = row;
        if (floatingFilter && isFloatingFilterVisible && headerRowIndex === headerRowCount - 1) headerRowIndex++;
        return headerRowIndex === -1 ? null : {
            headerRowIndex: headerRowIndex,
            column: column
        };
    }
    /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */ navigateVertically(direction, fromHeader, event) {
        if (!fromHeader) fromHeader = this.focusService.getFocusedHeader();
        if (!fromHeader) return false;
        const { headerRowIndex: headerRowIndex  } = fromHeader;
        const column = fromHeader.column;
        const rowLen = this.getHeaderRowCount();
        const isUp = direction === 0 /* UP */ ;
        let { headerRowIndex: nextRow , column: nextFocusColumn , headerRowIndexWithoutSpan: // eslint-disable-next-line prefer-const
        headerRowIndexWithoutSpan  } = isUp ? this.headerPositionUtils.getColumnVisibleParent(column, headerRowIndex) : this.headerPositionUtils.getColumnVisibleChild(column, headerRowIndex);
        let skipColumn = false;
        if (nextRow < 0) {
            nextRow = 0;
            nextFocusColumn = column;
            skipColumn = true;
        }
        if (nextRow >= rowLen) {
            nextRow = -1;
            this.setCurrentHeaderRowWithoutSpan(-1);
        } else if (headerRowIndexWithoutSpan !== void 0) this.currentHeaderRowWithoutSpan = headerRowIndexWithoutSpan;
        if (!skipColumn && !nextFocusColumn) return false;
        return this.focusService.focusHeaderPosition({
            headerPosition: {
                headerRowIndex: nextRow,
                column: nextFocusColumn
            },
            allowUserOverride: true,
            event: event
        });
    }
    setCurrentHeaderRowWithoutSpan(row) {
        this.currentHeaderRowWithoutSpan = row;
    }
    /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */ navigateHorizontally(direction, fromTab = false, event) {
        const focusedHeader = this.focusService.getFocusedHeader();
        const isLeft = direction === 2 /* LEFT */ ;
        const isRtl = this.gos.get("enableRtl");
        let nextHeader;
        let normalisedDirection;
        if (this.currentHeaderRowWithoutSpan !== -1) focusedHeader.headerRowIndex = this.currentHeaderRowWithoutSpan;
        else this.currentHeaderRowWithoutSpan = focusedHeader.headerRowIndex;
        if (isLeft !== isRtl) {
            normalisedDirection = "Before";
            nextHeader = this.headerPositionUtils.findHeader(focusedHeader, normalisedDirection);
        } else {
            normalisedDirection = "After";
            nextHeader = this.headerPositionUtils.findHeader(focusedHeader, normalisedDirection);
        }
        if (nextHeader || !fromTab) return this.focusService.focusHeaderPosition({
            headerPosition: nextHeader,
            direction: normalisedDirection,
            fromTab: fromTab,
            allowUserOverride: true,
            event: event
        });
        else if (fromTab) {
            const userFunc = this.gos.getCallback("tabToNextHeader");
            if (userFunc) return this.focusService.focusHeaderPositionFromUserFunc({
                userFunc: userFunc,
                headerPosition: nextHeader,
                direction: normalisedDirection
            });
        }
        return this.focusNextHeaderRow(focusedHeader, normalisedDirection, event);
    }
    focusNextHeaderRow(focusedHeader, direction, event) {
        const currentIndex = focusedHeader.headerRowIndex;
        let nextPosition = null;
        let nextRowIndex;
        if (direction === "Before") {
            if (currentIndex > 0) {
                nextRowIndex = currentIndex - 1;
                this.currentHeaderRowWithoutSpan -= 1;
                nextPosition = this.headerPositionUtils.findColAtEdgeForHeaderRow(nextRowIndex, "end");
            }
        } else {
            nextRowIndex = currentIndex + 1;
            if (this.currentHeaderRowWithoutSpan < this.getHeaderRowCount()) this.currentHeaderRowWithoutSpan += 1;
            else this.setCurrentHeaderRowWithoutSpan(-1);
            nextPosition = this.headerPositionUtils.findColAtEdgeForHeaderRow(nextRowIndex, "start");
        }
        if (!nextPosition) return false;
        const { column: column , headerRowIndex: headerRowIndex  } = this.headerPositionUtils.getHeaderIndexToFocus(nextPosition.column, nextPosition?.headerRowIndex);
        return this.focusService.focusHeaderPosition({
            headerPosition: {
                column: column,
                headerRowIndex: headerRowIndex
            },
            direction: direction,
            fromTab: true,
            allowUserOverride: true,
            event: event
        });
    }
    scrollToColumn(column, direction = "After") {
        if (column.getPinned()) return;
        let columnToScrollTo;
        if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(column)) {
            const columns = column.getDisplayedLeafColumns();
            columnToScrollTo = direction === "Before" ? $7b57b57eaf5a9648$export$236389741107357f(columns) : columns[0];
        } else columnToScrollTo = column;
        this.gridBodyCon.getScrollFeature().ensureColumnVisible(columnToScrollTo);
    }
};
// community-modules/core/src/headerRendering/gridHeaderCtrl.ts
var $7b57b57eaf5a9648$export$20b300eb69ca4d09 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.headerNavigationService = beans.headerNavigationService;
        this.focusService = beans.focusService;
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
        this.ctrlsService = beans.ctrlsService;
        this.filterManager = beans.filterManager;
        this.menuService = beans.menuService;
    }
    setComp(comp, eGui, eFocusableElement) {
        this.comp = comp;
        this.eGui = eGui;
        this.createManagedBean(new $7b57b57eaf5a9648$export$5510e53ed3962582(eFocusableElement, {
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusOut: this.onFocusOut.bind(this)
        }));
        this.addManagedEventListeners({
            columnPivotModeChanged: this.onPivotModeChanged.bind(this),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
        });
        this.onPivotModeChanged();
        this.setupHeaderHeight();
        const listener = this.onHeaderContextMenu.bind(this);
        this.addManagedElementListeners(this.eGui, {
            contextmenu: listener
        });
        this.mockContextMenuForIPad(listener);
        this.ctrlsService.register("gridHeaderCtrl", this);
    }
    setupHeaderHeight() {
        const listener = this.setHeaderHeight.bind(this);
        listener();
        this.addManagedPropertyListener("headerHeight", listener);
        this.addManagedPropertyListener("pivotHeaderHeight", listener);
        this.addManagedPropertyListener("groupHeaderHeight", listener);
        this.addManagedPropertyListener("pivotGroupHeaderHeight", listener);
        this.addManagedPropertyListener("floatingFiltersHeight", listener);
        this.addManagedEventListeners({
            displayedColumnsChanged: listener,
            columnHeaderHeightChanged: listener,
            gridStylesChanged: listener,
            advancedFilterEnabledChanged: listener
        });
    }
    getHeaderHeight() {
        return this.headerHeight;
    }
    setHeaderHeight() {
        const { columnModel: columnModel  } = this;
        let numberOfFloating = 0;
        let headerRowCount = columnModel.getHeaderRowCount();
        let totalHeaderHeight;
        const hasFloatingFilters = this.filterManager?.hasFloatingFilters();
        if (hasFloatingFilters) {
            headerRowCount++;
            numberOfFloating = 1;
        }
        const groupHeight = this.columnModel.getColumnGroupHeaderRowHeight();
        const headerHeight = this.columnModel.getColumnHeaderRowHeight();
        const numberOfNonGroups = 1 + numberOfFloating;
        const numberOfGroups = headerRowCount - numberOfNonGroups;
        totalHeaderHeight = numberOfFloating * columnModel.getFloatingFiltersHeight();
        totalHeaderHeight += numberOfGroups * groupHeight;
        totalHeaderHeight += headerHeight;
        if (this.headerHeight === totalHeaderHeight) return;
        this.headerHeight = totalHeaderHeight;
        const px = `${totalHeaderHeight + 1}px`;
        this.comp.setHeightAndMinHeight(px);
        this.eventService.dispatchEvent({
            type: "headerHeightChanged"
        });
    }
    onPivotModeChanged() {
        const pivotMode = this.columnModel.isPivotMode();
        this.comp.addOrRemoveCssClass("ag-pivot-on", pivotMode);
        this.comp.addOrRemoveCssClass("ag-pivot-off", !pivotMode);
    }
    onDisplayedColumnsChanged() {
        const columns = this.visibleColsService.getAllCols();
        const shouldAllowOverflow = columns.some((col)=>col.isSpanHeaderHeight());
        this.comp.addOrRemoveCssClass("ag-header-allow-overflow", shouldAllowOverflow);
    }
    onTabKeyDown(e) {
        const isRtl = this.gos.get("enableRtl");
        const direction = e.shiftKey !== isRtl ? 2 /* LEFT */  : 3 /* RIGHT */ ;
        if (this.headerNavigationService.navigateHorizontally(direction, true, e) || this.focusService.focusNextGridCoreContainer(e.shiftKey)) e.preventDefault();
    }
    handleKeyDown(e) {
        let direction = null;
        switch(e.key){
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT:
                direction = 2 /* LEFT */ ;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT:
                if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(direction)) direction = 3 /* RIGHT */ ;
                this.headerNavigationService.navigateHorizontally(direction, false, e);
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
                direction = 0 /* UP */ ;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
                if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(direction)) direction = 1 /* DOWN */ ;
                if (this.headerNavigationService.navigateVertically(direction, null, e)) e.preventDefault();
                break;
            default:
                return;
        }
    }
    onFocusOut(e) {
        const { relatedTarget: relatedTarget  } = e;
        if (!relatedTarget && this.eGui.contains(this.gos.getActiveDomElement())) return;
        if (!this.eGui.contains(relatedTarget)) this.focusService.clearFocusedHeader();
    }
    onHeaderContextMenu(mouseEvent, touch, touchEvent) {
        if (!mouseEvent && !touchEvent || !this.menuService.isHeaderContextMenuEnabled()) return;
        const { target: target  } = mouseEvent ?? touch;
        if (target === this.eGui || target === this.ctrlsService.getHeaderRowContainerCtrl().getViewport()) this.menuService.showHeaderContextMenu(void 0, mouseEvent, touchEvent);
    }
    mockContextMenuForIPad(listener) {
        if (!$7b57b57eaf5a9648$export$6b6034a68325bd8a()) return;
        const touchListener = new $7b57b57eaf5a9648$export$7b2e93987414b382(this.eGui);
        const longTapListener = (event)=>{
            listener(void 0, event.touchStart, event.touchEvent);
        };
        this.addManagedListeners(touchListener, {
            longTap: longTapListener
        });
        this.addDestroyFunc(()=>touchListener.destroy());
    }
};
// community-modules/core/src/gridBodyComp/centerWidthFeature.ts
var $7b57b57eaf5a9648$var$CenterWidthFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(callback, addSpacer = false){
        super();
        this.callback = callback;
        this.addSpacer = addSpacer;
    }
    wireBeans(beans) {
        this.visibleColsService = beans.visibleColsService;
        this.scrollVisibleService = beans.scrollVisibleService;
    }
    postConstruct() {
        const listener = this.setWidth.bind(this);
        this.addManagedPropertyListener("domLayout", listener);
        this.addManagedEventListeners({
            columnContainerWidthChanged: listener,
            displayedColumnsChanged: listener,
            leftPinnedWidthChanged: listener
        });
        if (this.addSpacer) this.addManagedEventListeners({
            rightPinnedWidthChanged: listener,
            scrollVisibilityChanged: listener,
            scrollbarWidthChanged: listener
        });
        this.setWidth();
    }
    setWidth() {
        const printLayout = this.gos.isDomLayout("print");
        const centerWidth = this.visibleColsService.getBodyContainerWidth();
        const leftWidth = this.visibleColsService.getColsLeftWidth();
        const rightWidth = this.visibleColsService.getDisplayedColumnsRightWidth();
        let totalWidth;
        if (printLayout) totalWidth = centerWidth + leftWidth + rightWidth;
        else {
            totalWidth = centerWidth;
            if (this.addSpacer) {
                const relevantWidth = this.gos.get("enableRtl") ? leftWidth : rightWidth;
                if (relevantWidth === 0 && this.scrollVisibleService.isVerticalScrollShowing()) totalWidth += this.gos.getScrollbarWidth();
            }
        }
        this.callback(totalWidth);
    }
};
// community-modules/core/src/headerRendering/columnDrag/bodyDropPivotTarget.ts
var $7b57b57eaf5a9648$export$2828fedc973b5610 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(pinned){
        super();
        this.columnsToAggregate = [];
        this.columnsToGroup = [];
        this.columnsToPivot = [];
        this.pinned = pinned;
    }
    wireBeans(beans) {
        this.funcColsService = beans.funcColsService;
    }
    /** Callback for when drag enters */ onDragEnter(draggingEvent) {
        this.clearColumnsList();
        if (this.gos.get("functionsReadOnly")) return;
        const dragColumns = draggingEvent.dragItem.columns;
        if (!dragColumns) return;
        dragColumns.forEach((column)=>{
            if (!column.isPrimary()) return;
            if (column.isAnyFunctionActive()) return;
            if (column.isAllowValue()) this.columnsToAggregate.push(column);
            else if (column.isAllowRowGroup()) this.columnsToGroup.push(column);
            else if (column.isAllowPivot()) this.columnsToPivot.push(column);
        });
    }
    getIconName() {
        const totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
        if (totalColumns > 0) return this.pinned ? "pinned" : "move";
        return null;
    }
    /** Callback for when drag leaves */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDragLeave(draggingEvent) {
        this.clearColumnsList();
    }
    clearColumnsList() {
        this.columnsToAggregate.length = 0;
        this.columnsToGroup.length = 0;
        this.columnsToPivot.length = 0;
    }
    /** Callback for when dragging */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDragging(draggingEvent) {}
    /** Callback for when drag stops */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDragStop(draggingEvent) {
        if (this.columnsToAggregate.length > 0) this.funcColsService.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop");
        if (this.columnsToGroup.length > 0) this.funcColsService.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop");
        if (this.columnsToPivot.length > 0) this.funcColsService.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
    }
};
// community-modules/core/src/headerRendering/columnMoveHelper.ts
function $7b57b57eaf5a9648$var$attemptMoveColumns(params) {
    const { isFromHeader: isFromHeader , hDirection: hDirection , xPosition: xPosition , fromEnter: fromEnter , fakeEvent: fakeEvent , pinned: pinned , gos: gos , columnModel: columnModel , columnMoveService: columnMoveService , presentedColsService: presentedColsService  } = params;
    const draggingLeft = hDirection === 0 /* Left */ ;
    const draggingRight = hDirection === 1 /* Right */ ;
    let { allMovingColumns: allMovingColumns  } = params;
    if (isFromHeader) {
        const newCols = [];
        allMovingColumns.forEach((col)=>{
            let movingGroup = null;
            let parent = col.getParent();
            while(parent != null && parent.getDisplayedLeafColumns().length === 1){
                movingGroup = parent;
                parent = parent.getParent();
            }
            if (movingGroup != null) {
                const isMarryChildren = !!movingGroup.getColGroupDef()?.marryChildren;
                const columnsToMove = isMarryChildren ? // when marry children is true, we also have to move hidden
                // columns within the group, so grab them from the `providedColumnGroup`
                movingGroup.getProvidedColumnGroup().getLeafColumns() : movingGroup.getLeafColumns();
                columnsToMove.forEach((newCol)=>{
                    if (!newCols.includes(newCol)) newCols.push(newCol);
                });
            } else if (!newCols.includes(col)) newCols.push(col);
        });
        allMovingColumns = newCols;
    }
    const allMovingColumnsOrdered = allMovingColumns.slice();
    columnModel.sortColsLikeCols(allMovingColumnsOrdered);
    const validMoves = $7b57b57eaf5a9648$var$calculateValidMoves({
        movingCols: allMovingColumnsOrdered,
        draggingRight: draggingRight,
        xPosition: xPosition,
        pinned: pinned,
        gos: gos,
        columnModel: columnModel,
        presentedColsService: presentedColsService
    });
    const oldIndex = $7b57b57eaf5a9648$var$calculateOldIndex(allMovingColumnsOrdered, columnModel);
    if (validMoves.length === 0) return;
    const firstValidMove = validMoves[0];
    let constrainDirection = oldIndex !== null && !fromEnter;
    if (isFromHeader) constrainDirection = oldIndex !== null;
    if (constrainDirection && !fakeEvent) {
        if (draggingLeft && firstValidMove >= oldIndex) return;
        if (draggingRight && firstValidMove <= oldIndex) return;
    }
    const displayedCols = presentedColsService.getAllCols();
    const potentialMoves = [];
    let targetOrder = null;
    for(let i = 0; i < validMoves.length; i++){
        const move = validMoves[i];
        const order = columnMoveService.getProposedColumnOrder(allMovingColumnsOrdered, move);
        if (!columnMoveService.doesOrderPassRules(order)) continue;
        const displayedOrder = order.filter((col)=>displayedCols.includes(col));
        if (targetOrder === null) targetOrder = displayedOrder;
        else if (!$7b57b57eaf5a9648$export$893967cdb9833fdd(displayedOrder, targetOrder)) break;
        const fragCount = $7b57b57eaf5a9648$var$groupFragCount(order);
        potentialMoves.push({
            move: move,
            fragCount: fragCount
        });
    }
    if (potentialMoves.length === 0) return;
    potentialMoves.sort((a, b)=>a.fragCount - b.fragCount);
    return $7b57b57eaf5a9648$var$moveColumns(allMovingColumns, potentialMoves[0].move, "uiColumnMoved", false, columnMoveService);
}
function $7b57b57eaf5a9648$var$moveColumns(columns, toIndex, source, finished, columnMoveService) {
    columnMoveService.moveColumns(columns, toIndex, source, finished);
    return finished ? null : {
        columns: columns,
        toIndex: toIndex
    };
}
function $7b57b57eaf5a9648$var$calculateOldIndex(movingCols, columnModel) {
    const gridCols = columnModel.getCols();
    const indexes = $7b57b57eaf5a9648$var$_sortNumerically(movingCols.map((col)=>gridCols.indexOf(col)));
    const firstIndex = indexes[0];
    const lastIndex = $7b57b57eaf5a9648$export$236389741107357f(indexes);
    const spread = lastIndex - firstIndex;
    const gapsExist = spread !== indexes.length - 1;
    return gapsExist ? null : firstIndex;
}
function $7b57b57eaf5a9648$var$groupFragCount(columns) {
    function parents(col) {
        const result = [];
        let parent = col.getOriginalParent();
        while(parent != null){
            result.push(parent);
            parent = parent.getOriginalParent();
        }
        return result;
    }
    let count = 0;
    for(let i = 0; i < columns.length - 1; i++){
        let a = parents(columns[i]);
        let b = parents(columns[i + 1]);
        [a, b] = a.length > b.length ? [
            a,
            b
        ] : [
            b,
            a
        ];
        a.forEach((parent)=>{
            if (b.indexOf(parent) === -1) count++;
        });
    }
    return count;
}
function $7b57b57eaf5a9648$var$getDisplayedColumns(presentedColsService, type) {
    switch(type){
        case "left":
            return presentedColsService.getLeftCols();
        case "right":
            return presentedColsService.getRightCols();
        default:
            return presentedColsService.getCenterCols();
    }
}
function $7b57b57eaf5a9648$var$calculateValidMoves(params) {
    const { movingCols: movingCols , draggingRight: draggingRight , xPosition: xPosition , pinned: pinned , gos: gos , columnModel: columnModel , presentedColsService: presentedColsService  } = params;
    const isMoveBlocked = gos.get("suppressMovableColumns") || movingCols.some((col)=>col.getColDef().suppressMovable);
    if (isMoveBlocked) return [];
    const allDisplayedCols = $7b57b57eaf5a9648$var$getDisplayedColumns(presentedColsService, pinned);
    const allGridCols = columnModel.getCols();
    const movingDisplayedCols = allDisplayedCols.filter((col)=>$7b57b57eaf5a9648$export$fccf016a6caa651d(movingCols, col));
    const otherDisplayedCols = allDisplayedCols.filter((col)=>!$7b57b57eaf5a9648$export$fccf016a6caa651d(movingCols, col));
    const otherGridCols = allGridCols.filter((col)=>!$7b57b57eaf5a9648$export$fccf016a6caa651d(movingCols, col));
    let displayIndex = 0;
    let availableWidth = xPosition;
    if (draggingRight) {
        let widthOfMovingDisplayedCols = 0;
        movingDisplayedCols.forEach((col)=>widthOfMovingDisplayedCols += col.getActualWidth());
        availableWidth -= widthOfMovingDisplayedCols;
    }
    if (availableWidth > 0) {
        for(let i = 0; i < otherDisplayedCols.length; i++){
            const col = otherDisplayedCols[i];
            availableWidth -= col.getActualWidth();
            if (availableWidth < 0) break;
            displayIndex++;
        }
        if (draggingRight) displayIndex++;
    }
    let firstValidMove;
    if (displayIndex > 0) {
        const leftColumn = otherDisplayedCols[displayIndex - 1];
        firstValidMove = otherGridCols.indexOf(leftColumn) + 1;
    } else {
        firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);
        if (firstValidMove === -1) firstValidMove = 0;
    }
    const validMoves = [
        firstValidMove
    ];
    const numberComparator = (a, b)=>a - b;
    if (draggingRight) {
        let pointer = firstValidMove + 1;
        const lastIndex = allGridCols.length - 1;
        while(pointer <= lastIndex){
            validMoves.push(pointer);
            pointer++;
        }
        validMoves.sort(numberComparator);
    } else {
        let pointer = firstValidMove;
        const lastIndex = allGridCols.length - 1;
        let displacedCol = allGridCols[pointer];
        while(pointer <= lastIndex && allDisplayedCols.indexOf(displacedCol) < 0){
            pointer++;
            validMoves.push(pointer);
            displacedCol = allGridCols[pointer];
        }
        pointer = firstValidMove - 1;
        const firstDisplayIndex = 0;
        while(pointer >= firstDisplayIndex){
            validMoves.push(pointer);
            pointer--;
        }
        validMoves.sort(numberComparator).reverse();
    }
    return validMoves;
}
function $7b57b57eaf5a9648$var$normaliseX(x, pinned, fromKeyboard, gos, ctrlsService) {
    const eViewport = ctrlsService.getHeaderRowContainerCtrl(pinned).getViewport();
    if (fromKeyboard) x -= eViewport.getBoundingClientRect().left;
    if (gos.get("enableRtl")) {
        const clientWidth = eViewport.clientWidth;
        x = clientWidth - x;
    }
    if (pinned == null) x += ctrlsService.get("center").getCenterViewportScrollLeft();
    return x;
}
// community-modules/core/src/headerRendering/columnDrag/moveColumnFeature.ts
var $7b57b57eaf5a9648$export$a5c24618571fc64c = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(pinned){
        super();
        this.needToMoveLeft = false;
        this.needToMoveRight = false;
        this.lastMovedInfo = null;
        this.pinned = pinned;
        this.isCenterContainer = !$7b57b57eaf5a9648$export$25d27f17d3af40f7(pinned);
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
        this.columnMoveService = beans.columnMoveService;
        this.dragAndDropService = beans.dragAndDropService;
        this.ctrlsService = beans.ctrlsService;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            this.gridBodyCon = p.gridBodyCtrl;
        });
    }
    getIconName() {
        return this.pinned ? "pinned" : "move";
    }
    onDragEnter(draggingEvent) {
        const columns = draggingEvent.dragItem.columns;
        const dragCameFromToolPanel = draggingEvent.dragSource.type === 0 /* ToolPanel */ ;
        if (dragCameFromToolPanel) this.setColumnsVisible(columns, true, "uiColumnDragged");
        else {
            const visibleState = draggingEvent.dragItem.visibleState;
            const visibleColumns = (columns || []).filter((column)=>visibleState[column.getId()]);
            this.setColumnsVisible(visibleColumns, true, "uiColumnDragged");
        }
        this.setColumnsPinned(columns, this.pinned, "uiColumnDragged");
        this.onDragging(draggingEvent, true, true);
    }
    onDragLeave() {
        this.ensureIntervalCleared();
        this.lastMovedInfo = null;
    }
    setColumnsVisible(columns, visible, source) {
        if (columns) {
            const allowedCols = columns.filter((c)=>!c.getColDef().lockVisible);
            this.columnModel.setColsVisible(allowedCols, visible, source);
        }
    }
    setColumnsPinned(columns, pinned, source) {
        if (columns) {
            const allowedCols = columns.filter((c)=>!c.getColDef().lockPinned);
            this.columnModel.setColsPinned(allowedCols, pinned, source);
        }
    }
    onDragStop() {
        this.onDragging(this.lastDraggingEvent, false, true, true);
        this.ensureIntervalCleared();
        this.lastMovedInfo = null;
    }
    checkCenterForScrolling(xAdjustedForScroll) {
        if (this.isCenterContainer) {
            const centerCtrl = this.ctrlsService.get("center");
            const firstVisiblePixel = centerCtrl.getCenterViewportScrollLeft();
            const lastVisiblePixel = firstVisiblePixel + centerCtrl.getCenterWidth();
            if (this.gos.get("enableRtl")) {
                this.needToMoveRight = xAdjustedForScroll < firstVisiblePixel + 50;
                this.needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - 50;
            } else {
                this.needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + 50;
                this.needToMoveRight = xAdjustedForScroll > lastVisiblePixel - 50;
            }
            if (this.needToMoveLeft || this.needToMoveRight) this.ensureIntervalStarted();
            else this.ensureIntervalCleared();
        }
    }
    onDragging(draggingEvent = this.lastDraggingEvent, fromEnter = false, fakeEvent = false, finished = false) {
        if (finished) {
            if (this.lastMovedInfo) {
                const { columns: columns , toIndex: toIndex  } = this.lastMovedInfo;
                $7b57b57eaf5a9648$var$moveColumns(columns, toIndex, "uiColumnMoved", true, this.columnMoveService);
            }
            return;
        }
        this.lastDraggingEvent = draggingEvent;
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(draggingEvent.hDirection)) return;
        const mouseX = $7b57b57eaf5a9648$var$normaliseX(draggingEvent.x, this.pinned, false, this.gos, this.ctrlsService);
        if (!fromEnter) this.checkCenterForScrolling(mouseX);
        const hDirection = this.normaliseDirection(draggingEvent.hDirection);
        const dragSourceType = draggingEvent.dragSource.type;
        const allMovingColumns = draggingEvent.dragSource.getDragItem().columns?.filter((col)=>{
            if (col.getColDef().lockPinned) return col.getPinned() == this.pinned;
            return true;
        }) || [];
        const lastMovedInfo = $7b57b57eaf5a9648$var$attemptMoveColumns({
            allMovingColumns: allMovingColumns,
            isFromHeader: dragSourceType === 1 /* HeaderCell */ ,
            hDirection: hDirection,
            xPosition: mouseX,
            pinned: this.pinned,
            fromEnter: fromEnter,
            fakeEvent: fakeEvent,
            gos: this.gos,
            columnModel: this.columnModel,
            columnMoveService: this.columnMoveService,
            presentedColsService: this.visibleColsService
        });
        if (lastMovedInfo) this.lastMovedInfo = lastMovedInfo;
    }
    normaliseDirection(hDirection) {
        if (this.gos.get("enableRtl")) switch(hDirection){
            case 0 /* Left */ :
                return 1 /* Right */ ;
            case 1 /* Right */ :
                return 0 /* Left */ ;
            default:
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`Unknown direction ${hDirection}`);
        }
        else return hDirection;
    }
    ensureIntervalStarted() {
        if (!this.movingIntervalId) {
            this.intervalCount = 0;
            this.failedMoveAttempts = 0;
            this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);
            this.dragAndDropService.setGhostIcon(this.needToMoveLeft ? "left" : "right", true);
        }
    }
    ensureIntervalCleared() {
        if (this.movingIntervalId) {
            window.clearInterval(this.movingIntervalId);
            this.movingIntervalId = null;
            this.dragAndDropService.setGhostIcon("move");
        }
    }
    moveInterval() {
        let pixelsToMove;
        this.intervalCount++;
        pixelsToMove = 10 + this.intervalCount * 5;
        if (pixelsToMove > 100) pixelsToMove = 100;
        let pixelsMoved = null;
        const scrollFeature = this.gridBodyCon.getScrollFeature();
        if (this.needToMoveLeft) pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);
        else if (this.needToMoveRight) pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);
        if (pixelsMoved !== 0) {
            this.onDragging(this.lastDraggingEvent);
            this.failedMoveAttempts = 0;
        } else {
            this.failedMoveAttempts++;
            const columns = this.lastDraggingEvent.dragItem.columns;
            const columnsThatCanPin = columns.filter((c)=>!c.getColDef().lockPinned);
            if (columnsThatCanPin.length > 0) {
                this.dragAndDropService.setGhostIcon("pinned");
                if (this.failedMoveAttempts > 7) {
                    const pinType = this.needToMoveLeft ? "left" : "right";
                    this.setColumnsPinned(columnsThatCanPin, pinType, "uiColumnDragged");
                    this.dragAndDropService.nudge();
                }
            }
        }
    }
};
// community-modules/core/src/headerRendering/columnDrag/bodyDropTarget.ts
var $7b57b57eaf5a9648$export$2350838bf1877b9e = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.dragAndDropService = beans.dragAndDropService;
        this.columnModel = beans.columnModel;
        this.ctrlsService = beans.ctrlsService;
    }
    constructor(pinned, eContainer){
        super();
        this.pinned = pinned;
        this.eContainer = eContainer;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            switch(this.pinned){
                case "left":
                    this.eSecondaryContainers = [
                        [
                            p.gridBodyCtrl.getBodyViewportElement(),
                            p.left.getContainerElement()
                        ],
                        [
                            p.bottomLeft.getContainerElement()
                        ],
                        [
                            p.topLeft.getContainerElement()
                        ]
                    ];
                    break;
                case "right":
                    this.eSecondaryContainers = [
                        [
                            p.gridBodyCtrl.getBodyViewportElement(),
                            p.right.getContainerElement()
                        ],
                        [
                            p.bottomRight.getContainerElement()
                        ],
                        [
                            p.topRight.getContainerElement()
                        ]
                    ];
                    break;
                default:
                    this.eSecondaryContainers = [
                        [
                            p.gridBodyCtrl.getBodyViewportElement(),
                            p.center.getViewportElement()
                        ],
                        [
                            p.bottomCenter.getViewportElement()
                        ],
                        [
                            p.topCenter.getViewportElement()
                        ]
                    ];
                    break;
            }
        });
        this.moveColumnFeature = this.createManagedBean(new $7b57b57eaf5a9648$export$a5c24618571fc64c(this.pinned));
        this.bodyDropPivotTarget = this.createManagedBean(new $7b57b57eaf5a9648$export$2828fedc973b5610(this.pinned));
        this.dragAndDropService.addDropTarget(this);
    }
    isInterestedIn(type) {
        return type === 1 /* HeaderCell */  || type === 0 /* ToolPanel */  && this.gos.get("allowDragFromColumnsToolPanel");
    }
    getSecondaryContainers() {
        return this.eSecondaryContainers;
    }
    getContainer() {
        return this.eContainer;
    }
    getIconName() {
        return this.currentDropListener.getIconName();
    }
    // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
    // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
    // dropped into the grid's body.
    isDropColumnInPivotMode(draggingEvent) {
        return this.columnModel.isPivotMode() && draggingEvent.dragSource.type === 0 /* ToolPanel */ ;
    }
    onDragEnter(draggingEvent) {
        this.currentDropListener = this.isDropColumnInPivotMode(draggingEvent) ? this.bodyDropPivotTarget : this.moveColumnFeature;
        this.currentDropListener.onDragEnter(draggingEvent);
    }
    onDragLeave(params) {
        this.currentDropListener.onDragLeave(params);
    }
    onDragging(params) {
        this.currentDropListener.onDragging(params);
    }
    onDragStop(params) {
        this.currentDropListener.onDragStop(params);
    }
};
// community-modules/core/src/headerRendering/cells/column/resizeFeature.ts
var $7b57b57eaf5a9648$var$ResizeFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.horizontalResizeService = beans.horizontalResizeService;
        this.pinnedWidthService = beans.pinnedWidthService;
        this.ctrlsService = beans.ctrlsService;
        this.columnSizeService = beans.columnSizeService;
        this.columnAutosizeService = beans.columnAutosizeService;
    }
    constructor(pinned, column, eResize, comp, ctrl){
        super();
        this.pinned = pinned;
        this.column = column;
        this.eResize = eResize;
        this.comp = comp;
        this.ctrl = ctrl;
    }
    postConstruct() {
        const destroyResizeFuncs = [];
        let canResize;
        let canAutosize;
        const addResize = ()=>{
            $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.eResize, canResize);
            if (!canResize) return;
            const finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({
                eResizeBar: this.eResize,
                onResizeStart: this.onResizeStart.bind(this),
                onResizing: this.onResizing.bind(this, false),
                onResizeEnd: this.onResizing.bind(this, true)
            });
            destroyResizeFuncs.push(finishedWithResizeFunc);
            if (canAutosize) {
                const skipHeaderOnAutoSize = this.gos.get("skipHeaderOnAutoSize");
                const autoSizeColListener = ()=>{
                    this.columnAutosizeService.autoSizeColumn(this.column, "uiColumnResized", skipHeaderOnAutoSize);
                };
                this.eResize.addEventListener("dblclick", autoSizeColListener);
                const touchListener = new $7b57b57eaf5a9648$export$7b2e93987414b382(this.eResize);
                touchListener.addEventListener("doubleTap", autoSizeColListener);
                destroyResizeFuncs.push(()=>{
                    this.eResize.removeEventListener("dblclick", autoSizeColListener);
                    touchListener.removeEventListener("doubleTap", autoSizeColListener);
                    touchListener.destroy();
                });
            }
        };
        const removeResize = ()=>{
            destroyResizeFuncs.forEach((f)=>f());
            destroyResizeFuncs.length = 0;
        };
        const refresh = ()=>{
            const resize = this.column.isResizable();
            const autoSize = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
            const propertyChange = resize !== canResize || autoSize !== canAutosize;
            if (propertyChange) {
                canResize = resize;
                canAutosize = autoSize;
                removeResize();
                addResize();
            }
        };
        refresh();
        this.addDestroyFunc(removeResize);
        this.ctrl.addRefreshFunction(refresh);
    }
    onResizing(finished, resizeAmount) {
        const { column: key , lastResizeAmount: lastResizeAmount , resizeStartWidth: resizeStartWidth  } = this;
        const resizeAmountNormalised = this.normaliseResizeAmount(resizeAmount);
        const newWidth = resizeStartWidth + resizeAmountNormalised;
        const columnWidths = [
            {
                key: key,
                newWidth: newWidth
            }
        ];
        if (this.column.getPinned()) {
            const leftWidth = this.pinnedWidthService.getPinnedLeftWidth();
            const rightWidth = this.pinnedWidthService.getPinnedRightWidth();
            const bodyWidth = $7b57b57eaf5a9648$export$cc615e4191ec3e0c(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
            if (leftWidth + rightWidth + (resizeAmountNormalised - lastResizeAmount) > bodyWidth) return;
        }
        this.lastResizeAmount = resizeAmountNormalised;
        this.columnSizeService.setColumnWidths(columnWidths, this.resizeWithShiftKey, finished, "uiColumnResized");
        if (finished) this.toggleColumnResizing(false);
    }
    onResizeStart(shiftKey) {
        this.resizeStartWidth = this.column.getActualWidth();
        this.lastResizeAmount = 0;
        this.resizeWithShiftKey = shiftKey;
        this.toggleColumnResizing(true);
    }
    toggleColumnResizing(resizing) {
        this.comp.addOrRemoveCssClass("ag-column-resizing", resizing);
    }
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
    normaliseResizeAmount(dragChange) {
        let result = dragChange;
        const notPinningLeft = this.pinned !== "left";
        const pinningRight = this.pinned === "right";
        if (this.gos.get("enableRtl")) {
            if (notPinningLeft) result *= -1;
        } else if (pinningRight) result *= -1;
        return result;
    }
};
// community-modules/core/src/headerRendering/cells/column/selectAllFeature.ts
var $7b57b57eaf5a9648$var$SelectAllFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(column){
        super();
        this.cbSelectAllVisible = false;
        this.processingEventFromCheckbox = false;
        this.column = column;
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.selectionService = beans.selectionService;
    }
    onSpaceKeyDown(e) {
        const checkbox = this.cbSelectAll;
        if (checkbox.isDisplayed() && !checkbox.getGui().contains(this.gos.getActiveDomElement())) {
            e.preventDefault();
            checkbox.setValue(!checkbox.getValue());
        }
    }
    getCheckboxGui() {
        return this.cbSelectAll.getGui();
    }
    setComp(ctrl) {
        this.headerCellCtrl = ctrl;
        this.cbSelectAll = this.createManagedBean(new $7b57b57eaf5a9648$export$b00c508c1ae18d07());
        this.cbSelectAll.addCssClass("ag-header-select-all");
        $7b57b57eaf5a9648$export$f8d01fa01787902(this.cbSelectAll.getGui(), "presentation");
        this.showOrHideSelectAll();
        this.addManagedEventListeners({
            newColumnsLoaded: this.onNewColumnsLoaded.bind(this),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            selectionChanged: this.onSelectionChanged.bind(this),
            paginationChanged: this.onSelectionChanged.bind(this),
            modelUpdated: this.onModelChanged.bind(this)
        });
        this.addManagedListeners(this.cbSelectAll, {
            fieldValueChanged: this.onCbSelectAll.bind(this)
        });
        $7b57b57eaf5a9648$export$ee52c2b3744c455d(this.cbSelectAll.getGui(), true);
        this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1");
        this.refreshSelectAllLabel();
    }
    onNewColumnsLoaded() {
        this.showOrHideSelectAll();
    }
    onDisplayedColumnsChanged() {
        if (!this.isAlive()) return;
        this.showOrHideSelectAll();
    }
    showOrHideSelectAll() {
        this.cbSelectAllVisible = this.isCheckboxSelection();
        this.cbSelectAll.setDisplayed(this.cbSelectAllVisible, {
            skipAriaHidden: true
        });
        if (this.cbSelectAllVisible) {
            this.checkRightRowModelType("selectAllCheckbox");
            this.checkSelectionType("selectAllCheckbox");
            this.updateStateOfCheckbox();
        }
        this.refreshSelectAllLabel();
    }
    onModelChanged() {
        if (!this.cbSelectAllVisible) return;
        this.updateStateOfCheckbox();
    }
    onSelectionChanged() {
        if (!this.cbSelectAllVisible) return;
        this.updateStateOfCheckbox();
    }
    updateStateOfCheckbox() {
        if (this.processingEventFromCheckbox) return;
        this.processingEventFromCheckbox = true;
        const allSelected = this.selectionService.getSelectAllState(this.isFilteredOnly(), this.isCurrentPageOnly());
        this.cbSelectAll.setValue(allSelected);
        const hasNodesToSelect = this.selectionService.hasNodesToSelect(this.isFilteredOnly(), this.isCurrentPageOnly());
        this.cbSelectAll.setDisabled(!hasNodesToSelect);
        this.refreshSelectAllLabel();
        this.processingEventFromCheckbox = false;
    }
    refreshSelectAllLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const checked = this.cbSelectAll.getValue();
        const ariaStatus = checked ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
        const ariaLabel = translate("ariaRowSelectAll", "Press Space to toggle all rows selection");
        if (!this.cbSelectAllVisible) this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null);
        else this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${ariaLabel} (${ariaStatus})`);
        this.cbSelectAll.setInputAriaLabel(`${ariaLabel} (${ariaStatus})`);
        this.headerCellCtrl.announceAriaDescription();
    }
    checkSelectionType(feature) {
        const isMultiSelect = this.gos.get("rowSelection") === "multiple";
        if (!isMultiSelect) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`${feature} is only available if using 'multiple' rowSelection.`);
            return false;
        }
        return true;
    }
    checkRightRowModelType(feature) {
        const rowModelType = this.rowModel.getType();
        const rowModelMatches = rowModelType === "clientSide" || rowModelType === "serverSide";
        if (!rowModelMatches) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`${feature} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${rowModelType}.`);
            return false;
        }
        return true;
    }
    onCbSelectAll() {
        if (this.processingEventFromCheckbox) return;
        if (!this.cbSelectAllVisible) return;
        const value = this.cbSelectAll.getValue();
        const justFiltered = this.isFilteredOnly();
        const justCurrentPage = this.isCurrentPageOnly();
        let source = "uiSelectAll";
        if (justCurrentPage) source = "uiSelectAllCurrentPage";
        else if (justFiltered) source = "uiSelectAllFiltered";
        const params = {
            source: source,
            justFiltered: justFiltered,
            justCurrentPage: justCurrentPage
        };
        if (value) this.selectionService.selectAllRowNodes(params);
        else this.selectionService.deselectAllRowNodes(params);
    }
    isCheckboxSelection() {
        let result = this.column.getColDef().headerCheckboxSelection;
        if (typeof result === "function") {
            const func = result;
            const params = this.gos.addGridCommonParams({
                column: this.column,
                colDef: this.column.getColDef()
            });
            result = func(params);
        }
        if (result) return this.checkRightRowModelType("headerCheckboxSelection") && this.checkSelectionType("headerCheckboxSelection");
        return false;
    }
    isFilteredOnly() {
        return !!this.column.getColDef().headerCheckboxSelectionFilteredOnly;
    }
    isCurrentPageOnly() {
        return !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly;
    }
};
// community-modules/core/src/headerRendering/cells/column/headerCellCtrl.ts
var $7b57b57eaf5a9648$export$8a024062e840d3f5 = class extends $7b57b57eaf5a9648$export$879ff627d5a4d5c {
    constructor(column, beans, parentRowCtrl){
        super(column, beans, parentRowCtrl);
        this.refreshFunctions = [];
        this.userHeaderClasses = /* @__PURE__ */ new Set();
        this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
        this.column = column;
    }
    setComp(comp, eGui, eResize, eHeaderCompWrapper) {
        this.comp = comp;
        this.setGui(eGui);
        this.updateState();
        this.setupWidth();
        this.setupMovingCss();
        this.setupMenuClass();
        this.setupSortableClass();
        this.setupWrapTextClass();
        this.refreshSpanHeaderHeight();
        this.setupAutoHeight(eHeaderCompWrapper);
        this.addColumnHoverListener();
        this.setupFilterClass();
        this.setupClassesFromColDef();
        this.setupTooltip();
        this.addActiveHeaderMouseListeners();
        this.setupSelectAll();
        this.setupUserComp();
        this.refreshAria();
        this.resizeFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$ResizeFeature(this.getPinned(), this.column, eResize, comp, this));
        this.createManagedBean(new $7b57b57eaf5a9648$var$HoverFeature([
            this.column
        ], eGui));
        this.createManagedBean(new $7b57b57eaf5a9648$export$84c1fb51ab89c7b5(this.column, eGui, this.beans));
        this.createManagedBean(new $7b57b57eaf5a9648$export$5510e53ed3962582(eGui, {
            shouldStopEventPropagation: (e)=>this.shouldStopEventPropagation(e),
            onTabKeyDown: ()=>null,
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this),
            onFocusOut: this.onFocusOut.bind(this)
        }));
        this.addResizeAndMoveKeyboardListeners();
        this.addManagedPropertyListeners([
            "suppressMovableColumns",
            "suppressMenuHide",
            "suppressAggFuncInHeader"
        ], this.refresh.bind(this));
        this.addManagedListeners(this.column, {
            colDefChanged: this.refresh.bind(this)
        });
        this.addManagedEventListeners({
            columnValueChanged: this.onColumnValueChanged.bind(this),
            columnRowGroupChanged: this.onColumnRowGroupChanged.bind(this),
            columnPivotChanged: this.onColumnPivotChanged.bind(this),
            headerHeightChanged: this.onHeaderHeightChanged.bind(this)
        });
    }
    resizeHeader(delta, shiftKey) {
        if (!this.column.isResizable()) return;
        const actualWidth = this.column.getActualWidth();
        const minWidth = this.column.getMinWidth();
        const maxWidth = this.column.getMaxWidth();
        const newWidth = Math.min(Math.max(actualWidth + delta, minWidth), maxWidth);
        this.beans.columnSizeService.setColumnWidths([
            {
                key: this.column,
                newWidth: newWidth
            }
        ], shiftKey, true, "uiColumnResized");
    }
    moveHeader(hDirection) {
        const { eGui: eGui , column: column , gos: gos , ctrlsService: ctrlsService  } = this;
        const pinned = this.getPinned();
        const left = eGui.getBoundingClientRect().left;
        const width = column.getActualWidth();
        const isRtl = gos.get("enableRtl");
        const isLeft = hDirection === 0 /* Left */  !== isRtl;
        const xPosition = $7b57b57eaf5a9648$var$normaliseX(isLeft ? left - 20 : left + width + 20, pinned, true, gos, ctrlsService);
        $7b57b57eaf5a9648$var$attemptMoveColumns({
            allMovingColumns: [
                column
            ],
            isFromHeader: true,
            hDirection: hDirection,
            xPosition: xPosition,
            pinned: pinned,
            fromEnter: false,
            fakeEvent: false,
            gos: gos,
            columnModel: this.beans.columnModel,
            columnMoveService: this.beans.columnMoveService,
            presentedColsService: this.beans.visibleColsService
        });
        ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(column, "auto");
    }
    setupUserComp() {
        const compDetails = this.lookupUserCompDetails();
        this.setCompDetails(compDetails);
    }
    setCompDetails(compDetails) {
        this.userCompDetails = compDetails;
        this.comp.setUserCompDetails(compDetails);
    }
    lookupUserCompDetails() {
        const params = this.createParams();
        const colDef = this.column.getColDef();
        return this.userComponentFactory.getHeaderCompDetails(colDef, params);
    }
    createParams() {
        const params = this.gos.addGridCommonParams({
            column: this.column,
            displayName: this.displayName,
            enableSorting: this.column.isSortable(),
            enableMenu: this.menuEnabled,
            enableFilterButton: this.openFilterEnabled && this.menuService.isHeaderFilterButtonEnabled(this.column),
            enableFilterIcon: !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(),
            showColumnMenu: (buttonElement)=>{
                this.menuService.showColumnMenu({
                    column: this.column,
                    buttonElement: buttonElement,
                    positionBy: "button"
                });
            },
            showColumnMenuAfterMouseClick: (mouseEvent)=>{
                this.menuService.showColumnMenu({
                    column: this.column,
                    mouseEvent: mouseEvent,
                    positionBy: "mouse"
                });
            },
            showFilter: (buttonElement)=>{
                this.menuService.showFilterMenu({
                    column: this.column,
                    buttonElement: buttonElement,
                    containerType: "columnFilter",
                    positionBy: "button"
                });
            },
            progressSort: (multiSort)=>{
                this.beans.sortController.progressSort(this.column, !!multiSort, "uiColumnSorted");
            },
            setSort: (sort, multiSort)=>{
                this.beans.sortController.setSortForColumn(this.column, sort, !!multiSort, "uiColumnSorted");
            },
            eGridHeader: this.getGui(),
            setTooltip: (value, shouldDisplayTooltip)=>{
                this.setupTooltip(value, shouldDisplayTooltip);
            }
        });
        return params;
    }
    setupSelectAll() {
        this.selectAllFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$SelectAllFeature(this.column));
        this.selectAllFeature.setComp(this);
    }
    getSelectAllGui() {
        return this.selectAllFeature.getCheckboxGui();
    }
    handleKeyDown(e) {
        super.handleKeyDown(e);
        if (e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.SPACE) this.selectAllFeature.onSpaceKeyDown(e);
        if (e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER) this.onEnterKeyDown(e);
        if (e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN && e.altKey) this.showMenuOnKeyPress(e, false);
    }
    onEnterKeyDown(e) {
        if (e.ctrlKey || e.metaKey) this.showMenuOnKeyPress(e, true);
        else if (this.sortable) {
            const multiSort = e.shiftKey;
            this.beans.sortController.progressSort(this.column, multiSort, "uiColumnSorted");
        }
    }
    showMenuOnKeyPress(e, isFilterShortcut) {
        const headerComp = this.comp.getUserCompInstance();
        if (!headerComp || !(headerComp instanceof $7b57b57eaf5a9648$var$HeaderComp)) return;
        if (headerComp.onMenuKeyboardShortcut(isFilterShortcut)) e.preventDefault();
    }
    onFocusIn(e) {
        if (!this.getGui().contains(e.relatedTarget)) {
            const rowIndex = this.getRowIndex();
            this.focusService.setFocusedHeader(rowIndex, this.column);
            this.announceAriaDescription();
        }
        if (this.focusService.isKeyboardMode()) this.setActiveHeader(true);
    }
    onFocusOut(e) {
        if (this.getGui().contains(e.relatedTarget)) return;
        this.setActiveHeader(false);
    }
    setupTooltip(value, shouldDisplayTooltip) {
        if (this.tooltipFeature) this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        const isTooltipWhenTruncated = this.gos.get("tooltipShowMode") === "whenTruncated";
        const eGui = this.eGui;
        const colDef = this.column.getColDef();
        if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colDef.headerComponent) shouldDisplayTooltip = ()=>{
            const textEl = eGui.querySelector(".ag-header-cell-text");
            if (!textEl) return true;
            return textEl.scrollWidth > textEl.clientWidth;
        };
        const tooltipCtrl = {
            getColumn: ()=>this.column,
            getColDef: ()=>this.column.getColDef(),
            getGui: ()=>eGui,
            getLocation: ()=>"header",
            getTooltipValue: ()=>{
                if (value != null) return value;
                const res = this.column.getColDef().headerTooltip;
                return res;
            },
            shouldDisplayTooltip: shouldDisplayTooltip
        };
        const tooltipFeature = this.createManagedBean(new $7b57b57eaf5a9648$export$e5073a590d24815c(tooltipCtrl));
        this.refreshFunctions.push(()=>tooltipFeature.refreshToolTip());
    }
    setupClassesFromColDef() {
        const refreshHeaderClasses = ()=>{
            const colDef = this.column.getColDef();
            const classes = $7b57b57eaf5a9648$export$9ba3bd48c77c5e8a(colDef, this.gos, this.column, null);
            const oldClasses = this.userHeaderClasses;
            this.userHeaderClasses = new Set(classes);
            classes.forEach((c)=>{
                if (oldClasses.has(c)) oldClasses.delete(c);
                else this.comp.addOrRemoveCssClass(c, true);
            });
            oldClasses.forEach((c)=>this.comp.addOrRemoveCssClass(c, false));
        };
        this.refreshFunctions.push(refreshHeaderClasses);
        refreshHeaderClasses();
    }
    setDragSource(eSource) {
        this.dragSourceElement = eSource;
        this.removeDragSource();
        if (!eSource || !this.draggable) return;
        const { column: column , beans: beans , displayName: displayName , dragAndDropService: dragAndDropService , gos: gos  } = this;
        const { columnModel: columnModel  } = beans;
        let hideColumnOnExit = !this.gos.get("suppressDragLeaveHidesColumns");
        const dragSource = this.dragSource = {
            type: 1 /* HeaderCell */ ,
            eElement: eSource,
            getDefaultIconName: ()=>hideColumnOnExit ? "hide" : "notAllowed",
            getDragItem: ()=>this.createDragItem(column),
            dragItemName: displayName,
            onDragStarted: ()=>{
                hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
                column.setMoving(true, "uiColumnMoved");
            },
            onDragStopped: ()=>column.setMoving(false, "uiColumnMoved"),
            onGridEnter: (dragItem)=>{
                if (hideColumnOnExit) {
                    const unlockedColumns = dragItem?.columns?.filter((col)=>!col.getColDef().lockVisible) || [];
                    columnModel.setColsVisible(unlockedColumns, true, "uiColumnMoved");
                }
            },
            onGridExit: (dragItem)=>{
                if (hideColumnOnExit) {
                    const unlockedColumns = dragItem?.columns?.filter((col)=>!col.getColDef().lockVisible) || [];
                    columnModel.setColsVisible(unlockedColumns, false, "uiColumnMoved");
                }
            }
        };
        dragAndDropService.addDragSource(dragSource, true);
    }
    createDragItem(column) {
        const visibleState = {};
        visibleState[column.getId()] = column.isVisible();
        return {
            columns: [
                column
            ],
            visibleState: visibleState
        };
    }
    updateState() {
        this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(this.column);
        this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(this.column);
        this.sortable = this.column.isSortable();
        this.displayName = this.calculateDisplayName();
        this.draggable = this.workOutDraggable();
    }
    addRefreshFunction(func) {
        this.refreshFunctions.push(func);
    }
    refresh() {
        this.updateState();
        this.refreshHeaderComp();
        this.refreshAria();
        this.refreshFunctions.forEach((f)=>f());
    }
    refreshHeaderComp() {
        const newCompDetails = this.lookupUserCompDetails();
        const compInstance = this.comp.getUserCompInstance();
        const attemptRefresh = compInstance != null && this.userCompDetails.componentClass == newCompDetails.componentClass;
        const headerCompRefreshed = attemptRefresh ? this.attemptHeaderCompRefresh(newCompDetails.params) : false;
        if (headerCompRefreshed) this.setDragSource(this.dragSourceElement);
        else this.setCompDetails(newCompDetails);
    }
    attemptHeaderCompRefresh(params) {
        const headerComp = this.comp.getUserCompInstance();
        if (!headerComp) return false;
        if (!headerComp.refresh) return false;
        const res = headerComp.refresh(params);
        return res;
    }
    calculateDisplayName() {
        return this.beans.columnNameService.getDisplayNameForColumn(this.column, "header", true);
    }
    checkDisplayName() {
        if (this.displayName !== this.calculateDisplayName()) this.refresh();
    }
    workOutDraggable() {
        const colDef = this.column.getColDef();
        const isSuppressMovableColumns = this.gos.get("suppressMovableColumns");
        const colCanMove = !isSuppressMovableColumns && !colDef.suppressMovable && !colDef.lockPosition;
        return !!colCanMove || !!colDef.enableRowGroup || !!colDef.enablePivot;
    }
    onColumnRowGroupChanged() {
        this.checkDisplayName();
    }
    onColumnPivotChanged() {
        this.checkDisplayName();
    }
    onColumnValueChanged() {
        this.checkDisplayName();
    }
    setupWidth() {
        const listener = ()=>{
            const columnWidth = this.column.getActualWidth();
            this.comp.setWidth(`${columnWidth}px`);
        };
        this.addManagedListeners(this.column, {
            widthChanged: listener
        });
        listener();
    }
    setupMovingCss() {
        const listener = ()=>{
            this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
        };
        this.addManagedListeners(this.column, {
            movingChanged: listener
        });
        listener();
    }
    setupMenuClass() {
        const listener = ()=>{
            this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
        };
        this.addManagedListeners(this.column, {
            menuVisibleChanged: listener
        });
        listener();
    }
    setupSortableClass() {
        const updateSortableCssClass = ()=>{
            this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
        };
        updateSortableCssClass();
        this.addRefreshFunction(updateSortableCssClass);
        this.addManagedEventListeners({
            sortChanged: this.refreshAriaSort.bind(this)
        });
    }
    setupFilterClass() {
        const listener = ()=>{
            const isFilterActive = this.column.isFilterActive();
            this.comp.addOrRemoveCssClass("ag-header-cell-filtered", isFilterActive);
            this.refreshAria();
        };
        this.addManagedListeners(this.column, {
            filterActiveChanged: listener
        });
        listener();
    }
    setupWrapTextClass() {
        const listener = ()=>{
            const wrapText = !!this.column.getColDef().wrapHeaderText;
            this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", wrapText);
        };
        listener();
        this.addRefreshFunction(listener);
    }
    onDisplayedColumnsChanged() {
        super.onDisplayedColumnsChanged();
        if (!this.isAlive()) return;
        this.onHeaderHeightChanged();
    }
    onHeaderHeightChanged() {
        this.refreshSpanHeaderHeight();
    }
    refreshSpanHeaderHeight() {
        const { eGui: eGui , column: column , comp: comp , beans: beans  } = this;
        if (!column.isSpanHeaderHeight()) {
            eGui.style.removeProperty("top");
            eGui.style.removeProperty("height");
            comp.addOrRemoveCssClass("ag-header-span-height", false);
            comp.addOrRemoveCssClass("ag-header-span-total", false);
            return;
        }
        const { numberOfParents: numberOfParents , isSpanningTotal: isSpanningTotal  } = this.column.getColumnGroupPaddingInfo();
        comp.addOrRemoveCssClass("ag-header-span-height", numberOfParents > 0);
        const { columnModel: columnModel  } = beans;
        const headerHeight = columnModel.getColumnHeaderRowHeight();
        if (numberOfParents === 0) {
            comp.addOrRemoveCssClass("ag-header-span-total", false);
            eGui.style.setProperty("top", `0px`);
            eGui.style.setProperty("height", `${headerHeight}px`);
            return;
        }
        comp.addOrRemoveCssClass("ag-header-span-total", isSpanningTotal);
        const pivotMode = columnModel.isPivotMode();
        const groupHeaderHeight = pivotMode ? columnModel.getPivotGroupHeaderHeight() : columnModel.getGroupHeaderHeight();
        const extraHeight = numberOfParents * groupHeaderHeight;
        eGui.style.setProperty("top", `${-extraHeight}px`);
        eGui.style.setProperty("height", `${headerHeight + extraHeight}px`);
    }
    setupAutoHeight(wrapperElement) {
        const { columnModel: columnModel , resizeObserverService: resizeObserverService  } = this.beans;
        const measureHeight = (timesCalled)=>{
            if (!this.isAlive()) return;
            const { paddingTop: paddingTop , paddingBottom: paddingBottom , borderBottomWidth: borderBottomWidth , borderTopWidth: borderTopWidth  } = $7b57b57eaf5a9648$var$_getElementSize(this.getGui());
            const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
            const wrapperHeight = wrapperElement.offsetHeight;
            const autoHeight = wrapperHeight + extraHeight;
            if (timesCalled < 5) {
                const doc = this.beans.gos.getDocument();
                const notYetInDom = !doc || !doc.contains(wrapperElement);
                const possiblyNoContentYet = autoHeight == 0;
                if (notYetInDom || possiblyNoContentYet) {
                    window.setTimeout(()=>measureHeight(timesCalled + 1), 0);
                    return;
                }
            }
            columnModel.setColHeaderHeight(this.column, autoHeight);
        };
        let isMeasuring = false;
        let stopResizeObserver;
        const checkMeasuring = ()=>{
            const newValue = this.column.isAutoHeaderHeight();
            if (newValue && !isMeasuring) startMeasuring();
            if (!newValue && isMeasuring) stopMeasuring();
        };
        const startMeasuring = ()=>{
            isMeasuring = true;
            measureHeight(0);
            this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", true);
            stopResizeObserver = resizeObserverService.observeResize(wrapperElement, ()=>measureHeight(0));
        };
        const stopMeasuring = ()=>{
            isMeasuring = false;
            if (stopResizeObserver) stopResizeObserver();
            this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", false);
            stopResizeObserver = void 0;
        };
        checkMeasuring();
        this.addDestroyFunc(()=>stopMeasuring());
        this.addManagedListeners(this.column, {
            widthChanged: ()=>isMeasuring && measureHeight(0)
        });
        this.addManagedEventListeners({
            sortChanged: ()=>{
                if (isMeasuring) window.setTimeout(()=>measureHeight(0));
            }
        });
        this.addRefreshFunction(checkMeasuring);
    }
    refreshAriaSort() {
        if (this.sortable) {
            const translate = this.localeService.getLocaleTextFunc();
            const sort = this.beans.sortController.getDisplaySortForColumn(this.column) || null;
            this.comp.setAriaSort($7b57b57eaf5a9648$var$_getAriaSortState(sort));
            this.setAriaDescriptionProperty("sort", translate("ariaSortableColumn", "Press ENTER to sort"));
        } else {
            this.comp.setAriaSort();
            this.setAriaDescriptionProperty("sort", null);
        }
    }
    refreshAriaMenu() {
        if (this.menuEnabled) {
            const translate = this.localeService.getLocaleTextFunc();
            this.setAriaDescriptionProperty("menu", translate("ariaMenuColumn", "Press ALT DOWN to open column menu"));
        } else this.setAriaDescriptionProperty("menu", null);
    }
    refreshAriaFilterButton() {
        if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
            const translate = this.localeService.getLocaleTextFunc();
            this.setAriaDescriptionProperty("filterButton", translate("ariaFilterColumn", "Press CTRL ENTER to open filter"));
        } else this.setAriaDescriptionProperty("filterButton", null);
    }
    refreshAriaFiltered() {
        const translate = this.localeService.getLocaleTextFunc();
        const isFilterActive = this.column.isFilterActive();
        if (isFilterActive) this.setAriaDescriptionProperty("filter", translate("ariaColumnFiltered", "Column Filtered"));
        else this.setAriaDescriptionProperty("filter", null);
    }
    setAriaDescriptionProperty(property, value) {
        if (value != null) this.ariaDescriptionProperties.set(property, value);
        else this.ariaDescriptionProperties.delete(property);
    }
    announceAriaDescription() {
        if (!this.eGui.contains(this.beans.gos.getActiveDomElement())) return;
        const ariaDescription = Array.from(this.ariaDescriptionProperties.keys()).sort((a, b)=>a === "filter" ? -1 : b.charCodeAt(0) - a.charCodeAt(0)).map((key)=>this.ariaDescriptionProperties.get(key)).join(". ");
        this.beans.ariaAnnouncementService.announceValue(ariaDescription);
    }
    refreshAria() {
        this.refreshAriaSort();
        this.refreshAriaMenu();
        this.refreshAriaFilterButton();
        this.refreshAriaFiltered();
    }
    addColumnHoverListener() {
        const listener = ()=>{
            if (!this.gos.get("columnHoverHighlight")) return;
            const isHovered = this.beans.columnHoverService.isHovered(this.column);
            this.comp.addOrRemoveCssClass("ag-column-hover", isHovered);
        };
        this.addManagedEventListeners({
            columnHoverChanged: listener
        });
        listener();
    }
    getColId() {
        return this.column.getColId();
    }
    addActiveHeaderMouseListeners() {
        const listener = (e)=>this.handleMouseOverChange(e.type === "mouseenter");
        const clickListener = ()=>this.dispatchColumnMouseEvent("columnHeaderClicked", this.column);
        const contextMenuListener = (event)=>this.handleContextMenuMouseEvent(event, void 0, this.column);
        this.addManagedListeners(this.getGui(), {
            mouseenter: listener,
            mouseleave: listener,
            click: clickListener,
            contextmenu: contextMenuListener
        });
    }
    handleMouseOverChange(isMouseOver) {
        this.setActiveHeader(isMouseOver);
        const eventType = isMouseOver ? "columnHeaderMouseOver" : "columnHeaderMouseLeave";
        const event = {
            type: eventType,
            column: this.column
        };
        this.eventService.dispatchEvent(event);
    }
    setActiveHeader(active) {
        this.comp.addOrRemoveCssClass("ag-header-active", active);
    }
    getAnchorElementForMenu(isFilter) {
        const headerComp = this.comp.getUserCompInstance();
        if (headerComp instanceof $7b57b57eaf5a9648$var$HeaderComp) return headerComp.getAnchorElementForMenu(isFilter);
        return this.getGui();
    }
    destroy() {
        super.destroy();
        this.refreshFunctions = null;
        this.selectAllFeature = null;
        this.dragSourceElement = null;
        this.userCompDetails = null;
        this.userHeaderClasses = null;
        this.ariaDescriptionProperties = null;
    }
};
// community-modules/core/src/headerRendering/cells/columnGroup/groupResizeFeature.ts
var $7b57b57eaf5a9648$var$GroupResizeFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.horizontalResizeService = beans.horizontalResizeService;
        this.autoWidthCalculator = beans.autoWidthCalculator;
        this.visibleColsService = beans.visibleColsService;
        this.columnSizeService = beans.columnSizeService;
        this.columnAutosizeService = beans.columnAutosizeService;
    }
    constructor(comp, eResize, pinned, columnGroup){
        super();
        this.eResize = eResize;
        this.comp = comp;
        this.pinned = pinned;
        this.columnGroup = columnGroup;
    }
    postConstruct() {
        if (!this.columnGroup.isResizable()) {
            this.comp.setResizableDisplayed(false);
            return;
        }
        const finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({
            eResizeBar: this.eResize,
            onResizeStart: this.onResizeStart.bind(this),
            onResizing: this.onResizing.bind(this, false),
            onResizeEnd: this.onResizing.bind(this, true)
        });
        this.addDestroyFunc(finishedWithResizeFunc);
        if (!this.gos.get("suppressAutoSize")) {
            const skipHeaderOnAutoSize = this.gos.get("skipHeaderOnAutoSize");
            this.eResize.addEventListener("dblclick", ()=>{
                const keys = [];
                const leafCols = this.columnGroup.getDisplayedLeafColumns();
                leafCols.forEach((column)=>{
                    if (!column.getColDef().suppressAutoSize) keys.push(column.getColId());
                });
                if (keys.length > 0) this.columnAutosizeService.autoSizeCols({
                    colKeys: keys,
                    skipHeader: skipHeaderOnAutoSize,
                    stopAtGroup: this.columnGroup,
                    source: "uiColumnResized"
                });
                this.resizeLeafColumnsToFit("uiColumnResized");
            });
        }
    }
    onResizeStart(shiftKey) {
        const initialValues = this.getInitialValues(shiftKey);
        this.storeLocalValues(initialValues);
        this.toggleColumnResizing(true);
    }
    onResizing(finished, resizeAmount, source = "uiColumnResized") {
        const resizeAmountNormalised = this.normaliseDragChange(resizeAmount);
        const width = this.resizeStartWidth + resizeAmountNormalised;
        this.resizeColumnsFromLocalValues(width, source, finished);
    }
    getInitialValues(shiftKey) {
        const columnsToResize = this.getColumnsToResize();
        const resizeStartWidth = this.getInitialSizeOfColumns(columnsToResize);
        const resizeRatios = this.getSizeRatiosOfColumns(columnsToResize, resizeStartWidth);
        const columnSizeAndRatios = {
            columnsToResize: columnsToResize,
            resizeStartWidth: resizeStartWidth,
            resizeRatios: resizeRatios
        };
        let groupAfter = null;
        if (shiftKey) groupAfter = this.visibleColsService.getGroupAtDirection(this.columnGroup, "After");
        if (groupAfter) {
            const takeFromLeafCols = groupAfter.getDisplayedLeafColumns();
            const groupAfterColumns = columnSizeAndRatios.groupAfterColumns = takeFromLeafCols.filter((col)=>col.isResizable());
            const groupAfterStartWidth = columnSizeAndRatios.groupAfterStartWidth = this.getInitialSizeOfColumns(groupAfterColumns);
            columnSizeAndRatios.groupAfterRatios = this.getSizeRatiosOfColumns(groupAfterColumns, groupAfterStartWidth);
        } else {
            columnSizeAndRatios.groupAfterColumns = void 0;
            columnSizeAndRatios.groupAfterStartWidth = void 0;
            columnSizeAndRatios.groupAfterRatios = void 0;
        }
        return columnSizeAndRatios;
    }
    storeLocalValues(initialValues) {
        const { columnsToResize: columnsToResize , resizeStartWidth: resizeStartWidth , resizeRatios: resizeRatios , groupAfterColumns: groupAfterColumns , groupAfterStartWidth: groupAfterStartWidth , groupAfterRatios: groupAfterRatios  } = initialValues;
        this.resizeCols = columnsToResize;
        this.resizeStartWidth = resizeStartWidth;
        this.resizeRatios = resizeRatios;
        this.resizeTakeFromCols = groupAfterColumns;
        this.resizeTakeFromStartWidth = groupAfterStartWidth;
        this.resizeTakeFromRatios = groupAfterRatios;
    }
    clearLocalValues() {
        this.resizeCols = void 0;
        this.resizeRatios = void 0;
        this.resizeTakeFromCols = void 0;
        this.resizeTakeFromRatios = void 0;
    }
    resizeLeafColumnsToFit(source) {
        const preferredSize = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup);
        const initialValues = this.getInitialValues();
        if (preferredSize > initialValues.resizeStartWidth) this.resizeColumns(initialValues, preferredSize, source, true);
    }
    resizeColumnsFromLocalValues(totalWidth, source, finished = true) {
        if (!this.resizeCols || !this.resizeRatios) return;
        const initialValues = {
            columnsToResize: this.resizeCols,
            resizeStartWidth: this.resizeStartWidth,
            resizeRatios: this.resizeRatios,
            groupAfterColumns: this.resizeTakeFromCols ?? void 0,
            groupAfterStartWidth: this.resizeTakeFromStartWidth ?? void 0,
            groupAfterRatios: this.resizeTakeFromRatios ?? void 0
        };
        this.resizeColumns(initialValues, totalWidth, source, finished);
    }
    resizeColumns(initialValues, totalWidth, source, finished = true) {
        const { columnsToResize: columnsToResize , resizeStartWidth: resizeStartWidth , resizeRatios: resizeRatios , groupAfterColumns: groupAfterColumns , groupAfterStartWidth: groupAfterStartWidth , groupAfterRatios: groupAfterRatios  } = initialValues;
        const resizeSets = [];
        resizeSets.push({
            columns: columnsToResize,
            ratios: resizeRatios,
            width: totalWidth
        });
        if (groupAfterColumns) {
            const diff = totalWidth - resizeStartWidth;
            resizeSets.push({
                columns: groupAfterColumns,
                ratios: groupAfterRatios,
                width: groupAfterStartWidth - diff
            });
        }
        this.columnSizeService.resizeColumnSets({
            resizeSets: resizeSets,
            finished: finished,
            source: source
        });
        if (finished) this.toggleColumnResizing(false);
    }
    toggleColumnResizing(resizing) {
        this.comp.addOrRemoveCssClass("ag-column-resizing", resizing);
    }
    getColumnsToResize() {
        const leafCols = this.columnGroup.getDisplayedLeafColumns();
        return leafCols.filter((col)=>col.isResizable());
    }
    getInitialSizeOfColumns(columns) {
        return columns.reduce((totalWidth, column)=>totalWidth + column.getActualWidth(), 0);
    }
    getSizeRatiosOfColumns(columns, initialSizeOfColumns) {
        return columns.map((column)=>column.getActualWidth() / initialSizeOfColumns);
    }
    // optionally inverts the drag, depending on pinned and RTL
    // note - this method is duplicated in RenderedHeaderCell - should refactor out?
    normaliseDragChange(dragChange) {
        let result = dragChange;
        if (this.gos.get("enableRtl")) {
            if (this.pinned !== "left") result *= -1;
        } else if (this.pinned === "right") result *= -1;
        return result;
    }
    destroy() {
        super.destroy();
        this.clearLocalValues();
    }
};
// community-modules/core/src/headerRendering/cells/columnGroup/groupWidthFeature.ts
var $7b57b57eaf5a9648$var$GroupWidthFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(comp, columnGroup){
        super();
        // the children can change, we keep destroy functions related to listening to the children here
        this.removeChildListenersFuncs = [];
        this.columnGroup = columnGroup;
        this.comp = comp;
    }
    postConstruct() {
        this.addListenersToChildrenColumns();
        this.addManagedListeners(this.columnGroup, {
            displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
        });
        this.onWidthChanged();
        this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
    }
    addListenersToChildrenColumns() {
        this.removeListenersOnChildrenColumns();
        const widthChangedListener = this.onWidthChanged.bind(this);
        this.columnGroup.getLeafColumns().forEach((column)=>{
            column.addEventListener("widthChanged", widthChangedListener);
            column.addEventListener("visibleChanged", widthChangedListener);
            this.removeChildListenersFuncs.push(()=>{
                column.removeEventListener("widthChanged", widthChangedListener);
                column.removeEventListener("visibleChanged", widthChangedListener);
            });
        });
    }
    removeListenersOnChildrenColumns() {
        this.removeChildListenersFuncs.forEach((func)=>func());
        this.removeChildListenersFuncs = [];
    }
    onDisplayedChildrenChanged() {
        this.addListenersToChildrenColumns();
        this.onWidthChanged();
    }
    onWidthChanged() {
        const columnWidth = this.columnGroup.getActualWidth();
        this.comp.setWidth(`${columnWidth}px`);
        this.comp.addOrRemoveCssClass("ag-hidden", columnWidth === 0);
    }
};
// community-modules/core/src/headerRendering/cells/columnGroup/headerGroupCellCtrl.ts
var $7b57b57eaf5a9648$export$6ab7b303345e4c8 = class extends $7b57b57eaf5a9648$export$879ff627d5a4d5c {
    constructor(columnGroup, beans, parentRowCtrl){
        super(columnGroup, beans, parentRowCtrl);
        this.onSuppressColMoveChange = ()=>{
            if (!this.isAlive() || this.isSuppressMoving()) this.removeDragSource();
            else if (!this.dragSource) {
                const eGui = this.getGui();
                this.setDragSource(eGui);
            }
        };
        this.column = columnGroup;
    }
    setComp(comp, eGui, eResize) {
        this.comp = comp;
        this.setGui(eGui);
        this.displayName = this.beans.columnNameService.getDisplayNameForColumnGroup(this.column, "header");
        this.addClasses();
        this.setupMovingCss();
        this.setupExpandable();
        this.setupTooltip();
        this.addDestroyFunc(()=>{
            if (this.tooltipFeature) this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        });
        this.setupUserComp();
        this.addHeaderMouseListeners();
        const pinned = this.getParentRowCtrl().getPinned();
        const leafCols = this.column.getProvidedColumnGroup().getLeafColumns();
        this.createManagedBean(new $7b57b57eaf5a9648$var$HoverFeature(leafCols, eGui));
        this.createManagedBean(new $7b57b57eaf5a9648$export$84c1fb51ab89c7b5(this.column, eGui, this.beans));
        this.createManagedBean(new $7b57b57eaf5a9648$var$GroupWidthFeature(comp, this.column));
        this.resizeFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$GroupResizeFeature(comp, eResize, pinned, this.column));
        this.createManagedBean(new $7b57b57eaf5a9648$export$5510e53ed3962582(eGui, {
            shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
            onTabKeyDown: ()=>void 0,
            handleKeyDown: this.handleKeyDown.bind(this),
            onFocusIn: this.onFocusIn.bind(this)
        }));
        this.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange);
        this.addResizeAndMoveKeyboardListeners();
    }
    resizeHeader(delta, shiftKey) {
        if (!this.resizeFeature) return;
        const initialValues = this.resizeFeature.getInitialValues(shiftKey);
        this.resizeFeature.resizeColumns(initialValues, initialValues.resizeStartWidth + delta, "uiColumnResized", true);
    }
    moveHeader(hDirection) {
        const { beans: beans , eGui: eGui , column: column , gos: gos , ctrlsService: ctrlsService  } = this;
        const isRtl = gos.get("enableRtl");
        const isLeft = hDirection === 0 /* Left */ ;
        const pinned = this.getPinned();
        const rect = eGui.getBoundingClientRect();
        const left = rect.left;
        const width = rect.width;
        const xPosition = $7b57b57eaf5a9648$var$normaliseX(isLeft !== isRtl ? left - 20 : left + width + 20, pinned, true, gos, ctrlsService);
        const id = column.getGroupId();
        const headerPosition = this.focusService.getFocusedHeader();
        $7b57b57eaf5a9648$var$attemptMoveColumns({
            allMovingColumns: this.column.getLeafColumns(),
            isFromHeader: true,
            hDirection: hDirection,
            xPosition: xPosition,
            pinned: pinned,
            fromEnter: false,
            fakeEvent: false,
            gos: gos,
            columnModel: beans.columnModel,
            columnMoveService: beans.columnMoveService,
            presentedColsService: beans.visibleColsService
        });
        const displayedLeafColumns = column.getDisplayedLeafColumns();
        const targetColumn = isLeft ? displayedLeafColumns[0] : $7b57b57eaf5a9648$export$236389741107357f(displayedLeafColumns);
        this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(targetColumn, "auto");
        if (!this.isAlive() && headerPosition) this.restoreFocus(id, column, headerPosition);
    }
    restoreFocus(groupId, previousColumnGroup, previousPosition) {
        const leafCols = previousColumnGroup.getLeafColumns();
        if (!leafCols.length) return;
        const parent = leafCols[0].getParent();
        if (!parent) return;
        const newColumnGroup = this.findGroupWidthId(parent, groupId);
        if (newColumnGroup) this.focusService.focusHeaderPosition({
            headerPosition: {
                ...previousPosition,
                column: newColumnGroup
            }
        });
    }
    findGroupWidthId(columnGroup, id) {
        while(columnGroup){
            if (columnGroup.getGroupId() === id) return columnGroup;
            columnGroup = columnGroup.getParent();
        }
        return null;
    }
    resizeLeafColumnsToFit(source) {
        if (!this.resizeFeature) return;
        this.resizeFeature.resizeLeafColumnsToFit(source);
    }
    setupUserComp() {
        const params = this.gos.addGridCommonParams({
            displayName: this.displayName,
            columnGroup: this.column,
            setExpanded: (expanded)=>{
                this.beans.columnModel.setColumnGroupOpened(this.column.getProvidedColumnGroup(), expanded, "gridInitializing");
            },
            setTooltip: (value, shouldDisplayTooltip)=>{
                this.setupTooltip(value, shouldDisplayTooltip);
            }
        });
        const compDetails = this.userComponentFactory.getHeaderGroupCompDetails(params);
        this.comp.setUserCompDetails(compDetails);
    }
    addHeaderMouseListeners() {
        const listener = (e)=>this.handleMouseOverChange(e.type === "mouseenter");
        const clickListener = ()=>this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup());
        const contextMenuListener = (event)=>this.handleContextMenuMouseEvent(event, void 0, this.column.getProvidedColumnGroup());
        this.addManagedListeners(this.getGui(), {
            mouseenter: listener,
            mouseleave: listener,
            click: clickListener,
            contextmenu: contextMenuListener
        });
    }
    handleMouseOverChange(isMouseOver) {
        const eventType = isMouseOver ? "columnHeaderMouseOver" : "columnHeaderMouseLeave";
        const event = {
            type: eventType,
            column: this.column.getProvidedColumnGroup()
        };
        this.eventService.dispatchEvent(event);
    }
    setupTooltip(value, shouldDisplayTooltip) {
        if (this.tooltipFeature) this.tooltipFeature = this.destroyBean(this.tooltipFeature);
        const colGroupDef = this.column.getColGroupDef();
        const isTooltipWhenTruncated = this.gos.get("tooltipShowMode") === "whenTruncated";
        const eGui = this.eGui;
        if (!shouldDisplayTooltip && isTooltipWhenTruncated && !colGroupDef?.headerGroupComponent) shouldDisplayTooltip = ()=>{
            const textEl = eGui.querySelector(".ag-header-group-text");
            if (!textEl) return true;
            return textEl.scrollWidth > textEl.clientWidth;
        };
        const tooltipCtrl = {
            getColumn: ()=>this.column,
            getGui: ()=>eGui,
            getLocation: ()=>"headerGroup",
            getTooltipValue: ()=>value ?? (colGroupDef && colGroupDef.headerTooltip),
            shouldDisplayTooltip: shouldDisplayTooltip
        };
        if (colGroupDef) tooltipCtrl.getColDef = ()=>colGroupDef;
        this.createManagedBean(new $7b57b57eaf5a9648$export$e5073a590d24815c(tooltipCtrl));
    }
    setupExpandable() {
        const providedColGroup = this.column.getProvidedColumnGroup();
        this.refreshExpanded();
        const listener = this.refreshExpanded.bind(this);
        this.addManagedListeners(providedColGroup, {
            expandedChanged: listener,
            expandableChanged: listener
        });
    }
    refreshExpanded() {
        const { column: column  } = this;
        this.expandable = column.isExpandable();
        const expanded = column.isExpanded();
        if (this.expandable) this.comp.setAriaExpanded(expanded ? "true" : "false");
        else this.comp.setAriaExpanded(void 0);
    }
    getColId() {
        return this.column.getUniqueId();
    }
    addClasses() {
        const colGroupDef = this.column.getColGroupDef();
        const classes = $7b57b57eaf5a9648$export$9ba3bd48c77c5e8a(colGroupDef, this.gos, null, this.column);
        if (this.column.isPadding()) {
            classes.push("ag-header-group-cell-no-group");
            const leafCols = this.column.getLeafColumns();
            if (leafCols.every((col)=>col.isSpanHeaderHeight())) classes.push("ag-header-span-height");
        } else classes.push("ag-header-group-cell-with-group");
        classes.forEach((c)=>this.comp.addOrRemoveCssClass(c, true));
    }
    setupMovingCss() {
        const providedColumnGroup = this.column.getProvidedColumnGroup();
        const leafColumns = providedColumnGroup.getLeafColumns();
        const listener = ()=>this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
        leafColumns.forEach((col)=>{
            this.addManagedListeners(col, {
                movingChanged: listener
            });
        });
        listener();
    }
    onFocusIn(e) {
        if (!this.eGui.contains(e.relatedTarget)) {
            const rowIndex = this.getRowIndex();
            this.beans.focusService.setFocusedHeader(rowIndex, this.column);
        }
    }
    handleKeyDown(e) {
        super.handleKeyDown(e);
        const wrapperHasFocus = this.getWrapperHasFocus();
        if (!this.expandable || !wrapperHasFocus) return;
        if (e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER) {
            const column = this.column;
            const newExpandedValue = !column.isExpanded();
            this.beans.columnModel.setColumnGroupOpened(column.getProvidedColumnGroup(), newExpandedValue, "uiColumnExpanded");
        }
    }
    // unlike columns, this will only get called once, as we don't react on props on column groups
    // (we will always destroy and recreate this comp if something changes)
    setDragSource(eHeaderGroup) {
        if (!this.isAlive() || this.isSuppressMoving()) return;
        this.removeDragSource();
        if (!eHeaderGroup) return;
        const { beans: beans , column: column , displayName: displayName , gos: gos , dragAndDropService: dragAndDropService  } = this;
        const { columnModel: columnModel  } = beans;
        const allLeafColumns = column.getProvidedColumnGroup().getLeafColumns();
        let hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
        const dragSource = this.dragSource = {
            type: 1 /* HeaderCell */ ,
            eElement: eHeaderGroup,
            getDefaultIconName: ()=>hideColumnOnExit ? "hide" : "notAllowed",
            dragItemName: displayName,
            // we add in the original group leaf columns, so we move both visible and non-visible items
            getDragItem: ()=>this.getDragItemForGroup(column),
            onDragStarted: ()=>{
                hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
                allLeafColumns.forEach((col)=>col.setMoving(true, "uiColumnDragged"));
            },
            onDragStopped: ()=>allLeafColumns.forEach((col)=>col.setMoving(false, "uiColumnDragged")),
            onGridEnter: (dragItem)=>{
                if (hideColumnOnExit) {
                    const unlockedColumns = dragItem?.columns?.filter((col)=>!col.getColDef().lockVisible) || [];
                    columnModel.setColsVisible(unlockedColumns, true, "uiColumnMoved");
                }
            },
            onGridExit: (dragItem)=>{
                if (hideColumnOnExit) {
                    const unlockedColumns = dragItem?.columns?.filter((col)=>!col.getColDef().lockVisible) || [];
                    columnModel.setColsVisible(unlockedColumns, false, "uiColumnMoved");
                }
            }
        };
        dragAndDropService.addDragSource(dragSource, true);
    }
    // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
    // and in the order they are currently in the screen.
    getDragItemForGroup(columnGroup) {
        const allColumnsOriginalOrder = columnGroup.getProvidedColumnGroup().getLeafColumns();
        const visibleState = {};
        allColumnsOriginalOrder.forEach((column)=>visibleState[column.getId()] = column.isVisible());
        const allColumnsCurrentOrder = [];
        this.beans.visibleColsService.getAllCols().forEach((column)=>{
            if (allColumnsOriginalOrder.indexOf(column) >= 0) {
                allColumnsCurrentOrder.push(column);
                $7b57b57eaf5a9648$export$83a881c8b5120679(allColumnsOriginalOrder, column);
            }
        });
        allColumnsOriginalOrder.forEach((column)=>allColumnsCurrentOrder.push(column));
        return {
            columns: allColumnsCurrentOrder,
            visibleState: visibleState
        };
    }
    isSuppressMoving() {
        let childSuppressesMoving = false;
        this.column.getLeafColumns().forEach((column)=>{
            if (column.getColDef().suppressMovable || column.getColDef().lockPosition) childSuppressesMoving = true;
        });
        const result = childSuppressesMoving || this.gos.get("suppressMovableColumns");
        return result;
    }
};
// community-modules/core/src/headerRendering/row/headerRowCtrl.ts
var $7b57b57eaf5a9648$var$instanceIdSequence3 = 0;
var $7b57b57eaf5a9648$export$d184e9bef4f8ca43 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(rowIndex, pinned, type){
        super();
        this.instanceId = $7b57b57eaf5a9648$var$instanceIdSequence3++;
        this.rowIndex = rowIndex;
        this.pinned = pinned;
        this.type = type;
        const typeClass = type == "group" /* COLUMN_GROUP */  ? `ag-header-row-column-group` : type == "filter" /* FLOATING_FILTER */  ? `ag-header-row-column-filter` : `ag-header-row-column`;
        this.headerRowClass = `ag-header-row ${typeClass}`;
    }
    wireBeans(beans) {
        this.beans = beans;
    }
    postConstruct() {
        this.isPrintLayout = this.gos.isDomLayout("print");
        this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
    }
    getInstanceId() {
        return this.instanceId;
    }
    /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */ areCellsRendered() {
        if (!this.comp) return false;
        return this.getHeaderCellCtrls().every((ctrl)=>ctrl.getGui() != null);
    }
    /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */ setComp(comp, initCompState = true) {
        this.comp = comp;
        if (initCompState) {
            this.onRowHeightChanged();
            this.onVirtualColumnsChanged();
        }
        this.setWidth();
        this.addEventListeners();
    }
    getHeaderRowClass() {
        return this.headerRowClass;
    }
    getAriaRowIndex() {
        return this.rowIndex + 1;
    }
    addEventListeners() {
        const onHeightChanged = this.onRowHeightChanged.bind(this);
        this.addManagedEventListeners({
            columnResized: this.onColumnResized.bind(this),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            virtualColumnsChanged: (params)=>this.onVirtualColumnsChanged(params.afterScroll),
            columnHeaderHeightChanged: onHeightChanged,
            gridStylesChanged: onHeightChanged,
            advancedFilterEnabledChanged: onHeightChanged
        });
        this.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this));
        this.addManagedPropertyListener("ensureDomOrder", (e)=>this.isEnsureDomOrder = e.currentValue);
        this.addManagedPropertyListeners([
            "headerHeight",
            "pivotHeaderHeight",
            "groupHeaderHeight",
            "pivotGroupHeaderHeight",
            "floatingFiltersHeight"
        ], onHeightChanged);
    }
    getHeaderCellCtrl(column) {
        if (!this.headerCellCtrls) return;
        return $7b57b57eaf5a9648$export$3d4b197b660054d2(this.headerCellCtrls).find((cellCtrl)=>cellCtrl.getColumnGroupChild() === column);
    }
    onDisplayedColumnsChanged() {
        this.isPrintLayout = this.gos.isDomLayout("print");
        this.onVirtualColumnsChanged();
        this.setWidth();
        this.onRowHeightChanged();
    }
    getType() {
        return this.type;
    }
    onColumnResized() {
        this.setWidth();
    }
    setWidth() {
        const width = this.getWidthForRow();
        this.comp.setWidth(`${width}px`);
    }
    getWidthForRow() {
        const { visibleColsService: presentedColsService  } = this.beans;
        if (this.isPrintLayout) {
            const pinned = this.pinned != null;
            if (pinned) return 0;
            return presentedColsService.getContainerWidth("right") + presentedColsService.getContainerWidth("left") + presentedColsService.getContainerWidth(null);
        }
        return presentedColsService.getContainerWidth(this.pinned);
    }
    onRowHeightChanged() {
        const { topOffset: topOffset , rowHeight: rowHeight  } = this.getTopAndHeight();
        this.comp.setTop(topOffset + "px");
        this.comp.setHeight(rowHeight + "px");
    }
    getTopAndHeight() {
        const { columnModel: columnModel , filterManager: filterManager  } = this.beans;
        let headerRowCount = columnModel.getHeaderRowCount();
        const sizes = [];
        let numberOfFloating = 0;
        if (filterManager?.hasFloatingFilters()) {
            headerRowCount++;
            numberOfFloating = 1;
        }
        const groupHeight = columnModel.getColumnGroupHeaderRowHeight();
        const headerHeight = columnModel.getColumnHeaderRowHeight();
        const numberOfNonGroups = 1 + numberOfFloating;
        const numberOfGroups = headerRowCount - numberOfNonGroups;
        for(let i = 0; i < numberOfGroups; i++)sizes.push(groupHeight);
        sizes.push(headerHeight);
        for(let i = 0; i < numberOfFloating; i++)sizes.push(columnModel.getFloatingFiltersHeight());
        let topOffset = 0;
        for(let i = 0; i < this.rowIndex; i++)topOffset += sizes[i];
        const rowHeight = sizes[this.rowIndex];
        return {
            topOffset: topOffset,
            rowHeight: rowHeight
        };
    }
    getPinned() {
        return this.pinned;
    }
    getRowIndex() {
        return this.rowIndex;
    }
    onVirtualColumnsChanged(afterScroll = false) {
        const ctrlsToDisplay = this.getHeaderCtrls();
        const forceOrder = this.isEnsureDomOrder || this.isPrintLayout;
        this.comp.setHeaderCtrls(ctrlsToDisplay, forceOrder, afterScroll);
    }
    getHeaderCtrls() {
        const oldCtrls = this.headerCellCtrls;
        this.headerCellCtrls = /* @__PURE__ */ new Map();
        const columns = this.getColumnsInViewport();
        for (const child of columns)this.recycleAndCreateHeaderCtrls(child, oldCtrls);
        const isFocusedAndDisplayed = (ctrl)=>{
            const { focusService: focusService , visibleColsService: visibleColsService  } = this.beans;
            const isFocused = focusService.isHeaderWrapperFocused(ctrl);
            if (!isFocused) return false;
            const isDisplayed = visibleColsService.isVisible(ctrl.getColumnGroupChild());
            return isDisplayed;
        };
        if (oldCtrls) for (const [id, oldCtrl] of oldCtrls){
            const keepCtrl = isFocusedAndDisplayed(oldCtrl);
            if (keepCtrl) this.headerCellCtrls.set(id, oldCtrl);
            else this.destroyBean(oldCtrl);
        }
        return this.getHeaderCellCtrls();
    }
    getHeaderCellCtrls() {
        return Array.from(this.headerCellCtrls?.values() ?? []);
    }
    recycleAndCreateHeaderCtrls(headerColumn, oldCtrls) {
        if (!this.headerCellCtrls) return;
        if (headerColumn.isEmptyGroup()) return;
        const idOfChild = headerColumn.getUniqueId();
        let headerCtrl;
        if (oldCtrls) {
            headerCtrl = oldCtrls.get(idOfChild);
            oldCtrls.delete(idOfChild);
        }
        const forOldColumn = headerCtrl && headerCtrl.getColumnGroupChild() != headerColumn;
        if (forOldColumn) {
            this.destroyBean(headerCtrl);
            headerCtrl = void 0;
        }
        if (headerCtrl == null) switch(this.type){
            case "filter" /* FLOATING_FILTER */ :
                headerCtrl = this.createBean(this.beans.ctrlsFactory.getInstance("headerFilterCell", headerColumn, this.beans, this));
                break;
            case "group" /* COLUMN_GROUP */ :
                headerCtrl = this.createBean(new $7b57b57eaf5a9648$export$6ab7b303345e4c8(headerColumn, this.beans, this));
                break;
            default:
                headerCtrl = this.createBean(new $7b57b57eaf5a9648$export$8a024062e840d3f5(headerColumn, this.beans, this));
                break;
        }
        this.headerCellCtrls.set(idOfChild, headerCtrl);
    }
    getColumnsInViewport() {
        return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
    }
    getColumnsInViewportPrintLayout() {
        if (this.pinned != null) return [];
        let viewportColumns = [];
        const actualDepth = this.getActualDepth();
        const { columnViewportService: columnViewportService  } = this.beans;
        [
            "left",
            null,
            "right"
        ].forEach((pinned)=>{
            const items = columnViewportService.getHeadersToRender(pinned, actualDepth);
            viewportColumns = viewportColumns.concat(items);
        });
        return viewportColumns;
    }
    getActualDepth() {
        return this.type == "filter" /* FLOATING_FILTER */  ? this.rowIndex - 1 : this.rowIndex;
    }
    getColumnsInViewportNormalLayout() {
        return this.beans.columnViewportService.getHeadersToRender(this.pinned, this.getActualDepth());
    }
    findHeaderCellCtrl(column) {
        if (!this.headerCellCtrls) return;
        const allCtrls = this.getHeaderCellCtrls();
        const ctrl = allCtrls.find((ctrl2)=>ctrl2.getColumnGroupChild() == column);
        return ctrl;
    }
    focusHeader(column, event) {
        const ctrl = this.findHeaderCellCtrl(column);
        if (!ctrl) return false;
        const focused = ctrl.focus(event);
        return focused;
    }
    destroy() {
        if (this.headerCellCtrls) this.headerCellCtrls.forEach((ctrl)=>{
            this.destroyBean(ctrl);
        });
        this.headerCellCtrls = void 0;
        super.destroy();
    }
};
// community-modules/core/src/headerRendering/rowContainer/headerRowContainerCtrl.ts
var $7b57b57eaf5a9648$export$1e864ee88f54e7b = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(pinned){
        super();
        this.hidden = false;
        this.includeFloatingFilter = false;
        this.groupsRowCtrls = [];
        this.pinned = pinned;
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
        this.scrollVisibleService = beans.scrollVisibleService;
        this.pinnedWidthService = beans.pinnedWidthService;
        this.columnModel = beans.columnModel;
        this.focusService = beans.focusService;
        this.filterManager = beans.filterManager;
    }
    setComp(comp, eGui) {
        this.comp = comp;
        this.eViewport = eGui;
        this.setupCenterWidth();
        this.setupPinnedWidth();
        this.setupDragAndDrop(this.eViewport);
        const onDisplayedColsChanged = this.onDisplayedColumnsChanged.bind(this);
        this.addManagedEventListeners({
            gridColumnsChanged: this.onGridColumnsChanged.bind(this),
            displayedColumnsChanged: onDisplayedColsChanged,
            advancedFilterEnabledChanged: onDisplayedColsChanged
        });
        this.ctrlsService.registerHeaderContainer(this, this.pinned);
        if (this.columnModel.isReady()) this.refresh();
    }
    getAllCtrls() {
        const res = [
            ...this.groupsRowCtrls
        ];
        if (this.columnsRowCtrl) res.push(this.columnsRowCtrl);
        if (this.filtersRowCtrl) res.push(this.filtersRowCtrl);
        return res;
    }
    refresh(keepColumns = false) {
        const sequence = new $7b57b57eaf5a9648$export$9bbf3cc62ef6fcad();
        const focusedHeaderPosition = this.focusService.getFocusHeaderToUseAfterRefresh();
        const refreshColumnGroups = ()=>{
            const groupRowCount = this.columnModel.getHeaderRowCount() - 1;
            this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
            for(let i = 0; i < groupRowCount; i++){
                const ctrl = this.createBean(new $7b57b57eaf5a9648$export$d184e9bef4f8ca43(sequence.next(), this.pinned, "group" /* COLUMN_GROUP */ ));
                this.groupsRowCtrls.push(ctrl);
            }
        };
        const refreshColumns = ()=>{
            const rowIndex = sequence.next();
            const needNewInstance = !this.hidden && (this.columnsRowCtrl == null || !keepColumns || this.columnsRowCtrl.getRowIndex() !== rowIndex);
            const shouldDestroyInstance = needNewInstance || this.hidden;
            if (shouldDestroyInstance) this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
            if (needNewInstance) this.columnsRowCtrl = this.createBean(new $7b57b57eaf5a9648$export$d184e9bef4f8ca43(rowIndex, this.pinned, "column" /* COLUMN */ ));
        };
        const refreshFilters = ()=>{
            this.includeFloatingFilter = !!this.filterManager?.hasFloatingFilters() && !this.hidden;
            const destroyPreviousComp = ()=>{
                this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
            };
            if (!this.includeFloatingFilter) {
                destroyPreviousComp();
                return;
            }
            const rowIndex = sequence.next();
            if (this.filtersRowCtrl) {
                const rowIndexMismatch = this.filtersRowCtrl.getRowIndex() !== rowIndex;
                if (!keepColumns || rowIndexMismatch) destroyPreviousComp();
            }
            if (!this.filtersRowCtrl) this.filtersRowCtrl = this.createBean(new $7b57b57eaf5a9648$export$d184e9bef4f8ca43(rowIndex, this.pinned, "filter" /* FLOATING_FILTER */ ));
        };
        refreshColumnGroups();
        refreshColumns();
        refreshFilters();
        const allCtrls = this.getAllCtrls();
        this.comp.setCtrls(allCtrls);
        this.restoreFocusOnHeader(focusedHeaderPosition);
    }
    getHeaderCtrlForColumn(column) {
        if ($7b57b57eaf5a9648$export$891484e65a02ec71(column)) {
            if (!this.columnsRowCtrl) return;
            return this.columnsRowCtrl.getHeaderCellCtrl(column);
        }
        if (this.groupsRowCtrls.length === 0) return;
        for(let i = 0; i < this.groupsRowCtrls.length; i++){
            const ctrl = this.groupsRowCtrls[i].getHeaderCellCtrl(column);
            if (ctrl) return ctrl;
        }
    }
    getHtmlElementForColumnHeader(column) {
        const cellCtrl = this.getHeaderCtrlForColumn(column);
        if (!cellCtrl) return null;
        return cellCtrl.getGui();
    }
    getRowType(rowIndex) {
        const allCtrls = this.getAllCtrls();
        const ctrl = allCtrls[rowIndex];
        return ctrl ? ctrl.getType() : void 0;
    }
    focusHeader(rowIndex, column, event) {
        const allCtrls = this.getAllCtrls();
        const ctrl = allCtrls[rowIndex];
        if (!ctrl) return false;
        return ctrl.focusHeader(column, event);
    }
    getViewport() {
        return this.eViewport;
    }
    getRowCount() {
        return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
    }
    setHorizontalScroll(offset) {
        this.comp.setViewportScrollLeft(offset);
    }
    destroy() {
        if (this.filtersRowCtrl) this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
        if (this.columnsRowCtrl) this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
        if (this.groupsRowCtrls && this.groupsRowCtrls.length) this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
        super.destroy();
    }
    setupDragAndDrop(dropContainer) {
        const bodyDropTarget = new $7b57b57eaf5a9648$export$2350838bf1877b9e(this.pinned, dropContainer);
        this.createManagedBean(bodyDropTarget);
    }
    restoreFocusOnHeader(position) {
        if (!position) return;
        const { column: column  } = position;
        if (column.getPinned() != this.pinned) return;
        this.focusService.focusHeaderPosition({
            headerPosition: position
        });
    }
    // grid cols have changed - this also means the number of rows in the header can have
    // changed. so we remove all the old rows and insert new ones for a complete refresh
    onGridColumnsChanged() {
        this.refresh(true);
    }
    onDisplayedColumnsChanged() {
        const includeFloatingFilter = this.filterManager?.hasFloatingFilters() && !this.hidden;
        if (this.includeFloatingFilter !== includeFloatingFilter) this.refresh(true);
    }
    setupCenterWidth() {
        if (this.pinned != null) return;
        this.createManagedBean(new $7b57b57eaf5a9648$var$CenterWidthFeature((width)=>this.comp.setCenterWidth(`${width}px`), true));
    }
    setupPinnedWidth() {
        if (this.pinned == null) return;
        const pinningLeft = this.pinned === "left";
        const pinningRight = this.pinned === "right";
        this.hidden = true;
        const listener = ()=>{
            const width = pinningLeft ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
            if (width == null) return;
            const hidden = width == 0;
            const hiddenChanged = this.hidden !== hidden;
            const isRtl = this.gos.get("enableRtl");
            const scrollbarWidth = this.gos.getScrollbarWidth();
            const addPaddingForScrollbar = this.scrollVisibleService.isVerticalScrollShowing() && (isRtl && pinningLeft || !isRtl && pinningRight);
            const widthWithPadding = addPaddingForScrollbar ? width + scrollbarWidth : width;
            this.comp.setPinnedContainerWidth(`${widthWithPadding}px`);
            this.comp.setDisplayed(!hidden);
            if (hiddenChanged) {
                this.hidden = hidden;
                this.refresh();
            }
        };
        this.addManagedEventListeners({
            leftPinnedWidthChanged: listener,
            rightPinnedWidthChanged: listener,
            scrollVisibilityChanged: listener,
            scrollbarWidthChanged: listener
        });
    }
};
// community-modules/core/src/headerRendering/rowContainer/headerRowContainerComp.ts
var $7b57b57eaf5a9648$var$PINNED_LEFT_TEMPLATE = /* html */ `<div class="ag-pinned-left-header" role="rowgroup"></div>`;
var $7b57b57eaf5a9648$var$PINNED_RIGHT_TEMPLATE = /* html */ `<div class="ag-pinned-right-header" role="rowgroup"></div>`;
var $7b57b57eaf5a9648$var$CENTER_TEMPLATE = /* html */ `<div class="ag-header-viewport" role="presentation">
        <div class="ag-header-container" data-ref="eCenterContainer" role="rowgroup"></div>
    </div>`;
var $7b57b57eaf5a9648$export$f44f3572151186aa = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(pinned){
        super();
        this.eCenterContainer = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.headerRowComps = {};
        this.rowCompsList = [];
        this.pinned = pinned;
    }
    postConstruct() {
        this.selectAndSetTemplate();
        const compProxy = {
            setDisplayed: (displayed)=>this.setDisplayed(displayed),
            setCtrls: (ctrls)=>this.setCtrls(ctrls),
            // only gets called for center section
            setCenterWidth: (width)=>this.eCenterContainer.style.width = width,
            setViewportScrollLeft: (left)=>this.getGui().scrollLeft = left,
            // only gets called for pinned sections
            setPinnedContainerWidth: (width)=>{
                const eGui = this.getGui();
                eGui.style.width = width;
                eGui.style.maxWidth = width;
                eGui.style.minWidth = width;
            }
        };
        const ctrl = this.createManagedBean(new $7b57b57eaf5a9648$export$1e864ee88f54e7b(this.pinned));
        ctrl.setComp(compProxy, this.getGui());
    }
    selectAndSetTemplate() {
        const pinnedLeft = this.pinned == "left";
        const pinnedRight = this.pinned == "right";
        const template = pinnedLeft ? $7b57b57eaf5a9648$var$PINNED_LEFT_TEMPLATE : pinnedRight ? $7b57b57eaf5a9648$var$PINNED_RIGHT_TEMPLATE : $7b57b57eaf5a9648$var$CENTER_TEMPLATE;
        this.setTemplate(template);
        this.eRowContainer = this.eCenterContainer !== $7b57b57eaf5a9648$export$6c811454646ed8be ? this.eCenterContainer : this.getGui();
    }
    destroy() {
        this.setCtrls([]);
        super.destroy();
    }
    destroyRowComp(rowComp) {
        this.destroyBean(rowComp);
        this.eRowContainer.removeChild(rowComp.getGui());
    }
    setCtrls(ctrls) {
        const oldRowComps = this.headerRowComps;
        this.headerRowComps = {};
        this.rowCompsList = [];
        let prevGui;
        const appendEnsuringDomOrder = (rowComp)=>{
            const eGui = rowComp.getGui();
            const notAlreadyIn = eGui.parentElement != this.eRowContainer;
            if (notAlreadyIn) this.eRowContainer.appendChild(eGui);
            if (prevGui) $7b57b57eaf5a9648$var$_ensureDomOrder(this.eRowContainer, eGui, prevGui);
            prevGui = eGui;
        };
        ctrls.forEach((ctrl)=>{
            const ctrlId = ctrl.getInstanceId();
            const existingComp = oldRowComps[ctrlId];
            delete oldRowComps[ctrlId];
            const rowComp = existingComp ? existingComp : this.createBean(new $7b57b57eaf5a9648$export$e63c63fafc55a465(ctrl));
            this.headerRowComps[ctrlId] = rowComp;
            this.rowCompsList.push(rowComp);
            appendEnsuringDomOrder(rowComp);
        });
        $7b57b57eaf5a9648$export$2f52ef471f042094(oldRowComps).forEach((c)=>this.destroyRowComp(c));
    }
};
// community-modules/core/src/headerRendering/gridHeaderComp.ts
var $7b57b57eaf5a9648$export$a83f8d9da6e79f4 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html */ `<div class="ag-header" role="presentation"/>`);
    }
    postConstruct() {
        const compProxy = {
            addOrRemoveCssClass: (cssClassName, on)=>this.addOrRemoveCssClass(cssClassName, on),
            setHeightAndMinHeight: (height)=>{
                this.getGui().style.height = height;
                this.getGui().style.minHeight = height;
            }
        };
        const ctrl = this.createManagedBean(new $7b57b57eaf5a9648$export$20b300eb69ca4d09());
        ctrl.setComp(compProxy, this.getGui(), this.getFocusableElement());
        const addContainer = (container)=>{
            this.createManagedBean(container);
            this.appendChild(container);
        };
        addContainer(new $7b57b57eaf5a9648$export$f44f3572151186aa("left"));
        addContainer(new $7b57b57eaf5a9648$export$f44f3572151186aa(null));
        addContainer(new $7b57b57eaf5a9648$export$f44f3572151186aa("right"));
    }
};
var $7b57b57eaf5a9648$var$GridHeaderSelector = {
    selector: "AG-HEADER-ROOT",
    component: $7b57b57eaf5a9648$export$a83f8d9da6e79f4
};
// community-modules/core/src/styling/layoutFeature.ts
var $7b57b57eaf5a9648$export$f22675e2b4e3ac28 = /* @__PURE__ */ ((LayoutCssClasses2)=>{
    LayoutCssClasses2["AUTO_HEIGHT"] = "ag-layout-auto-height";
    LayoutCssClasses2["NORMAL"] = "ag-layout-normal";
    LayoutCssClasses2["PRINT"] = "ag-layout-print";
    return LayoutCssClasses2;
})($7b57b57eaf5a9648$export$f22675e2b4e3ac28 || {});
var $7b57b57eaf5a9648$var$LayoutFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(view){
        super();
        this.view = view;
    }
    postConstruct() {
        this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this));
        this.updateLayoutClasses();
    }
    updateLayoutClasses() {
        const domLayout = this.getDomLayout();
        const params = {
            autoHeight: domLayout === "autoHeight",
            normal: domLayout === "normal",
            print: domLayout === "print"
        };
        const cssClass = params.autoHeight ? "ag-layout-auto-height" /* AUTO_HEIGHT */  : params.print ? "ag-layout-print" /* PRINT */  : "ag-layout-normal" /* NORMAL */ ;
        this.view.updateLayoutClasses(cssClass, params);
    }
    // returns either 'print', 'autoHeight' or 'normal' (normal is the default)
    getDomLayout() {
        const domLayout = this.gos.get("domLayout") ?? "normal";
        const validLayouts = [
            "normal",
            "print",
            "autoHeight"
        ];
        if (validLayouts.indexOf(domLayout) === -1) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`${domLayout} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`);
            return "normal";
        }
        return domLayout;
    }
};
// community-modules/core/src/rendering/overlays/overlayWrapperComponent.ts
var $7b57b57eaf5a9648$export$869f90871f63c638 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html */ `
            <div class="ag-overlay" role="presentation">
                <div class="ag-overlay-panel" role="presentation">
                    <div class="ag-overlay-wrapper" data-ref="eOverlayWrapper" role="presentation"></div>
                </div>
            </div>`);
        this.eOverlayWrapper = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.activePromise = null;
        this.activeOverlay = null;
        this.updateListenerDestroyFunc = null;
        this.activeOverlayWrapperCssClass = null;
    }
    wireBeans(beans) {
        this.overlayService = beans.overlayService;
    }
    updateLayoutClasses(cssClass, params) {
        const overlayWrapperClassList = this.eOverlayWrapper.classList;
        overlayWrapperClassList.toggle("ag-layout-auto-height" /* AUTO_HEIGHT */ , params.autoHeight);
        overlayWrapperClassList.toggle("ag-layout-normal" /* NORMAL */ , params.normal);
        overlayWrapperClassList.toggle("ag-layout-print" /* PRINT */ , params.print);
    }
    postConstruct() {
        this.createManagedBean(new $7b57b57eaf5a9648$var$LayoutFeature(this));
        this.setDisplayed(false, {
            skipAriaHidden: true
        });
        this.overlayService.registerOverlayWrapperComp(this);
    }
    setWrapperTypeClass(overlayWrapperCssClass) {
        const overlayWrapperClassList = this.eOverlayWrapper.classList;
        if (this.activeOverlayWrapperCssClass) overlayWrapperClassList.toggle(this.activeOverlayWrapperCssClass, false);
        this.activeOverlayWrapperCssClass = overlayWrapperCssClass;
        overlayWrapperClassList.toggle(overlayWrapperCssClass, true);
    }
    showOverlay(overlayComponentPromise, overlayWrapperCssClass, gridOption) {
        this.setWrapperTypeClass(overlayWrapperCssClass);
        this.destroyActiveOverlay();
        this.activePromise = overlayComponentPromise;
        overlayComponentPromise?.then((comp)=>{
            if (this.activePromise !== overlayComponentPromise) {
                if (this.activeOverlay !== comp) {
                    this.destroyBean(comp);
                    comp = null;
                }
                return;
            }
            this.activePromise = null;
            if (!comp) return;
            if (this.activeOverlay == comp) return;
            this.eOverlayWrapper.appendChild(comp.getGui());
            this.activeOverlay = comp;
            if (gridOption) {
                const component = comp;
                this.updateListenerDestroyFunc = this.addManagedPropertyListener(gridOption, ({ currentValue: currentValue  })=>{
                    component.refresh?.(this.gos.addGridCommonParams({
                        ...currentValue ?? {}
                    }));
                });
            }
        });
        this.setDisplayed(true, {
            skipAriaHidden: true
        });
    }
    destroyActiveOverlay() {
        this.activePromise = null;
        const activeOverlay = this.activeOverlay;
        if (!activeOverlay) return;
        this.activeOverlay = null;
        const updateListenerDestroyFunc = this.updateListenerDestroyFunc;
        if (updateListenerDestroyFunc) {
            updateListenerDestroyFunc();
            this.updateListenerDestroyFunc = null;
        }
        this.destroyBean(activeOverlay);
        $7b57b57eaf5a9648$export$69e6e10709eabd91(this.eOverlayWrapper);
    }
    hideOverlay() {
        this.destroyActiveOverlay();
        this.setDisplayed(false, {
            skipAriaHidden: true
        });
    }
    destroy() {
        this.destroyActiveOverlay();
        super.destroy();
    }
};
var $7b57b57eaf5a9648$var$OverlayWrapperSelector = {
    selector: "AG-OVERLAY-WRAPPER",
    component: $7b57b57eaf5a9648$export$869f90871f63c638
};
// community-modules/core/src/gridBodyComp/abstractFakeScrollComp.ts
var $7b57b57eaf5a9648$var$AbstractFakeScrollComp = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(template, direction){
        super();
        this.direction = direction;
        this.eViewport = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eContainer = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.hideTimeout = null;
        this.setTemplate(template);
    }
    wireBeans(beans) {
        this.animationFrameService = beans.animationFrameService;
    }
    postConstruct() {
        this.addManagedEventListeners({
            scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
        });
        this.onScrollVisibilityChanged();
        this.addOrRemoveCssClass("ag-apple-scrollbar", $7b57b57eaf5a9648$var$_isMacOsUserAgent() || $7b57b57eaf5a9648$export$6b6034a68325bd8a());
    }
    initialiseInvisibleScrollbar() {
        if (this.invisibleScrollbar !== void 0) return;
        this.invisibleScrollbar = $7b57b57eaf5a9648$var$_isInvisibleScrollbar();
        if (this.invisibleScrollbar) {
            this.hideAndShowInvisibleScrollAsNeeded();
            this.addActiveListenerToggles();
        }
    }
    addActiveListenerToggles() {
        const eGui = this.getGui();
        const onActivate = ()=>this.addOrRemoveCssClass("ag-scrollbar-active", true);
        const onDeactivate = ()=>this.addOrRemoveCssClass("ag-scrollbar-active", false);
        this.addManagedListeners(eGui, {
            mouseenter: onActivate,
            mousedown: onActivate,
            touchstart: onActivate,
            mouseleave: onDeactivate,
            touchend: onDeactivate
        });
    }
    onScrollVisibilityChanged() {
        if (this.invisibleScrollbar === void 0) this.initialiseInvisibleScrollbar();
        this.animationFrameService.requestAnimationFrame(()=>this.setScrollVisible());
    }
    hideAndShowInvisibleScrollAsNeeded() {
        this.addManagedEventListeners({
            bodyScroll: (params)=>{
                if (params.direction === this.direction) {
                    if (this.hideTimeout !== null) {
                        window.clearTimeout(this.hideTimeout);
                        this.hideTimeout = null;
                    }
                    this.addOrRemoveCssClass("ag-scrollbar-scrolling", true);
                }
            },
            bodyScrollEnd: ()=>{
                this.hideTimeout = window.setTimeout(()=>{
                    this.addOrRemoveCssClass("ag-scrollbar-scrolling", false);
                    this.hideTimeout = null;
                }, 400);
            }
        });
    }
    attemptSettingScrollPosition(value) {
        const viewport = this.getViewport();
        $7b57b57eaf5a9648$export$b863e7aac7884b8(()=>$7b57b57eaf5a9648$export$2badf4aa566524cb(viewport), ()=>this.setScrollPosition(value), 100);
    }
    getViewport() {
        return this.eViewport;
    }
    getContainer() {
        return this.eContainer;
    }
    onScrollCallback(fn) {
        this.addManagedElementListeners(this.getViewport(), {
            scroll: fn
        });
    }
};
// community-modules/core/src/gridBodyComp/fakeHScrollComp.ts
var $7b57b57eaf5a9648$export$8f252e09ef6be2d3 = class extends $7b57b57eaf5a9648$var$AbstractFakeScrollComp {
    constructor(){
        super(/* html */ `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" data-ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" data-ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" data-ref="eRightSpacer"></div>
        </div>`, "horizontal");
        this.eLeftSpacer = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eRightSpacer = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    wireBeans(beans) {
        super.wireBeans(beans);
        this.visibleColsService = beans.visibleColsService;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.ctrlsService = beans.ctrlsService;
        this.scrollVisibleService = beans.scrollVisibleService;
    }
    postConstruct() {
        super.postConstruct();
        const spacerWidthsListener = this.setFakeHScrollSpacerWidths.bind(this);
        this.addManagedEventListeners({
            displayedColumnsChanged: spacerWidthsListener,
            displayedColumnsWidthChanged: spacerWidthsListener,
            pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this)
        });
        this.addManagedPropertyListener("domLayout", spacerWidthsListener);
        this.ctrlsService.register("fakeHScrollComp", this);
        this.createManagedBean(new $7b57b57eaf5a9648$var$CenterWidthFeature((width)=>this.eContainer.style.width = `${width}px`));
        this.addManagedPropertyListeners([
            "suppressHorizontalScroll"
        ], this.onScrollVisibilityChanged.bind(this));
    }
    initialiseInvisibleScrollbar() {
        if (this.invisibleScrollbar !== void 0) return;
        this.enableRtl = this.gos.get("enableRtl");
        super.initialiseInvisibleScrollbar();
        if (this.invisibleScrollbar) this.refreshCompBottom();
    }
    onPinnedRowDataChanged() {
        this.refreshCompBottom();
    }
    refreshCompBottom() {
        if (!this.invisibleScrollbar) return;
        const bottomPinnedHeight = this.pinnedRowModel.getPinnedBottomTotalHeight();
        this.getGui().style.bottom = `${bottomPinnedHeight}px`;
    }
    onScrollVisibilityChanged() {
        super.onScrollVisibilityChanged();
        this.setFakeHScrollSpacerWidths();
    }
    setFakeHScrollSpacerWidths() {
        const vScrollShowing = this.scrollVisibleService.isVerticalScrollShowing();
        let rightSpacing = this.visibleColsService.getDisplayedColumnsRightWidth();
        const scrollOnRight = !this.enableRtl && vScrollShowing;
        const scrollbarWidth = this.gos.getScrollbarWidth();
        if (scrollOnRight) rightSpacing += scrollbarWidth;
        $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(this.eRightSpacer, rightSpacing);
        this.eRightSpacer.classList.toggle("ag-scroller-corner", rightSpacing <= scrollbarWidth);
        let leftSpacing = this.visibleColsService.getColsLeftWidth();
        const scrollOnLeft = this.enableRtl && vScrollShowing;
        if (scrollOnLeft) leftSpacing += scrollbarWidth;
        $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(this.eLeftSpacer, leftSpacing);
        this.eLeftSpacer.classList.toggle("ag-scroller-corner", leftSpacing <= scrollbarWidth);
    }
    setScrollVisible() {
        const hScrollShowing = this.scrollVisibleService.isHorizontalScrollShowing();
        const invisibleScrollbar2 = this.invisibleScrollbar;
        const isSuppressHorizontalScroll = this.gos.get("suppressHorizontalScroll");
        const scrollbarWidth = hScrollShowing ? this.gos.getScrollbarWidth() || 0 : 0;
        const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
        const scrollContainerSize = !isSuppressHorizontalScroll ? adjustedScrollbarWidth : 0;
        this.addOrRemoveCssClass("ag-scrollbar-invisible", invisibleScrollbar2);
        $7b57b57eaf5a9648$var$_setFixedHeight(this.getGui(), scrollContainerSize);
        $7b57b57eaf5a9648$var$_setFixedHeight(this.eViewport, scrollContainerSize);
        $7b57b57eaf5a9648$var$_setFixedHeight(this.eContainer, scrollContainerSize);
        this.setDisplayed(hScrollShowing, {
            skipAriaHidden: true
        });
    }
    getScrollPosition() {
        return $7b57b57eaf5a9648$var$_getScrollLeft(this.getViewport(), this.enableRtl);
    }
    setScrollPosition(value) {
        if (!$7b57b57eaf5a9648$export$2badf4aa566524cb(this.getViewport())) this.attemptSettingScrollPosition(value);
        $7b57b57eaf5a9648$var$_setScrollLeft(this.getViewport(), value, this.enableRtl);
    }
};
var $7b57b57eaf5a9648$var$FakeHScrollSelector = {
    selector: "AG-FAKE-HORIZONTAL-SCROLL",
    component: $7b57b57eaf5a9648$export$8f252e09ef6be2d3
};
// community-modules/core/src/gridBodyComp/rowContainer/setHeightFeature.ts
var $7b57b57eaf5a9648$var$SetHeightFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.maxDivHeightScaler = beans.rowContainerHeightService;
    }
    constructor(eContainer, eViewport){
        super();
        this.eContainer = eContainer;
        this.eViewport = eViewport;
    }
    postConstruct() {
        this.addManagedEventListeners({
            rowContainerHeightChanged: this.onHeightChanged.bind(this)
        });
    }
    onHeightChanged() {
        const height = this.maxDivHeightScaler.getUiContainerHeight();
        const heightString = height != null ? `${height}px` : ``;
        this.eContainer.style.height = heightString;
        if (this.eViewport) this.eViewport.style.height = heightString;
    }
};
// community-modules/core/src/gridBodyComp/fakeVScrollComp.ts
var $7b57b57eaf5a9648$export$f496fc30dbebdfa3 = class extends $7b57b57eaf5a9648$var$AbstractFakeScrollComp {
    wireBeans(beans) {
        super.wireBeans(beans);
        this.ctrlsService = beans.ctrlsService;
        this.scrollVisibleService = beans.scrollVisibleService;
    }
    constructor(){
        super(/* html */ `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-vertical-scroll-container" data-ref="eContainer"></div>
            </div>
        </div>`, "vertical");
    }
    postConstruct() {
        super.postConstruct();
        this.createManagedBean(new $7b57b57eaf5a9648$var$SetHeightFeature(this.eContainer));
        this.ctrlsService.register("fakeVScrollComp", this);
        this.addManagedEventListeners({
            rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this)
        });
    }
    setScrollVisible() {
        const vScrollShowing = this.scrollVisibleService.isVerticalScrollShowing();
        const invisibleScrollbar2 = this.invisibleScrollbar;
        const scrollbarWidth = vScrollShowing ? this.gos.getScrollbarWidth() || 0 : 0;
        const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
        this.addOrRemoveCssClass("ag-scrollbar-invisible", invisibleScrollbar2);
        $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(this.getGui(), adjustedScrollbarWidth);
        $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(this.eViewport, adjustedScrollbarWidth);
        $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(this.eContainer, adjustedScrollbarWidth);
        this.setDisplayed(vScrollShowing, {
            skipAriaHidden: true
        });
    }
    onRowContainerHeightChanged() {
        const { ctrlsService: ctrlsService  } = this;
        const gridBodyCtrl = ctrlsService.getGridBodyCtrl();
        const gridBodyViewportEl = gridBodyCtrl.getBodyViewportElement();
        const eViewportScrollTop = this.getScrollPosition();
        const gridBodyViewportScrollTop = gridBodyViewportEl.scrollTop;
        if (eViewportScrollTop != gridBodyViewportScrollTop) this.setScrollPosition(gridBodyViewportScrollTop, true);
    }
    getScrollPosition() {
        return this.getViewport().scrollTop;
    }
    setScrollPosition(value, force) {
        if (!force && !$7b57b57eaf5a9648$export$2badf4aa566524cb(this.getViewport())) this.attemptSettingScrollPosition(value);
        this.getViewport().scrollTop = value;
    }
};
var $7b57b57eaf5a9648$var$FakeVScrollSelector = {
    selector: "AG-FAKE-VERTICAL-SCROLL",
    component: $7b57b57eaf5a9648$export$f496fc30dbebdfa3
};
// community-modules/core/src/gridBodyComp/gridBodyScrollFeature.ts
var $7b57b57eaf5a9648$var$GridBodyScrollFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(eBodyViewport){
        super();
        this.lastScrollSource = [
            null,
            null
        ];
        this.scrollLeft = -1;
        this.nextScrollTop = -1;
        this.scrollTop = -1;
        // Used to provide approximate values of scrollTop and offsetHeight
        // without forcing the browser to recalculate styles.
        this.lastOffsetHeight = -1;
        this.lastScrollTop = -1;
        this.eBodyViewport = eBodyViewport;
        this.resetLastHScrollDebounced = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(()=>this.lastScrollSource[1 /* Horizontal */ ] = null, 500);
        this.resetLastVScrollDebounced = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(()=>this.lastScrollSource[0 /* Vertical */ ] = null, 500);
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
        this.animationFrameService = beans.animationFrameService;
        this.paginationService = beans.paginationService;
        this.pageBoundsService = beans.pageBoundsService;
        this.rowModel = beans.rowModel;
        this.heightScaler = beans.rowContainerHeightService;
        this.rowRenderer = beans.rowRenderer;
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
    }
    postConstruct() {
        this.enableRtl = this.gos.get("enableRtl");
        this.addManagedEventListeners({
            displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this)
        });
        this.ctrlsService.whenReady((p)=>{
            this.centerRowsCtrl = p.center;
            this.onDisplayedColumnsWidthChanged();
            this.addScrollListener();
        });
    }
    addScrollListener() {
        const { fakeHScrollComp: fakeHScrollComp , fakeVScrollComp: fakeVScrollComp  } = this.ctrlsService.getParams();
        this.addManagedElementListeners(this.centerRowsCtrl.getViewportElement(), {
            scroll: this.onHScroll.bind(this)
        });
        fakeHScrollComp.onScrollCallback(this.onFakeHScroll.bind(this));
        const isDebounce = this.gos.get("debounceVerticalScrollbar");
        const onVScroll = isDebounce ? $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.onVScroll.bind(this), 100) : this.onVScroll.bind(this);
        const onFakeVScroll = isDebounce ? $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.onFakeVScroll.bind(this), 100) : this.onFakeVScroll.bind(this);
        this.addManagedElementListeners(this.eBodyViewport, {
            scroll: onVScroll
        });
        fakeVScrollComp.onScrollCallback(onFakeVScroll);
    }
    onDisplayedColumnsWidthChanged() {
        if (this.enableRtl) this.horizontallyScrollHeaderCenterAndFloatingCenter();
    }
    horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft) {
        const notYetInitialised = this.centerRowsCtrl == null;
        if (notYetInitialised) return;
        if (scrollLeft === void 0) scrollLeft = this.centerRowsCtrl.getCenterViewportScrollLeft();
        const offset = this.enableRtl ? scrollLeft : -scrollLeft;
        const { topCenter: topCenter , stickyTopCenter: stickyTopCenter , stickyBottomCenter: stickyBottomCenter , centerHeader: centerHeader , bottomCenter: bottomCenter , fakeHScrollComp: fakeHScrollComp  } = this.ctrlsService.getParams();
        centerHeader.setHorizontalScroll(-offset);
        bottomCenter.setContainerTranslateX(offset);
        topCenter.setContainerTranslateX(offset);
        stickyTopCenter.setContainerTranslateX(offset);
        stickyBottomCenter.setContainerTranslateX(offset);
        const centerViewport = this.centerRowsCtrl.getViewportElement();
        const isCenterViewportLastHorizontal = this.lastScrollSource[1 /* Horizontal */ ] === 0 /* Container */ ;
        scrollLeft = Math.abs(scrollLeft);
        if (isCenterViewportLastHorizontal) fakeHScrollComp.setScrollPosition(scrollLeft);
        else $7b57b57eaf5a9648$var$_setScrollLeft(centerViewport, scrollLeft, this.enableRtl);
    }
    isControllingScroll(source, direction) {
        if (this.lastScrollSource[direction] == null) {
            this.lastScrollSource[direction] = source;
            return true;
        }
        return this.lastScrollSource[direction] === source;
    }
    onFakeHScroll() {
        if (!this.isControllingScroll(1 /* FakeContainer */ , 1 /* Horizontal */ )) return;
        this.onHScrollCommon(1 /* FakeContainer */ );
    }
    onHScroll() {
        if (!this.isControllingScroll(0 /* Container */ , 1 /* Horizontal */ )) return;
        this.onHScrollCommon(0 /* Container */ );
    }
    onHScrollCommon(source) {
        const centerContainerViewport = this.centerRowsCtrl.getViewportElement();
        const { scrollLeft: scrollLeft  } = centerContainerViewport;
        if (this.shouldBlockScrollUpdate(1 /* Horizontal */ , scrollLeft, true)) return;
        let newScrollLeft;
        if (source === 0 /* Container */ ) newScrollLeft = $7b57b57eaf5a9648$var$_getScrollLeft(centerContainerViewport, this.enableRtl);
        else newScrollLeft = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
        this.doHorizontalScroll(Math.round(newScrollLeft));
        this.resetLastHScrollDebounced();
    }
    onFakeVScroll() {
        if (!this.isControllingScroll(1 /* FakeContainer */ , 0 /* Vertical */ )) return;
        this.onVScrollCommon(1 /* FakeContainer */ );
    }
    onVScroll() {
        if (!this.isControllingScroll(0 /* Container */ , 0 /* Vertical */ )) return;
        this.onVScrollCommon(0 /* Container */ );
    }
    onVScrollCommon(source) {
        let scrollTop;
        if (source === 0 /* Container */ ) scrollTop = this.eBodyViewport.scrollTop;
        else scrollTop = this.ctrlsService.get("fakeVScrollComp").getScrollPosition();
        if (this.shouldBlockScrollUpdate(0 /* Vertical */ , scrollTop, true)) return;
        this.animationFrameService.setScrollTop(scrollTop);
        this.nextScrollTop = scrollTop;
        if (source === 0 /* Container */ ) this.ctrlsService.get("fakeVScrollComp").setScrollPosition(scrollTop);
        else this.eBodyViewport.scrollTop = scrollTop;
        if (this.gos.get("suppressAnimationFrame")) this.scrollGridIfNeeded();
        else this.animationFrameService.schedule();
        this.resetLastVScrollDebounced();
    }
    doHorizontalScroll(scrollLeft) {
        const fakeScrollLeft = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
        if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) return;
        this.scrollLeft = scrollLeft;
        this.fireScrollEvent(1 /* Horizontal */ );
        this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);
        this.centerRowsCtrl.onHorizontalViewportChanged(true);
    }
    fireScrollEvent(direction) {
        const bodyScrollEvent = {
            type: "bodyScroll",
            direction: direction === 1 /* Horizontal */  ? "horizontal" : "vertical",
            left: this.scrollLeft,
            top: this.scrollTop
        };
        this.eventService.dispatchEvent(bodyScrollEvent);
        window.clearTimeout(this.scrollTimer);
        this.scrollTimer = void 0;
        this.scrollTimer = window.setTimeout(()=>{
            const bodyScrollEndEvent = {
                ...bodyScrollEvent,
                type: "bodyScrollEnd"
            };
            this.eventService.dispatchEvent(bodyScrollEndEvent);
        }, 100);
    }
    shouldBlockScrollUpdate(direction, scrollTo, touchOnly = false) {
        if (touchOnly && !$7b57b57eaf5a9648$export$6b6034a68325bd8a()) return false;
        if (direction === 0 /* Vertical */ ) return this.shouldBlockVerticalScroll(scrollTo);
        return this.shouldBlockHorizontalScroll(scrollTo);
    }
    shouldBlockVerticalScroll(scrollTo) {
        const clientHeight = $7b57b57eaf5a9648$export$c20e968103d9c16e(this.eBodyViewport);
        const { scrollHeight: scrollHeight  } = this.eBodyViewport;
        if (scrollTo < 0 || scrollTo + clientHeight > scrollHeight) return true;
        return false;
    }
    shouldBlockHorizontalScroll(scrollTo) {
        const clientWidth = this.centerRowsCtrl.getCenterWidth();
        const { scrollWidth: scrollWidth  } = this.centerRowsCtrl.getViewportElement();
        if (this.enableRtl && $7b57b57eaf5a9648$var$_isRtlNegativeScroll()) {
            if (scrollTo > 0) return true;
        } else if (scrollTo < 0) return true;
        if (Math.abs(scrollTo) + clientWidth > scrollWidth) return true;
        return false;
    }
    redrawRowsAfterScroll() {
        this.fireScrollEvent(0 /* Vertical */ );
    }
    // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
    // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
    // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
    // back to the left to be kept in sync.
    // adding and removing the grid from the DOM both resets the scroll position and
    // triggers a resize event, so notify listeners if the scroll position has changed
    checkScrollLeft() {
        if (this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft()) this.onHScrollCommon(0 /* Container */ );
    }
    scrollGridIfNeeded() {
        const frameNeeded = this.scrollTop != this.nextScrollTop;
        if (frameNeeded) {
            this.scrollTop = this.nextScrollTop;
            this.redrawRowsAfterScroll();
        }
        return frameNeeded;
    }
    // called by scrollHorizontally method and alignedGridsService
    setHorizontalScrollPosition(hScrollPosition, fromAlignedGridsService = false) {
        const minScrollLeft = 0;
        const maxScrollLeft = this.centerRowsCtrl.getViewportElement().scrollWidth - this.centerRowsCtrl.getCenterWidth();
        if (!fromAlignedGridsService && this.shouldBlockScrollUpdate(1 /* Horizontal */ , hScrollPosition)) {
            if (this.enableRtl && $7b57b57eaf5a9648$var$_isRtlNegativeScroll()) hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;
            else hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);
        }
        $7b57b57eaf5a9648$var$_setScrollLeft(this.centerRowsCtrl.getViewportElement(), Math.abs(hScrollPosition), this.enableRtl);
        this.doHorizontalScroll(hScrollPosition);
    }
    setVerticalScrollPosition(vScrollPosition) {
        this.eBodyViewport.scrollTop = vScrollPosition;
    }
    getVScrollPosition() {
        this.lastScrollTop = this.eBodyViewport.scrollTop;
        this.lastOffsetHeight = this.eBodyViewport.offsetHeight;
        const result = {
            top: this.lastScrollTop,
            bottom: this.lastScrollTop + this.lastOffsetHeight
        };
        return result;
    }
    /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */ getApproximateVScollPosition() {
        if (this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0) return {
            top: this.scrollTop,
            bottom: this.scrollTop + this.lastOffsetHeight
        };
        return this.getVScrollPosition();
    }
    getHScrollPosition() {
        return this.centerRowsCtrl.getHScrollPosition();
    }
    isHorizontalScrollShowing() {
        return this.centerRowsCtrl.isHorizontalScrollShowing();
    }
    // called by the headerRootComp and moveColumnController
    scrollHorizontally(pixels) {
        const oldScrollPosition = this.centerRowsCtrl.getViewportElement().scrollLeft;
        this.setHorizontalScrollPosition(oldScrollPosition + pixels);
        return this.centerRowsCtrl.getViewportElement().scrollLeft - oldScrollPosition;
    }
    // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
    scrollToTop() {
        this.eBodyViewport.scrollTop = 0;
    }
    // Valid values for position are bottom, middle and top
    ensureNodeVisible(comparator, position = null) {
        const rowCount = this.rowModel.getRowCount();
        let indexToSelect = -1;
        for(let i = 0; i < rowCount; i++){
            const node = this.rowModel.getRow(i);
            if (typeof comparator === "function") {
                const predicate = comparator;
                if (node && predicate(node)) {
                    indexToSelect = i;
                    break;
                }
            } else if (comparator === node || comparator === node.data) {
                indexToSelect = i;
                break;
            }
        }
        if (indexToSelect >= 0) this.ensureIndexVisible(indexToSelect, position);
    }
    // Valid values for position are bottom, middle and top
    // position should be {'top','middle','bottom', or undefined/null}.
    // if undefined/null, then the grid will to the minimal amount of scrolling,
    // eg if grid needs to scroll up, it scrolls until row is on top,
    //    if grid needs to scroll down, it scrolls until row is on bottom,
    //    if row is already in view, grid does not scroll
    ensureIndexVisible(index, position) {
        if (this.gos.isDomLayout("print")) return;
        const rowCount = this.rowModel.getRowCount();
        if (typeof index !== "number" || index < 0 || index >= rowCount) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("Invalid row index for ensureIndexVisible: " + index);
            return;
        }
        const isPaging = this.gos.get("pagination");
        const paginationPanelEnabled = isPaging && !this.gos.get("suppressPaginationPanel");
        this.getFrameworkOverrides().wrapIncoming(()=>{
            if (!paginationPanelEnabled) this.paginationService?.goToPageWithIndex(index);
            const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
            const stickyTopHeight = gridBodyCtrl.getStickyTopHeight();
            const stickyBottomHeight = gridBodyCtrl.getStickyBottomHeight();
            const rowNode = this.rowModel.getRow(index);
            let rowGotShiftedDuringOperation;
            do {
                const startingRowTop = rowNode.rowTop;
                const startingRowHeight = rowNode.rowHeight;
                const paginationOffset = this.pageBoundsService.getPixelOffset();
                const rowTopPixel = rowNode.rowTop - paginationOffset;
                const rowBottomPixel = rowTopPixel + rowNode.rowHeight;
                const scrollPosition = this.getVScrollPosition();
                const heightOffset = this.heightScaler.getDivStretchOffset();
                const vScrollTop = scrollPosition.top + heightOffset;
                const vScrollBottom = scrollPosition.bottom + heightOffset;
                const viewportHeight = vScrollBottom - vScrollTop;
                const pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);
                const pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);
                const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);
                const rowAboveViewport = vScrollTop + stickyTopHeight > rowTopPixel;
                const rowBelowViewport = vScrollBottom - stickyBottomHeight < rowBottomPixel;
                let newScrollPosition = null;
                if (position === "top") newScrollPosition = pxTop;
                else if (position === "bottom") newScrollPosition = pxBottom;
                else if (position === "middle") newScrollPosition = pxMiddle;
                else if (rowAboveViewport) newScrollPosition = pxTop - stickyTopHeight;
                else if (rowBelowViewport) newScrollPosition = pxBottom + stickyBottomHeight;
                if (newScrollPosition !== null) {
                    this.setVerticalScrollPosition(newScrollPosition);
                    this.rowRenderer.redraw({
                        afterScroll: true
                    });
                }
                rowGotShiftedDuringOperation = startingRowTop !== rowNode.rowTop || startingRowHeight !== rowNode.rowHeight;
            }while (rowGotShiftedDuringOperation);
            this.animationFrameService.flushAllFrames();
        });
    }
    ensureColumnVisible(key, position = "auto") {
        const column = this.columnModel.getCol(key);
        if (!column) return;
        if (column.isPinned()) return;
        if (!this.visibleColsService.isColDisplayed(column)) return;
        const newHorizontalScroll = this.getPositionedHorizontalScroll(column, position);
        this.getFrameworkOverrides().wrapIncoming(()=>{
            if (newHorizontalScroll !== null) this.centerRowsCtrl.setCenterViewportScrollLeft(newHorizontalScroll);
            this.centerRowsCtrl.onHorizontalViewportChanged();
            this.animationFrameService.flushAllFrames();
        });
    }
    setScrollPosition(top, left) {
        this.getFrameworkOverrides().wrapIncoming(()=>{
            this.centerRowsCtrl.setCenterViewportScrollLeft(left);
            this.setVerticalScrollPosition(top);
            this.rowRenderer.redraw({
                afterScroll: true
            });
            this.animationFrameService.flushAllFrames();
        });
    }
    getPositionedHorizontalScroll(column, position) {
        const { columnBeforeStart: columnBeforeStart , columnAfterEnd: columnAfterEnd  } = this.isColumnOutsideViewport(column);
        const viewportTooSmallForColumn = this.centerRowsCtrl.getCenterWidth() < column.getActualWidth();
        const viewportWidth = this.centerRowsCtrl.getCenterWidth();
        const isRtl = this.enableRtl;
        let alignColToStart = (isRtl ? columnBeforeStart : columnAfterEnd) || viewportTooSmallForColumn;
        let alignColToEnd = isRtl ? columnAfterEnd : columnBeforeStart;
        if (position !== "auto") {
            alignColToStart = position === "start";
            alignColToEnd = position === "end";
        }
        const isMiddle = position === "middle";
        if (alignColToStart || alignColToEnd || isMiddle) {
            const { colLeft: colLeft , colMiddle: colMiddle , colRight: colRight  } = this.getColumnBounds(column);
            if (isMiddle) return colMiddle - viewportWidth / 2;
            if (alignColToStart) return isRtl ? colRight : colLeft;
            return isRtl ? colLeft - viewportWidth : colRight - viewportWidth;
        }
        return null;
    }
    isColumnOutsideViewport(column) {
        const { start: viewportStart , end: viewportEnd  } = this.getViewportBounds();
        const { colLeft: colLeft , colRight: colRight  } = this.getColumnBounds(column);
        const isRtl = this.enableRtl;
        const columnBeforeStart = isRtl ? viewportStart > colRight : viewportEnd < colRight;
        const columnAfterEnd = isRtl ? viewportEnd < colLeft : viewportStart > colLeft;
        return {
            columnBeforeStart: columnBeforeStart,
            columnAfterEnd: columnAfterEnd
        };
    }
    getColumnBounds(column) {
        const isRtl = this.enableRtl;
        const bodyWidth = this.visibleColsService.getBodyContainerWidth();
        const colWidth = column.getActualWidth();
        const colLeft = column.getLeft();
        const multiplier = isRtl ? -1 : 1;
        const colLeftPixel = isRtl ? bodyWidth - colLeft : colLeft;
        const colRightPixel = colLeftPixel + colWidth * multiplier;
        const colMidPixel = colLeftPixel + colWidth / 2 * multiplier;
        return {
            colLeft: colLeftPixel,
            colMiddle: colMidPixel,
            colRight: colRightPixel
        };
    }
    getViewportBounds() {
        const viewportWidth = this.centerRowsCtrl.getCenterWidth();
        const scrollPosition = this.centerRowsCtrl.getCenterViewportScrollLeft();
        const viewportStartPixel = scrollPosition;
        const viewportEndPixel = viewportWidth + scrollPosition;
        return {
            start: viewportStartPixel,
            end: viewportEndPixel,
            width: viewportWidth
        };
    }
};
// community-modules/core/src/gridBodyComp/gridBodyCtrl.ts
var $7b57b57eaf5a9648$var$CSS_CLASS_FORCE_VERTICAL_SCROLL = "ag-force-vertical-scroll";
var $7b57b57eaf5a9648$var$CSS_CLASS_CELL_SELECTABLE = "ag-selectable";
var $7b57b57eaf5a9648$var$CSS_CLASS_COLUMN_MOVING = "ag-column-moving";
var $7b57b57eaf5a9648$export$8bebc3145b40d221 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.stickyTopHeight = 0;
        this.stickyBottomHeight = 0;
    }
    wireBeans(beans) {
        this.animationFrameService = beans.animationFrameService;
        this.rowContainerHeightService = beans.rowContainerHeightService;
        this.ctrlsService = beans.ctrlsService;
        this.columnModel = beans.columnModel;
        this.columnSizeService = beans.columnSizeService;
        this.scrollVisibleService = beans.scrollVisibleService;
        this.menuService = beans.menuService;
        this.headerNavigationService = beans.headerNavigationService;
        this.dragAndDropService = beans.dragAndDropService;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.rowRenderer = beans.rowRenderer;
        this.popupService = beans.popupService;
        this.mouseEventService = beans.mouseEventService;
        this.rowModel = beans.rowModel;
        this.filterManager = beans.filterManager;
        this.environment = beans.environment;
    }
    getScrollFeature() {
        return this.bodyScrollFeature;
    }
    getBodyViewportElement() {
        return this.eBodyViewport;
    }
    setComp(comp, eGridBody, eBodyViewport, eTop, eBottom, eStickyTop, eStickyBottom) {
        this.comp = comp;
        this.eGridBody = eGridBody;
        this.eBodyViewport = eBodyViewport;
        this.eTop = eTop;
        this.eBottom = eBottom;
        this.eStickyTop = eStickyTop;
        this.eStickyBottom = eStickyBottom;
        this.setCellTextSelection(this.gos.get("enableCellTextSelection"));
        this.addManagedPropertyListener("enableCellTextSelection", (props)=>this.setCellTextSelection(props.currentValue));
        this.createManagedBean(new $7b57b57eaf5a9648$var$LayoutFeature(this.comp));
        this.bodyScrollFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$GridBodyScrollFeature(this.eBodyViewport));
        this.addRowDragListener();
        this.setupRowAnimationCssClass();
        this.addEventListeners();
        this.addFocusListeners([
            eTop,
            eBodyViewport,
            eBottom,
            eStickyTop,
            eStickyBottom
        ]);
        this.onGridColumnsChanged();
        this.addBodyViewportListener();
        this.setFloatingHeights();
        this.disableBrowserDragging();
        this.addStopEditingWhenGridLosesFocus();
        this.filterManager?.setupAdvancedFilterHeaderComp(eTop);
        this.ctrlsService.register("gridBodyCtrl", this);
    }
    getComp() {
        return this.comp;
    }
    addEventListeners() {
        this.addManagedEventListeners({
            gridColumnsChanged: this.onGridColumnsChanged.bind(this),
            scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
            pinnedRowDataChanged: this.setFloatingHeights.bind(this),
            pinnedHeightChanged: this.setFloatingHeights.bind(this),
            headerHeightChanged: this.onHeaderHeightChanged.bind(this)
        });
    }
    addFocusListeners(elements) {
        elements.forEach((element)=>{
            this.addManagedElementListeners(element, {
                focusin: (e)=>{
                    const { target: target  } = e;
                    const isFocusedElementNested = $7b57b57eaf5a9648$var$_isElementChildOfClass(target, "ag-root", element);
                    element.classList.toggle("ag-has-focus", !isFocusedElementNested);
                },
                focusout: (e)=>{
                    const { target: target , relatedTarget: relatedTarget  } = e;
                    const gridContainRelatedTarget = element.contains(relatedTarget);
                    const isNestedRelatedTarget = $7b57b57eaf5a9648$var$_isElementChildOfClass(relatedTarget, "ag-root", element);
                    const isNestedTarget = $7b57b57eaf5a9648$var$_isElementChildOfClass(target, "ag-root", element);
                    if (isNestedTarget) return;
                    if (!gridContainRelatedTarget || isNestedRelatedTarget) element.classList.remove("ag-has-focus");
                }
            });
        });
    }
    // used by ColumnAnimationService
    setColumnMovingCss(moving) {
        this.comp.setColumnMovingCss($7b57b57eaf5a9648$var$CSS_CLASS_COLUMN_MOVING, moving);
    }
    setCellTextSelection(selectable = false) {
        this.comp.setCellSelectableCss($7b57b57eaf5a9648$var$CSS_CLASS_CELL_SELECTABLE, selectable);
    }
    onScrollVisibilityChanged() {
        const visible = this.scrollVisibleService.isVerticalScrollShowing();
        this.setVerticalScrollPaddingVisible(visible);
        this.setStickyWidth(visible);
        this.setStickyBottomOffsetBottom();
        const scrollbarWidth = visible ? this.gos.getScrollbarWidth() || 0 : 0;
        const pad = $7b57b57eaf5a9648$var$_isInvisibleScrollbar() ? 16 : 0;
        const width = `calc(100% + ${scrollbarWidth + pad}px)`;
        this.animationFrameService.requestAnimationFrame(()=>this.comp.setBodyViewportWidth(width));
    }
    onGridColumnsChanged() {
        const columns = this.columnModel.getCols();
        this.comp.setColumnCount(columns.length);
    }
    // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
    // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
    disableBrowserDragging() {
        this.addManagedElementListeners(this.eGridBody, {
            dragstart: (event)=>{
                if (event.target instanceof HTMLImageElement) {
                    event.preventDefault();
                    return false;
                }
            }
        });
    }
    addStopEditingWhenGridLosesFocus() {
        if (!this.gos.get("stopEditingWhenCellsLoseFocus")) return;
        const focusOutListener = (event)=>{
            const elementWithFocus = event.relatedTarget;
            if ($7b57b57eaf5a9648$var$_getTabIndex(elementWithFocus) === null) {
                this.rowRenderer.stopEditing();
                return;
            }
            let clickInsideGrid = // see if click came from inside the viewports
            viewports.some((viewport)=>viewport.contains(elementWithFocus)) && // and also that it's not from a detail grid
            this.mouseEventService.isElementInThisGrid(elementWithFocus);
            if (!clickInsideGrid) {
                const popupService = this.popupService;
                clickInsideGrid = popupService.getActivePopups().some((popup)=>popup.contains(elementWithFocus)) || popupService.isElementWithinCustomPopup(elementWithFocus);
            }
            if (!clickInsideGrid) this.rowRenderer.stopEditing();
        };
        const viewports = [
            this.eBodyViewport,
            this.eBottom,
            this.eTop,
            this.eStickyTop,
            this.eStickyBottom
        ];
        viewports.forEach((viewport)=>this.addManagedElementListeners(viewport, {
                focusout: focusOutListener
            }));
    }
    updateRowCount() {
        const headerCount = this.headerNavigationService.getHeaderRowCount() + (this.filterManager?.getHeaderRowCount() ?? 0);
        const rowCount = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1;
        const total = rowCount === -1 ? -1 : headerCount + rowCount;
        this.comp.setRowCount(total);
    }
    registerBodyViewportResizeListener(listener) {
        this.comp.registerBodyViewportResizeListener(listener);
    }
    setVerticalScrollPaddingVisible(visible) {
        const overflowY = visible ? "scroll" : "hidden";
        this.comp.setPinnedTopBottomOverflowY(overflowY);
    }
    isVerticalScrollShowing() {
        const show = this.gos.get("alwaysShowVerticalScroll");
        const cssClass = show ? $7b57b57eaf5a9648$var$CSS_CLASS_FORCE_VERTICAL_SCROLL : null;
        const allowVerticalScroll = this.gos.isDomLayout("normal");
        this.comp.setAlwaysVerticalScrollClass(cssClass, show);
        return show || allowVerticalScroll && $7b57b57eaf5a9648$var$_isVerticalScrollShowing(this.eBodyViewport);
    }
    setupRowAnimationCssClass() {
        let initialSizeMeasurementComplete = this.environment.hasMeasuredSizes();
        const updateAnimationClass = ()=>{
            const animateRows = initialSizeMeasurementComplete && this.gos.isAnimateRows() && !this.rowContainerHeightService.isStretching();
            const animateRowsCssClass = animateRows ? "ag-row-animation" : "ag-row-no-animation";
            this.comp.setRowAnimationCssOnBodyViewport(animateRowsCssClass, animateRows);
        };
        updateAnimationClass();
        this.addManagedEventListeners({
            heightScaleChanged: updateAnimationClass
        });
        this.addManagedPropertyListener("animateRows", updateAnimationClass);
        this.addManagedEventListeners({
            gridStylesChanged: ()=>{
                if (!initialSizeMeasurementComplete && this.environment.hasMeasuredSizes()) {
                    initialSizeMeasurementComplete = true;
                    updateAnimationClass();
                }
            }
        });
    }
    getGridBodyElement() {
        return this.eGridBody;
    }
    addBodyViewportListener() {
        const listener = this.onBodyViewportContextMenu.bind(this);
        this.addManagedElementListeners(this.eBodyViewport, {
            contextmenu: listener
        });
        this.mockContextMenuForIPad(listener);
        this.addManagedElementListeners(this.eBodyViewport, {
            wheel: this.onBodyViewportWheel.bind(this)
        });
        this.addManagedElementListeners(this.eStickyTop, {
            wheel: this.onStickyWheel.bind(this)
        });
        this.addManagedElementListeners(this.eStickyBottom, {
            wheel: this.onStickyWheel.bind(this)
        });
        this.addFullWidthContainerWheelListener();
    }
    addFullWidthContainerWheelListener() {
        const fullWidthContainer = this.eBodyViewport.querySelector(".ag-full-width-container");
        const eCenterColsViewport = this.eBodyViewport.querySelector(".ag-center-cols-viewport");
        if (fullWidthContainer && eCenterColsViewport) this.addManagedElementListeners(fullWidthContainer, {
            wheel: (e)=>this.onFullWidthContainerWheel(e, eCenterColsViewport)
        });
    }
    onFullWidthContainerWheel(e, eCenterColsViewport) {
        if (!e.deltaX || Math.abs(e.deltaY) > Math.abs(e.deltaX) || !this.mouseEventService.isEventFromThisGrid(e)) return;
        e.preventDefault();
        eCenterColsViewport.scrollBy({
            left: e.deltaX
        });
    }
    onBodyViewportContextMenu(mouseEvent, touch, touchEvent) {
        if (!mouseEvent && !touchEvent) return;
        if (this.gos.get("preventDefaultOnContextMenu")) {
            const event = mouseEvent || touchEvent;
            event.preventDefault();
        }
        const { target: target  } = mouseEvent || touch;
        if (target === this.eBodyViewport || target === this.ctrlsService.get("center").getViewportElement()) this.menuService.showContextMenu({
            mouseEvent: mouseEvent,
            touchEvent: touchEvent,
            value: null,
            anchorToElement: this.eGridBody
        });
    }
    mockContextMenuForIPad(listener) {
        if (!$7b57b57eaf5a9648$export$6b6034a68325bd8a()) return;
        const touchListener = new $7b57b57eaf5a9648$export$7b2e93987414b382(this.eBodyViewport);
        const longTapListener = (event)=>{
            listener(void 0, event.touchStart, event.touchEvent);
        };
        this.addManagedListeners(touchListener, {
            longTap: longTapListener
        });
        this.addDestroyFunc(()=>touchListener.destroy());
    }
    onBodyViewportWheel(e) {
        if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) return;
        if (this.popupService.hasAnchoredPopup()) e.preventDefault();
    }
    onStickyWheel(e) {
        e.preventDefault();
        if (e.offsetY) this.scrollVertically(e.deltaY);
    }
    getGui() {
        return this.eGridBody;
    }
    // called by rowDragFeature
    scrollVertically(pixels) {
        const oldScrollPosition = this.eBodyViewport.scrollTop;
        this.bodyScrollFeature.setVerticalScrollPosition(oldScrollPosition + pixels);
        return this.eBodyViewport.scrollTop - oldScrollPosition;
    }
    addRowDragListener() {
        this.rowDragFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$RowDragFeature(this.eBodyViewport));
        this.dragAndDropService.addDropTarget(this.rowDragFeature);
    }
    getRowDragFeature() {
        return this.rowDragFeature;
    }
    setFloatingHeights() {
        const { pinnedRowModel: pinnedRowModel  } = this;
        const floatingTopHeight = pinnedRowModel.getPinnedTopTotalHeight();
        const floatingBottomHeight = pinnedRowModel.getPinnedBottomTotalHeight();
        this.comp.setTopHeight(floatingTopHeight);
        this.comp.setBottomHeight(floatingBottomHeight);
        this.comp.setTopDisplay(floatingTopHeight ? "inherit" : "none");
        this.comp.setBottomDisplay(floatingBottomHeight ? "inherit" : "none");
        this.setStickyTopOffsetTop();
        this.setStickyBottomOffsetBottom();
    }
    setStickyTopHeight(height = 0) {
        this.comp.setStickyTopHeight(`${height}px`);
        this.stickyTopHeight = height;
    }
    getStickyTopHeight() {
        return this.stickyTopHeight;
    }
    setStickyBottomHeight(height = 0) {
        this.comp.setStickyBottomHeight(`${height}px`);
        this.stickyBottomHeight = height;
    }
    getStickyBottomHeight() {
        return this.stickyBottomHeight;
    }
    setStickyWidth(vScrollVisible) {
        if (!vScrollVisible) {
            this.comp.setStickyTopWidth("100%");
            this.comp.setStickyBottomWidth("100%");
        } else {
            const scrollbarWidth = this.gos.getScrollbarWidth();
            this.comp.setStickyTopWidth(`calc(100% - ${scrollbarWidth}px)`);
            this.comp.setStickyBottomWidth(`calc(100% - ${scrollbarWidth}px)`);
        }
    }
    onHeaderHeightChanged() {
        this.setStickyTopOffsetTop();
    }
    setStickyTopOffsetTop() {
        const headerCtrl = this.ctrlsService.get("gridHeaderCtrl");
        const headerHeight = headerCtrl.getHeaderHeight() + (this.filterManager?.getHeaderHeight() ?? 0);
        const pinnedTopHeight = this.pinnedRowModel.getPinnedTopTotalHeight();
        let height = 0;
        if (headerHeight > 0) height += headerHeight;
        if (pinnedTopHeight > 0) height += pinnedTopHeight;
        if (height > 0) height += 1;
        this.comp.setStickyTopTop(`${height}px`);
    }
    setStickyBottomOffsetBottom() {
        const pinnedBottomHeight = this.pinnedRowModel.getPinnedBottomTotalHeight();
        const hScrollShowing = this.scrollVisibleService.isHorizontalScrollShowing();
        const scrollbarWidth = hScrollShowing ? this.gos.getScrollbarWidth() || 0 : 0;
        const height = pinnedBottomHeight + scrollbarWidth;
        this.comp.setStickyBottomBottom(`${height}px`);
    }
    // method will call itself if no available width. this covers if the grid
    // isn't visible, but is just about to be visible.
    sizeColumnsToFit(params, nextTimeout) {
        const removeScrollWidth = this.isVerticalScrollShowing();
        const scrollWidthToRemove = removeScrollWidth ? this.gos.getScrollbarWidth() : 0;
        const bodyViewportWidth = $7b57b57eaf5a9648$export$cc615e4191ec3e0c(this.eGridBody);
        const availableWidth = bodyViewportWidth - scrollWidthToRemove;
        if (availableWidth > 0) {
            this.columnSizeService.sizeColumnsToFit(availableWidth, "sizeColumnsToFit", false, params);
            return;
        }
        if (nextTimeout === void 0) window.setTimeout(()=>{
            this.sizeColumnsToFit(params, 100);
        }, 0);
        else if (nextTimeout === 100) window.setTimeout(()=>{
            this.sizeColumnsToFit(params, 500);
        }, 100);
        else if (nextTimeout === 500) window.setTimeout(()=>{
            this.sizeColumnsToFit(params, -1);
        }, 500);
        else $7b57b57eaf5a9648$export$2cf41453020eef66("tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?");
    }
    // + rangeService
    addScrollEventListener(listener) {
        this.eBodyViewport.addEventListener("scroll", listener, {
            passive: true
        });
    }
    // + focusService
    removeScrollEventListener(listener) {
        this.eBodyViewport.removeEventListener("scroll", listener);
    }
};
// community-modules/core/src/rendering/cell/cellComp.ts
var $7b57b57eaf5a9648$export$e59215a9594b9f01 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(beans, cellCtrl, printLayout, eRow, editingRow){
        super();
        // every time we go into edit mode, or back again, this gets incremented.
        // it's the components way of dealing with the async nature of framework components,
        // so if a framework component takes a while to be created, we know if the object
        // is still relevant when creating is finished. eg we could click edit / un-edit 20
        // times before the first React edit component comes back - we should discard
        // the first 19.
        this.rendererVersion = 0;
        this.editorVersion = 0;
        this.beans = beans;
        this.column = cellCtrl.getColumn();
        this.rowNode = cellCtrl.getRowNode();
        this.rowCtrl = cellCtrl.getRowCtrl();
        this.eRow = eRow;
        this.cellCtrl = cellCtrl;
        const cellDiv = document.createElement("div");
        cellDiv.setAttribute("comp-id", `${this.getCompId()}`);
        this.setTemplateFromElement(cellDiv);
        const eGui = this.getGui();
        this.forceWrapper = cellCtrl.isForceWrapper();
        this.refreshWrapper(false);
        const setAttribute = (name, value)=>{
            if (value != null && value != "") eGui.setAttribute(name, value);
            else eGui.removeAttribute(name);
        };
        $7b57b57eaf5a9648$export$f8d01fa01787902(eGui, cellCtrl.getCellAriaRole());
        setAttribute("col-id", cellCtrl.getColumnIdSanitised());
        const tabIndex = cellCtrl.getTabIndex();
        if (tabIndex !== void 0) setAttribute("tabindex", tabIndex.toString());
        const compProxy = {
            addOrRemoveCssClass: (cssClassName, on)=>this.addOrRemoveCssClass(cssClassName, on),
            setUserStyles: (styles)=>$7b57b57eaf5a9648$var$_addStylesToElement(eGui, styles),
            getFocusableElement: ()=>this.getFocusableElement(),
            setIncludeSelection: (include)=>this.includeSelection = include,
            setIncludeRowDrag: (include)=>this.includeRowDrag = include,
            setIncludeDndSource: (include)=>this.includeDndSource = include,
            setRenderDetails: (compDetails, valueToDisplay, force)=>this.setRenderDetails(compDetails, valueToDisplay, force),
            setEditDetails: (compDetails, popup, position)=>this.setEditDetails(compDetails, popup, position),
            getCellEditor: ()=>this.cellEditor || null,
            getCellRenderer: ()=>this.cellRenderer || null,
            getParentOfValue: ()=>this.getParentOfValue()
        };
        cellCtrl.setComp(compProxy, this.getGui(), this.eCellWrapper, printLayout, editingRow);
    }
    getParentOfValue() {
        if (this.eCellValue) return this.eCellValue;
        if (this.eCellWrapper) return this.eCellWrapper;
        return this.getGui();
    }
    setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance) {
        const isInlineEditing = this.cellEditor && !this.cellEditorPopupWrapper;
        if (isInlineEditing) return;
        this.firstRender = this.firstRender == null;
        const controlWrapperChanged = this.refreshWrapper(false);
        this.refreshEditStyles(false);
        if (compDetails) {
            const neverRefresh = forceNewCellRendererInstance || controlWrapperChanged;
            const cellRendererRefreshSuccessful = neverRefresh ? false : this.refreshCellRenderer(compDetails);
            if (!cellRendererRefreshSuccessful) {
                this.destroyRenderer();
                this.createCellRendererInstance(compDetails);
            }
        } else {
            this.destroyRenderer();
            this.insertValueWithoutCellRenderer(valueToDisplay);
        }
    }
    setEditDetails(compDetails, popup, position) {
        if (compDetails) this.createCellEditorInstance(compDetails, popup, position);
        else this.destroyEditor();
    }
    removeControls() {
        this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp);
        this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp);
        this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);
    }
    // returns true if wrapper was changed
    refreshWrapper(editing) {
        const providingControls = this.includeRowDrag || this.includeDndSource || this.includeSelection;
        const usingWrapper = providingControls || this.forceWrapper;
        const putWrapperIn = usingWrapper && this.eCellWrapper == null;
        if (putWrapperIn) {
            const wrapperDiv = document.createElement("div");
            wrapperDiv.setAttribute("role", "presentation");
            wrapperDiv.setAttribute("class", "ag-cell-wrapper");
            this.eCellWrapper = wrapperDiv;
            this.getGui().appendChild(this.eCellWrapper);
        }
        const takeWrapperOut = !usingWrapper && this.eCellWrapper != null;
        if (takeWrapperOut) {
            $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(this.eCellWrapper);
            this.eCellWrapper = void 0;
        }
        this.addOrRemoveCssClass("ag-cell-value", !usingWrapper);
        const usingCellValue = !editing && usingWrapper;
        const putCellValueIn = usingCellValue && this.eCellValue == null;
        if (putCellValueIn) {
            const cellSpan = document.createElement("span");
            cellSpan.setAttribute("role", "presentation");
            cellSpan.setAttribute("class", "ag-cell-value");
            this.eCellValue = cellSpan;
            this.eCellWrapper.appendChild(this.eCellValue);
        }
        const takeCellValueOut = !usingCellValue && this.eCellValue != null;
        if (takeCellValueOut) {
            $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(this.eCellValue);
            this.eCellValue = void 0;
        }
        const templateChanged = putWrapperIn || takeWrapperOut || putCellValueIn || takeCellValueOut;
        if (templateChanged) this.removeControls();
        if (!editing) {
            if (providingControls) this.addControls();
        }
        return templateChanged;
    }
    addControls() {
        if (this.includeRowDrag) {
            if (this.rowDraggingComp == null) {
                this.rowDraggingComp = this.cellCtrl.createRowDragComp();
                if (this.rowDraggingComp) this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue);
            }
        }
        if (this.includeDndSource) {
            if (this.dndSourceComp == null) {
                this.dndSourceComp = this.cellCtrl.createDndSource();
                this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue);
            }
        }
        if (this.includeSelection) {
            if (this.checkboxSelectionComp == null) {
                this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox();
                this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue);
            }
        }
    }
    createCellEditorInstance(compDetails, popup, position) {
        const versionCopy = this.editorVersion;
        const cellEditorPromise = compDetails.newAgStackInstance();
        if (cellEditorPromise == null) return;
        const { params: params  } = compDetails;
        cellEditorPromise.then((c)=>this.afterCellEditorCreated(versionCopy, c, params, popup, position));
        const cellEditorAsync = $7b57b57eaf5a9648$export$672d9e47bc342bac(this.cellEditor);
        if (cellEditorAsync && params.cellStartedEdit) this.cellCtrl.focusCell(true);
    }
    insertValueWithoutCellRenderer(valueToDisplay) {
        const eParent = this.getParentOfValue();
        $7b57b57eaf5a9648$export$69e6e10709eabd91(eParent);
        const escapedValue = valueToDisplay != null ? $7b57b57eaf5a9648$export$3df06b741968da82(valueToDisplay, true) : null;
        if (escapedValue != null) eParent.textContent = escapedValue;
    }
    destroyEditorAndRenderer() {
        this.destroyRenderer();
        this.destroyEditor();
    }
    destroyRenderer() {
        const { context: context  } = this.beans;
        this.cellRenderer = context.destroyBean(this.cellRenderer);
        $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(this.cellRendererGui);
        this.cellRendererGui = null;
        this.rendererVersion++;
    }
    destroyEditor() {
        const { context: context  } = this.beans;
        if (this.hideEditorPopup) this.hideEditorPopup();
        this.hideEditorPopup = void 0;
        this.cellEditor = context.destroyBean(this.cellEditor);
        this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);
        $7b57b57eaf5a9648$export$dd4d52e41fb4cef5(this.cellEditorGui);
        this.cellEditorGui = null;
        this.editorVersion++;
    }
    refreshCellRenderer(compClassAndParams) {
        if (this.cellRenderer == null || this.cellRenderer.refresh == null) return false;
        if (this.cellRendererClass !== compClassAndParams.componentClass) return false;
        const result = this.cellRenderer.refresh(compClassAndParams.params);
        return result === true || result === void 0;
    }
    createCellRendererInstance(compDetails) {
        const suppressAnimationFrame = this.beans.gos.get("suppressAnimationFrame");
        const useTaskService = !suppressAnimationFrame;
        const displayComponentVersionCopy = this.rendererVersion;
        const { componentClass: componentClass  } = compDetails;
        const createCellRendererFunc = ()=>{
            const staleTask = this.rendererVersion !== displayComponentVersionCopy || !this.isAlive();
            if (staleTask) return;
            const componentPromise = compDetails.newAgStackInstance();
            const callback = this.afterCellRendererCreated.bind(this, displayComponentVersionCopy, componentClass);
            if (componentPromise) componentPromise.then(callback);
        };
        if (useTaskService && this.firstRender) this.beans.animationFrameService.createTask(createCellRendererFunc, this.rowNode.rowIndex, "createTasksP2");
        else createCellRendererFunc();
    }
    getCtrl() {
        return this.cellCtrl;
    }
    getRowCtrl() {
        return this.rowCtrl;
    }
    getCellRenderer() {
        return this.cellRenderer;
    }
    getCellEditor() {
        return this.cellEditor;
    }
    afterCellRendererCreated(cellRendererVersion, cellRendererClass, cellRenderer) {
        const staleTask = !this.isAlive() || cellRendererVersion !== this.rendererVersion;
        if (staleTask) {
            this.beans.context.destroyBean(cellRenderer);
            return;
        }
        this.cellRenderer = cellRenderer;
        this.cellRendererClass = cellRendererClass;
        this.cellRendererGui = this.cellRenderer.getGui();
        if (this.cellRendererGui != null) {
            const eParent = this.getParentOfValue();
            $7b57b57eaf5a9648$export$69e6e10709eabd91(eParent);
            eParent.appendChild(this.cellRendererGui);
        }
    }
    afterCellEditorCreated(requestVersion, cellEditor, params, popup, position) {
        const staleComp = requestVersion !== this.editorVersion;
        if (staleComp) {
            this.beans.context.destroyBean(cellEditor);
            return;
        }
        const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
        if (editingCancelledByUserComp) {
            this.beans.context.destroyBean(cellEditor);
            this.cellCtrl.stopEditing(true);
            return;
        }
        if (!cellEditor.getGui) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`cellEditor for column ${this.column.getId()} is missing getGui() method`);
            this.beans.context.destroyBean(cellEditor);
            return;
        }
        this.cellEditor = cellEditor;
        this.cellEditorGui = cellEditor.getGui();
        const cellEditorInPopup = popup || cellEditor.isPopup !== void 0 && cellEditor.isPopup();
        if (cellEditorInPopup) this.addPopupCellEditor(params, position);
        else this.addInCellEditor();
        this.refreshEditStyles(true, cellEditorInPopup);
        if (cellEditor.afterGuiAttached) cellEditor.afterGuiAttached();
    }
    refreshEditStyles(editing, isPopup) {
        this.addOrRemoveCssClass("ag-cell-inline-editing", editing && !isPopup);
        this.addOrRemoveCssClass("ag-cell-popup-editing", editing && !!isPopup);
        this.addOrRemoveCssClass("ag-cell-not-inline-editing", !editing || !!isPopup);
        this.rowCtrl?.setInlineEditingCss(editing);
    }
    addInCellEditor() {
        const eGui = this.getGui();
        if (eGui.contains(this.beans.gos.getActiveDomElement())) eGui.focus();
        this.destroyRenderer();
        this.refreshWrapper(true);
        this.clearParentOfValue();
        if (this.cellEditorGui) {
            const eParent = this.getParentOfValue();
            eParent.appendChild(this.cellEditorGui);
        }
    }
    addPopupCellEditor(params, position) {
        if (this.beans.gos.get("editType") === "fullRow") $7b57b57eaf5a9648$export$2cf41453020eef66("popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.");
        const cellEditor = this.cellEditor;
        this.cellEditorPopupWrapper = this.beans.context.createBean(this.beans.editService.createPopupEditorWrapper(params));
        const ePopupGui = this.cellEditorPopupWrapper.getGui();
        if (this.cellEditorGui) ePopupGui.appendChild(this.cellEditorGui);
        const popupService = this.beans.popupService;
        const useModelPopup = this.beans.gos.get("stopEditingWhenCellsLoseFocus");
        const positionToUse = position != null ? position : cellEditor.getPopupPosition ? cellEditor.getPopupPosition() : "over";
        const isRtl = this.beans.gos.get("enableRtl");
        const positionParams = {
            ePopup: ePopupGui,
            column: this.column,
            rowNode: this.rowNode,
            type: "popupCellEditor",
            eventSource: this.getGui(),
            position: positionToUse,
            alignSide: isRtl ? "right" : "left",
            keepWithinBounds: true
        };
        const positionCallback = popupService.positionPopupByComponent.bind(popupService, positionParams);
        const translate = this.beans.localeService.getLocaleTextFunc();
        const addPopupRes = popupService.addPopup({
            modal: useModelPopup,
            eChild: ePopupGui,
            closeOnEsc: true,
            closedCallback: ()=>{
                this.cellCtrl.onPopupEditorClosed();
            },
            anchorToElement: this.getGui(),
            positionCallback: positionCallback,
            ariaLabel: translate("ariaLabelCellEditor", "Cell Editor")
        });
        if (addPopupRes) this.hideEditorPopup = addPopupRes.hideFunc;
    }
    detach() {
        this.eRow.removeChild(this.getGui());
    }
    // if the row is also getting destroyed, then we don't need to remove from dom,
    // as the row will also get removed, so no need to take out the cells from the row
    // if the row is going (removing is an expensive operation, so only need to remove
    // the top part)
    //
    // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
    destroy() {
        this.cellCtrl.stopEditing();
        this.destroyEditorAndRenderer();
        this.removeControls();
        super.destroy();
    }
    clearParentOfValue() {
        const eGui = this.getGui();
        if (eGui.contains(this.beans.gos.getActiveDomElement()) && $7b57b57eaf5a9648$var$_browserSupportsPreventScroll()) eGui.focus({
            preventScroll: true
        });
        $7b57b57eaf5a9648$export$69e6e10709eabd91(this.getParentOfValue());
    }
};
// community-modules/core/src/rendering/row/rowComp.ts
var $7b57b57eaf5a9648$var$RowComp = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(ctrl, beans, containerType){
        super();
        this.cellComps = {};
        this.beans = beans;
        this.rowCtrl = ctrl;
        const rowDiv = document.createElement("div");
        rowDiv.setAttribute("comp-id", `${this.getCompId()}`);
        rowDiv.setAttribute("style", this.getInitialStyle(containerType));
        this.setTemplateFromElement(rowDiv);
        const eGui = this.getGui();
        const style = eGui.style;
        this.domOrder = this.rowCtrl.getDomOrder();
        $7b57b57eaf5a9648$export$f8d01fa01787902(eGui, "row");
        const tabIndex = this.rowCtrl.getTabIndex();
        if (tabIndex != null) eGui.setAttribute("tabindex", tabIndex.toString());
        const compProxy = {
            setDomOrder: (domOrder)=>this.domOrder = domOrder,
            setCellCtrls: (cellCtrls)=>this.setCellCtrls(cellCtrls),
            showFullWidth: (compDetails)=>this.showFullWidth(compDetails),
            getFullWidthCellRenderer: ()=>this.getFullWidthCellRenderer(),
            addOrRemoveCssClass: (name, on)=>this.addOrRemoveCssClass(name, on),
            setUserStyles: (styles)=>$7b57b57eaf5a9648$var$_addStylesToElement(eGui, styles),
            setTop: (top)=>style.top = top,
            setTransform: (transform)=>style.transform = transform,
            setRowIndex: (rowIndex)=>eGui.setAttribute("row-index", rowIndex),
            setRowId: (rowId)=>eGui.setAttribute("row-id", rowId),
            setRowBusinessKey: (businessKey)=>eGui.setAttribute("row-business-key", businessKey),
            refreshFullWidth: (getUpdatedParams)=>this.refreshFullWidth(getUpdatedParams)
        };
        ctrl.setComp(compProxy, this.getGui(), containerType);
        this.addDestroyFunc(()=>{
            ctrl.unsetComp(containerType);
        });
    }
    getInitialStyle(containerType) {
        const transform = this.rowCtrl.getInitialTransform(containerType);
        return transform ? `transform: ${transform}` : `top: ${this.rowCtrl.getInitialRowTop(containerType)}`;
    }
    showFullWidth(compDetails) {
        const callback = (cellRenderer)=>{
            if (this.isAlive()) {
                const eGui = cellRenderer.getGui();
                this.getGui().appendChild(eGui);
                this.rowCtrl.setupDetailRowAutoHeight(eGui);
                this.setFullWidthRowComp(cellRenderer);
            } else this.beans.context.destroyBean(cellRenderer);
        };
        const res = compDetails.newAgStackInstance();
        if (!res) return;
        res.then(callback);
    }
    setCellCtrls(cellCtrls) {
        const cellsToRemove = Object.assign({}, this.cellComps);
        cellCtrls.forEach((cellCtrl)=>{
            const key = cellCtrl.getInstanceId();
            const existingCellComp = this.cellComps[key];
            if (existingCellComp == null) this.newCellComp(cellCtrl);
            else cellsToRemove[key] = null;
        });
        const cellCompsToRemove = $7b57b57eaf5a9648$export$2f52ef471f042094(cellsToRemove).filter((cellComp)=>cellComp != null);
        this.destroyCells(cellCompsToRemove);
        this.ensureDomOrder(cellCtrls);
    }
    ensureDomOrder(cellCtrls) {
        if (!this.domOrder) return;
        const elementsInOrder = [];
        cellCtrls.forEach((cellCtrl)=>{
            const cellComp = this.cellComps[cellCtrl.getInstanceId()];
            if (cellComp) elementsInOrder.push(cellComp.getGui());
        });
        $7b57b57eaf5a9648$var$_setDomChildOrder(this.getGui(), elementsInOrder);
    }
    newCellComp(cellCtrl) {
        const cellComp = new $7b57b57eaf5a9648$export$e59215a9594b9f01(this.beans, cellCtrl, this.rowCtrl.isPrintLayout(), this.getGui(), this.rowCtrl.isEditing());
        this.cellComps[cellCtrl.getInstanceId()] = cellComp;
        this.getGui().appendChild(cellComp.getGui());
    }
    destroy() {
        super.destroy();
        this.destroyAllCells();
    }
    destroyAllCells() {
        const cellsToDestroy = $7b57b57eaf5a9648$export$2f52ef471f042094(this.cellComps).filter((cp)=>cp != null);
        this.destroyCells(cellsToDestroy);
    }
    setFullWidthRowComp(fullWidthRowComponent) {
        if (this.fullWidthCellRenderer) $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("should not be setting fullWidthRowComponent twice");
        this.fullWidthCellRenderer = fullWidthRowComponent;
        this.addDestroyFunc(()=>{
            this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
        });
    }
    getFullWidthCellRenderer() {
        return this.fullWidthCellRenderer;
    }
    destroyCells(cellComps) {
        cellComps.forEach((cellComp)=>{
            if (!cellComp) return;
            const instanceId = cellComp.getCtrl().getInstanceId();
            if (this.cellComps[instanceId] !== cellComp) return;
            cellComp.detach();
            cellComp.destroy();
            this.cellComps[instanceId] = null;
        });
    }
    refreshFullWidth(getUpdatedParams) {
        const { fullWidthCellRenderer: fullWidthCellRenderer  } = this;
        if (!fullWidthCellRenderer || !fullWidthCellRenderer.refresh) return false;
        const params = getUpdatedParams();
        return fullWidthCellRenderer.refresh(params);
    }
};
// community-modules/core/src/gridBodyComp/viewportSizeFeature.ts
var $7b57b57eaf5a9648$var$ViewportSizeFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
        this.pinnedWidthService = beans.pinnedWidthService;
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
        this.columnSizeService = beans.columnSizeService;
        this.scrollVisibleService = beans.scrollVisibleService;
        this.columnViewportService = beans.columnViewportService;
    }
    constructor(centerContainerCtrl){
        super();
        this.centerContainerCtrl = centerContainerCtrl;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            this.gridBodyCtrl = p.gridBodyCtrl;
            this.listenForResize();
        });
        this.addManagedEventListeners({
            scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this)
        });
        this.addManagedPropertyListeners([
            "alwaysShowHorizontalScroll",
            "alwaysShowVerticalScroll"
        ], ()=>{
            this.checkViewportAndScrolls();
        });
    }
    listenForResize() {
        const listener = ()=>this.onCenterViewportResized();
        this.centerContainerCtrl.registerViewportResizeListener(listener);
        this.gridBodyCtrl.registerBodyViewportResizeListener(listener);
    }
    onScrollbarWidthChanged() {
        this.checkViewportAndScrolls();
    }
    onCenterViewportResized() {
        if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
            this.keepPinnedColumnsNarrowerThanViewport();
            this.checkViewportAndScrolls();
            const newWidth = this.centerContainerCtrl.getCenterWidth();
            if (newWidth !== this.centerWidth) {
                this.centerWidth = newWidth;
                this.columnSizeService.refreshFlexedColumns({
                    viewportWidth: this.centerWidth,
                    updateBodyWidths: true,
                    fireResizedEvent: true
                });
            }
        } else this.bodyHeight = 0;
    }
    keepPinnedColumnsNarrowerThanViewport() {
        const eBodyViewport = this.gridBodyCtrl.getBodyViewportElement();
        const bodyWidth = $7b57b57eaf5a9648$export$cc615e4191ec3e0c(eBodyViewport);
        if (bodyWidth <= 50) return;
        let columnsToRemove = this.getPinnedColumnsOverflowingViewport(bodyWidth - 50);
        const processUnpinnedColumns = this.gos.getCallback("processUnpinnedColumns");
        if (!columnsToRemove.length) return;
        if (processUnpinnedColumns) {
            const params = {
                columns: columnsToRemove,
                viewportWidth: bodyWidth
            };
            columnsToRemove = processUnpinnedColumns(params);
        }
        this.columnModel.setColsPinned(columnsToRemove, null, "viewportSizeFeature");
    }
    getPinnedColumnsOverflowingViewport(viewportWidth) {
        const pinnedRightWidth = this.pinnedWidthService.getPinnedRightWidth();
        const pinnedLeftWidth = this.pinnedWidthService.getPinnedLeftWidth();
        const totalPinnedWidth = pinnedRightWidth + pinnedLeftWidth;
        if (totalPinnedWidth < viewportWidth) return [];
        const pinnedLeftColumns = [
            ...this.visibleColsService.getLeftCols()
        ];
        const pinnedRightColumns = [
            ...this.visibleColsService.getRightCols()
        ];
        let indexRight = 0;
        let indexLeft = 0;
        const totalWidthRemoved = 0;
        const columnsToRemove = [];
        let spaceNecessary = totalPinnedWidth - totalWidthRemoved - viewportWidth;
        while((indexLeft < pinnedLeftColumns.length || indexRight < pinnedRightColumns.length) && spaceNecessary > 0){
            if (indexRight < pinnedRightColumns.length) {
                const currentColumn = pinnedRightColumns[indexRight++];
                spaceNecessary -= currentColumn.getActualWidth();
                columnsToRemove.push(currentColumn);
            }
            if (indexLeft < pinnedLeftColumns.length && spaceNecessary > 0) {
                const currentColumn = pinnedLeftColumns[indexLeft++];
                spaceNecessary -= currentColumn.getActualWidth();
                columnsToRemove.push(currentColumn);
            }
        }
        return columnsToRemove;
    }
    // gets called every time the viewport size changes. we use this to check visibility of scrollbars
    // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
    checkViewportAndScrolls() {
        this.updateScrollVisibleService();
        this.checkBodyHeight();
        this.onHorizontalViewportChanged();
        this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
    }
    getBodyHeight() {
        return this.bodyHeight;
    }
    checkBodyHeight() {
        const eBodyViewport = this.gridBodyCtrl.getBodyViewportElement();
        const bodyHeight = $7b57b57eaf5a9648$export$c20e968103d9c16e(eBodyViewport);
        if (this.bodyHeight !== bodyHeight) {
            this.bodyHeight = bodyHeight;
            const event = {
                type: "bodyHeightChanged"
            };
            this.eventService.dispatchEvent(event);
        }
    }
    updateScrollVisibleService() {
        this.updateScrollVisibleServiceImpl();
        setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
    }
    updateScrollVisibleServiceImpl() {
        const params = {
            horizontalScrollShowing: this.isHorizontalScrollShowing(),
            verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
        };
        this.scrollVisibleService.setScrollsVisible(params);
    }
    isHorizontalScrollShowing() {
        return this.centerContainerCtrl.isHorizontalScrollShowing();
    }
    // this gets called whenever a change in the viewport, so we can inform column controller it has to work
    // out the virtual columns again. gets called from following locations:
    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
    onHorizontalViewportChanged() {
        const scrollWidth = this.centerContainerCtrl.getCenterWidth();
        const scrollPosition = this.centerContainerCtrl.getViewportScrollLeft();
        this.columnViewportService.setScrollPosition(scrollWidth, scrollPosition);
    }
};
// community-modules/core/src/gridBodyComp/rowContainer/dragListenerFeature.ts
var $7b57b57eaf5a9648$var$DragListenerFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.dragService = beans.dragService;
        this.rangeService = beans.rangeService;
    }
    constructor(eContainer){
        super();
        this.eContainer = eContainer;
    }
    postConstruct() {
        if (!this.rangeService) return;
        this.params = {
            eElement: this.eContainer,
            onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
            onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
            onDragging: this.rangeService.onDragging.bind(this.rangeService)
        };
        this.addManagedPropertyListener("enableRangeSelection", (props)=>{
            const isEnabled = props.currentValue;
            if (isEnabled) {
                this.enableFeature();
                return;
            }
            this.disableFeature();
        });
        this.addDestroyFunc(()=>this.disableFeature());
        const isRangeSelection = this.gos.get("enableRangeSelection");
        if (isRangeSelection) this.enableFeature();
    }
    enableFeature() {
        this.dragService.addDragSource(this.params);
    }
    disableFeature() {
        this.dragService.removeDragSource(this.params);
    }
};
// community-modules/core/src/rendering/checkboxSelectionComponent.ts
var $7b57b57eaf5a9648$export$b54c7a6db4674fde = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html*/ `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`, [
            $7b57b57eaf5a9648$export$2e2c317d2e31f2ca
        ]);
        this.eCheckbox = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    postConstruct() {
        this.eCheckbox.setPassive(true);
    }
    getCheckboxId() {
        return this.eCheckbox.getInputElement().id;
    }
    onDataChanged() {
        this.onSelectionChanged();
    }
    onSelectableChanged() {
        this.showOrHideSelect();
    }
    onSelectionChanged() {
        const translate = this.localeService.getLocaleTextFunc();
        const state = this.rowNode.isSelected();
        const stateName = $7b57b57eaf5a9648$var$_getAriaCheckboxStateName(translate, state);
        const [ariaKey, ariaLabel] = this.rowNode.selectable ? [
            "ariaRowToggleSelection",
            "Press Space to toggle row selection"
        ] : [
            "ariaRowSelectionDisabled",
            "Row Selection is disabled for this row"
        ];
        const translatedLabel = translate(ariaKey, ariaLabel);
        this.eCheckbox.setValue(state, true);
        this.eCheckbox.setInputAriaLabel(`${translatedLabel} (${stateName})`);
    }
    onClicked(newValue, groupSelectsFiltered, event) {
        return this.rowNode.setSelectedParams({
            newValue: newValue,
            rangeSelect: event.shiftKey,
            groupSelectsFiltered: groupSelectsFiltered,
            event: event,
            source: "checkboxSelected"
        });
    }
    init(params) {
        this.rowNode = params.rowNode;
        this.column = params.column;
        this.overrides = params.overrides;
        this.onSelectionChanged();
        this.addManagedListeners(this.eCheckbox.getInputElement(), {
            // we don't want double click on this icon to open a group
            dblclick: (event)=>$7b57b57eaf5a9648$export$456c40e80134d72a(event),
            click: (event)=>{
                $7b57b57eaf5a9648$export$456c40e80134d72a(event);
                const groupSelectsFiltered = this.gos.get("groupSelectsFiltered");
                const isSelected = this.eCheckbox.getValue();
                if (this.shouldHandleIndeterminateState(isSelected, groupSelectsFiltered)) {
                    const result = this.onClicked(true, groupSelectsFiltered, event || {});
                    if (result === 0) this.onClicked(false, groupSelectsFiltered, event);
                } else if (isSelected) this.onClicked(false, groupSelectsFiltered, event);
                else this.onClicked(true, groupSelectsFiltered, event || {});
            }
        });
        this.addManagedListeners(this.rowNode, {
            rowSelected: this.onSelectionChanged.bind(this),
            dataChanged: this.onDataChanged.bind(this),
            selectableChanged: this.onSelectableChanged.bind(this)
        });
        const isRowSelectableFunc = this.gos.get("isRowSelectable");
        const checkboxVisibleIsDynamic = isRowSelectableFunc || typeof this.getIsVisible() === "function";
        if (checkboxVisibleIsDynamic) {
            const showOrHideSelectListener = this.showOrHideSelect.bind(this);
            this.addManagedEventListeners({
                displayedColumnsChanged: showOrHideSelectListener
            });
            this.addManagedListeners(this.rowNode, {
                dataChanged: showOrHideSelectListener,
                cellChanged: showOrHideSelectListener
            });
            this.showOrHideSelect();
        }
        this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
    }
    shouldHandleIndeterminateState(isSelected, groupSelectsFiltered) {
        return groupSelectsFiltered && (this.eCheckbox.getPreviousValue() === void 0 || isSelected === void 0) && this.gos.isRowModelType("clientSide");
    }
    showOrHideSelect() {
        let selectable = this.rowNode.selectable;
        const isVisible = this.getIsVisible();
        if (selectable) {
            if (typeof isVisible === "function") {
                const extraParams = this.overrides?.callbackParams;
                if (!this.column) selectable = isVisible({
                    ...extraParams,
                    node: this.rowNode,
                    data: this.rowNode.data
                });
                else {
                    const params = this.column.createColumnFunctionCallbackParams(this.rowNode);
                    selectable = isVisible({
                        ...extraParams,
                        ...params
                    });
                }
            } else selectable = isVisible ?? false;
        }
        const disableInsteadOfHide = this.column?.getColDef().showDisabledCheckboxes;
        if (disableInsteadOfHide) {
            this.eCheckbox.setDisabled(!selectable);
            this.setVisible(true);
            this.setDisplayed(true);
            return;
        }
        if (this.overrides?.removeHidden) {
            this.setDisplayed(selectable);
            return;
        }
        this.setVisible(selectable);
    }
    getIsVisible() {
        if (this.overrides) return this.overrides.isVisible;
        return this.column?.getColDef()?.checkboxSelection;
    }
};
// community-modules/core/src/rendering/dndSourceComp.ts
var $7b57b57eaf5a9648$var$DndSourceComp = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(rowNode, column, eCell){
        super(/* html */ `<div class="ag-drag-handle ag-row-drag" draggable="true"></div>`);
        this.rowNode = rowNode;
        this.column = column;
        this.eCell = eCell;
    }
    postConstruct() {
        const eGui = this.getGui();
        eGui.appendChild($7b57b57eaf5a9648$export$d8feba07bf373edb("rowDrag", this.gos, null));
        this.addGuiEventListener("mousedown", (e)=>{
            e.stopPropagation();
        });
        this.addDragSource();
        this.checkVisibility();
    }
    addDragSource() {
        this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
    }
    onDragStart(dragEvent) {
        const providedOnRowDrag = this.column.getColDef().dndSourceOnRowDrag;
        dragEvent.dataTransfer.setDragImage(this.eCell, 0, 0);
        const defaultOnRowDrag = ()=>{
            try {
                const jsonData = JSON.stringify(this.rowNode.data);
                dragEvent.dataTransfer.setData("application/json", jsonData);
                dragEvent.dataTransfer.setData("text/plain", jsonData);
            } catch (e) {}
        };
        if (providedOnRowDrag) {
            const params = this.gos.addGridCommonParams({
                rowNode: this.rowNode,
                dragEvent: dragEvent
            });
            providedOnRowDrag(params);
        } else defaultOnRowDrag();
    }
    checkVisibility() {
        const visible = this.column.isDndSource(this.rowNode);
        this.setDisplayed(visible);
    }
};
// community-modules/core/src/rendering/cell/cellCustomStyleFeature.ts
var $7b57b57eaf5a9648$var$CellCustomStyleFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(ctrl, beans){
        super();
        this.staticClasses = [];
        this.cellCtrl = ctrl;
        this.beans = beans;
        this.column = ctrl.getColumn();
        this.rowNode = ctrl.getRowNode();
    }
    setComp(comp) {
        this.cellComp = comp;
        this.applyUserStyles();
        this.applyCellClassRules();
        this.applyClassesFromColDef();
    }
    applyCellClassRules() {
        const colDef = this.column.getColDef();
        const { cellClassRules: cellClassRules  } = colDef;
        const cellClassParams = this.beans.gos.addGridCommonParams({
            value: this.cellCtrl.getValue(),
            data: this.rowNode.data,
            node: this.rowNode,
            colDef: colDef,
            column: this.column,
            rowIndex: this.rowNode.rowIndex
        });
        this.beans.stylingService.processClassRules(// if current was previous, skip
        cellClassRules === this.cellClassRules ? void 0 : this.cellClassRules, cellClassRules, cellClassParams, (className)=>this.cellComp.addOrRemoveCssClass(className, true), (className)=>this.cellComp.addOrRemoveCssClass(className, false));
        this.cellClassRules = cellClassRules;
    }
    applyUserStyles() {
        const colDef = this.column.getColDef();
        if (!colDef.cellStyle) return;
        let styles;
        if (typeof colDef.cellStyle === "function") {
            const cellStyleParams = this.beans.gos.addGridCommonParams({
                column: this.column,
                value: this.cellCtrl.getValue(),
                colDef: colDef,
                data: this.rowNode.data,
                node: this.rowNode,
                rowIndex: this.rowNode.rowIndex
            });
            const cellStyleFunc = colDef.cellStyle;
            styles = cellStyleFunc(cellStyleParams);
        } else styles = colDef.cellStyle;
        if (styles) this.cellComp.setUserStyles(styles);
    }
    applyClassesFromColDef() {
        const colDef = this.column.getColDef();
        const cellClassParams = this.beans.gos.addGridCommonParams({
            value: this.cellCtrl.getValue(),
            data: this.rowNode.data,
            node: this.rowNode,
            column: this.column,
            colDef: colDef,
            rowIndex: this.rowNode.rowIndex
        });
        if (this.staticClasses.length) this.staticClasses.forEach((className)=>this.cellComp.addOrRemoveCssClass(className, false));
        this.staticClasses = this.beans.stylingService.getStaticCellClasses(colDef, cellClassParams);
        if (this.staticClasses.length) this.staticClasses.forEach((className)=>this.cellComp.addOrRemoveCssClass(className, true));
    }
    // overriding to make public, as we don't dispose this bean via context
    destroy() {
        super.destroy();
    }
};
// community-modules/core/src/rendering/cell/cellKeyboardListenerFeature.ts
var $7b57b57eaf5a9648$var$CellKeyboardListenerFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(ctrl, beans, column, rowNode, rowCtrl){
        super();
        this.cellCtrl = ctrl;
        this.beans = beans;
        this.rowNode = rowNode;
        this.rowCtrl = rowCtrl;
    }
    setComp(eGui) {
        this.eGui = eGui;
    }
    onKeyDown(event) {
        const key = event.key;
        switch(key){
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER:
                this.onEnterKeyDown(event);
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.F2:
                this.onF2KeyDown(event);
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ESCAPE:
                this.onEscapeKeyDown(event);
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.TAB:
                this.onTabKeyDown(event);
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.BACKSPACE:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DELETE:
                this.onBackspaceOrDeleteKeyDown(key, event);
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT:
                this.onNavigationKeyDown(event, key);
                break;
        }
    }
    onNavigationKeyDown(event, key) {
        if (this.cellCtrl.isEditing()) return;
        if (event.shiftKey && this.cellCtrl.isRangeSelectionEnabled()) this.onShiftRangeSelect(event);
        else this.beans.navigationService.navigateToNextCell(event, key, this.cellCtrl.getCellPosition(), true);
        event.preventDefault();
    }
    onShiftRangeSelect(event) {
        if (!this.beans.rangeService) return;
        const endCell = this.beans.rangeService.extendLatestRangeInDirection(event);
        if (endCell) this.beans.navigationService.ensureCellVisible(endCell);
    }
    onTabKeyDown(event) {
        this.beans.navigationService.onTabKeyDown(this.cellCtrl, event);
    }
    onBackspaceOrDeleteKeyDown(key, event) {
        const { cellCtrl: cellCtrl , beans: beans , rowNode: rowNode  } = this;
        const { gos: gos , rangeService: rangeService , eventService: eventService  } = beans;
        if (cellCtrl.isEditing()) return;
        eventService.dispatchEvent({
            type: "keyShortcutChangedCellStart"
        });
        if ($7b57b57eaf5a9648$var$_isDeleteKey(key, gos.get("enableCellEditingOnBackspace"))) {
            if (rangeService && gos.get("enableRangeSelection")) rangeService.clearCellRangeCellValues({
                dispatchWrapperEvents: true,
                wrapperEventSource: "deleteKey"
            });
            else if (cellCtrl.isCellEditable()) {
                const column = cellCtrl.getColumn();
                const emptyValue = this.beans.valueService.parseValue(column, rowNode, "", rowNode.getValueFromValueService(column)) ?? null;
                rowNode.setDataValue(column, emptyValue, "cellClear");
            }
        } else cellCtrl.startRowOrCellEdit(key, event);
        eventService.dispatchEvent({
            type: "keyShortcutChangedCellEnd"
        });
    }
    onEnterKeyDown(e) {
        if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing()) this.cellCtrl.stopEditingAndFocus(false, e.shiftKey);
        else if (this.beans.gos.get("enterNavigatesVertically")) {
            const key = e.shiftKey ? $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP : $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN;
            this.beans.navigationService.navigateToNextCell(null, key, this.cellCtrl.getCellPosition(), false);
        } else {
            this.cellCtrl.startRowOrCellEdit($7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER, e);
            if (this.cellCtrl.isEditing()) e.preventDefault();
        }
    }
    onF2KeyDown(event) {
        if (!this.cellCtrl.isEditing()) this.cellCtrl.startRowOrCellEdit($7b57b57eaf5a9648$export$e9e0d96f49f57c33.F2, event);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onEscapeKeyDown(event) {
        if (this.cellCtrl.isEditing()) {
            this.cellCtrl.stopRowOrCellEdit(true);
            this.cellCtrl.focusCell(true);
        }
    }
    processCharacter(event) {
        const eventTarget = event.target;
        const eventOnChildComponent = eventTarget !== this.eGui;
        if (eventOnChildComponent || this.cellCtrl.isEditing()) return;
        const key = event.key;
        if (key === " ") this.onSpaceKeyDown(event);
        else {
            this.cellCtrl.startRowOrCellEdit(key, event);
            event.preventDefault();
        }
    }
    onSpaceKeyDown(event) {
        const { gos: gos  } = this.beans;
        if (!this.cellCtrl.isEditing() && gos.isRowSelection()) {
            const currentSelection = this.rowNode.isSelected();
            const newSelection = !currentSelection;
            if (newSelection || !gos.get("suppressRowDeselection")) {
                const groupSelectsFiltered = this.beans.gos.get("groupSelectsFiltered");
                const updatedCount = this.rowNode.setSelectedParams({
                    newValue: newSelection,
                    rangeSelect: event.shiftKey,
                    groupSelectsFiltered: groupSelectsFiltered,
                    event: event,
                    source: "spaceKey"
                });
                if (currentSelection === void 0 && updatedCount === 0) this.rowNode.setSelectedParams({
                    newValue: false,
                    rangeSelect: event.shiftKey,
                    groupSelectsFiltered: groupSelectsFiltered,
                    event: event,
                    source: "spaceKey"
                });
            }
        }
        event.preventDefault();
    }
    destroy() {
        super.destroy();
    }
};
// community-modules/core/src/rendering/cell/cellMouseListenerFeature.ts
var $7b57b57eaf5a9648$var$CellMouseListenerFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(ctrl, beans, column){
        super();
        this.cellCtrl = ctrl;
        this.beans = beans;
        this.column = column;
    }
    onMouseEvent(eventName, mouseEvent) {
        if ($7b57b57eaf5a9648$export$9a48e23524c6d58(mouseEvent)) return;
        switch(eventName){
            case "click":
                this.onCellClicked(mouseEvent);
                break;
            case "mousedown":
            case "touchstart":
                this.onMouseDown(mouseEvent);
                break;
            case "dblclick":
                this.onCellDoubleClicked(mouseEvent);
                break;
            case "mouseout":
                this.onMouseOut(mouseEvent);
                break;
            case "mouseover":
                this.onMouseOver(mouseEvent);
                break;
        }
    }
    onCellClicked(mouseEvent) {
        if (this.isDoubleClickOnIPad()) {
            this.onCellDoubleClicked(mouseEvent);
            mouseEvent.preventDefault();
            return;
        }
        const { eventService: eventService , rangeService: rangeService , gos: gos  } = this.beans;
        const isMultiKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
        if (rangeService && isMultiKey) {
            if (rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1) rangeService.intersectLastRange(true);
        }
        const cellClickedEvent = this.cellCtrl.createEvent(mouseEvent, "cellClicked");
        eventService.dispatchEvent(cellClickedEvent);
        const colDef = this.column.getColDef();
        if (colDef.onCellClicked) window.setTimeout(()=>{
            this.beans.frameworkOverrides.wrapOutgoing(()=>{
                colDef.onCellClicked(cellClickedEvent);
            });
        }, 0);
        const editOnSingleClick = (gos.get("singleClickEdit") || colDef.singleClickEdit) && !gos.get("suppressClickEdit");
        if (editOnSingleClick && !(mouseEvent.shiftKey && rangeService?.getCellRanges().length != 0)) this.cellCtrl.startRowOrCellEdit();
    }
    // returns true if on iPad and this is second 'click' event in 200ms
    isDoubleClickOnIPad() {
        if (!$7b57b57eaf5a9648$export$6b6034a68325bd8a() || $7b57b57eaf5a9648$var$_isEventSupported("dblclick")) return false;
        const nowMillis = /* @__PURE__ */ new Date().getTime();
        const res = nowMillis - this.lastIPadMouseClickEvent < 200;
        this.lastIPadMouseClickEvent = nowMillis;
        return res;
    }
    onCellDoubleClicked(mouseEvent) {
        const { column: column , beans: beans , cellCtrl: cellCtrl  } = this;
        const { eventService: eventService , frameworkOverrides: frameworkOverrides , gos: gos  } = beans;
        const colDef = column.getColDef();
        const cellDoubleClickedEvent = cellCtrl.createEvent(mouseEvent, "cellDoubleClicked");
        eventService.dispatchEvent(cellDoubleClickedEvent);
        if (typeof colDef.onCellDoubleClicked === "function") window.setTimeout(()=>{
            frameworkOverrides.wrapOutgoing(()=>{
                colDef.onCellDoubleClicked(cellDoubleClickedEvent);
            });
        }, 0);
        const editOnDoubleClick = !gos.get("singleClickEdit") && !gos.get("suppressClickEdit");
        if (editOnDoubleClick) cellCtrl.startRowOrCellEdit(null, mouseEvent);
    }
    onMouseDown(mouseEvent) {
        const { ctrlKey: ctrlKey , metaKey: metaKey , shiftKey: shiftKey  } = mouseEvent;
        const target = mouseEvent.target;
        const { cellCtrl: cellCtrl , beans: beans  } = this;
        const { eventService: eventService , rangeService: rangeService , focusService: focusService , gos: gos  } = beans;
        if (this.isRightClickInExistingRange(mouseEvent)) return;
        const ranges = rangeService && rangeService.getCellRanges().length != 0;
        if (!shiftKey || !ranges) {
            const isEnableCellTextSelection = gos.get("enableCellTextSelection");
            const shouldFocus = isEnableCellTextSelection && mouseEvent.defaultPrevented;
            const forceBrowserFocus = ($7b57b57eaf5a9648$var$_isBrowserSafari() || shouldFocus) && !cellCtrl.isEditing() && !$7b57b57eaf5a9648$var$_isFocusableFormField(target);
            cellCtrl.focusCell(forceBrowserFocus);
        }
        if (shiftKey && ranges && !focusService.isCellFocused(cellCtrl.getCellPosition())) {
            mouseEvent.preventDefault();
            const focusedCellPosition = focusService.getFocusedCell();
            if (focusedCellPosition) {
                const { column: column , rowIndex: rowIndex , rowPinned: rowPinned  } = focusedCellPosition;
                const focusedRowCtrl = beans.rowRenderer.getRowByPosition({
                    rowIndex: rowIndex,
                    rowPinned: rowPinned
                });
                const focusedCellCtrl = focusedRowCtrl?.getCellCtrl(column);
                if (focusedCellCtrl?.isEditing()) focusedCellCtrl.stopEditing();
                focusService.setFocusedCell({
                    column: column,
                    rowIndex: rowIndex,
                    rowPinned: rowPinned,
                    forceBrowserFocus: true,
                    preventScrollOnBrowserFocus: true
                });
            }
        }
        if (this.containsWidget(target)) return;
        if (rangeService) {
            const thisCell = this.cellCtrl.getCellPosition();
            if (shiftKey) rangeService.extendLatestRangeToCell(thisCell);
            else {
                const isMultiKey = ctrlKey || metaKey;
                rangeService.setRangeToCell(thisCell, isMultiKey);
            }
        }
        eventService.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseDown"));
    }
    isRightClickInExistingRange(mouseEvent) {
        const { rangeService: rangeService  } = this.beans;
        if (rangeService) {
            const cellInRange = rangeService.isCellInAnyRange(this.cellCtrl.getCellPosition());
            const isRightClick = mouseEvent.button === 2 || mouseEvent.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
            if (cellInRange && isRightClick) return true;
        }
        return false;
    }
    containsWidget(target) {
        return $7b57b57eaf5a9648$var$_isElementChildOfClass(target, "ag-selection-checkbox", 3);
    }
    onMouseOut(mouseEvent) {
        if (this.mouseStayingInsideCell(mouseEvent)) return;
        const cellMouseOutEvent = this.cellCtrl.createEvent(mouseEvent, "cellMouseOut");
        this.beans.eventService.dispatchEvent(cellMouseOutEvent);
        this.beans.columnHoverService.clearMouseOver();
    }
    onMouseOver(mouseEvent) {
        if (this.mouseStayingInsideCell(mouseEvent)) return;
        const cellMouseOverEvent = this.cellCtrl.createEvent(mouseEvent, "cellMouseOver");
        this.beans.eventService.dispatchEvent(cellMouseOverEvent);
        this.beans.columnHoverService.setMouseOver([
            this.column
        ]);
    }
    mouseStayingInsideCell(e) {
        if (!e.target || !e.relatedTarget) return false;
        const eGui = this.cellCtrl.getGui();
        const cellContainsTarget = eGui.contains(e.target);
        const cellContainsRelatedTarget = eGui.contains(e.relatedTarget);
        return cellContainsTarget && cellContainsRelatedTarget;
    }
    destroy() {
        super.destroy();
    }
};
// community-modules/core/src/rendering/cell/cellPositionFeature.ts
var $7b57b57eaf5a9648$var$CellPositionFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(ctrl, beans){
        super();
        this.cellCtrl = ctrl;
        this.beans = beans;
        this.column = ctrl.getColumn();
        this.rowNode = ctrl.getRowNode();
    }
    setupRowSpan() {
        this.rowSpan = this.column.getRowSpan(this.rowNode);
        this.addManagedListeners(this.beans.eventService, {
            newColumnsLoaded: ()=>this.onNewColumnsLoaded()
        });
    }
    setComp(eGui) {
        this.eGui = eGui;
        this.setupColSpan();
        this.setupRowSpan();
        this.onLeftChanged();
        this.onWidthChanged();
        this.applyRowSpan();
    }
    onNewColumnsLoaded() {
        const rowSpan = this.column.getRowSpan(this.rowNode);
        if (this.rowSpan === rowSpan) return;
        this.rowSpan = rowSpan;
        this.applyRowSpan(true);
    }
    onDisplayColumnsChanged() {
        const colsSpanning = this.getColSpanningList();
        if (!$7b57b57eaf5a9648$export$893967cdb9833fdd(this.colsSpanning, colsSpanning)) {
            this.colsSpanning = colsSpanning;
            this.onWidthChanged();
            this.onLeftChanged();
        }
    }
    setupColSpan() {
        if (this.column.getColDef().colSpan == null) return;
        this.colsSpanning = this.getColSpanningList();
        this.addManagedListeners(this.beans.eventService, {
            // because we are col spanning, a reorder of the cols can change what cols we are spanning over
            displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
            // because we are spanning over multiple cols, we check for width any time any cols width changes.
            // this is expensive - really we should be explicitly checking only the cols we are spanning over
            // instead of every col, however it would be tricky code to track the cols we are spanning over, so
            // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
            displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
        });
    }
    onWidthChanged() {
        if (!this.eGui) return;
        const width = this.getCellWidth();
        this.eGui.style.width = `${width}px`;
    }
    getCellWidth() {
        if (!this.colsSpanning) return this.column.getActualWidth();
        return this.colsSpanning.reduce((width, col)=>width + col.getActualWidth(), 0);
    }
    getColSpanningList() {
        const colSpan = this.column.getColSpan(this.rowNode);
        const colsSpanning = [];
        if (colSpan === 1) colsSpanning.push(this.column);
        else {
            let pointer = this.column;
            const pinned = this.column.getPinned();
            for(let i = 0; pointer && i < colSpan; i++){
                colsSpanning.push(pointer);
                pointer = this.beans.visibleColsService.getColAfter(pointer);
                if (!pointer || $7b57b57eaf5a9648$export$672d9e47bc342bac(pointer)) break;
                if (pinned !== pointer.getPinned()) break;
            }
        }
        return colsSpanning;
    }
    onLeftChanged() {
        if (!this.eGui) return;
        const left = this.modifyLeftForPrintLayout(this.getCellLeft());
        this.eGui.style.left = left + "px";
    }
    getCellLeft() {
        let mostLeftCol;
        if (this.beans.gos.get("enableRtl") && this.colsSpanning) mostLeftCol = $7b57b57eaf5a9648$export$236389741107357f(this.colsSpanning);
        else mostLeftCol = this.column;
        return mostLeftCol.getLeft();
    }
    modifyLeftForPrintLayout(leftPosition) {
        if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left") return leftPosition;
        const leftWidth = this.beans.visibleColsService.getColsLeftWidth();
        if (this.column.getPinned() === "right") {
            const bodyWidth = this.beans.visibleColsService.getBodyContainerWidth();
            return leftWidth + bodyWidth + (leftPosition || 0);
        }
        return leftWidth + (leftPosition || 0);
    }
    applyRowSpan(force) {
        if (this.rowSpan === 1 && !force) return;
        const singleRowHeight = this.beans.gos.getRowHeightAsNumber();
        const totalRowHeight = singleRowHeight * this.rowSpan;
        this.eGui.style.height = `${totalRowHeight}px`;
        this.eGui.style.zIndex = "1";
    }
    // overriding to make public, as we don't dispose this bean via context
    destroy() {
        super.destroy();
    }
};
// community-modules/core/src/interfaces/IRangeService.ts
var $7b57b57eaf5a9648$export$dc43114153b7f047 = /* @__PURE__ */ ((SelectionHandleType2)=>{
    SelectionHandleType2[SelectionHandleType2["FILL"] = 0] = "FILL";
    SelectionHandleType2[SelectionHandleType2["RANGE"] = 1] = "RANGE";
    return SelectionHandleType2;
})($7b57b57eaf5a9648$export$dc43114153b7f047 || {});
var $7b57b57eaf5a9648$export$162bc75b85f28397 = /* @__PURE__ */ ((CellRangeType2)=>{
    CellRangeType2[CellRangeType2["VALUE"] = 0] = "VALUE";
    CellRangeType2[CellRangeType2["DIMENSION"] = 1] = "DIMENSION";
    return CellRangeType2;
})($7b57b57eaf5a9648$export$162bc75b85f28397 || {});
// community-modules/core/src/rendering/cell/cellRangeFeature.ts
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_SELECTED = "ag-cell-range-selected";
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_CHART = "ag-cell-range-chart";
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_SINGLE_CELL = "ag-cell-range-single-cell";
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_CHART_CATEGORY = "ag-cell-range-chart-category";
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_HANDLE = "ag-cell-range-handle";
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_TOP = "ag-cell-range-top";
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_RIGHT = "ag-cell-range-right";
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_BOTTOM = "ag-cell-range-bottom";
var $7b57b57eaf5a9648$var$CSS_CELL_RANGE_LEFT = "ag-cell-range-left";
var $7b57b57eaf5a9648$var$CellRangeFeature = class {
    constructor(beans, ctrl){
        this.beans = beans;
        this.rangeService = beans.rangeService;
        this.selectionHandleFactory = beans.selectionHandleFactory;
        this.cellCtrl = ctrl;
    }
    setComp(cellComp, eGui) {
        this.cellComp = cellComp;
        this.eGui = eGui;
        this.onRangeSelectionChanged();
    }
    onRangeSelectionChanged() {
        if (!this.cellComp) return;
        this.rangeCount = this.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition());
        this.hasChartRange = this.getHasChartRange();
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_SELECTED, this.rangeCount !== 0);
        this.cellComp.addOrRemoveCssClass(`${$7b57b57eaf5a9648$var$CSS_CELL_RANGE_SELECTED}-1`, this.rangeCount === 1);
        this.cellComp.addOrRemoveCssClass(`${$7b57b57eaf5a9648$var$CSS_CELL_RANGE_SELECTED}-2`, this.rangeCount === 2);
        this.cellComp.addOrRemoveCssClass(`${$7b57b57eaf5a9648$var$CSS_CELL_RANGE_SELECTED}-3`, this.rangeCount === 3);
        this.cellComp.addOrRemoveCssClass(`${$7b57b57eaf5a9648$var$CSS_CELL_RANGE_SELECTED}-4`, this.rangeCount >= 4);
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_CHART, this.hasChartRange);
        $7b57b57eaf5a9648$export$c22e3722e8a33469(this.eGui, this.rangeCount > 0 ? true : void 0);
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_SINGLE_CELL, this.isSingleCell());
        this.updateRangeBorders();
        this.refreshHandle();
    }
    updateRangeBorders() {
        const rangeBorders = this.getRangeBorders();
        const isSingleCell = this.isSingleCell();
        const isTop = !isSingleCell && rangeBorders.top;
        const isRight = !isSingleCell && rangeBorders.right;
        const isBottom = !isSingleCell && rangeBorders.bottom;
        const isLeft = !isSingleCell && rangeBorders.left;
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_TOP, isTop);
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_RIGHT, isRight);
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_BOTTOM, isBottom);
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_LEFT, isLeft);
    }
    isSingleCell() {
        const { rangeService: rangeService  } = this.beans;
        return this.rangeCount === 1 && !!rangeService && !rangeService.isMoreThanOneCell();
    }
    getHasChartRange() {
        const { rangeService: rangeService  } = this.beans;
        if (!this.rangeCount || !rangeService) return false;
        const cellRanges = rangeService.getCellRanges();
        return cellRanges.length > 0 && cellRanges.every((range)=>$7b57b57eaf5a9648$export$fccf016a6caa651d([
                1 /* DIMENSION */ ,
                0 /* VALUE */ 
            ], range.type));
    }
    updateRangeBordersIfRangeCount() {
        if (this.rangeCount > 0) {
            this.updateRangeBorders();
            this.refreshHandle();
        }
    }
    getRangeBorders() {
        const isRtl = this.beans.gos.get("enableRtl");
        let top = false;
        let right = false;
        let bottom = false;
        let left = false;
        const thisCol = this.cellCtrl.getCellPosition().column;
        const presentedColsService = this.beans.visibleColsService;
        let leftCol;
        let rightCol;
        if (isRtl) {
            leftCol = presentedColsService.getColAfter(thisCol);
            rightCol = presentedColsService.getColBefore(thisCol);
        } else {
            leftCol = presentedColsService.getColBefore(thisCol);
            rightCol = presentedColsService.getColAfter(thisCol);
        }
        const ranges = this.rangeService.getCellRanges().filter((range)=>this.rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), range));
        if (!leftCol) left = true;
        if (!rightCol) right = true;
        for(let i = 0; i < ranges.length; i++){
            if (top && right && bottom && left) break;
            const range = ranges[i];
            const startRow = this.rangeService.getRangeStartRow(range);
            const endRow = this.rangeService.getRangeEndRow(range);
            if (!top && this.beans.rowPositionUtils.sameRow(startRow, this.cellCtrl.getCellPosition())) top = true;
            if (!bottom && this.beans.rowPositionUtils.sameRow(endRow, this.cellCtrl.getCellPosition())) bottom = true;
            if (!left && leftCol && range.columns.indexOf(leftCol) < 0) left = true;
            if (!right && rightCol && range.columns.indexOf(rightCol) < 0) right = true;
        }
        return {
            top: top,
            right: right,
            bottom: bottom,
            left: left
        };
    }
    refreshHandle() {
        if (this.beans.context.isDestroyed()) return;
        const shouldHaveSelectionHandle = this.shouldHaveSelectionHandle();
        if (this.selectionHandle && !shouldHaveSelectionHandle) this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);
        if (shouldHaveSelectionHandle) this.addSelectionHandle();
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_HANDLE, !!this.selectionHandle);
    }
    shouldHaveSelectionHandle() {
        const gos = this.beans.gos;
        const cellRanges = this.rangeService.getCellRanges();
        const rangesLen = cellRanges.length;
        if (this.rangeCount < 1 || rangesLen < 1) return false;
        const cellRange = $7b57b57eaf5a9648$export$236389741107357f(cellRanges);
        const cellPosition = this.cellCtrl.getCellPosition();
        const isFillHandleAvailable = gos.get("enableFillHandle") && !this.cellCtrl.isSuppressFillHandle();
        const isRangeHandleAvailable = gos.get("enableRangeHandle");
        let handleIsAvailable = rangesLen === 1 && !this.cellCtrl.isEditing() && (isFillHandleAvailable || isRangeHandleAvailable);
        if (this.hasChartRange) {
            const hasCategoryRange = cellRanges[0].type === 1 /* DIMENSION */ ;
            const isCategoryCell = hasCategoryRange && this.rangeService.isCellInSpecificRange(cellPosition, cellRanges[0]);
            this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_RANGE_CHART_CATEGORY, isCategoryCell);
            handleIsAvailable = cellRange.type === 0 /* VALUE */ ;
        }
        return handleIsAvailable && cellRange.endRow != null && this.rangeService.isContiguousRange(cellRange) && this.rangeService.isBottomRightCell(cellRange, cellPosition);
    }
    addSelectionHandle() {
        const gos = this.beans.gos;
        const cellRangeType = $7b57b57eaf5a9648$export$236389741107357f(this.rangeService.getCellRanges()).type;
        const selectionHandleFill = gos.get("enableFillHandle") && $7b57b57eaf5a9648$export$672d9e47bc342bac(cellRangeType);
        const type = selectionHandleFill ? 0 /* FILL */  : 1 /* RANGE */ ;
        if (this.selectionHandle && this.selectionHandle.getType() !== type) this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);
        if (!this.selectionHandle) this.selectionHandle = this.selectionHandleFactory.createSelectionHandle(type);
        this.selectionHandle.refresh(this.cellCtrl);
    }
    destroy() {
        this.beans.context.destroyBean(this.selectionHandle);
    }
};
// community-modules/core/src/rendering/cell/cellCtrl.ts
var $7b57b57eaf5a9648$var$CSS_CELL = "ag-cell";
var $7b57b57eaf5a9648$var$CSS_AUTO_HEIGHT = "ag-cell-auto-height";
var $7b57b57eaf5a9648$var$CSS_NORMAL_HEIGHT = "ag-cell-normal-height";
var $7b57b57eaf5a9648$var$CSS_CELL_FOCUS = "ag-cell-focus";
var $7b57b57eaf5a9648$var$CSS_CELL_FIRST_RIGHT_PINNED = "ag-cell-first-right-pinned";
var $7b57b57eaf5a9648$var$CSS_CELL_LAST_LEFT_PINNED = "ag-cell-last-left-pinned";
var $7b57b57eaf5a9648$var$CSS_CELL_NOT_INLINE_EDITING = "ag-cell-not-inline-editing";
var $7b57b57eaf5a9648$var$CSS_COLUMN_HOVER = "ag-column-hover";
var $7b57b57eaf5a9648$var$CSS_CELL_WRAP_TEXT = "ag-cell-wrap-text";
var $7b57b57eaf5a9648$var$instanceIdSequence4 = 0;
var $7b57b57eaf5a9648$var$_CellCtrl = class _CellCtrl extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(column, rowNode, beans, rowCtrl){
        super();
        this.column = column;
        this.rowNode = rowNode;
        this.beans = beans;
        this.rowCtrl = rowCtrl;
        this.cellRangeFeature = null;
        this.cellPositionFeature = null;
        this.cellCustomStyleFeature = null;
        this.tooltipFeature = null;
        this.cellMouseListenerFeature = null;
        this.cellKeyboardListenerFeature = null;
        this.suppressRefreshCell = false;
        this.onCellCompAttachedFuncs = [];
        this.instanceId = column.getId() + "-" + $7b57b57eaf5a9648$var$instanceIdSequence4++;
        this.colIdSanitised = $7b57b57eaf5a9648$export$3df06b741968da82(this.column.getId());
        if (!beans.gos.get("suppressCellFocus")) this.tabIndex = -1;
        this.createCellPosition();
        this.addFeatures();
        this.updateAndFormatValue(false);
    }
    shouldRestoreFocus() {
        return this.beans.focusService.shouldRestoreFocus(this.cellPosition);
    }
    addFeatures() {
        this.cellPositionFeature = new $7b57b57eaf5a9648$var$CellPositionFeature(this, this.beans);
        this.addDestroyFunc(()=>{
            this.cellPositionFeature?.destroy();
            this.cellPositionFeature = null;
        });
        this.cellCustomStyleFeature = new $7b57b57eaf5a9648$var$CellCustomStyleFeature(this, this.beans);
        this.addDestroyFunc(()=>{
            this.cellCustomStyleFeature?.destroy();
            this.cellCustomStyleFeature = null;
        });
        this.cellMouseListenerFeature = new $7b57b57eaf5a9648$var$CellMouseListenerFeature(this, this.beans, this.column);
        this.addDestroyFunc(()=>{
            this.cellMouseListenerFeature?.destroy();
            this.cellMouseListenerFeature = null;
        });
        this.cellKeyboardListenerFeature = new $7b57b57eaf5a9648$var$CellKeyboardListenerFeature(this, this.beans, this.column, this.rowNode, this.rowCtrl);
        this.addDestroyFunc(()=>{
            this.cellKeyboardListenerFeature?.destroy();
            this.cellKeyboardListenerFeature = null;
        });
        if (this.column.isTooltipEnabled()) {
            this.enableTooltipFeature();
            this.addDestroyFunc(()=>{
                this.disableTooltipFeature();
            });
        }
        const rangeSelectionEnabled = this.beans.rangeService && this.beans.gos.get("enableRangeSelection");
        if (rangeSelectionEnabled) {
            this.cellRangeFeature = new $7b57b57eaf5a9648$var$CellRangeFeature(this.beans, this);
            this.addDestroyFunc(()=>{
                this.cellRangeFeature?.destroy();
                this.cellRangeFeature = null;
            });
        }
    }
    enableTooltipFeature(value, shouldDisplayTooltip) {
        const getTooltipValue = ()=>{
            const colDef = this.column.getColDef();
            const data = this.rowNode.data;
            if (colDef.tooltipField && $7b57b57eaf5a9648$export$25d27f17d3af40f7(data)) return $7b57b57eaf5a9648$var$_getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());
            const valueGetter = colDef.tooltipValueGetter;
            if (valueGetter) return valueGetter(this.beans.gos.addGridCommonParams({
                location: "cell",
                colDef: this.column.getColDef(),
                column: this.column,
                rowIndex: this.cellPosition.rowIndex,
                node: this.rowNode,
                data: this.rowNode.data,
                value: this.value,
                valueFormatted: this.valueFormatted
            }));
            return null;
        };
        const isTooltipWhenTruncated = this.beans.gos.get("tooltipShowMode") === "whenTruncated";
        if (!shouldDisplayTooltip && isTooltipWhenTruncated && !this.isCellRenderer()) shouldDisplayTooltip = ()=>{
            const eGui = this.getGui();
            const textEl = eGui.children.length === 0 ? eGui : eGui.querySelector(".ag-cell-value");
            if (!textEl) return true;
            return textEl.scrollWidth > textEl.clientWidth;
        };
        const tooltipCtrl = {
            getColumn: ()=>this.column,
            getColDef: ()=>this.column.getColDef(),
            getRowIndex: ()=>this.cellPosition.rowIndex,
            getRowNode: ()=>this.rowNode,
            getGui: ()=>this.getGui(),
            getLocation: ()=>"cell",
            getTooltipValue: value != null ? ()=>value : getTooltipValue,
            // this makes no sense, why is the cell formatted value passed to the tooltip???
            getValueFormatted: ()=>this.valueFormatted,
            shouldDisplayTooltip: shouldDisplayTooltip
        };
        this.tooltipFeature = new $7b57b57eaf5a9648$export$e5073a590d24815c(tooltipCtrl, this.beans);
    }
    disableTooltipFeature() {
        if (!this.tooltipFeature) return;
        this.tooltipFeature.destroy();
        this.tooltipFeature = null;
    }
    setComp(comp, eGui, eCellWrapper, printLayout, startEditing) {
        this.cellComp = comp;
        this.eGui = eGui;
        this.printLayout = printLayout;
        this.addDomData();
        this.onCellFocused(this.focusEventToRestore);
        this.applyStaticCssClasses();
        this.setWrapText();
        this.onFirstRightPinnedChanged();
        this.onLastLeftPinnedChanged();
        this.onColumnHover();
        this.setupControlComps();
        this.setupAutoHeight(eCellWrapper);
        this.refreshFirstAndLastStyles();
        this.refreshAriaColIndex();
        this.cellPositionFeature?.setComp(eGui);
        this.cellCustomStyleFeature?.setComp(comp);
        this.tooltipFeature?.refreshToolTip();
        this.cellKeyboardListenerFeature?.setComp(this.eGui);
        if (this.cellRangeFeature) this.cellRangeFeature.setComp(comp, eGui);
        if (startEditing && this.isCellEditable()) this.startEditing();
        else this.showValue();
        if (this.onCellCompAttachedFuncs.length) {
            this.onCellCompAttachedFuncs.forEach((func)=>func());
            this.onCellCompAttachedFuncs = [];
        }
    }
    setupAutoHeight(eCellWrapper) {
        this.isAutoHeight = this.column.isAutoHeight();
        if (!this.isAutoHeight || !eCellWrapper) return;
        const eParentCell = eCellWrapper.parentElement;
        const minRowHeight = this.beans.gos.getRowHeightForNode(this.rowNode).height;
        const measureHeight = (timesCalled)=>{
            if (this.editing) return;
            if (!this.isAlive()) return;
            const { paddingTop: paddingTop , paddingBottom: paddingBottom , borderBottomWidth: borderBottomWidth , borderTopWidth: borderTopWidth  } = $7b57b57eaf5a9648$var$_getElementSize(eParentCell);
            const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
            const wrapperHeight = eCellWrapper.offsetHeight;
            const autoHeight = wrapperHeight + extraHeight;
            if (timesCalled < 5) {
                const doc = this.beans.gos.getDocument();
                const notYetInDom = !doc || !doc.contains(eCellWrapper);
                const possiblyNoContentYet = autoHeight == 0;
                if (notYetInDom || possiblyNoContentYet) {
                    window.setTimeout(()=>measureHeight(timesCalled + 1), 0);
                    return;
                }
            }
            const newHeight = Math.max(autoHeight, minRowHeight);
            this.rowNode.setRowAutoHeight(newHeight, this.column);
        };
        const listener = ()=>measureHeight(0);
        listener();
        const destroyResizeObserver = this.beans.resizeObserverService.observeResize(eCellWrapper, listener);
        this.addDestroyFunc(()=>{
            destroyResizeObserver();
            this.rowNode.setRowAutoHeight(void 0, this.column);
        });
    }
    getCellAriaRole() {
        return this.column.getColDef().cellAriaRole ?? "gridcell";
    }
    getInstanceId() {
        return this.instanceId;
    }
    getColumnIdSanitised() {
        return this.colIdSanitised;
    }
    getTabIndex() {
        return this.tabIndex;
    }
    isCellRenderer() {
        const colDef = this.column.getColDef();
        return colDef.cellRenderer != null || colDef.cellRendererSelector != null;
    }
    getValueToDisplay() {
        return this.valueFormatted ?? this.value;
    }
    showValue(forceNewCellRendererInstance = false) {
        const valueToDisplay = this.getValueToDisplay();
        let compDetails;
        if (this.rowNode.stub) {
            const params = this.createCellRendererParams();
            compDetails = this.beans.userComponentFactory.getLoadingCellRendererDetails(this.column.getColDef(), params);
        } else if (this.isCellRenderer()) {
            const params = this.createCellRendererParams();
            compDetails = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), params);
        }
        this.cellComp.setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance);
        this.cellRangeFeature?.refreshHandle();
    }
    setupControlComps() {
        const colDef = this.column.getColDef();
        this.includeSelection = this.isIncludeControl(colDef.checkboxSelection);
        this.includeRowDrag = this.isIncludeControl(colDef.rowDrag);
        this.includeDndSource = this.isIncludeControl(colDef.dndSource);
        this.cellComp.setIncludeSelection(this.includeSelection);
        this.cellComp.setIncludeDndSource(this.includeDndSource);
        this.cellComp.setIncludeRowDrag(this.includeRowDrag);
    }
    isForceWrapper() {
        const forceWrapper = this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
        return forceWrapper;
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    isIncludeControl(value) {
        const rowNodePinned = this.rowNode.rowPinned != null;
        const isFunc = typeof value === "function";
        const res = rowNodePinned ? false : isFunc || value === true;
        return res;
    }
    refreshShouldDestroy() {
        const colDef = this.column.getColDef();
        const selectionChanged = this.includeSelection != this.isIncludeControl(colDef.checkboxSelection);
        const rowDragChanged = this.includeRowDrag != this.isIncludeControl(colDef.rowDrag);
        const dndSourceChanged = this.includeDndSource != this.isIncludeControl(colDef.dndSource);
        const autoHeightChanged = this.isAutoHeight != this.column.isAutoHeight();
        return selectionChanged || rowDragChanged || dndSourceChanged || autoHeightChanged;
    }
    // either called internally if single cell editing, or called by rowRenderer if row editing
    startEditing(key = null, cellStartedEdit = false, event = null) {
        const { editService: editService  } = this.beans;
        if (!this.isCellEditable() || this.editing || !editService) return;
        if (!this.cellComp) {
            this.onCellCompAttachedFuncs.push(()=>{
                this.startEditing(key, cellStartedEdit, event);
            });
            return;
        }
        editService.startEditing(this, key, cellStartedEdit, event);
    }
    setEditing(editing, compDetails) {
        this.editCompDetails = compDetails;
        if (this.editing === editing) return;
        this.editing = editing;
        this.cellRangeFeature?.refreshHandle();
    }
    // pass in 'true' to cancel the editing.
    stopRowOrCellEdit(cancel = false) {
        if (this.beans.gos.get("editType") === "fullRow") this.rowCtrl.stopEditing(cancel);
        else this.stopEditing(cancel);
    }
    onPopupEditorClosed() {
        if (!this.editing) return;
        this.stopEditingAndFocus();
    }
    /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */ stopEditing(cancel = false) {
        const { editService: editService  } = this.beans;
        if (!this.editing || !editService) return false;
        return editService.stopEditing(this, cancel);
    }
    createCellRendererParams() {
        const res = this.beans.gos.addGridCommonParams({
            value: this.value,
            valueFormatted: this.valueFormatted,
            getValue: ()=>this.rowNode.getValueFromValueService(this.column),
            setValue: (value)=>this.beans.valueService.setValue(this.rowNode, this.column, value),
            formatValue: this.formatValue.bind(this),
            data: this.rowNode.data,
            node: this.rowNode,
            pinned: this.column.getPinned(),
            colDef: this.column.getColDef(),
            column: this.column,
            refreshCell: this.refreshCell.bind(this),
            eGridCell: this.getGui(),
            eParentOfValue: this.cellComp.getParentOfValue(),
            registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange)=>this.registerRowDragger(rowDraggerElement, dragStartPixels, suppressVisibilityChange),
            setTooltip: (value, shouldDisplayTooltip)=>{
                if (this.tooltipFeature) this.disableTooltipFeature();
                this.enableTooltipFeature(value, shouldDisplayTooltip);
                this.tooltipFeature?.refreshToolTip();
            }
        });
        return res;
    }
    setFocusOutOnEditor() {
        if (!this.editing) return;
        this.beans.editService?.setFocusOutOnEditor(this);
    }
    setFocusInOnEditor() {
        if (!this.editing) return;
        this.beans.editService?.setFocusInOnEditor(this);
    }
    onCellChanged(event) {
        const eventImpactsThisCell = event.column === this.column;
        if (eventImpactsThisCell) this.refreshCell({});
    }
    refreshOrDestroyCell(params) {
        if (this.refreshShouldDestroy()) this.rowCtrl?.recreateCell(this);
        else this.refreshCell(params);
    }
    // + stop editing {forceRefresh: true, suppressFlash: true}
    // + event cellChanged {}
    // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
    // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
    // + rowCtrl: api refreshCells() {animate: true/false}
    // + rowRenderer: api softRefreshView() {}
    refreshCell(params) {
        if (this.suppressRefreshCell || this.editing) return;
        const colDef = this.column.getColDef();
        const newData = params != null && !!params.newData;
        const suppressFlash = params != null && !!params.suppressFlash || !!colDef.suppressCellFlash;
        const noValueProvided = colDef.field == null && colDef.valueGetter == null && colDef.showRowGroup == null;
        const forceRefresh = params && params.forceRefresh || noValueProvided || newData;
        const isCellCompReady = !!this.cellComp;
        const valuesDifferent = this.updateAndFormatValue(isCellCompReady);
        const dataNeedsUpdating = forceRefresh || valuesDifferent;
        if (!isCellCompReady) return;
        if (dataNeedsUpdating) {
            this.showValue(newData);
            const processingFilterChange = this.beans.filterManager?.isSuppressFlashingCellsBecauseFiltering();
            const flashCell = !suppressFlash && !processingFilterChange && (this.beans.gos.get("enableCellChangeFlash") || colDef.enableCellChangeFlash);
            if (flashCell) this.flashCell();
            this.cellCustomStyleFeature?.applyUserStyles();
            this.cellCustomStyleFeature?.applyClassesFromColDef();
        }
        this.tooltipFeature?.refreshToolTip();
        this.cellCustomStyleFeature?.applyCellClassRules();
    }
    // cell editors call this, when they want to stop for reasons other
    // than what we pick up on. eg selecting from a dropdown ends editing.
    stopEditingAndFocus(suppressNavigateAfterEdit = false, shiftKey = false) {
        this.beans.editService?.stopEditingAndFocus(this, suppressNavigateAfterEdit, shiftKey);
    }
    // user can also call this via API
    flashCell(delays) {
        const flashDuration = delays?.flashDuration ?? delays?.flashDelay;
        const fadeDuration = delays?.fadeDuration ?? delays?.fadeDelay;
        this.animateCell("data-changed", flashDuration, fadeDuration);
    }
    animateCell(cssName, flashDuration, fadeDuration) {
        if (!this.cellComp) return;
        const fullName = `ag-cell-${cssName}`;
        const animationFullName = `ag-cell-${cssName}-animation`;
        const { gos: gos  } = this.beans;
        if (!flashDuration) flashDuration = gos.get("cellFlashDuration");
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(fadeDuration)) fadeDuration = gos.get("cellFadeDuration");
        this.cellComp.addOrRemoveCssClass(fullName, true);
        this.cellComp.addOrRemoveCssClass(animationFullName, false);
        this.beans.frameworkOverrides.wrapIncoming(()=>{
            window.setTimeout(()=>{
                if (!this.isAlive()) return;
                this.cellComp.addOrRemoveCssClass(fullName, false);
                this.cellComp.addOrRemoveCssClass(animationFullName, true);
                this.eGui.style.transition = `background-color ${fadeDuration}ms`;
                window.setTimeout(()=>{
                    if (!this.isAlive()) return;
                    this.cellComp.addOrRemoveCssClass(animationFullName, false);
                    this.eGui.style.transition = "";
                }, fadeDuration);
            }, flashDuration);
        });
    }
    onFlashCells(event) {
        if (!this.cellComp) return;
        const cellId = this.beans.cellPositionUtils.createId(this.getCellPosition());
        const shouldFlash = event.cells[cellId];
        if (shouldFlash) this.animateCell("highlight");
    }
    isCellEditable() {
        return this.column.isCellEditable(this.rowNode);
    }
    isSuppressFillHandle() {
        return this.column.isSuppressFillHandle();
    }
    formatValue(value) {
        return this.callValueFormatter(value) ?? value;
    }
    callValueFormatter(value) {
        return this.beans.valueService.formatValue(this.column, this.rowNode, value);
    }
    updateAndFormatValue(compareValues) {
        const oldValue = this.value;
        const oldValueFormatted = this.valueFormatted;
        this.value = this.rowNode.getValueFromValueService(this.column);
        this.valueFormatted = this.callValueFormatter(this.value);
        if (compareValues) return !this.valuesAreEqual(oldValue, this.value) || this.valueFormatted != oldValueFormatted;
        return true;
    }
    valuesAreEqual(val1, val2) {
        const colDef = this.column.getColDef();
        return colDef.equals ? colDef.equals(val1, val2) : val1 === val2;
    }
    getComp() {
        return this.cellComp;
    }
    getValue() {
        return this.value;
    }
    addDomData() {
        const element = this.getGui();
        this.beans.gos.setDomData(element, _CellCtrl.DOM_DATA_KEY_CELL_CTRL, this);
        this.addDestroyFunc(()=>this.beans.gos.setDomData(element, _CellCtrl.DOM_DATA_KEY_CELL_CTRL, null));
    }
    createEvent(domEvent, eventType) {
        const event = this.beans.gos.addGridCommonParams({
            type: eventType,
            node: this.rowNode,
            data: this.rowNode.data,
            value: this.value,
            column: this.column,
            colDef: this.column.getColDef(),
            rowPinned: this.rowNode.rowPinned,
            event: domEvent,
            rowIndex: this.rowNode.rowIndex
        });
        return event;
    }
    processCharacter(event) {
        this.cellKeyboardListenerFeature?.processCharacter(event);
    }
    onKeyDown(event) {
        this.cellKeyboardListenerFeature?.onKeyDown(event);
    }
    onMouseEvent(eventName, mouseEvent) {
        this.cellMouseListenerFeature?.onMouseEvent(eventName, mouseEvent);
    }
    getGui() {
        return this.eGui;
    }
    getColSpanningList() {
        return this.cellPositionFeature.getColSpanningList();
    }
    onLeftChanged() {
        if (!this.cellComp) return;
        this.cellPositionFeature?.onLeftChanged();
    }
    onDisplayedColumnsChanged() {
        if (!this.eGui) return;
        this.refreshAriaColIndex();
        this.refreshFirstAndLastStyles();
    }
    refreshFirstAndLastStyles() {
        const { cellComp: cellComp , column: column , beans: beans  } = this;
        $7b57b57eaf5a9648$var$refreshFirstAndLastStyles(cellComp, column, beans.visibleColsService);
    }
    refreshAriaColIndex() {
        const colIdx = this.beans.visibleColsService.getAriaColIndex(this.column);
        $7b57b57eaf5a9648$export$84b73ecd0b234e89(this.getGui(), colIdx);
    }
    isSuppressNavigable() {
        return this.column.isSuppressNavigable(this.rowNode);
    }
    onWidthChanged() {
        return this.cellPositionFeature?.onWidthChanged();
    }
    getColumn() {
        return this.column;
    }
    getRowNode() {
        return this.rowNode;
    }
    isPrintLayout() {
        return this.printLayout;
    }
    getCellPosition() {
        return this.cellPosition;
    }
    isEditing() {
        return this.editing;
    }
    // called by rowRenderer when user navigates via tab key
    startRowOrCellEdit(key, event = null) {
        if (!this.cellComp) {
            this.onCellCompAttachedFuncs.push(()=>{
                this.startRowOrCellEdit(key, event);
            });
            return;
        }
        if (this.beans.gos.get("editType") === "fullRow") this.rowCtrl.startRowEditing(key, this);
        else this.startEditing(key, true, event);
    }
    getRowCtrl() {
        return this.rowCtrl;
    }
    getRowPosition() {
        return {
            rowIndex: this.cellPosition.rowIndex,
            rowPinned: this.cellPosition.rowPinned
        };
    }
    updateRangeBordersIfRangeCount() {
        if (!this.cellComp) return;
        if (this.cellRangeFeature) this.cellRangeFeature.updateRangeBordersIfRangeCount();
    }
    onRangeSelectionChanged() {
        if (!this.cellComp) return;
        if (this.cellRangeFeature) this.cellRangeFeature.onRangeSelectionChanged();
    }
    isRangeSelectionEnabled() {
        return this.cellRangeFeature != null;
    }
    focusCell(forceBrowserFocus = false) {
        this.beans.focusService.setFocusedCell({
            rowIndex: this.getCellPosition().rowIndex,
            column: this.column,
            rowPinned: this.rowNode.rowPinned,
            forceBrowserFocus: forceBrowserFocus
        });
    }
    onRowIndexChanged() {
        this.createCellPosition();
        this.onCellFocused();
        if (this.cellRangeFeature) this.cellRangeFeature.onRangeSelectionChanged();
    }
    onFirstRightPinnedChanged() {
        if (!this.cellComp) return;
        const firstRightPinned = this.column.isFirstRightPinned();
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_FIRST_RIGHT_PINNED, firstRightPinned);
    }
    onLastLeftPinnedChanged() {
        if (!this.cellComp) return;
        const lastLeftPinned = this.column.isLastLeftPinned();
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_LAST_LEFT_PINNED, lastLeftPinned);
    }
    onCellFocused(event) {
        if (this.beans.gos.get("suppressCellFocus")) return;
        const cellFocused = this.beans.focusService.isCellFocused(this.cellPosition);
        if (!this.cellComp) {
            if (cellFocused && event?.forceBrowserFocus) this.focusEventToRestore = event;
            return;
        }
        this.focusEventToRestore = void 0;
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_FOCUS, cellFocused);
        if (cellFocused && event && event.forceBrowserFocus) {
            let focusEl = this.cellComp.getFocusableElement();
            if (this.editing) {
                const focusableEls = this.beans.focusService.findFocusableElements(focusEl, null, true);
                if (focusableEls.length) focusEl = focusableEls[0];
            }
            focusEl.focus({
                preventScroll: !!event.preventScrollOnBrowserFocus
            });
        }
        const fullRowEdit = this.beans.gos.get("editType") === "fullRow";
        if (!cellFocused && !fullRowEdit && this.editing) this.stopRowOrCellEdit();
        if (cellFocused) this.rowCtrl.announceDescription();
    }
    createCellPosition() {
        this.cellPosition = {
            rowIndex: this.rowNode.rowIndex,
            rowPinned: $7b57b57eaf5a9648$export$4978424c4f7b5fc0(this.rowNode.rowPinned),
            column: this.column
        };
    }
    // CSS Classes that only get applied once, they never change
    applyStaticCssClasses() {
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL, true);
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_NOT_INLINE_EDITING, true);
        const autoHeight = this.column.isAutoHeight() == true;
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_AUTO_HEIGHT, autoHeight);
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_NORMAL_HEIGHT, !autoHeight);
    }
    onColumnHover() {
        if (!this.cellComp) return;
        if (!this.beans.gos.get("columnHoverHighlight")) return;
        const isHovered = this.beans.columnHoverService.isHovered(this.column);
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_COLUMN_HOVER, isHovered);
    }
    onColDefChanged() {
        if (!this.cellComp) return;
        const isTooltipEnabled = this.column.isTooltipEnabled();
        if (isTooltipEnabled) {
            this.disableTooltipFeature();
            this.enableTooltipFeature();
        } else this.disableTooltipFeature();
        this.setWrapText();
        if (!this.editing) this.refreshOrDestroyCell({
            forceRefresh: true,
            suppressFlash: true
        });
        else this.beans.editService?.handleColDefChanged(this);
    }
    setWrapText() {
        const value = this.column.getColDef().wrapText == true;
        this.cellComp.addOrRemoveCssClass($7b57b57eaf5a9648$var$CSS_CELL_WRAP_TEXT, value);
    }
    dispatchCellContextMenuEvent(event) {
        const colDef = this.column.getColDef();
        const cellContextMenuEvent = this.createEvent(event, "cellContextMenu");
        this.beans.eventService.dispatchEvent(cellContextMenuEvent);
        if (colDef.onCellContextMenu) window.setTimeout(()=>{
            this.beans.frameworkOverrides.wrapOutgoing(()=>{
                colDef.onCellContextMenu(cellContextMenuEvent);
            });
        }, 0);
    }
    getCellRenderer() {
        return this.cellComp ? this.cellComp.getCellRenderer() : null;
    }
    getCellEditor() {
        return this.cellComp ? this.cellComp.getCellEditor() : null;
    }
    destroy() {
        this.onCellCompAttachedFuncs = [];
        super.destroy();
    }
    createSelectionCheckbox() {
        const cbSelectionComponent = new $7b57b57eaf5a9648$export$b54c7a6db4674fde();
        this.beans.context.createBean(cbSelectionComponent);
        cbSelectionComponent.init({
            rowNode: this.rowNode,
            column: this.column
        });
        return cbSelectionComponent;
    }
    createDndSource() {
        const dndSourceComp = new $7b57b57eaf5a9648$var$DndSourceComp(this.rowNode, this.column, this.eGui);
        this.beans.context.createBean(dndSourceComp);
        return dndSourceComp;
    }
    registerRowDragger(customElement, dragStartPixels, suppressVisibilityChange) {
        if (this.customRowDragComp) {
            this.customRowDragComp.setDragElement(customElement, dragStartPixels);
            return;
        }
        const newComp = this.createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange);
        if (newComp) {
            this.customRowDragComp = newComp;
            this.addDestroyFunc(()=>{
                this.beans.context.destroyBean(newComp);
                this.customRowDragComp = null;
            });
        }
    }
    createRowDragComp(customElement, dragStartPixels, suppressVisibilityChange) {
        const pagination = this.beans.gos.get("pagination");
        const rowDragManaged = this.beans.gos.get("rowDragManaged");
        const clientSideRowModelActive = this.beans.gos.isRowModelType("clientSide");
        if (rowDragManaged) {
            if (!clientSideRowModelActive) {
                $7b57b57eaf5a9648$export$2cf41453020eef66("managed row dragging is only allowed in the Client Side Row Model");
                return;
            }
            if (pagination) {
                $7b57b57eaf5a9648$export$2cf41453020eef66("managed row dragging is not possible when doing pagination");
                return;
            }
        }
        const rowDragComp = new $7b57b57eaf5a9648$export$10f7d2f62fe74867(()=>this.value, this.rowNode, this.column, customElement, dragStartPixels, suppressVisibilityChange);
        this.beans.context.createBean(rowDragComp);
        return rowDragComp;
    }
    setSuppressRefreshCell(suppressRefreshCell) {
        this.suppressRefreshCell = suppressRefreshCell;
    }
    getEditCompDetails() {
        return this.editCompDetails;
    }
};
$7b57b57eaf5a9648$var$_CellCtrl.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
var $7b57b57eaf5a9648$export$4fd76abbfd48a7b6 = $7b57b57eaf5a9648$var$_CellCtrl;
// community-modules/core/src/rendering/row/rowCtrl.ts
var $7b57b57eaf5a9648$var$instanceIdSequence5 = 0;
var $7b57b57eaf5a9648$var$_RowCtrl = class _RowCtrl extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(rowNode, beans, animateIn, useAnimationFrameForCreate, printLayout){
        super();
        this.allRowGuis = [];
        this.active = true;
        this.centerCellCtrls = {
            list: [],
            map: {}
        };
        this.leftCellCtrls = {
            list: [],
            map: {}
        };
        this.rightCellCtrls = {
            list: [],
            map: {}
        };
        this.slideInAnimation = {
            left: false,
            center: false,
            right: false,
            fullWidth: false
        };
        this.fadeInAnimation = {
            left: false,
            center: false,
            right: false,
            fullWidth: false
        };
        this.rowDragComps = [];
        this.lastMouseDownOnDragger = false;
        this.emptyStyle = {};
        this.updateColumnListsPending = false;
        this.rowId = null;
        this.businessKeySanitised = null;
        this.beans = beans;
        this.gos = beans.gos;
        this.rowNode = rowNode;
        this.paginationPage = beans.paginationService?.getCurrentPage() ?? 0;
        this.useAnimationFrameForCreate = useAnimationFrameForCreate;
        this.printLayout = printLayout;
        this.suppressRowTransform = this.gos.get("suppressRowTransform");
        this.instanceId = rowNode.id + "-" + $7b57b57eaf5a9648$var$instanceIdSequence5++;
        this.rowId = $7b57b57eaf5a9648$export$3df06b741968da82(rowNode.id);
        this.initRowBusinessKey();
        this.rowFocused = beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
        this.rowLevel = beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
        this.setRowType();
        this.setAnimateFlags(animateIn);
        this.rowStyles = this.processStylesFromGridOptions();
        if (this.isFullWidth() && !this.gos.get("suppressCellFocus")) this.tabIndex = -1;
        this.addListeners();
    }
    initRowBusinessKey() {
        this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode");
        this.updateRowBusinessKey();
    }
    updateRowBusinessKey() {
        if (typeof this.businessKeyForNodeFunc !== "function") return;
        const businessKey = this.businessKeyForNodeFunc(this.rowNode);
        this.businessKeySanitised = $7b57b57eaf5a9648$export$3df06b741968da82(businessKey);
    }
    getRowId() {
        return this.rowId;
    }
    getRowStyles() {
        return this.rowStyles;
    }
    getTabIndex() {
        return this.tabIndex;
    }
    isSticky() {
        return this.rowNode.sticky;
    }
    getInstanceId() {
        return this.instanceId;
    }
    updateGui(containerType, gui) {
        if (containerType === "left") this.leftGui = gui;
        else if (containerType === "right") this.rightGui = gui;
        else if (containerType === "fullWidth") this.fullWidthGui = gui;
        else this.centerGui = gui;
    }
    setComp(rowComp, element, containerType) {
        const gui = {
            rowComp: rowComp,
            element: element,
            containerType: containerType
        };
        this.allRowGuis.push(gui);
        this.updateGui(containerType, gui);
        this.initialiseRowComp(gui);
        if (this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned) this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
    }
    unsetComp(containerType) {
        this.allRowGuis = this.allRowGuis.filter((rowGui)=>rowGui.containerType !== containerType);
        this.updateGui(containerType, void 0);
    }
    isCacheable() {
        return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
    }
    setCached(cached) {
        const displayValue = cached ? "none" : "";
        this.allRowGuis.forEach((rg)=>rg.element.style.display = displayValue);
    }
    initialiseRowComp(gui) {
        const gos = this.gos;
        this.listenOnDomOrder(gui);
        if (this.beans.columnModel.wasAutoRowHeightEverActive()) this.rowNode.checkAutoHeights();
        this.onRowHeightChanged(gui);
        this.updateRowIndexes(gui);
        this.setFocusedClasses(gui);
        this.setStylesFromGridOptions(false, gui);
        if (gos.isRowSelection() && this.rowNode.selectable) this.onRowSelected(gui);
        this.updateColumnLists(!this.useAnimationFrameForCreate);
        const comp = gui.rowComp;
        const initialRowClasses = this.getInitialRowClasses(gui.containerType);
        initialRowClasses.forEach((name)=>comp.addOrRemoveCssClass(name, true));
        this.executeSlideAndFadeAnimations(gui);
        if (this.rowNode.group) $7b57b57eaf5a9648$export$3ad3518dddf15485(gui.element, this.rowNode.expanded == true);
        this.setRowCompRowId(comp);
        this.setRowCompRowBusinessKey(comp);
        gos.setDomData(gui.element, _RowCtrl.DOM_DATA_KEY_ROW_CTRL, this);
        this.addDestroyFunc(()=>gos.setDomData(gui.element, _RowCtrl.DOM_DATA_KEY_ROW_CTRL, null));
        if (this.useAnimationFrameForCreate) this.beans.animationFrameService.createTask(this.addHoverFunctionality.bind(this, gui.element), this.rowNode.rowIndex, "createTasksP2");
        else this.addHoverFunctionality(gui.element);
        if (this.isFullWidth()) this.setupFullWidth(gui);
        if (gos.get("rowDragEntireRow")) this.addRowDraggerToRow(gui);
        if (this.useAnimationFrameForCreate) this.beans.animationFrameService.addDestroyTask(()=>{
            if (!this.isAlive()) return;
            gui.rowComp.addOrRemoveCssClass("ag-after-created", true);
        });
        this.executeProcessRowPostCreateFunc();
    }
    setRowCompRowBusinessKey(comp) {
        if (this.businessKeySanitised == null) return;
        comp.setRowBusinessKey(this.businessKeySanitised);
    }
    getBusinessKey() {
        return this.businessKeySanitised;
    }
    setRowCompRowId(comp) {
        this.rowId = $7b57b57eaf5a9648$export$3df06b741968da82(this.rowNode.id);
        if (this.rowId == null) return;
        comp.setRowId(this.rowId);
    }
    executeSlideAndFadeAnimations(gui) {
        const { containerType: containerType  } = gui;
        const shouldSlide = this.slideInAnimation[containerType];
        if (shouldSlide) {
            $7b57b57eaf5a9648$var$_executeNextVMTurn(()=>{
                this.onTopChanged();
            });
            this.slideInAnimation[containerType] = false;
        }
        const shouldFade = this.fadeInAnimation[containerType];
        if (shouldFade) {
            $7b57b57eaf5a9648$var$_executeNextVMTurn(()=>{
                gui.rowComp.addOrRemoveCssClass("ag-opacity-zero", false);
            });
            this.fadeInAnimation[containerType] = false;
        }
    }
    addRowDraggerToRow(gui) {
        if (this.gos.get("enableRangeSelection")) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`");
            return;
        }
        const translate = this.beans.localeService.getLocaleTextFunc();
        const rowDragComp = new $7b57b57eaf5a9648$export$10f7d2f62fe74867(()=>`1 ${translate("rowDragRow", "row")}`, this.rowNode, void 0, gui.element, void 0, true);
        const rowDragBean = this.createBean(rowDragComp, this.beans.context);
        this.rowDragComps.push(rowDragBean);
    }
    setupFullWidth(gui) {
        const pinned = this.getPinnedForContainer(gui.containerType);
        if (this.rowType == "FullWidthDetail") {
            if (!$7b57b57eaf5a9648$export$dc053975cc7f6c11.__assertRegistered("@ag-grid-enterprise/master-detail" /* MasterDetailModule */ , "cell renderer 'agDetailCellRenderer' (for master detail)", this.beans.context.getGridId())) return;
        }
        const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
        gui.rowComp.showFullWidth(compDetails);
    }
    isPrintLayout() {
        return this.printLayout;
    }
    getFullWidthCellRenderers() {
        if (this.gos.get("embedFullWidthRows")) return this.allRowGuis.map((gui)=>gui?.rowComp?.getFullWidthCellRenderer());
        return [
            this.fullWidthGui?.rowComp?.getFullWidthCellRenderer()
        ];
    }
    // use by autoWidthCalculator, as it clones the elements
    getCellElement(column) {
        const cellCtrl = this.getCellCtrl(column);
        return cellCtrl ? cellCtrl.getGui() : null;
    }
    executeProcessRowPostCreateFunc() {
        const func = this.gos.getCallback("processRowPostCreate");
        if (!func || !this.areAllContainersReady()) return;
        const params = {
            // areAllContainersReady asserts that centerGui is not null
            eRow: this.centerGui.element,
            ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
            ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
            node: this.rowNode,
            rowIndex: this.rowNode.rowIndex,
            addRenderedRowListener: this.addEventListener.bind(this)
        };
        func(params);
    }
    areAllContainersReady() {
        const isLeftReady = !!this.leftGui || !this.beans.visibleColsService.isPinningLeft();
        const isCenterReady = !!this.centerGui;
        const isRightReady = !!this.rightGui || !this.beans.visibleColsService.isPinningRight();
        return isLeftReady && isCenterReady && isRightReady;
    }
    setRowType() {
        const isStub = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow");
        const isFullWidthCell = this.rowNode.isFullWidthCell();
        const isDetailCell = this.gos.get("masterDetail") && this.rowNode.detail;
        const pivotMode = this.beans.columnModel.isPivotMode();
        const isGroupRow = !!this.rowNode.group && !this.rowNode.footer;
        const isFullWidthGroup = isGroupRow && this.gos.isGroupUseEntireRow(pivotMode);
        if (isStub) this.rowType = "FullWidthLoading";
        else if (isDetailCell) this.rowType = "FullWidthDetail";
        else if (isFullWidthCell) this.rowType = "FullWidth";
        else if (isFullWidthGroup) this.rowType = "FullWidthGroup";
        else this.rowType = "Normal";
    }
    updateColumnLists(suppressAnimationFrame = false, useFlushSync = false) {
        if (this.isFullWidth()) return;
        const noAnimation = suppressAnimationFrame || this.gos.get("suppressAnimationFrame") || this.printLayout;
        if (noAnimation) {
            this.updateColumnListsImpl(useFlushSync);
            return;
        }
        if (this.updateColumnListsPending) return;
        this.beans.animationFrameService.createTask(()=>{
            if (!this.active) return;
            this.updateColumnListsImpl(true);
        }, this.rowNode.rowIndex, "createTasksP1");
        this.updateColumnListsPending = true;
    }
    createCellCtrls(prev, cols, pinned = null) {
        const res = {
            list: [],
            map: {}
        };
        const addCell = (colInstanceId, cellCtrl)=>{
            res.list.push(cellCtrl);
            res.map[colInstanceId] = cellCtrl;
        };
        cols.forEach((col)=>{
            const colInstanceId = col.getInstanceId();
            let cellCtrl = prev.map[colInstanceId];
            if (!cellCtrl) cellCtrl = new $7b57b57eaf5a9648$export$4fd76abbfd48a7b6(col, this.rowNode, this.beans, this);
            addCell(colInstanceId, cellCtrl);
        });
        prev.list.forEach((prevCellCtrl)=>{
            const cellInResult = res.map[prevCellCtrl.getColumn().getInstanceId()] != null;
            if (cellInResult) return;
            const keepCell = !this.isCellEligibleToBeRemoved(prevCellCtrl, pinned);
            if (keepCell) {
                addCell(prevCellCtrl.getColumn().getInstanceId(), prevCellCtrl);
                return;
            }
            prevCellCtrl.destroy();
        });
        return res;
    }
    updateColumnListsImpl(useFlushSync) {
        this.updateColumnListsPending = false;
        this.createAllCellCtrls();
        this.setCellCtrls(useFlushSync);
    }
    setCellCtrls(useFlushSync) {
        this.allRowGuis.forEach((item)=>{
            const cellControls = this.getCellCtrlsForContainer(item.containerType);
            item.rowComp.setCellCtrls(cellControls, useFlushSync);
        });
    }
    getCellCtrlsForContainer(containerType) {
        switch(containerType){
            case "left":
                return this.leftCellCtrls.list;
            case "right":
                return this.rightCellCtrls.list;
            case "fullWidth":
                return [];
            case "center":
                return this.centerCellCtrls.list;
        }
    }
    createAllCellCtrls() {
        const columnViewportService = this.beans.columnViewportService;
        const presentedColsService = this.beans.visibleColsService;
        if (this.printLayout) {
            this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, presentedColsService.getAllCols());
            this.leftCellCtrls = {
                list: [],
                map: {}
            };
            this.rightCellCtrls = {
                list: [],
                map: {}
            };
        } else {
            const centerCols = columnViewportService.getColsWithinViewport(this.rowNode);
            this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, centerCols);
            const leftCols = presentedColsService.getLeftColsForRow(this.rowNode);
            this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, leftCols, "left");
            const rightCols = presentedColsService.getRightColsForRow(this.rowNode);
            this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, rightCols, "right");
        }
    }
    isCellEligibleToBeRemoved(cellCtrl, nextContainerPinned) {
        const REMOVE_CELL = true;
        const KEEP_CELL = false;
        const column = cellCtrl.getColumn();
        if (column.getPinned() != nextContainerPinned) return REMOVE_CELL;
        const editing = cellCtrl.isEditing();
        const focused = this.beans.focusService.isCellFocused(cellCtrl.getCellPosition());
        const mightWantToKeepCell = editing || focused;
        if (mightWantToKeepCell) {
            const column2 = cellCtrl.getColumn();
            const displayedColumns = this.beans.visibleColsService.getAllCols();
            const cellStillDisplayed = displayedColumns.indexOf(column2) >= 0;
            return cellStillDisplayed ? KEEP_CELL : REMOVE_CELL;
        }
        return REMOVE_CELL;
    }
    getDomOrder() {
        const isEnsureDomOrder = this.gos.get("ensureDomOrder");
        return isEnsureDomOrder || this.gos.isDomLayout("print");
    }
    listenOnDomOrder(gui) {
        const listener = ()=>{
            gui.rowComp.setDomOrder(this.getDomOrder());
        };
        this.addManagedPropertyListener("domLayout", listener);
        this.addManagedPropertyListener("ensureDomOrder", listener);
    }
    setAnimateFlags(animateIn) {
        if (this.isSticky() || !animateIn) return;
        const oldRowTopExists = $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.rowNode.oldRowTop);
        const pinningLeft = this.beans.visibleColsService.isPinningLeft();
        const pinningRight = this.beans.visibleColsService.isPinningRight();
        if (oldRowTopExists) {
            if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
                this.slideInAnimation.fullWidth = true;
                return;
            }
            this.slideInAnimation.center = true;
            this.slideInAnimation.left = pinningLeft;
            this.slideInAnimation.right = pinningRight;
        } else {
            if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
                this.fadeInAnimation.fullWidth = true;
                return;
            }
            this.fadeInAnimation.center = true;
            this.fadeInAnimation.left = pinningLeft;
            this.fadeInAnimation.right = pinningRight;
        }
    }
    isEditing() {
        return this.editingRow;
    }
    isFullWidth() {
        return this.rowType !== "Normal";
    }
    refreshFullWidth() {
        const tryRefresh = (gui, pinned)=>{
            if (!gui) return true;
            return gui.rowComp.refreshFullWidth(()=>{
                const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
                return compDetails.params;
            });
        };
        const fullWidthSuccess = tryRefresh(this.fullWidthGui, null);
        const centerSuccess = tryRefresh(this.centerGui, null);
        const leftSuccess = tryRefresh(this.leftGui, "left");
        const rightSuccess = tryRefresh(this.rightGui, "right");
        const allFullWidthRowsRefreshed = fullWidthSuccess && centerSuccess && leftSuccess && rightSuccess;
        return allFullWidthRowsRefreshed;
    }
    addListeners() {
        this.addManagedListeners(this.rowNode, {
            heightChanged: ()=>this.onRowHeightChanged(),
            rowSelected: ()=>this.onRowSelected(),
            rowIndexChanged: this.onRowIndexChanged.bind(this),
            topChanged: this.onTopChanged.bind(this),
            expandedChanged: this.updateExpandedCss.bind(this),
            hasChildrenChanged: this.updateExpandedCss.bind(this)
        });
        if (this.rowNode.detail) this.addManagedListeners(this.rowNode.parent, {
            dataChanged: this.onRowNodeDataChanged.bind(this)
        });
        this.addManagedListeners(this.rowNode, {
            dataChanged: this.onRowNodeDataChanged.bind(this),
            cellChanged: this.postProcessCss.bind(this),
            rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
            draggingChanged: this.postProcessRowDragging.bind(this),
            uiLevelChanged: this.onUiLevelChanged.bind(this)
        });
        this.addManagedListeners(this.beans.eventService, {
            paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
            heightScaleChanged: this.onTopChanged.bind(this),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
            cellFocused: this.onCellFocusChanged.bind(this),
            cellFocusCleared: this.onCellFocusChanged.bind(this),
            paginationChanged: this.onPaginationChanged.bind(this),
            modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
            columnMoved: ()=>this.updateColumnLists()
        });
        this.addDestroyFunc(()=>{
            this.destroyBeans(this.rowDragComps, this.beans.context);
            if (this.tooltipFeature) this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context);
        });
        this.addManagedPropertyListeners([
            "rowDragEntireRow"
        ], ()=>{
            const useRowDragEntireRow = this.gos.get("rowDragEntireRow");
            if (useRowDragEntireRow) {
                this.allRowGuis.forEach((gui)=>{
                    this.addRowDraggerToRow(gui);
                });
                return;
            }
            this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
        });
        this.addListenersForCellComps();
    }
    addListenersForCellComps() {
        this.addManagedListeners(this.rowNode, {
            rowIndexChanged: ()=>{
                this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.onRowIndexChanged());
            },
            cellChanged: (event)=>{
                this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.onCellChanged(event));
            }
        });
    }
    onRowNodeDataChanged(event) {
        const fullWidthChanged = this.isFullWidth() !== !!this.rowNode.isFullWidthCell();
        if (fullWidthChanged) {
            this.beans.rowRenderer.redrawRow(this.rowNode);
            return;
        }
        if (this.isFullWidth()) {
            const refresh = this.refreshFullWidth();
            if (!refresh) this.beans.rowRenderer.redrawRow(this.rowNode);
            return;
        }
        this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.refreshCell({
                suppressFlash: !event.update,
                newData: !event.update
            }));
        this.allRowGuis.forEach((gui)=>{
            this.setRowCompRowId(gui.rowComp);
            this.updateRowBusinessKey();
            this.setRowCompRowBusinessKey(gui.rowComp);
        });
        this.onRowSelected();
        this.postProcessCss();
    }
    postProcessCss() {
        this.setStylesFromGridOptions(true);
        this.postProcessClassesFromGridOptions();
        this.postProcessRowClassRules();
        this.postProcessRowDragging();
    }
    onRowNodeHighlightChanged() {
        const highlighted = this.rowNode.highlighted;
        this.allRowGuis.forEach((gui)=>{
            const aboveOn = highlighted === 0 /* Above */ ;
            const belowOn = highlighted === 1 /* Below */ ;
            gui.rowComp.addOrRemoveCssClass("ag-row-highlight-above", aboveOn);
            gui.rowComp.addOrRemoveCssClass("ag-row-highlight-below", belowOn);
        });
    }
    postProcessRowDragging() {
        const dragging = this.rowNode.dragging;
        this.allRowGuis.forEach((gui)=>gui.rowComp.addOrRemoveCssClass("ag-row-dragging", dragging));
    }
    updateExpandedCss() {
        const expandable = this.rowNode.isExpandable();
        const expanded = this.rowNode.expanded == true;
        this.allRowGuis.forEach((gui)=>{
            gui.rowComp.addOrRemoveCssClass("ag-row-group", expandable);
            gui.rowComp.addOrRemoveCssClass("ag-row-group-expanded", expandable && expanded);
            gui.rowComp.addOrRemoveCssClass("ag-row-group-contracted", expandable && !expanded);
            $7b57b57eaf5a9648$export$3ad3518dddf15485(gui.element, expandable && expanded);
        });
    }
    onDisplayedColumnsChanged() {
        this.updateColumnLists(true);
        if (this.beans.columnModel.wasAutoRowHeightEverActive()) this.rowNode.checkAutoHeights();
    }
    onVirtualColumnsChanged() {
        this.updateColumnLists(false, true);
    }
    getRowPosition() {
        return {
            rowPinned: $7b57b57eaf5a9648$export$4978424c4f7b5fc0(this.rowNode.rowPinned),
            rowIndex: this.rowNode.rowIndex
        };
    }
    onKeyboardNavigate(keyboardEvent) {
        const currentFullWidthComp = this.allRowGuis.find((c)=>c.element.contains(keyboardEvent.target));
        const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
        const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
        if (!isFullWidthContainerFocused) return;
        const node = this.rowNode;
        const lastFocusedCell = this.beans.focusService.getFocusedCell();
        const cellPosition = {
            rowIndex: node.rowIndex,
            rowPinned: node.rowPinned,
            column: lastFocusedCell && lastFocusedCell.column
        };
        this.beans.navigationService.navigateToNextCell(keyboardEvent, keyboardEvent.key, cellPosition, true);
        keyboardEvent.preventDefault();
    }
    onTabKeyDown(keyboardEvent) {
        if (keyboardEvent.defaultPrevented || $7b57b57eaf5a9648$export$9a48e23524c6d58(keyboardEvent)) return;
        const currentFullWidthComp = this.allRowGuis.find((c)=>c.element.contains(keyboardEvent.target));
        const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
        const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
        let nextEl = null;
        if (!isFullWidthContainerFocused) nextEl = this.beans.focusService.findNextFocusableElement(currentFullWidthContainer, false, keyboardEvent.shiftKey);
        if (this.isFullWidth() && isFullWidthContainerFocused || !nextEl) this.beans.navigationService.onTabKeyDown(this, keyboardEvent);
    }
    getFullWidthElement() {
        if (this.fullWidthGui) return this.fullWidthGui.element;
        return null;
    }
    getRowYPosition() {
        const displayedEl = this.allRowGuis.find((el)=>$7b57b57eaf5a9648$export$2badf4aa566524cb(el.element))?.element;
        if (displayedEl) return displayedEl.getBoundingClientRect().top;
        return 0;
    }
    onFullWidthRowFocused(event) {
        const node = this.rowNode;
        const isFocused = !event ? false : this.isFullWidth() && event.rowIndex === node.rowIndex && event.rowPinned == node.rowPinned;
        const element = this.fullWidthGui ? this.fullWidthGui.element : this.centerGui?.element;
        if (!element) return;
        element.classList.toggle("ag-full-width-focus", isFocused);
        if (isFocused && event?.forceBrowserFocus) element.focus({
            preventScroll: true
        });
    }
    recreateCell(cellCtrl) {
        this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, cellCtrl);
        this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, cellCtrl);
        this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, cellCtrl);
        cellCtrl.destroy();
        this.updateColumnLists();
    }
    removeCellCtrl(prev, cellCtrlToRemove) {
        const res = {
            list: [],
            map: {}
        };
        prev.list.forEach((cellCtrl)=>{
            if (cellCtrl === cellCtrlToRemove) return;
            res.list.push(cellCtrl);
            res.map[cellCtrl.getColumn().getInstanceId()] = cellCtrl;
        });
        return res;
    }
    onMouseEvent(eventName, mouseEvent) {
        switch(eventName){
            case "dblclick":
                this.onRowDblClick(mouseEvent);
                break;
            case "click":
                this.onRowClick(mouseEvent);
                break;
            case "touchstart":
            case "mousedown":
                this.onRowMouseDown(mouseEvent);
                break;
        }
    }
    createRowEvent(type, domEvent) {
        return this.gos.addGridCommonParams({
            type: type,
            node: this.rowNode,
            data: this.rowNode.data,
            rowIndex: this.rowNode.rowIndex,
            rowPinned: this.rowNode.rowPinned,
            event: domEvent
        });
    }
    createRowEventWithSource(type, domEvent) {
        const event = this.createRowEvent(type, domEvent);
        event.source = this;
        return event;
    }
    onRowDblClick(mouseEvent) {
        if ($7b57b57eaf5a9648$export$9a48e23524c6d58(mouseEvent)) return;
        const agEvent = this.createRowEventWithSource("rowDoubleClicked", mouseEvent);
        this.beans.eventService.dispatchEvent(agEvent);
    }
    onRowMouseDown(mouseEvent) {
        this.lastMouseDownOnDragger = $7b57b57eaf5a9648$var$_isElementChildOfClass(mouseEvent.target, "ag-row-drag", 3);
        if (!this.isFullWidth()) return;
        const node = this.rowNode;
        const presentedColsService = this.beans.visibleColsService;
        if (this.beans.rangeService) this.beans.rangeService.removeAllCellRanges();
        const element = this.getFullWidthElement();
        const target = mouseEvent.target;
        let forceBrowserFocus = true;
        if (element && element.contains(target) && $7b57b57eaf5a9648$var$_isFocusableFormField(target)) forceBrowserFocus = false;
        this.beans.focusService.setFocusedCell({
            rowIndex: node.rowIndex,
            column: presentedColsService.getAllCols()[0],
            rowPinned: node.rowPinned,
            forceBrowserFocus: forceBrowserFocus
        });
    }
    onRowClick(mouseEvent) {
        const stop = $7b57b57eaf5a9648$export$9a48e23524c6d58(mouseEvent) || this.lastMouseDownOnDragger;
        if (stop) return;
        const agEvent = this.createRowEventWithSource("rowClicked", mouseEvent);
        this.beans.eventService.dispatchEvent(agEvent);
        const isMultiKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
        const isShiftKey = mouseEvent.shiftKey;
        const groupSelectsChildren = this.gos.get("groupSelectsChildren");
        if (// we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
        // so return if it's a group row
        groupSelectsChildren && this.rowNode.group || this.isRowSelectionBlocked() || // if click selection suppressed, do nothing
        this.gos.get("suppressRowClickSelection")) return;
        const multiSelectOnClick = this.gos.get("rowMultiSelectWithClick");
        const rowDeselectionWithCtrl = !this.gos.get("suppressRowDeselection");
        const source = "rowClicked";
        if (this.rowNode.isSelected()) {
            if (multiSelectOnClick) this.rowNode.setSelectedParams({
                newValue: false,
                event: mouseEvent,
                source: source
            });
            else if (isMultiKey) {
                if (rowDeselectionWithCtrl) this.rowNode.setSelectedParams({
                    newValue: false,
                    event: mouseEvent,
                    source: source
                });
            } else this.rowNode.setSelectedParams({
                newValue: true,
                clearSelection: !isShiftKey,
                rangeSelect: isShiftKey,
                event: mouseEvent,
                source: source
            });
        } else {
            const clearSelection = multiSelectOnClick ? false : !isMultiKey;
            this.rowNode.setSelectedParams({
                newValue: true,
                clearSelection: clearSelection,
                rangeSelect: isShiftKey,
                event: mouseEvent,
                source: source
            });
        }
    }
    isRowSelectionBlocked() {
        return !this.rowNode.selectable || !!this.rowNode.rowPinned || !this.gos.isRowSelection();
    }
    setupDetailRowAutoHeight(eDetailGui) {
        if (this.rowType !== "FullWidthDetail") return;
        if (!this.gos.get("detailRowAutoHeight")) return;
        const checkRowSizeFunc = ()=>{
            const clientHeight = eDetailGui.clientHeight;
            if (clientHeight != null && clientHeight > 0) {
                const updateRowHeightFunc = ()=>{
                    this.rowNode.setRowHeight(clientHeight);
                    if (this.beans.rowModel.getType() === "clientSide") this.beans.rowModel.onRowHeightChanged();
                    else if (this.beans.rowModel.getType() === "serverSide") this.beans.rowModel.onRowHeightChanged();
                };
                window.setTimeout(updateRowHeightFunc, 0);
            }
        };
        const resizeObserverDestroyFunc = this.beans.resizeObserverService.observeResize(eDetailGui, checkRowSizeFunc);
        this.addDestroyFunc(resizeObserverDestroyFunc);
        checkRowSizeFunc();
    }
    createFullWidthCompDetails(eRow, pinned) {
        const { gos: gos , rowNode: rowNode  } = this;
        const params = gos.addGridCommonParams({
            fullWidth: true,
            data: rowNode.data,
            node: rowNode,
            value: rowNode.key,
            valueFormatted: rowNode.key,
            // these need to be taken out, as part of 'afterAttached' now
            eGridCell: eRow,
            eParentOfValue: eRow,
            pinned: pinned,
            addRenderedRowListener: this.addEventListener.bind(this),
            registerRowDragger: (rowDraggerElement, dragStartPixels, value, suppressVisibilityChange)=>this.addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value, suppressVisibilityChange),
            setTooltip: (value, shouldDisplayTooltip)=>this.refreshRowTooltip(value, shouldDisplayTooltip)
        });
        const compFactory = this.beans.userComponentFactory;
        switch(this.rowType){
            case "FullWidthDetail":
                return compFactory.getFullWidthDetailCellRendererDetails(params);
            case "FullWidthGroup":
                return compFactory.getFullWidthGroupCellRendererDetails(params);
            case "FullWidthLoading":
                return compFactory.getFullWidthLoadingCellRendererDetails(params);
            default:
                return compFactory.getFullWidthCellRendererDetails(params);
        }
    }
    refreshRowTooltip(value, shouldDisplayTooltip) {
        if (!this.fullWidthGui) return;
        const tooltipParams = {
            getGui: ()=>this.fullWidthGui.element,
            getTooltipValue: ()=>value,
            getLocation: ()=>"fullWidthRow",
            shouldDisplayTooltip: shouldDisplayTooltip
        };
        if (this.tooltipFeature) this.destroyBean(this.tooltipFeature, this.beans.context);
        this.tooltipFeature = this.createBean(new $7b57b57eaf5a9648$export$e5073a590d24815c(tooltipParams, this.beans));
    }
    addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value = "", suppressVisibilityChange) {
        if (!this.isFullWidth()) return;
        const rowDragComp = new $7b57b57eaf5a9648$export$10f7d2f62fe74867(()=>value, this.rowNode, void 0, rowDraggerElement, dragStartPixels, suppressVisibilityChange);
        this.createBean(rowDragComp, this.beans.context);
        this.addDestroyFunc(()=>{
            this.destroyBean(rowDragComp, this.beans.context);
        });
    }
    onUiLevelChanged() {
        const newLevel = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
        if (this.rowLevel != newLevel) {
            const classToAdd = "ag-row-level-" + newLevel;
            const classToRemove = "ag-row-level-" + this.rowLevel;
            this.allRowGuis.forEach((gui)=>{
                gui.rowComp.addOrRemoveCssClass(classToAdd, true);
                gui.rowComp.addOrRemoveCssClass(classToRemove, false);
            });
        }
        this.rowLevel = newLevel;
    }
    isFirstRowOnPage() {
        return this.rowNode.rowIndex === this.beans.pageBoundsService.getFirstRow();
    }
    isLastRowOnPage() {
        return this.rowNode.rowIndex === this.beans.pageBoundsService.getLastRow();
    }
    refreshFirstAndLastRowStyles() {
        const newFirst = this.isFirstRowOnPage();
        const newLast = this.isLastRowOnPage();
        if (this.firstRowOnPage !== newFirst) {
            this.firstRowOnPage = newFirst;
            this.allRowGuis.forEach((gui)=>gui.rowComp.addOrRemoveCssClass("ag-row-first", newFirst));
        }
        if (this.lastRowOnPage !== newLast) {
            this.lastRowOnPage = newLast;
            this.allRowGuis.forEach((gui)=>gui.rowComp.addOrRemoveCssClass("ag-row-last", newLast));
        }
    }
    stopEditing(cancel = false) {
        if (this.stoppingRowEdit) return;
        this.beans.rowEditService?.stopEditing(this, cancel);
    }
    setInlineEditingCss(editing) {
        this.allRowGuis.forEach((gui)=>{
            gui.rowComp.addOrRemoveCssClass("ag-row-inline-editing", editing);
            gui.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !editing);
        });
    }
    setEditingRow(value) {
        this.editingRow = value;
    }
    startRowEditing(key = null, sourceRenderedCell = null, event = null) {
        if (this.editingRow) return;
        this.beans.rowEditService?.startEditing(this, key, sourceRenderedCell, event);
    }
    getAllCellCtrls() {
        if (this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0) return this.centerCellCtrls.list;
        const res = [
            ...this.centerCellCtrls.list,
            ...this.leftCellCtrls.list,
            ...this.rightCellCtrls.list
        ];
        return res;
    }
    postProcessClassesFromGridOptions() {
        const cssClasses = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
        if (!cssClasses || !cssClasses.length) return;
        cssClasses.forEach((classStr)=>{
            this.allRowGuis.forEach((c)=>c.rowComp.addOrRemoveCssClass(classStr, true));
        });
    }
    postProcessRowClassRules() {
        this.beans.rowCssClassCalculator.processRowClassRules(this.rowNode, (className)=>{
            this.allRowGuis.forEach((gui)=>gui.rowComp.addOrRemoveCssClass(className, true));
        }, (className)=>{
            this.allRowGuis.forEach((gui)=>gui.rowComp.addOrRemoveCssClass(className, false));
        });
    }
    setStylesFromGridOptions(updateStyles, gui) {
        if (updateStyles) this.rowStyles = this.processStylesFromGridOptions();
        this.forEachGui(gui, (gui2)=>gui2.rowComp.setUserStyles(this.rowStyles));
    }
    getPinnedForContainer(rowContainerType) {
        if (rowContainerType === "left" || rowContainerType === "right") return rowContainerType;
        return null;
    }
    getInitialRowClasses(rowContainerType) {
        const pinned = this.getPinnedForContainer(rowContainerType);
        const params = {
            rowNode: this.rowNode,
            rowFocused: this.rowFocused,
            fadeRowIn: this.fadeInAnimation[rowContainerType],
            rowIsEven: this.rowNode.rowIndex % 2 === 0,
            rowLevel: this.rowLevel,
            fullWidthRow: this.isFullWidth(),
            firstRowOnPage: this.isFirstRowOnPage(),
            lastRowOnPage: this.isLastRowOnPage(),
            printLayout: this.printLayout,
            expandable: this.rowNode.isExpandable(),
            pinned: pinned
        };
        return this.beans.rowCssClassCalculator.getInitialRowClasses(params);
    }
    processStylesFromGridOptions() {
        const rowStyle = this.gos.get("rowStyle");
        if (rowStyle && typeof rowStyle === "function") {
            $7b57b57eaf5a9648$export$2cf41453020eef66("rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
            return;
        }
        const rowStyleFunc = this.gos.getCallback("getRowStyle");
        let rowStyleFuncResult;
        if (rowStyleFunc) {
            const params = {
                data: this.rowNode.data,
                node: this.rowNode,
                rowIndex: this.rowNode.rowIndex
            };
            rowStyleFuncResult = rowStyleFunc(params);
        }
        if (rowStyleFuncResult || rowStyle) return Object.assign({}, rowStyle, rowStyleFuncResult);
        return this.emptyStyle;
    }
    onRowSelected(gui) {
        const selected = !!this.rowNode.isSelected();
        this.forEachGui(gui, (gui2)=>{
            gui2.rowComp.addOrRemoveCssClass("ag-row-selected", selected);
            $7b57b57eaf5a9648$export$c22e3722e8a33469(gui2.element, selected);
            const hasFocus = gui2.element.contains(this.gos.getActiveDomElement());
            if (hasFocus && (gui2 === this.centerGui || gui2 === this.fullWidthGui)) this.announceDescription();
        });
    }
    announceDescription() {
        if (this.isRowSelectionBlocked()) return;
        const selected = this.rowNode.isSelected();
        if (selected && this.gos.get("suppressRowDeselection")) return;
        const translate = this.beans.localeService.getLocaleTextFunc();
        const label = translate(selected ? "ariaRowDeselect" : "ariaRowSelect", `Press SPACE to ${selected ? "deselect" : "select"} this row.`);
        this.beans.ariaAnnouncementService.announceValue(label);
    }
    addHoverFunctionality(eRow) {
        if (!this.active) return;
        const { rowNode: rowNode , beans: beans , gos: gos  } = this;
        this.addManagedListeners(eRow, {
            mouseenter: ()=>rowNode.onMouseEnter(),
            mouseleave: ()=>rowNode.onMouseLeave()
        });
        this.addManagedListeners(rowNode, {
            mouseEnter: ()=>{
                if (!beans.dragService.isDragging() && !gos.get("suppressRowHoverHighlight")) {
                    eRow.classList.add("ag-row-hover");
                    rowNode.setHovered(true);
                }
            },
            mouseLeave: ()=>{
                eRow.classList.remove("ag-row-hover");
                rowNode.setHovered(false);
            }
        });
    }
    // for animation, we don't want to animate entry or exit to a very far away pixel,
    // otherwise the row would move so fast, it would appear to disappear. so this method
    // moves the row closer to the viewport if it is far away, so the row slide in / out
    // at a speed the user can see.
    roundRowTopToBounds(rowTop) {
        const range = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getApproximateVScollPosition();
        const minPixel = this.applyPaginationOffset(range.top, true) - 100;
        const maxPixel = this.applyPaginationOffset(range.bottom, true) + 100;
        return Math.min(Math.max(minPixel, rowTop), maxPixel);
    }
    getFrameworkOverrides() {
        return this.beans.frameworkOverrides;
    }
    forEachGui(gui, callback) {
        if (gui) callback(gui);
        else this.allRowGuis.forEach(callback);
    }
    onRowHeightChanged(gui) {
        if (this.rowNode.rowHeight == null) return;
        const rowHeight = this.rowNode.rowHeight;
        const defaultRowHeight = this.beans.environment.getDefaultRowHeight();
        const isHeightFromFunc = this.gos.isGetRowHeightFunction();
        const heightFromFunc = isHeightFromFunc ? this.gos.getRowHeightForNode(this.rowNode).height : void 0;
        const lineHeight = heightFromFunc ? `${Math.min(defaultRowHeight, heightFromFunc) - 2}px` : void 0;
        this.forEachGui(gui, (gui2)=>{
            gui2.element.style.height = `${rowHeight}px`;
            if (lineHeight) gui2.element.style.setProperty("--ag-line-height", lineHeight);
        });
    }
    addEventListener(eventType, listener) {
        super.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
        super.removeEventListener(eventType, listener);
    }
    // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
    destroyFirstPass(suppressAnimation = false) {
        this.active = false;
        if (!suppressAnimation && this.gos.isAnimateRows() && !this.isSticky()) {
            const rowStillVisibleJustNotInViewport = this.rowNode.rowTop != null;
            if (rowStillVisibleJustNotInViewport) {
                const rowTop = this.roundRowTopToBounds(this.rowNode.rowTop);
                this.setRowTop(rowTop);
            } else this.allRowGuis.forEach((gui)=>gui.rowComp.addOrRemoveCssClass("ag-opacity-zero", true));
        }
        this.rowNode.setHovered(false);
        const event = this.createRowEvent("virtualRowRemoved");
        this.dispatchLocalEvent(event);
        this.beans.eventService.dispatchEvent(event);
        super.destroy();
    }
    destroySecondPass() {
        this.allRowGuis.length = 0;
        this.stopEditing();
        const destroyCellCtrls = (ctrls)=>{
            ctrls.list.forEach((c)=>c.destroy());
            return {
                list: [],
                map: {}
            };
        };
        this.centerCellCtrls = destroyCellCtrls(this.centerCellCtrls);
        this.leftCellCtrls = destroyCellCtrls(this.leftCellCtrls);
        this.rightCellCtrls = destroyCellCtrls(this.rightCellCtrls);
    }
    setFocusedClasses(gui) {
        this.forEachGui(gui, (gui2)=>{
            gui2.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused);
            gui2.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
        });
    }
    onCellFocusChanged() {
        const rowFocused = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
        if (rowFocused !== this.rowFocused) {
            this.rowFocused = rowFocused;
            this.setFocusedClasses();
        }
        if (!rowFocused && this.editingRow) this.stopEditing(false);
    }
    onPaginationChanged() {
        const currentPage = this.beans.paginationService?.getCurrentPage() ?? 0;
        if (this.paginationPage !== currentPage) {
            this.paginationPage = currentPage;
            this.onTopChanged();
        }
        this.refreshFirstAndLastRowStyles();
    }
    onTopChanged() {
        this.setRowTop(this.rowNode.rowTop);
    }
    onPaginationPixelOffsetChanged() {
        this.onTopChanged();
    }
    // applies pagination offset, eg if on second page, and page height is 500px, then removes
    // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
    // reverse will take the offset away rather than add.
    applyPaginationOffset(topPx, reverse = false) {
        if (this.rowNode.isRowPinned() || this.rowNode.sticky) return topPx;
        const pixelOffset = this.beans.pageBoundsService.getPixelOffset();
        const multiplier = reverse ? 1 : -1;
        return topPx + pixelOffset * multiplier;
    }
    setRowTop(pixels) {
        if (this.printLayout) return;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(pixels)) {
            const afterPaginationPixels = this.applyPaginationOffset(pixels);
            const skipScaling = this.rowNode.isRowPinned() || this.rowNode.sticky;
            const afterScalingPixels = skipScaling ? afterPaginationPixels : this.beans.rowContainerHeightService.getRealPixelPosition(afterPaginationPixels);
            const topPx = `${afterScalingPixels}px`;
            this.setRowTopStyle(topPx);
        }
    }
    // the top needs to be set into the DOM element when the element is created, not updated afterwards.
    // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
    // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
    // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
    // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
    // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
    // time, the row would animate down (ie from position zero).
    getInitialRowTop(rowContainerType) {
        return this.suppressRowTransform ? this.getInitialRowTopShared(rowContainerType) : void 0;
    }
    getInitialTransform(rowContainerType) {
        return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(rowContainerType)})`;
    }
    getInitialRowTopShared(rowContainerType) {
        if (this.printLayout) return "";
        const rowNode = this.rowNode;
        let rowTop;
        if (this.isSticky()) rowTop = rowNode.stickyRowTop;
        else {
            const pixels = this.slideInAnimation[rowContainerType] ? this.roundRowTopToBounds(rowNode.oldRowTop) : rowNode.rowTop;
            const afterPaginationPixels = this.applyPaginationOffset(pixels);
            rowTop = rowNode.isRowPinned() ? afterPaginationPixels : this.beans.rowContainerHeightService.getRealPixelPosition(afterPaginationPixels);
        }
        return rowTop + "px";
    }
    setRowTopStyle(topPx) {
        this.allRowGuis.forEach((gui)=>this.suppressRowTransform ? gui.rowComp.setTop(topPx) : gui.rowComp.setTransform(`translateY(${topPx})`));
    }
    getRowNode() {
        return this.rowNode;
    }
    getCellCtrl(column) {
        let res = null;
        this.getAllCellCtrls().forEach((cellCtrl)=>{
            if (cellCtrl.getColumn() == column) res = cellCtrl;
        });
        if (res != null) return res;
        this.getAllCellCtrls().forEach((cellCtrl)=>{
            if (cellCtrl.getColSpanningList().indexOf(column) >= 0) res = cellCtrl;
        });
        return res;
    }
    onRowIndexChanged() {
        if (this.rowNode.rowIndex != null) {
            this.onCellFocusChanged();
            this.updateRowIndexes();
            this.postProcessCss();
        }
    }
    getRowIndex() {
        return this.rowNode.getRowIndexString();
    }
    updateRowIndexes(gui) {
        const rowIndexStr = this.rowNode.getRowIndexString();
        if (rowIndexStr === null) return;
        const headerRowCount = this.beans.headerNavigationService.getHeaderRowCount() + (this.beans.filterManager?.getHeaderRowCount() ?? 0);
        const rowIsEven = this.rowNode.rowIndex % 2 === 0;
        const ariaRowIndex = headerRowCount + this.rowNode.rowIndex + 1;
        this.forEachGui(gui, (c)=>{
            c.rowComp.setRowIndex(rowIndexStr);
            c.rowComp.addOrRemoveCssClass("ag-row-even", rowIsEven);
            c.rowComp.addOrRemoveCssClass("ag-row-odd", !rowIsEven);
            $7b57b57eaf5a9648$export$ba731dedf9d88615(c.element, ariaRowIndex);
        });
    }
    setStoppingRowEdit(stoppingRowEdit) {
        this.stoppingRowEdit = stoppingRowEdit;
    }
};
$7b57b57eaf5a9648$var$_RowCtrl.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var $7b57b57eaf5a9648$export$e449e57ac30326ed = $7b57b57eaf5a9648$var$_RowCtrl;
// community-modules/core/src/gridBodyComp/rowContainer/rowContainerEventsFeature.ts
var $7b57b57eaf5a9648$var$RowContainerEventsFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.mouseEventService = beans.mouseEventService;
        this.valueService = beans.valueService;
        this.menuService = beans.menuService;
        this.ctrlsService = beans.ctrlsService;
        this.navigationService = beans.navigationService;
        this.focusService = beans.focusService;
        this.undoRedoService = beans.undoRedoService;
        this.visibleColsService = beans.visibleColsService;
        this.rowModel = beans.rowModel;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.rangeService = beans.rangeService;
        this.clipboardService = beans.clipboardService;
    }
    constructor(element){
        super();
        this.element = element;
    }
    postConstruct() {
        this.addKeyboardListeners();
        this.addMouseListeners();
        this.mockContextMenuForIPad();
    }
    addKeyboardListeners() {
        const eventName = "keydown";
        const listener = this.processKeyboardEvent.bind(this, eventName);
        this.addManagedElementListeners(this.element, {
            [eventName]: listener
        });
    }
    addMouseListeners() {
        const mouseDownEvent = $7b57b57eaf5a9648$var$_isEventSupported("touchstart") ? "touchstart" : "mousedown";
        const eventNames = [
            "dblclick",
            "contextmenu",
            "mouseover",
            "mouseout",
            "click",
            mouseDownEvent
        ];
        eventNames.forEach((eventName)=>{
            const listener = this.processMouseEvent.bind(this, eventName);
            this.addManagedElementListeners(this.element, {
                [eventName]: listener
            });
        });
    }
    processMouseEvent(eventName, mouseEvent) {
        if (!this.mouseEventService.isEventFromThisGrid(mouseEvent) || $7b57b57eaf5a9648$export$9a48e23524c6d58(mouseEvent)) return;
        const rowComp = this.getRowForEvent(mouseEvent);
        const cellCtrl = this.mouseEventService.getRenderedCellForEvent(mouseEvent);
        if (eventName === "contextmenu") this.handleContextMenuMouseEvent(mouseEvent, void 0, rowComp, cellCtrl);
        else {
            if (cellCtrl) cellCtrl.onMouseEvent(eventName, mouseEvent);
            if (rowComp) rowComp.onMouseEvent(eventName, mouseEvent);
        }
    }
    mockContextMenuForIPad() {
        if (!$7b57b57eaf5a9648$export$6b6034a68325bd8a()) return;
        const touchListener = new $7b57b57eaf5a9648$export$7b2e93987414b382(this.element);
        const longTapListener = (event)=>{
            const rowComp = this.getRowForEvent(event.touchEvent);
            const cellComp = this.mouseEventService.getRenderedCellForEvent(event.touchEvent);
            this.handleContextMenuMouseEvent(void 0, event.touchEvent, rowComp, cellComp);
        };
        this.addManagedListeners(touchListener, {
            longTap: longTapListener
        });
        this.addDestroyFunc(()=>touchListener.destroy());
    }
    getRowForEvent(event) {
        let sourceElement = event.target;
        while(sourceElement){
            const rowCon = this.gos.getDomData(sourceElement, $7b57b57eaf5a9648$export$e449e57ac30326ed.DOM_DATA_KEY_ROW_CTRL);
            if (rowCon) return rowCon;
            sourceElement = sourceElement.parentElement;
        }
        return null;
    }
    handleContextMenuMouseEvent(mouseEvent, touchEvent, rowComp, cellCtrl) {
        const rowNode = rowComp ? rowComp.getRowNode() : null;
        const column = cellCtrl ? cellCtrl.getColumn() : null;
        let value = null;
        if (column) {
            const event = mouseEvent ? mouseEvent : touchEvent;
            cellCtrl.dispatchCellContextMenuEvent(event ?? null);
            value = this.valueService.getValue(column, rowNode);
        }
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        const anchorToElement = cellCtrl ? cellCtrl.getGui() : gridBodyCon.getGridBodyElement();
        this.menuService.showContextMenu({
            mouseEvent: mouseEvent,
            touchEvent: touchEvent,
            rowNode: rowNode,
            column: column,
            value: value,
            anchorToElement: anchorToElement
        });
    }
    getControlsForEventTarget(target) {
        return {
            cellCtrl: $7b57b57eaf5a9648$export$debbc44ebeaf0dc2(this.gos, target, $7b57b57eaf5a9648$export$4fd76abbfd48a7b6.DOM_DATA_KEY_CELL_CTRL),
            rowCtrl: $7b57b57eaf5a9648$export$debbc44ebeaf0dc2(this.gos, target, $7b57b57eaf5a9648$export$e449e57ac30326ed.DOM_DATA_KEY_ROW_CTRL)
        };
    }
    processKeyboardEvent(eventName, keyboardEvent) {
        const { cellCtrl: cellCtrl , rowCtrl: rowCtrl  } = this.getControlsForEventTarget(keyboardEvent.target);
        if (keyboardEvent.defaultPrevented) return;
        if (cellCtrl) this.processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent);
        else if (rowCtrl && rowCtrl.isFullWidth()) this.processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent);
    }
    processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent) {
        const rowNode = cellCtrl.getRowNode();
        const column = cellCtrl.getColumn();
        const editing = cellCtrl.isEditing();
        const gridProcessingAllowed = !$7b57b57eaf5a9648$var$_isUserSuppressingKeyboardEvent(this.gos, keyboardEvent, rowNode, column, editing);
        if (gridProcessingAllowed) {
            if (eventName === "keydown") {
                const wasScrollKey = !editing && this.navigationService.handlePageScrollingKey(keyboardEvent);
                if (!wasScrollKey) cellCtrl.onKeyDown(keyboardEvent);
                this.doGridOperations(keyboardEvent, cellCtrl.isEditing());
                if ($7b57b57eaf5a9648$export$33ecd6e270298858(keyboardEvent)) cellCtrl.processCharacter(keyboardEvent);
            }
        }
        if (eventName === "keydown") {
            const cellKeyDownEvent = cellCtrl.createEvent(keyboardEvent, "cellKeyDown");
            this.eventService.dispatchEvent(cellKeyDownEvent);
        }
    }
    processFullWidthRowKeyboardEvent(rowComp, eventName, keyboardEvent) {
        const rowNode = rowComp.getRowNode();
        const focusedCell = this.focusService.getFocusedCell();
        const column = focusedCell && focusedCell.column;
        const gridProcessingAllowed = !$7b57b57eaf5a9648$var$_isUserSuppressingKeyboardEvent(this.gos, keyboardEvent, rowNode, column, false);
        if (gridProcessingAllowed) {
            const key = keyboardEvent.key;
            if (eventName === "keydown") switch(key){
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_HOME:
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_END:
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP:
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_DOWN:
                    this.navigationService.handlePageScrollingKey(keyboardEvent, true);
                    break;
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
                    rowComp.onKeyboardNavigate(keyboardEvent);
                    break;
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.TAB:
                    rowComp.onTabKeyDown(keyboardEvent);
                    break;
                default:
            }
        }
        if (eventName === "keydown") {
            const cellKeyDownEvent = rowComp.createRowEvent("cellKeyDown", keyboardEvent);
            this.eventService.dispatchEvent(cellKeyDownEvent);
        }
    }
    doGridOperations(keyboardEvent, editing) {
        if (!keyboardEvent.ctrlKey && !keyboardEvent.metaKey) return;
        if (editing) return;
        if (!this.mouseEventService.isEventFromThisGrid(keyboardEvent)) return;
        const keyCode = $7b57b57eaf5a9648$var$_normaliseQwertyAzerty(keyboardEvent);
        if (keyCode === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.A) return this.onCtrlAndA(keyboardEvent);
        if (keyCode === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.C) return this.onCtrlAndC(keyboardEvent);
        if (keyCode === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.D) return this.onCtrlAndD(keyboardEvent);
        if (keyCode === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.V) return this.onCtrlAndV(keyboardEvent);
        if (keyCode === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.X) return this.onCtrlAndX(keyboardEvent);
        if (keyCode === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.Y) return this.onCtrlAndY();
        if (keyCode === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.Z) return this.onCtrlAndZ(keyboardEvent);
    }
    onCtrlAndA(event) {
        const { pinnedRowModel: pinnedRowModel , rowModel: rowModel , rangeService: rangeService  } = this;
        if (rangeService && rowModel.isRowsToRender()) {
            const [isEmptyPinnedTop, isEmptyPinnedBottom] = [
                pinnedRowModel.isEmpty("top"),
                pinnedRowModel.isEmpty("bottom")
            ];
            const floatingStart = isEmptyPinnedTop ? null : "top";
            let floatingEnd;
            let rowEnd;
            if (isEmptyPinnedBottom) {
                floatingEnd = null;
                rowEnd = rowModel.getRowCount() - 1;
            } else {
                floatingEnd = "bottom";
                rowEnd = pinnedRowModel.getPinnedBottomRowNodes().length - 1;
            }
            const allDisplayedColumns = this.visibleColsService.getAllCols();
            if ($7b57b57eaf5a9648$export$c15f339f10321853(allDisplayedColumns)) return;
            rangeService.setCellRange({
                rowStartIndex: 0,
                rowStartPinned: floatingStart,
                rowEndIndex: rowEnd,
                rowEndPinned: floatingEnd,
                columnStart: allDisplayedColumns[0],
                columnEnd: $7b57b57eaf5a9648$export$236389741107357f(allDisplayedColumns)
            });
        }
        event.preventDefault();
    }
    onCtrlAndC(event) {
        if (!this.clipboardService || this.gos.get("enableCellTextSelection")) return;
        const { cellCtrl: cellCtrl , rowCtrl: rowCtrl  } = this.getControlsForEventTarget(event.target);
        if (cellCtrl?.isEditing() || rowCtrl?.isEditing()) return;
        event.preventDefault();
        this.clipboardService.copyToClipboard();
    }
    onCtrlAndX(event) {
        if (!this.clipboardService || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard")) return;
        const { cellCtrl: cellCtrl , rowCtrl: rowCtrl  } = this.getControlsForEventTarget(event.target);
        if (cellCtrl?.isEditing() || rowCtrl?.isEditing()) return;
        event.preventDefault();
        this.clipboardService.cutToClipboard(void 0, "ui");
    }
    onCtrlAndV(event) {
        const { cellCtrl: cellCtrl , rowCtrl: rowCtrl  } = this.getControlsForEventTarget(event.target);
        if (cellCtrl?.isEditing() || rowCtrl?.isEditing()) return;
        if (this.clipboardService && !this.gos.get("suppressClipboardPaste")) this.clipboardService.pasteFromClipboard();
    }
    onCtrlAndD(event) {
        if (this.clipboardService && !this.gos.get("suppressClipboardPaste")) this.clipboardService.copyRangeDown();
        event.preventDefault();
    }
    onCtrlAndZ(event) {
        if (!this.gos.get("undoRedoCellEditing") || !this.undoRedoService) return;
        event.preventDefault();
        if (event.shiftKey) this.undoRedoService.redo("ui");
        else this.undoRedoService.undo("ui");
    }
    onCtrlAndY() {
        this.undoRedoService?.redo("ui");
    }
};
// community-modules/core/src/gridBodyComp/rowContainer/setPinnedLeftWidthFeature.ts
var $7b57b57eaf5a9648$var$SetPinnedLeftWidthFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.pinnedWidthService = beans.pinnedWidthService;
    }
    constructor(element){
        super();
        this.element = element;
    }
    postConstruct() {
        this.addManagedEventListeners({
            leftPinnedWidthChanged: this.onPinnedLeftWidthChanged.bind(this)
        });
    }
    onPinnedLeftWidthChanged() {
        const leftWidth = this.pinnedWidthService.getPinnedLeftWidth();
        const displayed = leftWidth > 0;
        $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.element, displayed);
        $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(this.element, leftWidth);
    }
    getWidth() {
        return this.pinnedWidthService.getPinnedLeftWidth();
    }
};
// community-modules/core/src/gridBodyComp/rowContainer/setPinnedRightWidthFeature.ts
var $7b57b57eaf5a9648$var$SetPinnedRightWidthFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    wireBeans(beans) {
        this.pinnedWidthService = beans.pinnedWidthService;
    }
    constructor(element){
        super();
        this.element = element;
    }
    postConstruct() {
        this.addManagedEventListeners({
            rightPinnedWidthChanged: this.onPinnedRightWidthChanged.bind(this)
        });
    }
    onPinnedRightWidthChanged() {
        const rightWidth = this.pinnedWidthService.getPinnedRightWidth();
        const displayed = rightWidth > 0;
        $7b57b57eaf5a9648$export$9405f1cbb4e2383f(this.element, displayed);
        $7b57b57eaf5a9648$export$ce98ba7f5cfe7725(this.element, rightWidth);
    }
    getWidth() {
        return this.pinnedWidthService.getPinnedRightWidth();
    }
};
// community-modules/core/src/gridBodyComp/rowContainer/rowContainerCtrl.ts
var $7b57b57eaf5a9648$var$getTopRowCtrls = (r)=>r.getTopRowCtrls();
var $7b57b57eaf5a9648$var$getStickyTopRowCtrls = (r)=>r.getStickyTopRowCtrls();
var $7b57b57eaf5a9648$var$getStickyBottomRowCtrls = (r)=>r.getStickyBottomRowCtrls();
var $7b57b57eaf5a9648$var$getBottomRowCtrls = (r)=>r.getBottomRowCtrls();
var $7b57b57eaf5a9648$var$getCentreRowCtrls = (r)=>r.getCentreRowCtrls();
var $7b57b57eaf5a9648$var$ContainerCssClasses = {
    center: {
        type: "center",
        container: "ag-center-cols-container",
        viewport: "ag-center-cols-viewport",
        getRowCtrls: $7b57b57eaf5a9648$var$getCentreRowCtrls
    },
    left: {
        type: "left",
        container: "ag-pinned-left-cols-container",
        pinnedType: "left",
        getRowCtrls: $7b57b57eaf5a9648$var$getCentreRowCtrls
    },
    right: {
        type: "right",
        container: "ag-pinned-right-cols-container",
        pinnedType: "right",
        getRowCtrls: $7b57b57eaf5a9648$var$getCentreRowCtrls
    },
    fullWidth: {
        type: "fullWidth",
        container: "ag-full-width-container",
        fullWidth: true,
        getRowCtrls: $7b57b57eaf5a9648$var$getCentreRowCtrls
    },
    topCenter: {
        type: "center",
        container: "ag-floating-top-container",
        viewport: "ag-floating-top-viewport",
        getRowCtrls: $7b57b57eaf5a9648$var$getTopRowCtrls
    },
    topLeft: {
        type: "left",
        container: "ag-pinned-left-floating-top",
        pinnedType: "left",
        getRowCtrls: $7b57b57eaf5a9648$var$getTopRowCtrls
    },
    topRight: {
        type: "right",
        container: "ag-pinned-right-floating-top",
        pinnedType: "right",
        getRowCtrls: $7b57b57eaf5a9648$var$getTopRowCtrls
    },
    topFullWidth: {
        type: "fullWidth",
        container: "ag-floating-top-full-width-container",
        fullWidth: true,
        getRowCtrls: $7b57b57eaf5a9648$var$getTopRowCtrls
    },
    stickyTopCenter: {
        type: "center",
        container: "ag-sticky-top-container",
        viewport: "ag-sticky-top-viewport",
        getRowCtrls: $7b57b57eaf5a9648$var$getStickyTopRowCtrls
    },
    stickyTopLeft: {
        type: "left",
        container: "ag-pinned-left-sticky-top",
        pinnedType: "left",
        getRowCtrls: $7b57b57eaf5a9648$var$getStickyTopRowCtrls
    },
    stickyTopRight: {
        type: "right",
        container: "ag-pinned-right-sticky-top",
        pinnedType: "right",
        getRowCtrls: $7b57b57eaf5a9648$var$getStickyTopRowCtrls
    },
    stickyTopFullWidth: {
        type: "fullWidth",
        container: "ag-sticky-top-full-width-container",
        fullWidth: true,
        getRowCtrls: $7b57b57eaf5a9648$var$getStickyTopRowCtrls
    },
    stickyBottomCenter: {
        type: "center",
        container: "ag-sticky-bottom-container",
        viewport: "ag-sticky-bottom-viewport",
        getRowCtrls: $7b57b57eaf5a9648$var$getStickyBottomRowCtrls
    },
    stickyBottomLeft: {
        type: "left",
        container: "ag-pinned-left-sticky-bottom",
        pinnedType: "left",
        getRowCtrls: $7b57b57eaf5a9648$var$getStickyBottomRowCtrls
    },
    stickyBottomRight: {
        type: "right",
        container: "ag-pinned-right-sticky-bottom",
        pinnedType: "right",
        getRowCtrls: $7b57b57eaf5a9648$var$getStickyBottomRowCtrls
    },
    stickyBottomFullWidth: {
        type: "fullWidth",
        container: "ag-sticky-bottom-full-width-container",
        fullWidth: true,
        getRowCtrls: $7b57b57eaf5a9648$var$getStickyBottomRowCtrls
    },
    bottomCenter: {
        type: "center",
        container: "ag-floating-bottom-container",
        viewport: "ag-floating-bottom-viewport",
        getRowCtrls: $7b57b57eaf5a9648$var$getBottomRowCtrls
    },
    bottomLeft: {
        type: "left",
        container: "ag-pinned-left-floating-bottom",
        pinnedType: "left",
        getRowCtrls: $7b57b57eaf5a9648$var$getBottomRowCtrls
    },
    bottomRight: {
        type: "right",
        container: "ag-pinned-right-floating-bottom",
        pinnedType: "right",
        getRowCtrls: $7b57b57eaf5a9648$var$getBottomRowCtrls
    },
    bottomFullWidth: {
        type: "fullWidth",
        container: "ag-floating-bottom-full-width-container",
        fullWidth: true,
        getRowCtrls: $7b57b57eaf5a9648$var$getBottomRowCtrls
    }
};
function $7b57b57eaf5a9648$export$a46aad9f8c79261f(name) {
    return $7b57b57eaf5a9648$var$ContainerCssClasses[name];
}
var $7b57b57eaf5a9648$var$allTopNoFW = [
    "topCenter",
    "topLeft",
    "topRight"
];
var $7b57b57eaf5a9648$var$allBottomNoFW = [
    "bottomCenter",
    "bottomLeft",
    "bottomRight"
];
var $7b57b57eaf5a9648$var$allMiddleNoFW = [
    "center",
    "left",
    "right"
];
var $7b57b57eaf5a9648$var$allMiddle = [
    "center",
    "left",
    "right",
    "fullWidth"
];
var $7b57b57eaf5a9648$var$allCenter = [
    "stickyTopCenter",
    "stickyBottomCenter",
    "center",
    "topCenter",
    "bottomCenter"
];
var $7b57b57eaf5a9648$var$allLeft = [
    "left",
    "bottomLeft",
    "topLeft",
    "stickyTopLeft",
    "stickyBottomLeft"
];
var $7b57b57eaf5a9648$var$allRight = [
    "right",
    "bottomRight",
    "topRight",
    "stickyTopRight",
    "stickyBottomRight"
];
var $7b57b57eaf5a9648$var$allStickyTopNoFW = [
    "stickyTopCenter",
    "stickyTopLeft",
    "stickyTopRight"
];
var $7b57b57eaf5a9648$var$allStickyBottomNoFW = [
    "stickyBottomCenter",
    "stickyBottomLeft",
    "stickyBottomRight"
];
var $7b57b57eaf5a9648$var$allStickyContainers = [
    ...$7b57b57eaf5a9648$var$allStickyTopNoFW,
    "stickyTopFullWidth",
    ...$7b57b57eaf5a9648$var$allStickyBottomNoFW,
    "stickyBottomFullWidth"
];
var $7b57b57eaf5a9648$var$allNoFW = [
    ...$7b57b57eaf5a9648$var$allTopNoFW,
    ...$7b57b57eaf5a9648$var$allBottomNoFW,
    ...$7b57b57eaf5a9648$var$allMiddleNoFW,
    ...$7b57b57eaf5a9648$var$allStickyTopNoFW,
    ...$7b57b57eaf5a9648$var$allStickyBottomNoFW
];
var $7b57b57eaf5a9648$export$2d4385f6f566fe5e = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(name){
        super();
        this.visible = true;
        // Maintaining a constant reference enables optimization in React.
        this.EMPTY_CTRLS = [];
        this.name = name;
        this.options = $7b57b57eaf5a9648$export$a46aad9f8c79261f(name);
    }
    wireBeans(beans) {
        this.dragService = beans.dragService;
        this.ctrlsService = beans.ctrlsService;
        this.columnViewportService = beans.columnViewportService;
        this.resizeObserverService = beans.resizeObserverService;
        this.rowRenderer = beans.rowRenderer;
    }
    postConstruct() {
        this.enableRtl = this.gos.get("enableRtl");
        this.forContainers([
            "center"
        ], ()=>{
            this.viewportSizeFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$ViewportSizeFeature(this));
            this.addManagedEventListeners({
                stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
            });
        });
    }
    onStickyTopOffsetChanged(event) {
        this.comp.setOffsetTop(`${event.offset}px`);
    }
    registerWithCtrlsService() {
        if (this.options.fullWidth) return;
        this.ctrlsService.register(this.name, this);
    }
    forContainers(names, callback) {
        if (names.indexOf(this.name) >= 0) callback();
    }
    getContainerElement() {
        return this.eContainer;
    }
    getViewportSizeFeature() {
        return this.viewportSizeFeature;
    }
    setComp(view, eContainer, eViewport) {
        this.comp = view;
        this.eContainer = eContainer;
        this.eViewport = eViewport;
        this.createManagedBean(new $7b57b57eaf5a9648$var$RowContainerEventsFeature(this.eContainer));
        this.addPreventScrollWhileDragging();
        this.listenOnDomOrder();
        this.stopHScrollOnPinnedRows();
        this.forContainers($7b57b57eaf5a9648$var$allLeft, ()=>{
            this.pinnedWidthFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$SetPinnedLeftWidthFeature(this.eContainer));
            this.addManagedEventListeners({
                leftPinnedWidthChanged: ()=>this.onPinnedWidthChanged()
            });
        });
        this.forContainers($7b57b57eaf5a9648$var$allRight, ()=>{
            this.pinnedWidthFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$SetPinnedRightWidthFeature(this.eContainer));
            this.addManagedEventListeners({
                rightPinnedWidthChanged: ()=>this.onPinnedWidthChanged()
            });
        });
        this.forContainers($7b57b57eaf5a9648$var$allMiddle, ()=>this.createManagedBean(new $7b57b57eaf5a9648$var$SetHeightFeature(this.eContainer, this.name === "center" ? eViewport : void 0)));
        this.forContainers($7b57b57eaf5a9648$var$allNoFW, ()=>this.createManagedBean(new $7b57b57eaf5a9648$var$DragListenerFeature(this.eContainer)));
        this.forContainers($7b57b57eaf5a9648$var$allCenter, ()=>this.createManagedBean(new $7b57b57eaf5a9648$var$CenterWidthFeature((width)=>this.comp.setContainerWidth(`${width}px`))));
        this.addListeners();
        this.registerWithCtrlsService();
    }
    addListeners() {
        this.addManagedEventListeners({
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
            displayedRowsChanged: (params)=>this.onDisplayedRowsChanged(params.afterScroll)
        });
        this.onDisplayedColumnsChanged();
        this.onDisplayedColumnsWidthChanged();
        this.onDisplayedRowsChanged();
    }
    listenOnDomOrder() {
        const isStickContainer = $7b57b57eaf5a9648$var$allStickyContainers.indexOf(this.name) >= 0;
        if (isStickContainer) {
            this.comp.setDomOrder(true);
            return;
        }
        const listener = ()=>{
            const isEnsureDomOrder = this.gos.get("ensureDomOrder");
            const isPrintLayout = this.gos.isDomLayout("print");
            this.comp.setDomOrder(isEnsureDomOrder || isPrintLayout);
        };
        this.addManagedPropertyListener("domLayout", listener);
        listener();
    }
    // when editing a pinned row, if the cell is half outside the scrollable area, the browser can
    // scroll the column into view. we do not want this, the pinned sections should never scroll.
    // so we listen to scrolls on these containers and reset the scroll if we find one.
    stopHScrollOnPinnedRows() {
        this.forContainers([
            "topCenter",
            "stickyTopCenter",
            "bottomCenter",
            "stickyBottomCenter"
        ], ()=>{
            const resetScrollLeft = ()=>this.eViewport.scrollLeft = 0;
            this.addManagedElementListeners(this.eViewport, {
                scroll: resetScrollLeft
            });
        });
    }
    onDisplayedColumnsChanged() {
        this.forContainers([
            "center"
        ], ()=>this.onHorizontalViewportChanged());
    }
    onDisplayedColumnsWidthChanged() {
        this.forContainers([
            "center"
        ], ()=>this.onHorizontalViewportChanged());
    }
    // this methods prevents the grid views from being scrolled while the dragService is being used
    // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
    addPreventScrollWhileDragging() {
        const preventScroll = (e)=>{
            if (this.dragService.isDragging()) {
                if (e.cancelable) e.preventDefault();
            }
        };
        this.eContainer.addEventListener("touchmove", preventScroll, {
            passive: false
        });
        this.addDestroyFunc(()=>this.eContainer.removeEventListener("touchmove", preventScroll));
    }
    // this gets called whenever a change in the viewport, so we can inform column controller it has to work
    // out the virtual columns again. gets called from following locations:
    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
    onHorizontalViewportChanged(afterScroll = false) {
        const scrollWidth = this.getCenterWidth();
        const scrollPosition = this.getCenterViewportScrollLeft();
        this.columnViewportService.setScrollPosition(scrollWidth, scrollPosition, afterScroll);
    }
    getCenterWidth() {
        return $7b57b57eaf5a9648$export$cc615e4191ec3e0c(this.eViewport);
    }
    getCenterViewportScrollLeft() {
        return $7b57b57eaf5a9648$var$_getScrollLeft(this.eViewport, this.enableRtl);
    }
    registerViewportResizeListener(listener) {
        const unsubscribeFromResize = this.resizeObserverService.observeResize(this.eViewport, listener);
        this.addDestroyFunc(()=>unsubscribeFromResize());
    }
    isViewportInTheDOMTree() {
        return $7b57b57eaf5a9648$var$_isInDOM(this.eViewport);
    }
    getViewportScrollLeft() {
        return $7b57b57eaf5a9648$var$_getScrollLeft(this.eViewport, this.enableRtl);
    }
    isHorizontalScrollShowing() {
        const isAlwaysShowHorizontalScroll = this.gos.get("alwaysShowHorizontalScroll");
        return isAlwaysShowHorizontalScroll || $7b57b57eaf5a9648$var$_isHorizontalScrollShowing(this.eViewport);
    }
    getViewportElement() {
        return this.eViewport;
    }
    setContainerTranslateX(amount) {
        this.eContainer.style.transform = `translateX(${amount}px)`;
    }
    getHScrollPosition() {
        const res = {
            left: this.eViewport.scrollLeft,
            right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
        };
        return res;
    }
    setCenterViewportScrollLeft(value) {
        $7b57b57eaf5a9648$var$_setScrollLeft(this.eViewport, value, this.enableRtl);
    }
    isContainerVisible() {
        const pinned = this.options.pinnedType != null;
        return !pinned || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
    }
    onPinnedWidthChanged() {
        const visible = this.isContainerVisible();
        if (this.visible != visible) {
            this.visible = visible;
            this.onDisplayedRowsChanged();
        }
    }
    onDisplayedRowsChanged(afterScroll = false) {
        const rows = this.options.getRowCtrls(this.rowRenderer);
        if (!this.visible || rows.length === 0) {
            this.comp.setRowCtrls({
                rowCtrls: this.EMPTY_CTRLS
            });
            return;
        }
        const printLayout = this.gos.isDomLayout("print");
        const embedFullWidthRows = this.gos.get("embedFullWidthRows");
        const embedFW = embedFullWidthRows || printLayout;
        const rowsThisContainer = rows.filter((rowCtrl)=>{
            const fullWidthRow = rowCtrl.isFullWidth();
            const match = this.options.fullWidth ? !embedFW && fullWidthRow : embedFW || !fullWidthRow;
            return match;
        });
        this.comp.setRowCtrls({
            rowCtrls: rowsThisContainer,
            useFlushSync: afterScroll
        });
    }
};
// community-modules/core/src/gridBodyComp/rowContainer/rowContainerComp.ts
function $7b57b57eaf5a9648$var$templateFactory(options) {
    let res;
    if (options.type === "center") res = /* html */ `<div class="${options.viewport}" data-ref="eViewport" role="presentation">
                <div class="${options.container}" data-ref="eContainer"></div>
            </div>`;
    else res = /* html */ `<div class="${options.container}" data-ref="eContainer"></div>`;
    return res;
}
var $7b57b57eaf5a9648$export$a301f7d71bb9bd77 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super();
        this.eViewport = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eContainer = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.rowComps = {};
        this.name = $7b57b57eaf5a9648$export$16fa2f45be04daa8.elementGettingCreated.getAttribute("name");
        this.options = $7b57b57eaf5a9648$export$a46aad9f8c79261f(this.name);
        this.setTemplate($7b57b57eaf5a9648$var$templateFactory(this.options));
    }
    wireBeans(beans) {
        this.beans = beans;
    }
    postConstruct() {
        const compProxy = {
            setViewportHeight: (height)=>this.eViewport.style.height = height,
            setRowCtrls: ({ rowCtrls: rowCtrls  })=>this.setRowCtrls(rowCtrls),
            setDomOrder: (domOrder)=>{
                this.domOrder = domOrder;
            },
            setContainerWidth: (width)=>this.eContainer.style.width = width,
            setOffsetTop: (offset)=>this.eContainer.style.transform = `translateY(${offset})`
        };
        const ctrl = this.createManagedBean(new $7b57b57eaf5a9648$export$2d4385f6f566fe5e(this.name));
        ctrl.setComp(compProxy, this.eContainer, this.eViewport);
    }
    destroy() {
        this.setRowCtrls([]);
        super.destroy();
    }
    setRowCtrls(rowCtrls) {
        const oldRows = {
            ...this.rowComps
        };
        this.rowComps = {};
        this.lastPlacedElement = null;
        const processRow = (rowCon)=>{
            const instanceId = rowCon.getInstanceId();
            const existingRowComp = oldRows[instanceId];
            if (existingRowComp) {
                this.rowComps[instanceId] = existingRowComp;
                delete oldRows[instanceId];
                this.ensureDomOrder(existingRowComp.getGui());
            } else {
                if (!rowCon.getRowNode().displayed) return;
                const rowComp = new $7b57b57eaf5a9648$var$RowComp(rowCon, this.beans, this.options.type);
                this.rowComps[instanceId] = rowComp;
                this.appendRow(rowComp.getGui());
            }
        };
        rowCtrls.forEach(processRow);
        $7b57b57eaf5a9648$export$2f52ef471f042094(oldRows).forEach((oldRowComp)=>{
            this.eContainer.removeChild(oldRowComp.getGui());
            oldRowComp.destroy();
        });
        $7b57b57eaf5a9648$export$f8d01fa01787902(this.eContainer, "rowgroup");
    }
    appendRow(element) {
        if (this.domOrder) $7b57b57eaf5a9648$var$_insertWithDomOrder(this.eContainer, element, this.lastPlacedElement);
        else this.eContainer.appendChild(element);
        this.lastPlacedElement = element;
    }
    ensureDomOrder(eRow) {
        if (this.domOrder) {
            $7b57b57eaf5a9648$var$_ensureDomOrder(this.eContainer, eRow, this.lastPlacedElement);
            this.lastPlacedElement = eRow;
        }
    }
};
var $7b57b57eaf5a9648$var$RowContainerSelector = {
    selector: "AG-ROW-CONTAINER",
    component: $7b57b57eaf5a9648$export$a301f7d71bb9bd77
};
// community-modules/core/src/gridBodyComp/gridBodyComp.ts
function $7b57b57eaf5a9648$var$makeRowContainers(names) {
    return names.map((name)=>`<ag-row-container name="${name}"></ag-row-container>`).join("");
}
var $7b57b57eaf5a9648$var$GRID_BODY_TEMPLATE = /* html */ `<div class="ag-root ag-unselectable" role="treegrid">
        <ag-header-root></ag-header-root>
        <div class="ag-floating-top" data-ref="eTop" role="presentation">
            ${$7b57b57eaf5a9648$var$makeRowContainers([
    "topLeft",
    "topCenter",
    "topRight",
    "topFullWidth"
])}
        </div>
        <div class="ag-body" data-ref="eBody" role="presentation">
            <div class="ag-body-viewport" data-ref="eBodyViewport" role="presentation">
            ${$7b57b57eaf5a9648$var$makeRowContainers([
    "left",
    "center",
    "right",
    "fullWidth"
])}
            </div>
            <ag-fake-vertical-scroll></ag-fake-vertical-scroll>
        </div>
        <div class="ag-sticky-top" data-ref="eStickyTop" role="presentation">
            ${$7b57b57eaf5a9648$var$makeRowContainers([
    "stickyTopLeft",
    "stickyTopCenter",
    "stickyTopRight",
    "stickyTopFullWidth"
])}
        </div>
        <div class="ag-sticky-bottom" data-ref="eStickyBottom" role="presentation">
            ${$7b57b57eaf5a9648$var$makeRowContainers([
    "stickyBottomLeft",
    "stickyBottomCenter",
    "stickyBottomRight",
    "stickyBottomFullWidth"
])}
        </div>
        <div class="ag-floating-bottom" data-ref="eBottom" role="presentation">
            ${$7b57b57eaf5a9648$var$makeRowContainers([
    "bottomLeft",
    "bottomCenter",
    "bottomRight",
    "bottomFullWidth"
])}
        </div>
        <ag-fake-horizontal-scroll></ag-fake-horizontal-scroll>
        <ag-overlay-wrapper></ag-overlay-wrapper>
    </div>`;
var $7b57b57eaf5a9648$export$fb561602f10e2162 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super($7b57b57eaf5a9648$var$GRID_BODY_TEMPLATE, [
            $7b57b57eaf5a9648$var$OverlayWrapperSelector,
            $7b57b57eaf5a9648$var$FakeHScrollSelector,
            $7b57b57eaf5a9648$var$FakeVScrollSelector,
            $7b57b57eaf5a9648$var$GridHeaderSelector,
            $7b57b57eaf5a9648$var$RowContainerSelector
        ]);
        this.eBodyViewport = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eStickyTop = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eStickyBottom = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eTop = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eBottom = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eBody = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    wireBeans(beans) {
        this.resizeObserverService = beans.resizeObserverService;
        this.rangeService = beans.rangeService;
    }
    postConstruct() {
        const setHeight = (height, element)=>{
            const heightString = `${height}px`;
            element.style.minHeight = heightString;
            element.style.height = heightString;
        };
        const compProxy = {
            setRowAnimationCssOnBodyViewport: (cssClass, animate)=>this.setRowAnimationCssOnBodyViewport(cssClass, animate),
            setColumnCount: (count)=>$7b57b57eaf5a9648$export$56744a26086b5898(this.getGui(), count),
            setRowCount: (count)=>$7b57b57eaf5a9648$export$1ad8496b26b660f8(this.getGui(), count),
            setTopHeight: (height)=>setHeight(height, this.eTop),
            setBottomHeight: (height)=>setHeight(height, this.eBottom),
            setTopDisplay: (display)=>this.eTop.style.display = display,
            setBottomDisplay: (display)=>this.eBottom.style.display = display,
            setStickyTopHeight: (height)=>this.eStickyTop.style.height = height,
            setStickyTopTop: (top)=>this.eStickyTop.style.top = top,
            setStickyTopWidth: (width)=>this.eStickyTop.style.width = width,
            setStickyBottomHeight: (height)=>this.eStickyBottom.style.height = height,
            setStickyBottomBottom: (bottom)=>this.eStickyBottom.style.bottom = bottom,
            setStickyBottomWidth: (width)=>this.eStickyBottom.style.width = width,
            setColumnMovingCss: (cssClass, flag)=>this.addOrRemoveCssClass(cssClass, flag),
            updateLayoutClasses: (cssClass, params)=>{
                const classLists = [
                    this.eBodyViewport.classList,
                    this.eBody.classList
                ];
                classLists.forEach((classList)=>{
                    classList.toggle("ag-layout-auto-height" /* AUTO_HEIGHT */ , params.autoHeight);
                    classList.toggle("ag-layout-normal" /* NORMAL */ , params.normal);
                    classList.toggle("ag-layout-print" /* PRINT */ , params.print);
                });
                this.addOrRemoveCssClass("ag-layout-auto-height" /* AUTO_HEIGHT */ , params.autoHeight);
                this.addOrRemoveCssClass("ag-layout-normal" /* NORMAL */ , params.normal);
                this.addOrRemoveCssClass("ag-layout-print" /* PRINT */ , params.print);
            },
            setAlwaysVerticalScrollClass: (cssClass, on)=>this.eBodyViewport.classList.toggle($7b57b57eaf5a9648$var$CSS_CLASS_FORCE_VERTICAL_SCROLL, on),
            registerBodyViewportResizeListener: (listener)=>{
                const unsubscribeFromResize = this.resizeObserverService.observeResize(this.eBodyViewport, listener);
                this.addDestroyFunc(()=>unsubscribeFromResize());
            },
            setPinnedTopBottomOverflowY: (overflow)=>this.eTop.style.overflowY = this.eBottom.style.overflowY = overflow,
            setCellSelectableCss: (cssClass, selectable)=>{
                [
                    this.eTop,
                    this.eBodyViewport,
                    this.eBottom
                ].forEach((ct)=>ct.classList.toggle(cssClass, selectable));
            },
            setBodyViewportWidth: (width)=>this.eBodyViewport.style.width = width
        };
        this.ctrl = this.createManagedBean(new $7b57b57eaf5a9648$export$8bebc3145b40d221());
        this.ctrl.setComp(compProxy, this.getGui(), this.eBodyViewport, this.eTop, this.eBottom, this.eStickyTop, this.eStickyBottom);
        if (this.rangeService && this.gos.get("enableRangeSelection") || this.gos.get("rowSelection") === "multiple") $7b57b57eaf5a9648$var$_setAriaMultiSelectable(this.getGui(), true);
    }
    setRowAnimationCssOnBodyViewport(cssClass, animateRows) {
        const bodyViewportClassList = this.eBodyViewport.classList;
        bodyViewportClassList.toggle("ag-row-animation", animateRows);
        bodyViewportClassList.toggle("ag-row-no-animation", !animateRows);
    }
    getFloatingTopBottom() {
        return [
            this.eTop,
            this.eBottom
        ];
    }
};
var $7b57b57eaf5a9648$var$GridBodySelector = {
    selector: "AG-GRID-BODY",
    component: $7b57b57eaf5a9648$export$fb561602f10e2162
};
// community-modules/core/src/gridBodyComp/scrollVisibleService.ts
var $7b57b57eaf5a9648$export$eca0fad328f0291c = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "scrollVisibleService";
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
        this.columnAnimationService = beans.columnAnimationService;
    }
    postConstruct() {
        this.addManagedEventListeners({
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this)
        });
    }
    onDisplayedColumnsChanged() {
        this.update();
    }
    onDisplayedColumnsWidthChanged() {
        this.update();
    }
    update() {
        if (this.columnAnimationService.isActive()) this.columnAnimationService.executeLaterVMTurn(()=>{
            this.columnAnimationService.executeLaterVMTurn(()=>this.updateImpl());
        });
        else this.updateImpl();
    }
    updateImpl() {
        const centerRowCtrl = this.ctrlsService.get("center");
        if (!centerRowCtrl || this.columnAnimationService.isActive()) return;
        const params = {
            horizontalScrollShowing: centerRowCtrl.isHorizontalScrollShowing(),
            verticalScrollShowing: this.isVerticalScrollShowing()
        };
        this.setScrollsVisible(params);
    }
    setScrollsVisible(params) {
        const atLeastOneDifferent = this.horizontalScrollShowing !== params.horizontalScrollShowing || this.verticalScrollShowing !== params.verticalScrollShowing;
        if (atLeastOneDifferent) {
            this.horizontalScrollShowing = params.horizontalScrollShowing;
            this.verticalScrollShowing = params.verticalScrollShowing;
            const event = {
                type: "scrollVisibilityChanged"
            };
            this.eventService.dispatchEvent(event);
        }
    }
    // used by pagination service - to know page height
    isHorizontalScrollShowing() {
        return this.horizontalScrollShowing;
    }
    // used by header container
    isVerticalScrollShowing() {
        return this.verticalScrollShowing;
    }
};
// community-modules/core/src/gridBodyComp/mouseEventService.ts
var $7b57b57eaf5a9648$var$GRID_DOM_KEY = "__ag_grid_instance";
var $7b57b57eaf5a9648$var$_MouseEventService = class _MouseEventService extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "mouseEventService";
        this.gridInstanceId = _MouseEventService.gridInstanceSequence.next();
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
    }
    // we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
    // so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
    // for where this is used.
    stampTopLevelGridCompWithGridInstance(eGridDiv) {
        eGridDiv[$7b57b57eaf5a9648$var$GRID_DOM_KEY] = this.gridInstanceId;
    }
    getRenderedCellForEvent(event) {
        return $7b57b57eaf5a9648$export$debbc44ebeaf0dc2(this.gos, event.target, $7b57b57eaf5a9648$export$4fd76abbfd48a7b6.DOM_DATA_KEY_CELL_CTRL);
    }
    // walks the path of the event, and returns true if this grid is the first one that it finds. if doing
    // master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
    // getting executed on many grids at the same time.
    isEventFromThisGrid(event) {
        const res = this.isElementInThisGrid(event.target);
        return res;
    }
    isElementInThisGrid(element) {
        let pointer = element;
        while(pointer){
            const instanceId = pointer[$7b57b57eaf5a9648$var$GRID_DOM_KEY];
            if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(instanceId)) {
                const eventFromThisGrid = instanceId === this.gridInstanceId;
                return eventFromThisGrid;
            }
            pointer = pointer.parentElement;
        }
        return false;
    }
    getCellPositionForEvent(event) {
        const cellComp = this.getRenderedCellForEvent(event);
        return cellComp ? cellComp.getCellPosition() : null;
    }
    getNormalisedPosition(event) {
        const gridPanelHasScrolls = this.gos.isDomLayout("normal");
        const e = event;
        let x;
        let y;
        if (e.clientX != null || e.clientY != null) {
            x = e.clientX;
            y = e.clientY;
        } else {
            x = e.x;
            y = e.y;
        }
        if (gridPanelHasScrolls) {
            const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
            const vRange = gridBodyCon.getScrollFeature().getVScrollPosition();
            const hRange = gridBodyCon.getScrollFeature().getHScrollPosition();
            x += hRange.left;
            y += vRange.top;
        }
        return {
            x: x,
            y: y
        };
    }
};
$7b57b57eaf5a9648$var$_MouseEventService.gridInstanceSequence = new $7b57b57eaf5a9648$export$9bbf3cc62ef6fcad();
var $7b57b57eaf5a9648$export$2e403e146bc377e1 = $7b57b57eaf5a9648$var$_MouseEventService;
// community-modules/core/src/gridBodyComp/navigationService.ts
var $7b57b57eaf5a9648$export$2a4aa3d46d9c7613 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super();
        this.beanName = "navigationService";
        this.onPageDown = $7b57b57eaf5a9648$var$_throttle(this.onPageDown, 100);
        this.onPageUp = $7b57b57eaf5a9648$var$_throttle(this.onPageUp, 100);
    }
    wireBeans(beans) {
        this.mouseEventService = beans.mouseEventService;
        this.pageBoundsService = beans.pageBoundsService;
        this.focusService = beans.focusService;
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
        this.rowModel = beans.rowModel;
        this.ctrlsService = beans.ctrlsService;
        this.rowRenderer = beans.rowRenderer;
        this.headerNavigationService = beans.headerNavigationService;
        this.rowPositionUtils = beans.rowPositionUtils;
        this.cellNavigationService = beans.cellNavigationService;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.rangeService = beans.rangeService;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            this.gridBodyCon = p.gridBodyCtrl;
        });
    }
    handlePageScrollingKey(event, fromFullWidth = false) {
        const key = event.key;
        const alt = event.altKey;
        const ctrl = event.ctrlKey || event.metaKey;
        const rangeServiceShouldHandleShift = !!this.rangeService && event.shiftKey;
        const currentCell = this.mouseEventService.getCellPositionForEvent(event);
        let processed = false;
        switch(key){
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_HOME:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_END:
                if (!ctrl && !alt) {
                    this.onHomeOrEndKey(key);
                    processed = true;
                }
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
                if (!currentCell) return false;
                if (ctrl && !alt && !rangeServiceShouldHandleShift) {
                    this.onCtrlUpDownLeftRight(key, currentCell);
                    processed = true;
                }
                break;
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_DOWN:
            case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP:
                if (!ctrl && !alt) processed = this.handlePageUpDown(key, currentCell, fromFullWidth);
                break;
        }
        if (processed) event.preventDefault();
        return processed;
    }
    handlePageUpDown(key, currentCell, fromFullWidth) {
        if (fromFullWidth) currentCell = this.focusService.getFocusedCell();
        if (!currentCell) return false;
        if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP) this.onPageUp(currentCell);
        else this.onPageDown(currentCell);
        return true;
    }
    navigateTo(navigateParams) {
        const { scrollIndex: scrollIndex , scrollType: scrollType , scrollColumn: scrollColumn , focusIndex: focusIndex , focusColumn: focusColumn  } = navigateParams;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(scrollColumn) && !scrollColumn.isPinned()) this.gridBodyCon.getScrollFeature().ensureColumnVisible(scrollColumn);
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(scrollIndex)) this.gridBodyCon.getScrollFeature().ensureIndexVisible(scrollIndex, scrollType);
        if (!navigateParams.isAsync) this.gridBodyCon.getScrollFeature().ensureIndexVisible(focusIndex);
        this.focusService.setFocusedCell({
            rowIndex: focusIndex,
            column: focusColumn,
            rowPinned: null,
            forceBrowserFocus: true
        });
        this.rangeService?.setRangeToCell({
            rowIndex: focusIndex,
            rowPinned: null,
            column: focusColumn
        });
    }
    // this method is throttled, see the `constructor`
    onPageDown(gridCell) {
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();
        const pixelsInOnePage = this.getViewportHeight();
        const pagingPixelOffset = this.pageBoundsService.getPixelOffset();
        const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;
        const currentPageBottomRow = this.rowModel.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);
        if (this.columnModel.isAutoRowHeightActive()) this.navigateToNextPageWithAutoHeight(gridCell, currentPageBottomRow);
        else this.navigateToNextPage(gridCell, currentPageBottomRow);
    }
    // this method is throttled, see the `constructor`
    onPageUp(gridCell) {
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();
        const pagingPixelOffset = this.pageBoundsService.getPixelOffset();
        const currentPageTopPixel = scrollPosition.top;
        const currentPageTopRow = this.rowModel.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);
        if (this.columnModel.isAutoRowHeightActive()) this.navigateToNextPageWithAutoHeight(gridCell, currentPageTopRow, true);
        else this.navigateToNextPage(gridCell, currentPageTopRow, true);
    }
    navigateToNextPage(gridCell, scrollIndex, up = false) {
        const pixelsInOnePage = this.getViewportHeight();
        const firstRow = this.pageBoundsService.getFirstRow();
        const lastRow = this.pageBoundsService.getLastRow();
        const pagingPixelOffset = this.pageBoundsService.getPixelOffset();
        const currentRowNode = this.rowModel.getRow(gridCell.rowIndex);
        const rowPixelDiff = up ? // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
        currentRowNode?.rowHeight - pixelsInOnePage - pagingPixelOffset : pixelsInOnePage - pagingPixelOffset;
        const nextCellPixel = currentRowNode?.rowTop + rowPixelDiff;
        let focusIndex = this.rowModel.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
        if (focusIndex === gridCell.rowIndex) {
            const diff = up ? -1 : 1;
            scrollIndex = focusIndex = gridCell.rowIndex + diff;
        }
        let scrollType;
        if (up) {
            scrollType = "bottom";
            if (focusIndex < firstRow) focusIndex = firstRow;
            if (scrollIndex < firstRow) scrollIndex = firstRow;
        } else {
            scrollType = "top";
            if (focusIndex > lastRow) focusIndex = lastRow;
            if (scrollIndex > lastRow) scrollIndex = lastRow;
        }
        if (this.isRowTallerThanView(focusIndex)) {
            scrollIndex = focusIndex;
            scrollType = "top";
        }
        this.navigateTo({
            scrollIndex: scrollIndex,
            scrollType: scrollType,
            scrollColumn: null,
            focusIndex: focusIndex,
            focusColumn: gridCell.column
        });
    }
    navigateToNextPageWithAutoHeight(gridCell, scrollIndex, up = false) {
        this.navigateTo({
            scrollIndex: scrollIndex,
            scrollType: up ? "bottom" : "top",
            scrollColumn: null,
            focusIndex: scrollIndex,
            focusColumn: gridCell.column
        });
        setTimeout(()=>{
            const focusIndex = this.getNextFocusIndexForAutoHeight(gridCell, up);
            this.navigateTo({
                scrollIndex: scrollIndex,
                scrollType: up ? "bottom" : "top",
                scrollColumn: null,
                focusIndex: focusIndex,
                focusColumn: gridCell.column,
                isAsync: true
            });
        }, 50);
    }
    getNextFocusIndexForAutoHeight(gridCell, up = false) {
        const step = up ? -1 : 1;
        const pixelsInOnePage = this.getViewportHeight();
        const lastRowIndex = this.pageBoundsService.getLastRow();
        let pixelSum = 0;
        let currentIndex = gridCell.rowIndex;
        while(currentIndex >= 0 && currentIndex <= lastRowIndex){
            const currentCell = this.rowModel.getRow(currentIndex);
            if (currentCell) {
                const currentCellHeight = currentCell.rowHeight ?? 0;
                if (pixelSum + currentCellHeight > pixelsInOnePage) break;
                pixelSum += currentCellHeight;
            }
            currentIndex += step;
        }
        return Math.max(0, Math.min(currentIndex, lastRowIndex));
    }
    getViewportHeight() {
        const { gridBodyCtrl: gridBodyCtrl , center: center  } = this.ctrlsService.getParams();
        const scrollPosition = gridBodyCtrl.getScrollFeature().getVScrollPosition();
        const scrollbarWidth = this.gos.getScrollbarWidth();
        let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;
        if (center.isHorizontalScrollShowing()) pixelsInOnePage -= scrollbarWidth;
        return pixelsInOnePage;
    }
    isRowTallerThanView(rowIndex) {
        const rowNode = this.rowModel.getRow(rowIndex);
        if (!rowNode) return false;
        const rowHeight = rowNode.rowHeight;
        if (typeof rowHeight !== "number") return false;
        return rowHeight > this.getViewportHeight();
    }
    onCtrlUpDownLeftRight(key, gridCell) {
        const cellToFocus = this.cellNavigationService.getNextCellToFocus(key, gridCell, true);
        const { rowIndex: rowIndex  } = cellToFocus;
        const column = cellToFocus.column;
        this.navigateTo({
            scrollIndex: rowIndex,
            scrollType: null,
            scrollColumn: column,
            focusIndex: rowIndex,
            focusColumn: column
        });
    }
    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
    // same cell into view (which means either scroll all the way up, or all the way down).
    onHomeOrEndKey(key) {
        const homeKey = key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_HOME;
        const allColumns = this.visibleColsService.getAllCols();
        const columnToSelect = homeKey ? allColumns[0] : $7b57b57eaf5a9648$export$236389741107357f(allColumns);
        const scrollIndex = homeKey ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow();
        this.navigateTo({
            scrollIndex: scrollIndex,
            scrollType: null,
            scrollColumn: columnToSelect,
            focusIndex: scrollIndex,
            focusColumn: columnToSelect
        });
    }
    // result of keyboard event
    onTabKeyDown(previous, keyboardEvent) {
        const backwards = keyboardEvent.shiftKey;
        const movedToNextCell = this.tabToNextCellCommon(previous, backwards, keyboardEvent);
        if (movedToNextCell !== false) {
            if (movedToNextCell) keyboardEvent.preventDefault();
            return;
        }
        if (backwards) {
            const { rowIndex: rowIndex , rowPinned: rowPinned  } = previous.getRowPosition();
            const firstRow = rowPinned ? rowIndex === 0 : rowIndex === this.pageBoundsService.getFirstRow();
            if (firstRow) {
                if (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus")) this.focusService.focusNextGridCoreContainer(true, true);
                else {
                    keyboardEvent.preventDefault();
                    this.focusService.focusPreviousFromFirstCell(keyboardEvent);
                }
            }
        } else {
            if (previous instanceof $7b57b57eaf5a9648$export$4fd76abbfd48a7b6) previous.focusCell(true);
            if (this.focusService.focusNextGridCoreContainer(backwards)) keyboardEvent.preventDefault();
        }
    }
    // comes from API
    tabToNextCell(backwards, event) {
        const focusedCell = this.focusService.getFocusedCell();
        if (!focusedCell) return false;
        let cellOrRow = this.getCellByPosition(focusedCell);
        if (!cellOrRow) {
            cellOrRow = this.rowRenderer.getRowByPosition(focusedCell);
            if (!cellOrRow || !cellOrRow.isFullWidth()) return false;
        }
        return !!this.tabToNextCellCommon(cellOrRow, backwards, event);
    }
    tabToNextCellCommon(previous, backwards, event) {
        let editing = previous.isEditing();
        if (!editing && previous instanceof $7b57b57eaf5a9648$export$4fd76abbfd48a7b6) {
            const cell = previous;
            const row = cell.getRowCtrl();
            if (row) editing = row.isEditing();
        }
        let res;
        if (editing) {
            if (this.gos.get("editType") === "fullRow") res = this.moveToNextEditingRow(previous, backwards, event);
            else res = this.moveToNextEditingCell(previous, backwards, event);
        } else res = this.moveToNextCellNotEditing(previous, backwards);
        if (res === null) return res;
        return res || !!this.focusService.getFocusedHeader();
    }
    // returns null if no navigation should be performed
    moveToNextEditingCell(previousCell, backwards, event = null) {
        const previousPos = previousCell.getCellPosition();
        previousCell.getGui().focus();
        previousCell.stopEditing();
        const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);
        if (nextCell === false) return null;
        if (nextCell == null) return false;
        nextCell.startEditing(null, true, event);
        nextCell.focusCell(false);
        return true;
    }
    // returns null if no navigation should be performed
    moveToNextEditingRow(previousCell, backwards, event = null) {
        const previousPos = previousCell.getCellPosition();
        const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true);
        if (nextCell === false) return null;
        if (nextCell == null) return false;
        const nextPos = nextCell.getCellPosition();
        const previousEditable = this.isCellEditable(previousPos);
        const nextEditable = this.isCellEditable(nextPos);
        const rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;
        if (previousEditable) previousCell.setFocusOutOnEditor();
        if (!rowsMatch) {
            const pRow = previousCell.getRowCtrl();
            pRow.stopEditing();
            const nRow = nextCell.getRowCtrl();
            nRow.startRowEditing(void 0, void 0, event);
        }
        if (nextEditable) {
            nextCell.setFocusInOnEditor();
            nextCell.focusCell();
        } else nextCell.focusCell(true);
        return true;
    }
    // returns null if no navigation should be performed
    moveToNextCellNotEditing(previousCell, backwards) {
        const displayedColumns = this.visibleColsService.getAllCols();
        let cellPos;
        if (previousCell instanceof $7b57b57eaf5a9648$export$e449e57ac30326ed) cellPos = {
            ...previousCell.getRowPosition(),
            column: backwards ? displayedColumns[0] : $7b57b57eaf5a9648$export$236389741107357f(displayedColumns)
        };
        else cellPos = previousCell.getCellPosition();
        const nextCell = this.findNextCellToFocusOn(cellPos, backwards, false);
        if (nextCell === false) return null;
        if (nextCell instanceof $7b57b57eaf5a9648$export$4fd76abbfd48a7b6) nextCell.focusCell(true);
        else if (nextCell) return this.tryToFocusFullWidthRow(nextCell.getRowPosition(), backwards);
        return $7b57b57eaf5a9648$export$25d27f17d3af40f7(nextCell);
    }
    /**
   * called by the cell, when tab is pressed while editing.
   * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */ findNextCellToFocusOn(previousPosition, backwards, startEditing) {
        let nextPosition = previousPosition;
        while(true){
            if (previousPosition !== nextPosition) previousPosition = nextPosition;
            if (!backwards) nextPosition = this.getLastCellOfColSpan(nextPosition);
            nextPosition = this.cellNavigationService.getNextTabbedCell(nextPosition, backwards);
            const userFunc = this.gos.getCallback("tabToNextCell");
            if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(userFunc)) {
                const params = {
                    backwards: backwards,
                    editing: startEditing,
                    previousCellPosition: previousPosition,
                    nextCellPosition: nextPosition ? nextPosition : null
                };
                const userResult = userFunc(params);
                if (userResult === true || userResult === null) {
                    if (userResult === null) $7b57b57eaf5a9648$export$2cf41453020eef66("Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour.");
                    nextPosition = previousPosition;
                } else if (userResult === false) return false;
                else nextPosition = {
                    rowIndex: userResult.rowIndex,
                    column: userResult.column,
                    rowPinned: userResult.rowPinned
                };
            }
            if (!nextPosition) return null;
            if (nextPosition.rowIndex < 0) {
                const headerLen = this.headerNavigationService.getHeaderRowCount();
                this.focusService.focusHeaderPosition({
                    headerPosition: {
                        headerRowIndex: headerLen + nextPosition.rowIndex,
                        column: nextPosition.column
                    },
                    fromCell: true
                });
                return null;
            }
            const fullRowEdit = this.gos.get("editType") === "fullRow";
            if (startEditing && !fullRowEdit) {
                const cellIsEditable = this.isCellEditable(nextPosition);
                if (!cellIsEditable) continue;
            }
            this.ensureCellVisible(nextPosition);
            const nextCell = this.getCellByPosition(nextPosition);
            if (!nextCell) {
                const row = this.rowRenderer.getRowByPosition(nextPosition);
                if (!row || !row.isFullWidth() || startEditing) continue;
                return row;
            }
            if (nextCell.isSuppressNavigable()) continue;
            this.rangeService?.setRangeToCell(nextPosition);
            return nextCell;
        }
    }
    isCellEditable(cell) {
        const rowNode = this.lookupRowNodeForCell(cell);
        if (rowNode) return cell.column.isCellEditable(rowNode);
        return false;
    }
    getCellByPosition(cellPosition) {
        const rowCtrl = this.rowRenderer.getRowByPosition(cellPosition);
        if (!rowCtrl) return null;
        return rowCtrl.getCellCtrl(cellPosition.column);
    }
    lookupRowNodeForCell(cell) {
        if (cell.rowPinned === "top") return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);
        if (cell.rowPinned === "bottom") return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);
        return this.rowModel.getRow(cell.rowIndex);
    }
    // we use index for rows, but column object for columns, as the next column (by index) might not
    // be visible (header grouping) so it's not reliable, so using the column object instead.
    navigateToNextCell(event, key, currentCell, allowUserOverride) {
        let nextCell = currentCell;
        let hitEdgeOfGrid = false;
        while(nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))){
            if (this.gos.get("enableRtl")) {
                if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT) nextCell = this.getLastCellOfColSpan(nextCell);
            } else if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT) nextCell = this.getLastCellOfColSpan(nextCell);
            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);
            hitEdgeOfGrid = $7b57b57eaf5a9648$export$672d9e47bc342bac(nextCell);
        }
        if (hitEdgeOfGrid && event && event.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP) nextCell = {
            rowIndex: -1,
            rowPinned: null,
            column: currentCell.column
        };
        if (allowUserOverride) {
            const userFunc = this.gos.getCallback("navigateToNextCell");
            if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(userFunc)) {
                const params = {
                    key: key,
                    previousCellPosition: currentCell,
                    nextCellPosition: nextCell ? nextCell : null,
                    event: event
                };
                const userCell = userFunc(params);
                if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(userCell)) nextCell = {
                    rowPinned: userCell.rowPinned,
                    rowIndex: userCell.rowIndex,
                    column: userCell.column
                };
                else nextCell = null;
            }
        }
        if (!nextCell) return;
        if (nextCell.rowIndex < 0) {
            const headerLen = this.headerNavigationService.getHeaderRowCount();
            this.focusService.focusHeaderPosition({
                headerPosition: {
                    headerRowIndex: headerLen + nextCell.rowIndex,
                    column: currentCell.column
                },
                event: event || void 0,
                fromCell: true
            });
            return;
        }
        const normalisedPosition = this.getNormalisedPosition(nextCell);
        if (normalisedPosition) this.focusPosition(normalisedPosition);
        else this.tryToFocusFullWidthRow(nextCell);
    }
    getNormalisedPosition(cellPosition) {
        this.ensureCellVisible(cellPosition);
        const cellCtrl = this.getCellByPosition(cellPosition);
        if (!cellCtrl) return null;
        cellPosition = cellCtrl.getCellPosition();
        this.ensureCellVisible(cellPosition);
        return cellPosition;
    }
    tryToFocusFullWidthRow(position, backwards = false) {
        const displayedColumns = this.visibleColsService.getAllCols();
        const rowComp = this.rowRenderer.getRowByPosition(position);
        if (!rowComp || !rowComp.isFullWidth()) return false;
        const currentCellFocused = this.focusService.getFocusedCell();
        const cellPosition = {
            rowIndex: position.rowIndex,
            rowPinned: position.rowPinned,
            column: position.column || (backwards ? $7b57b57eaf5a9648$export$236389741107357f(displayedColumns) : displayedColumns[0])
        };
        this.focusPosition(cellPosition);
        const fromBelow = currentCellFocused != null ? this.rowPositionUtils.before(cellPosition, currentCellFocused) : false;
        const focusEvent = {
            type: "fullWidthRowFocused",
            rowIndex: cellPosition.rowIndex,
            rowPinned: cellPosition.rowPinned,
            column: cellPosition.column,
            isFullWidthCell: true,
            fromBelow: fromBelow
        };
        this.eventService.dispatchEvent(focusEvent);
        return true;
    }
    focusPosition(cellPosition) {
        this.focusService.setFocusedCell({
            rowIndex: cellPosition.rowIndex,
            column: cellPosition.column,
            rowPinned: cellPosition.rowPinned,
            forceBrowserFocus: true
        });
        this.rangeService?.setRangeToCell(cellPosition);
    }
    isValidNavigateCell(cell) {
        const rowNode = this.rowPositionUtils.getRowNode(cell);
        return !!rowNode;
    }
    getLastCellOfColSpan(cell) {
        const cellCtrl = this.getCellByPosition(cell);
        if (!cellCtrl) return cell;
        const colSpanningList = cellCtrl.getColSpanningList();
        if (colSpanningList.length === 1) return cell;
        return {
            rowIndex: cell.rowIndex,
            column: $7b57b57eaf5a9648$export$236389741107357f(colSpanningList),
            rowPinned: cell.rowPinned
        };
    }
    ensureCellVisible(gridCell) {
        const isGroupStickyEnabled = this.gos.isGroupRowsSticky();
        const rowNode = this.rowModel.getRow(gridCell.rowIndex);
        const skipScrollToRow = isGroupStickyEnabled && rowNode?.sticky;
        if (!skipScrollToRow && $7b57b57eaf5a9648$export$672d9e47bc342bac(gridCell.rowPinned)) this.gridBodyCon.getScrollFeature().ensureIndexVisible(gridCell.rowIndex);
        if (!gridCell.column.isPinned()) this.gridBodyCon.getScrollFeature().ensureColumnVisible(gridCell.column);
    }
};
// community-modules/core/src/headerRendering/common/horizontalResizeService.ts
var $7b57b57eaf5a9648$export$8c88ee8741066b8b = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "horizontalResizeService";
    }
    wireBeans(beans) {
        this.dragService = beans.dragService;
        this.ctrlsService = beans.ctrlsService;
    }
    addResizeBar(params) {
        const dragSource = {
            dragStartPixels: params.dragStartPixels || 0,
            eElement: params.eResizeBar,
            onDragStart: this.onDragStart.bind(this, params),
            onDragStop: this.onDragStop.bind(this, params),
            onDragging: this.onDragging.bind(this, params),
            includeTouch: true,
            stopPropagationForTouch: true
        };
        this.dragService.addDragSource(dragSource);
        const finishedWithResizeFunc = ()=>this.dragService.removeDragSource(dragSource);
        return finishedWithResizeFunc;
    }
    onDragStart(params, mouseEvent) {
        this.dragStartX = mouseEvent.clientX;
        this.setResizeIcons();
        const shiftKey = mouseEvent instanceof MouseEvent && mouseEvent.shiftKey === true;
        params.onResizeStart(shiftKey);
    }
    setResizeIcons() {
        const ctrl = this.ctrlsService.get("gridCtrl");
        ctrl.setResizeCursor(true);
        ctrl.disableUserSelect(true);
    }
    onDragStop(params, mouseEvent) {
        params.onResizeEnd(this.resizeAmount);
        this.resetIcons();
    }
    resetIcons() {
        const ctrl = this.ctrlsService.get("gridCtrl");
        ctrl.setResizeCursor(false);
        ctrl.disableUserSelect(false);
    }
    onDragging(params, mouseEvent) {
        this.resizeAmount = mouseEvent.clientX - this.dragStartX;
        params.onResizing(this.resizeAmount);
    }
};
// community-modules/core/src/headerRendering/cells/column/standardMenu.ts
var $7b57b57eaf5a9648$export$ddca88023f936464 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "filterMenuFactory";
    }
    wireBeans(beans) {
        this.popupService = beans.popupService;
        this.focusService = beans.focusService;
        this.ctrlsService = beans.ctrlsService;
        this.menuService = beans.menuService;
    }
    hideActiveMenu() {
        if (this.hidePopup) this.hidePopup();
    }
    showMenuAfterMouseEvent(column, mouseEvent, containerType) {
        this.showPopup(column, (eMenu)=>{
            this.popupService.positionPopupUnderMouseEvent({
                column: column,
                type: containerType,
                mouseEvent: mouseEvent,
                ePopup: eMenu
            });
        }, containerType, mouseEvent.target, this.menuService.isLegacyMenuEnabled());
    }
    showMenuAfterButtonClick(column, eventSource, containerType) {
        let multiplier = -1;
        let alignSide = "left";
        const isLegacyMenuEnabled = this.menuService.isLegacyMenuEnabled();
        if (!isLegacyMenuEnabled && this.gos.get("enableRtl")) {
            multiplier = 1;
            alignSide = "right";
        }
        const nudgeX = isLegacyMenuEnabled ? void 0 : 4 * multiplier;
        const nudgeY = isLegacyMenuEnabled ? void 0 : 4;
        this.showPopup(column, (eMenu)=>{
            this.popupService.positionPopupByComponent({
                type: containerType,
                eventSource: eventSource,
                ePopup: eMenu,
                nudgeX: nudgeX,
                nudgeY: nudgeY,
                alignSide: alignSide,
                keepWithinBounds: true,
                position: "under",
                column: column
            });
        }, containerType, eventSource, isLegacyMenuEnabled);
    }
    showPopup(column, positionCallback, containerType, eventSource, isLegacyMenuEnabled) {
        const comp = column ? this.createBean(new $7b57b57eaf5a9648$export$70acaf0e0e30e7d(column, "COLUMN_MENU")) : void 0;
        this.activeMenu = comp;
        if (!comp?.hasFilter() || !column) throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
        const eMenu = document.createElement("div");
        $7b57b57eaf5a9648$export$f8d01fa01787902(eMenu, "presentation");
        eMenu.classList.add("ag-menu");
        if (!isLegacyMenuEnabled) eMenu.classList.add("ag-filter-menu");
        [this.tabListener] = this.addManagedElementListeners(eMenu, {
            keydown: (e)=>this.trapFocusWithin(e, eMenu)
        });
        eMenu.appendChild(comp?.getGui());
        let hidePopup;
        const afterGuiDetached = ()=>comp?.afterGuiDetached();
        const anchorToElement = this.menuService.isColumnMenuAnchoringEnabled() ? eventSource ?? this.ctrlsService.getGridBodyCtrl().getGui() : void 0;
        const closedCallback = (e)=>{
            column.setMenuVisible(false, "contextMenu");
            const isKeyboardEvent = e instanceof KeyboardEvent;
            if (this.tabListener) this.tabListener = this.tabListener();
            if (isKeyboardEvent && eventSource && $7b57b57eaf5a9648$export$2badf4aa566524cb(eventSource)) {
                const focusableEl = this.focusService.findTabbableParent(eventSource);
                if (focusableEl) focusableEl.focus();
            }
            afterGuiDetached();
            this.destroyBean(this.activeMenu);
            this.dispatchVisibleChangedEvent(false, containerType, column);
        };
        const translate = this.localeService.getLocaleTextFunc();
        const ariaLabel = isLegacyMenuEnabled && containerType !== "columnFilter" ? translate("ariaLabelColumnMenu", "Column Menu") : translate("ariaLabelColumnFilter", "Column Filter");
        const addPopupRes = this.popupService.addPopup({
            modal: true,
            eChild: eMenu,
            closeOnEsc: true,
            closedCallback: closedCallback,
            positionCallback: ()=>positionCallback(eMenu),
            anchorToElement: anchorToElement,
            ariaLabel: ariaLabel
        });
        if (addPopupRes) this.hidePopup = hidePopup = addPopupRes.hideFunc;
        comp.afterInit().then(()=>{
            positionCallback(eMenu);
            comp.afterGuiAttached({
                container: containerType,
                hidePopup: hidePopup
            });
        });
        column.setMenuVisible(true, "contextMenu");
        this.dispatchVisibleChangedEvent(true, containerType, column);
    }
    trapFocusWithin(e, menu) {
        if (e.key !== $7b57b57eaf5a9648$export$e9e0d96f49f57c33.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(menu, false, e.shiftKey)) return;
        e.preventDefault();
        this.focusService.focusInto(menu, e.shiftKey);
    }
    dispatchVisibleChangedEvent(visible, containerType, column) {
        const displayedEvent = {
            type: "columnMenuVisibleChanged",
            visible: visible,
            switchingTab: false,
            key: containerType,
            column: column ?? null
        };
        this.eventService.dispatchEvent(displayedEvent);
    }
    isMenuEnabled(column) {
        return column.isFilterAllowed() && (column.getColDef().menuTabs ?? [
            "filterMenuTab"
        ]).includes("filterMenuTab");
    }
    showMenuAfterContextMenuEvent() {}
    destroy() {
        this.destroyBean(this.activeMenu);
        super.destroy();
    }
};
// community-modules/core/src/misc/resizeObserverService.ts
var $7b57b57eaf5a9648$var$DEBOUNCE_DELAY = 50;
var $7b57b57eaf5a9648$export$c3ae9ac02599b50f = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "resizeObserverService";
        this.polyfillFunctions = [];
    }
    observeResize(element, callback) {
        const win = this.gos.getWindow();
        const useBrowserResizeObserver = ()=>{
            const resizeObserver = new win.ResizeObserver(callback);
            resizeObserver.observe(element);
            return ()=>resizeObserver.disconnect();
        };
        const usePolyfill = ()=>{
            let widthLastTime = element?.clientWidth ?? 0;
            let heightLastTime = element?.clientHeight ?? 0;
            let running = true;
            const periodicallyCheckWidthAndHeight = ()=>{
                if (running) {
                    const newWidth = element?.clientWidth ?? 0;
                    const newHeight = element?.clientHeight ?? 0;
                    const changed = newWidth !== widthLastTime || newHeight !== heightLastTime;
                    if (changed) {
                        widthLastTime = newWidth;
                        heightLastTime = newHeight;
                        callback();
                    }
                    this.doNextPolyfillTurn(periodicallyCheckWidthAndHeight);
                }
            };
            periodicallyCheckWidthAndHeight();
            return ()=>running = false;
        };
        const suppressResize = this.gos.get("suppressBrowserResizeObserver");
        const resizeObserverExists = !!win.ResizeObserver;
        if (resizeObserverExists && !suppressResize) return useBrowserResizeObserver();
        return this.getFrameworkOverrides().wrapIncoming(()=>usePolyfill(), "resize-observer");
    }
    doNextPolyfillTurn(func) {
        this.polyfillFunctions.push(func);
        this.schedulePolyfill();
    }
    schedulePolyfill() {
        if (this.polyfillScheduled) return;
        const executeAllFuncs = ()=>{
            const funcs = this.polyfillFunctions;
            this.polyfillScheduled = false;
            this.polyfillFunctions = [];
            funcs.forEach((f)=>f());
        };
        this.polyfillScheduled = true;
        window.setTimeout(executeAllFuncs, $7b57b57eaf5a9648$var$DEBOUNCE_DELAY);
    }
};
// community-modules/core/src/misc/animationFrameService.ts
var $7b57b57eaf5a9648$export$2963e6121f7c3146 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "animationFrameService";
        // p1 and p2 are create tasks are to do with row and cell creation.
        // for them we want to execute according to row order, so we use
        // TaskItem so we know what index the item is for.
        this.createTasksP1 = {
            list: [],
            sorted: false
        };
        // eg drawing back-ground of rows
        this.createTasksP2 = {
            list: [],
            sorted: false
        };
        // eg cell renderers, adding hover functionality
        // destroy tasks are to do with row removal. they are done after row creation as the user will need to see new
        // rows first (as blank is scrolled into view), when we remove the old rows (no longer in view) is not as
        // important.
        this.destroyTasks = [];
        this.ticking = false;
        // we need to know direction of scroll, to build up rows in the direction of
        // the scroll. eg if user scrolls down, we extend the rows by building down.
        this.scrollGoingDown = true;
        this.lastPage = 0;
        this.lastScrollTop = 0;
        this.taskCount = 0;
        this.cancelledTasks = /* @__PURE__ */ new Set();
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
        this.paginationService = beans.paginationService;
    }
    setScrollTop(scrollTop) {
        const isPaginationActive = this.gos.get("pagination");
        this.scrollGoingDown = scrollTop >= this.lastScrollTop;
        if (isPaginationActive && scrollTop === 0) {
            const currentPage = this.paginationService?.getCurrentPage() ?? 0;
            if (currentPage !== this.lastPage) {
                this.lastPage = currentPage;
                this.scrollGoingDown = true;
            }
        }
        this.lastScrollTop = scrollTop;
    }
    postConstruct() {
        this.useAnimationFrame = !this.gos.get("suppressAnimationFrame");
    }
    isOn() {
        return this.useAnimationFrame;
    }
    // this method is for our AG Grid sanity only - if animation frames are turned off,
    // then no place in the code should be looking to add any work to be done in animation
    // frames. this stops bugs - where some code is asking for a frame to be executed
    // when it should not.
    verifyAnimationFrameOn(methodName) {
        if (this.useAnimationFrame === false) $7b57b57eaf5a9648$export$2cf41453020eef66(`AnimationFrameService.${methodName} called but animation frames are off`);
    }
    createTask(task, index, list) {
        this.verifyAnimationFrameOn(list);
        const taskItem = {
            task: task,
            index: index,
            createOrder: ++this.taskCount
        };
        this.addTaskToList(this[list], taskItem);
        this.schedule();
    }
    cancelTask(task) {
        this.cancelledTasks.add(task);
    }
    addTaskToList(taskList, task) {
        taskList.list.push(task);
        taskList.sorted = false;
    }
    sortTaskList(taskList) {
        if (taskList.sorted) return;
        const sortDirection = this.scrollGoingDown ? 1 : -1;
        taskList.list.sort((a, b)=>a.index !== b.index ? sortDirection * (b.index - a.index) : b.createOrder - a.createOrder);
        taskList.sorted = true;
    }
    addDestroyTask(task) {
        this.verifyAnimationFrameOn("createTasksP3");
        this.destroyTasks.push(task);
        this.schedule();
    }
    executeFrame(millis) {
        this.verifyAnimationFrameOn("executeFrame");
        const p1TaskList = this.createTasksP1;
        const p1Tasks = p1TaskList.list;
        const p2TaskList = this.createTasksP2;
        const p2Tasks = p2TaskList.list;
        const destroyTasks = this.destroyTasks;
        const frameStart = /* @__PURE__ */ new Date().getTime();
        let duration = /* @__PURE__ */ new Date().getTime() - frameStart;
        const noMaxMillis = millis <= 0;
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        while(noMaxMillis || duration < millis){
            const gridBodyDidSomething = gridBodyCon.getScrollFeature().scrollGridIfNeeded();
            if (!gridBodyDidSomething) {
                let task;
                if (p1Tasks.length) {
                    this.sortTaskList(p1TaskList);
                    task = p1Tasks.pop().task;
                } else if (p2Tasks.length) {
                    this.sortTaskList(p2TaskList);
                    task = p2Tasks.pop().task;
                } else if (destroyTasks.length) task = destroyTasks.pop();
                else {
                    this.cancelledTasks.clear();
                    break;
                }
                if (!this.cancelledTasks.has(task)) task();
            }
            duration = /* @__PURE__ */ new Date().getTime() - frameStart;
        }
        if (p1Tasks.length || p2Tasks.length || destroyTasks.length) this.requestFrame();
        else this.stopTicking();
    }
    stopTicking() {
        this.ticking = false;
    }
    flushAllFrames() {
        if (!this.useAnimationFrame) return;
        this.executeFrame(-1);
    }
    schedule() {
        if (!this.useAnimationFrame) return;
        if (!this.ticking) {
            this.ticking = true;
            this.requestFrame();
        }
    }
    requestFrame() {
        const callback = this.executeFrame.bind(this, 60);
        this.requestAnimationFrame(callback);
    }
    requestAnimationFrame(callback) {
        const win = this.gos.getWindow();
        if (win.requestAnimationFrame) win.requestAnimationFrame(callback);
        else if (win.webkitRequestAnimationFrame) win.webkitRequestAnimationFrame(callback);
        else win.setTimeout(callback, 0);
    }
    isQueueEmpty() {
        return !this.ticking;
    }
    // a debounce utility used for parts of the app involved with rendering.
    // the advantage over normal debounce is the client can call flushAllFrames()
    // to make sure all rendering is complete. we don't wait any milliseconds,
    // as this is intended to batch calls in one VM turn.
    debounce(func) {
        let pending = false;
        return ()=>{
            if (!this.isOn()) {
                window.setTimeout(func, 0);
                return;
            }
            if (pending) return;
            pending = true;
            this.addDestroyTask(()=>{
                pending = false;
                func();
            });
        };
    }
};
// community-modules/core/src/interfaces/iClientSideRowModel.ts
var $7b57b57eaf5a9648$export$42ac378faabadc9d = /* @__PURE__ */ ((ClientSideRowModelSteps2)=>{
    ClientSideRowModelSteps2["EVERYTHING"] = "group";
    ClientSideRowModelSteps2["FILTER"] = "filter";
    ClientSideRowModelSteps2["SORT"] = "sort";
    ClientSideRowModelSteps2["MAP"] = "map";
    ClientSideRowModelSteps2["AGGREGATE"] = "aggregate";
    ClientSideRowModelSteps2["FILTER_AGGREGATES"] = "filter_aggregates";
    ClientSideRowModelSteps2["PIVOT"] = "pivot";
    ClientSideRowModelSteps2["NOTHING"] = "nothing";
    return ClientSideRowModelSteps2;
})($7b57b57eaf5a9648$export$42ac378faabadc9d || {});
// community-modules/core/src/misc/expansionService.ts
var $7b57b57eaf5a9648$export$609b78da5e2f116c = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "expansionService";
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
    }
    postConstruct() {
        this.isClientSideRowModel = this.rowModel.getType() === "clientSide";
    }
    expandRows(rowIds) {
        if (!this.isClientSideRowModel) return;
        const rowIdSet = new Set(rowIds);
        this.rowModel.forEachNode((node)=>{
            if (node.id && rowIdSet.has(node.id)) node.expanded = true;
        });
        this.onGroupExpandedOrCollapsed();
    }
    getExpandedRows() {
        const expandedRows = [];
        this.rowModel.forEachNode(({ expanded: expanded , id: id  })=>{
            if (expanded && id) expandedRows.push(id);
        });
        return expandedRows;
    }
    expandAll(value) {
        if (!this.isClientSideRowModel) return;
        this.rowModel.expandOrCollapseAll(value);
    }
    setRowNodeExpanded(rowNode, expanded, expandParents, forceSync) {
        if (rowNode) {
            if (expandParents && rowNode.parent && rowNode.parent.level !== -1) this.setRowNodeExpanded(rowNode.parent, expanded, expandParents, forceSync);
            rowNode.setExpanded(expanded, void 0, forceSync);
        }
    }
    onGroupExpandedOrCollapsed() {
        if (!this.isClientSideRowModel) return;
        this.rowModel.refreshModel({
            step: "map" /* MAP */ 
        });
    }
};
// community-modules/core/src/misc/menuService.ts
var $7b57b57eaf5a9648$export$ec78627b94a587e2 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "menuService";
    }
    wireBeans(beans) {
        this.filterMenuFactory = beans.filterMenuFactory;
        this.ctrlsService = beans.ctrlsService;
        this.animationFrameService = beans.animationFrameService;
        this.filterManager = beans.filterManager;
        this.rowRenderer = beans.rowRenderer;
        this.columnChooserFactory = beans.columnChooserFactory;
        this.contextMenuFactory = beans.contextMenuFactory;
        this.enterpriseMenuFactory = beans.enterpriseMenuFactory;
    }
    postConstruct() {
        this.activeMenuFactory = this.enterpriseMenuFactory ?? this.filterMenuFactory;
    }
    showColumnMenu(params) {
        this.showColumnMenuCommon(this.activeMenuFactory, params, "columnMenu");
    }
    showFilterMenu(params) {
        const menuFactory = this.enterpriseMenuFactory && this.isLegacyMenuEnabled() ? this.enterpriseMenuFactory : this.filterMenuFactory;
        this.showColumnMenuCommon(menuFactory, params, params.containerType, true);
    }
    showHeaderContextMenu(column, mouseEvent, touchEvent) {
        this.activeMenuFactory.showMenuAfterContextMenuEvent(column, mouseEvent, touchEvent);
    }
    getContextMenuPosition(rowNode, column) {
        const rowCtrl = this.getRowCtrl(rowNode);
        const eGui = this.getCellGui(rowCtrl, column);
        if (!eGui) {
            if (rowCtrl) return {
                x: 0,
                y: rowCtrl.getRowYPosition()
            };
            return {
                x: 0,
                y: 0
            };
        }
        const rect = eGui.getBoundingClientRect();
        return {
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2
        };
    }
    showContextMenu(params) {
        const { rowNode: rowNode  } = params;
        const column = params.column;
        let { anchorToElement: anchorToElement , value: value  } = params;
        if (rowNode && column && value == null) value = rowNode.getValueFromValueService(column);
        if (anchorToElement == null) anchorToElement = this.getContextMenuAnchorElement(rowNode, column);
        this.contextMenuFactory?.onContextMenu(params.mouseEvent ?? null, params.touchEvent ?? null, rowNode ?? null, column ?? null, value, anchorToElement);
    }
    showColumnChooser(params) {
        this.columnChooserFactory?.showColumnChooser(params);
    }
    hidePopupMenu() {
        this.contextMenuFactory?.hideActiveMenu();
        this.activeMenuFactory.hideActiveMenu();
    }
    hideColumnChooser() {
        this.columnChooserFactory?.hideActiveColumnChooser();
    }
    isColumnMenuInHeaderEnabled(column) {
        const { suppressMenu: suppressMenu , suppressHeaderMenuButton: suppressHeaderMenuButton  } = column.getColDef();
        const isSuppressMenuButton = suppressHeaderMenuButton ?? suppressMenu;
        return !isSuppressMenuButton && this.activeMenuFactory.isMenuEnabled(column) && (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory);
    }
    isFilterMenuInHeaderEnabled(column) {
        return !column.getColDef().suppressHeaderFilterButton && !!this.filterManager?.isFilterAllowed(column);
    }
    isHeaderContextMenuEnabled(column) {
        return !column?.getColDef().suppressHeaderContextMenu && this.getColumnMenuType() === "new";
    }
    isHeaderMenuButtonAlwaysShowEnabled() {
        return this.isSuppressMenuHide();
    }
    isHeaderMenuButtonEnabled() {
        const menuHides = !this.isSuppressMenuHide();
        const onIpadAndMenuHides = $7b57b57eaf5a9648$export$6b6034a68325bd8a() && menuHides;
        return !onIpadAndMenuHides;
    }
    isHeaderFilterButtonEnabled(column) {
        return this.isFilterMenuInHeaderEnabled(column) && !this.isLegacyMenuEnabled() && !this.isFloatingFilterButtonDisplayed(column);
    }
    isFilterMenuItemEnabled(column) {
        return !!this.filterManager?.isFilterAllowed(column) && !this.isLegacyMenuEnabled() && !this.isFilterMenuInHeaderEnabled(column) && !this.isFloatingFilterButtonDisplayed(column);
    }
    isColumnMenuAnchoringEnabled() {
        return !this.isLegacyMenuEnabled();
    }
    areAdditionalColumnMenuItemsEnabled() {
        return this.getColumnMenuType() === "new";
    }
    isLegacyMenuEnabled() {
        return this.getColumnMenuType() === "legacy";
    }
    isFloatingFilterButtonEnabled(column) {
        const colDef = column.getColDef();
        const legacySuppressFilterButton = colDef.floatingFilterComponentParams?.suppressFilterButton;
        if (legacySuppressFilterButton != null) $7b57b57eaf5a9648$export$2cf41453020eef66(`As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead.`);
        return colDef.suppressFloatingFilterButton == null ? !legacySuppressFilterButton : !colDef.suppressFloatingFilterButton;
    }
    getColumnMenuType() {
        return this.gos.get("columnMenu");
    }
    isFloatingFilterButtonDisplayed(column) {
        return !!column.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(column);
    }
    isSuppressMenuHide() {
        const suppressMenuHide = this.gos.get("suppressMenuHide");
        if (this.isLegacyMenuEnabled()) return this.gos.exists("suppressMenuHide") ? suppressMenuHide : false;
        return suppressMenuHide;
    }
    showColumnMenuCommon(menuFactory, params, containerType, filtersOnly) {
        const { positionBy: positionBy  } = params;
        const column = params.column;
        if (positionBy === "button") {
            const { buttonElement: buttonElement  } = params;
            menuFactory.showMenuAfterButtonClick(column, buttonElement, containerType, filtersOnly);
        } else if (positionBy === "mouse") {
            const { mouseEvent: mouseEvent  } = params;
            menuFactory.showMenuAfterMouseEvent(column, mouseEvent, containerType, filtersOnly);
        } else if (column) {
            this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(column, "auto");
            this.animationFrameService.requestAnimationFrame(()=>{
                const headerCellCtrl = this.ctrlsService.getHeaderRowContainerCtrl(column.getPinned()).getHeaderCtrlForColumn(column);
                menuFactory.showMenuAfterButtonClick(column, headerCellCtrl.getAnchorElementForMenu(filtersOnly), containerType, true);
            });
        }
    }
    getRowCtrl(rowNode) {
        const { rowIndex: rowIndex , rowPinned: rowPinned  } = rowNode || {};
        if (rowIndex == null) return;
        return this.rowRenderer.getRowByPosition({
            rowIndex: rowIndex,
            rowPinned: rowPinned
        }) || void 0;
    }
    getCellGui(rowCtrl, column) {
        if (!rowCtrl || !column) return;
        const cellCtrl = rowCtrl.getCellCtrl(column);
        return cellCtrl?.getGui() || void 0;
    }
    getContextMenuAnchorElement(rowNode, column) {
        const gridBodyEl = this.ctrlsService.getGridBodyCtrl().getGridBodyElement();
        const rowCtrl = this.getRowCtrl(rowNode);
        if (!rowCtrl) return gridBodyEl;
        const cellGui = this.getCellGui(rowCtrl, column);
        if (cellGui) return cellGui;
        if (rowCtrl.isFullWidth()) return rowCtrl.getFullWidthElement();
        return gridBodyEl;
    }
};
// community-modules/core/src/widgets/agInputTextArea.ts
var $7b57b57eaf5a9648$export$fd677433260ffbc8 = class extends $7b57b57eaf5a9648$export$9671f513d4aa42e3 {
    constructor(config){
        super(config, "ag-text-area", null, "textarea");
    }
    setValue(value, silent) {
        const ret = super.setValue(value, silent);
        this.eInput.value = value;
        return ret;
    }
    setCols(cols) {
        this.eInput.cols = cols;
        return this;
    }
    setRows(rows) {
        this.eInput.rows = rows;
        return this;
    }
};
var $7b57b57eaf5a9648$var$AgInputTextAreaSelector = {
    selector: "AG-INPUT-TEXT-AREA",
    component: $7b57b57eaf5a9648$export$fd677433260ffbc8
};
// community-modules/core/src/edit/cellEditors/largeTextCellEditor.ts
var $7b57b57eaf5a9648$export$98890d6e078b4910 = class extends $7b57b57eaf5a9648$export$9fac2d040f3ed438 {
    constructor(){
        super(/* html */ `<div class="ag-large-text">
        <ag-input-text-area data-ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`, [
            $7b57b57eaf5a9648$var$AgInputTextAreaSelector
        ]);
        this.eTextArea = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    init(params) {
        this.params = params;
        this.focusAfterAttached = params.cellStartedEdit;
        this.eTextArea.setMaxLength(params.maxLength || 200).setCols(params.cols || 60).setRows(params.rows || 10);
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(params.value, true)) this.eTextArea.setValue(params.value.toString(), true);
        this.addGuiEventListener("keydown", this.onKeyDown.bind(this));
        this.activateTabIndex();
    }
    onKeyDown(event) {
        const key = event.key;
        if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT || key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP || key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT || key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN || event.shiftKey && key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER) event.stopPropagation();
    }
    afterGuiAttached() {
        const translate = this.localeService.getLocaleTextFunc();
        this.eTextArea.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
        if (this.focusAfterAttached) this.eTextArea.getFocusableElement().focus();
    }
    getValue() {
        const value = this.eTextArea.getValue();
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(value) && !$7b57b57eaf5a9648$export$25d27f17d3af40f7(this.params.value)) return this.params.value;
        return this.params.parseValue(value);
    }
};
// community-modules/core/src/edit/cellEditors/popupEditorWrapper.ts
var $7b57b57eaf5a9648$export$fdd61bfa9577e25 = class extends $7b57b57eaf5a9648$export$9fac2d040f3ed438 {
    constructor(params){
        super(/* html */ `<div class="ag-popup-editor" tabindex="-1"/>`);
        this.params = params;
    }
    postConstruct() {
        this.gos.setDomData(this.getGui(), "popupEditorWrapper", true);
        this.addKeyDownListener();
    }
    addKeyDownListener() {
        const eGui = this.getGui();
        const params = this.params;
        const listener = (event)=>{
            if (!$7b57b57eaf5a9648$var$_isUserSuppressingKeyboardEvent(this.gos, event, params.node, params.column, true)) params.onKeyDown(event);
        };
        this.addManagedElementListeners(eGui, {
            keydown: listener
        });
    }
};
// community-modules/core/src/edit/cellEditors/selectCellEditor.ts
var $7b57b57eaf5a9648$export$638f87cb94a2e5dc = class extends $7b57b57eaf5a9648$export$9fac2d040f3ed438 {
    constructor(){
        super(/* html */ `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" data-ref="eSelect"></ag-select>
            </div>`, [
            $7b57b57eaf5a9648$export$e32612175ad118ef
        ]);
        this.eSelect = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.startedByEnter = false;
    }
    wireBeans(beans) {
        this.valueService = beans.valueService;
    }
    init(params) {
        this.focusAfterAttached = params.cellStartedEdit;
        const { eSelect: eSelect , valueService: valueService , gos: gos  } = this;
        const { values: values , value: value , eventKey: eventKey  } = params;
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(values)) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("no values found for select cellEditor");
            return;
        }
        this.startedByEnter = eventKey != null ? eventKey === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER : false;
        let hasValue = false;
        values.forEach((currentValue)=>{
            const option = {
                value: currentValue
            };
            const valueFormatted = valueService.formatValue(params.column, null, currentValue);
            const valueFormattedExits = valueFormatted !== null && valueFormatted !== void 0;
            option.text = valueFormattedExits ? valueFormatted : currentValue;
            eSelect.addOption(option);
            hasValue = hasValue || value === currentValue;
        });
        if (hasValue) eSelect.setValue(params.value, true);
        else if (params.values.length) eSelect.setValue(params.values[0], true);
        const { valueListGap: valueListGap , valueListMaxWidth: valueListMaxWidth , valueListMaxHeight: valueListMaxHeight  } = params;
        if (valueListGap != null) eSelect.setPickerGap(valueListGap);
        if (valueListMaxHeight != null) eSelect.setPickerMaxHeight(valueListMaxHeight);
        if (valueListMaxWidth != null) eSelect.setPickerMaxWidth(valueListMaxWidth);
        if (gos.get("editType") !== "fullRow") this.addManagedListeners(this.eSelect, {
            selectedItem: ()=>params.stopEditing()
        });
    }
    afterGuiAttached() {
        if (this.focusAfterAttached) this.eSelect.getFocusableElement().focus();
        if (this.startedByEnter) setTimeout(()=>{
            if (this.isAlive()) this.eSelect.showPicker();
        });
    }
    focusIn() {
        this.eSelect.getFocusableElement().focus();
    }
    getValue() {
        return this.eSelect.getValue();
    }
    isPopup() {
        return false;
    }
};
// community-modules/core/src/edit/cellEditors/simpleCellEditor.ts
var $7b57b57eaf5a9648$var$SimpleCellEditor = class extends $7b57b57eaf5a9648$export$9fac2d040f3ed438 {
    constructor(cellEditorInput){
        super(/* html */ `
            <div class="ag-cell-edit-wrapper">
                ${cellEditorInput.getTemplate()}
            </div>`, cellEditorInput.getAgComponents());
        this.cellEditorInput = cellEditorInput;
        this.eInput = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    init(params) {
        this.params = params;
        const eInput = this.eInput;
        this.cellEditorInput.init(eInput, params);
        let startValue;
        if (params.cellStartedEdit) {
            this.focusAfterAttached = true;
            const eventKey = params.eventKey;
            if (eventKey === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.BACKSPACE || params.eventKey === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DELETE) startValue = "";
            else if (eventKey && eventKey.length === 1) startValue = eventKey;
            else {
                startValue = this.cellEditorInput.getStartValue();
                if (eventKey !== $7b57b57eaf5a9648$export$e9e0d96f49f57c33.F2) this.highlightAllOnFocus = true;
            }
        } else {
            this.focusAfterAttached = false;
            startValue = this.cellEditorInput.getStartValue();
        }
        if (startValue != null) eInput.setStartValue(startValue);
        this.addManagedElementListeners(eInput.getGui(), {
            keydown: (event)=>{
                const { key: key  } = event;
                if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_UP || key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.PAGE_DOWN) event.preventDefault();
            }
        });
    }
    afterGuiAttached() {
        const translate = this.localeService.getLocaleTextFunc();
        const eInput = this.eInput;
        eInput.setInputAriaLabel(translate("ariaInputEditor", "Input Editor"));
        if (!this.focusAfterAttached) return;
        if (!$7b57b57eaf5a9648$var$_isBrowserSafari()) eInput.getFocusableElement().focus();
        const inputEl = eInput.getInputElement();
        if (this.highlightAllOnFocus) inputEl.select();
        else this.cellEditorInput.setCaret?.();
    }
    // gets called when tabbing through cells and in full row edit mode
    focusIn() {
        const eInput = this.eInput;
        const focusEl = eInput.getFocusableElement();
        const inputEl = eInput.getInputElement();
        focusEl.focus();
        inputEl.select();
    }
    getValue() {
        return this.cellEditorInput.getValue();
    }
    isPopup() {
        return false;
    }
};
// community-modules/core/src/edit/cellEditors/textCellEditor.ts
var $7b57b57eaf5a9648$var$TextCellEditorInput = class {
    getTemplate() {
        return /* html */ `<ag-input-text-field class="ag-cell-editor" data-ref="eInput"></ag-input-text-field>`;
    }
    getAgComponents() {
        return [
            $7b57b57eaf5a9648$export$31e2985be4ee06ab
        ];
    }
    init(eInput, params) {
        this.eInput = eInput;
        this.params = params;
        if (params.maxLength != null) eInput.setMaxLength(params.maxLength);
    }
    getValue() {
        const value = this.eInput.getValue();
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(value) && !$7b57b57eaf5a9648$export$25d27f17d3af40f7(this.params.value)) return this.params.value;
        return this.params.parseValue(value);
    }
    getStartValue() {
        const formatValue = this.params.useFormatter || this.params.column.getColDef().refData;
        return formatValue ? this.params.formatValue(this.params.value) : this.params.value;
    }
    setCaret() {
        const value = this.eInput.getValue();
        const len = $7b57b57eaf5a9648$export$25d27f17d3af40f7(value) && value.length || 0;
        if (len) this.eInput.getInputElement().setSelectionRange(len, len);
    }
};
var $7b57b57eaf5a9648$export$6e94bf0a822a6a81 = class extends $7b57b57eaf5a9648$var$SimpleCellEditor {
    constructor(){
        super(new $7b57b57eaf5a9648$var$TextCellEditorInput());
    }
};
// community-modules/core/src/edit/cellEditors/numberCellEditor.ts
var $7b57b57eaf5a9648$var$NumberCellEditorInput = class {
    getTemplate() {
        return /* html */ `<ag-input-number-field class="ag-cell-editor" data-ref="eInput"></ag-input-number-field>`;
    }
    getAgComponents() {
        return [
            $7b57b57eaf5a9648$export$c18153c9c909b7d7
        ];
    }
    init(eInput, params) {
        this.eInput = eInput;
        this.params = params;
        if (params.max != null) eInput.setMax(params.max);
        if (params.min != null) eInput.setMin(params.min);
        if (params.precision != null) eInput.setPrecision(params.precision);
        if (params.step != null) eInput.setStep(params.step);
        const inputEl = eInput.getInputElement();
        if (params.preventStepping) eInput.addManagedElementListeners(inputEl, {
            keydown: this.preventStepping
        });
        else if (params.showStepperButtons) inputEl.classList.add("ag-number-field-input-stepper");
    }
    preventStepping(e) {
        if (e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP || e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN) e.preventDefault();
    }
    getValue() {
        const value = this.eInput.getValue();
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(value) && !$7b57b57eaf5a9648$export$25d27f17d3af40f7(this.params.value)) return this.params.value;
        let parsedValue = this.params.parseValue(value);
        if (parsedValue == null) return parsedValue;
        if (typeof parsedValue === "string") {
            if (parsedValue === "") return null;
            parsedValue = Number(parsedValue);
        }
        return isNaN(parsedValue) ? null : parsedValue;
    }
    getStartValue() {
        return this.params.value;
    }
};
var $7b57b57eaf5a9648$export$b0b5b22313882d92 = class extends $7b57b57eaf5a9648$var$SimpleCellEditor {
    constructor(){
        super(new $7b57b57eaf5a9648$var$NumberCellEditorInput());
    }
};
// community-modules/core/src/widgets/agInputDateField.ts
var $7b57b57eaf5a9648$export$9e01ec8ba43de612 = class extends $7b57b57eaf5a9648$export$8c027679838afd47 {
    constructor(config){
        super(config, "ag-date-field", "date");
    }
    postConstruct() {
        super.postConstruct();
        const usingSafari = $7b57b57eaf5a9648$var$_isBrowserSafari();
        this.addManagedListeners(this.eInput, {
            wheel: this.onWheel.bind(this),
            mousedown: ()=>{
                if (this.isDisabled() || usingSafari) return;
                this.eInput.focus();
            }
        });
        this.eInput.step = "any";
    }
    onWheel(e) {
        if (this.gos.getActiveDomElement() === this.eInput) e.preventDefault();
    }
    setMin(minDate) {
        const min = minDate instanceof Date ? $7b57b57eaf5a9648$export$3d7fedfb21962874(minDate ?? null, false) ?? void 0 : minDate;
        if (this.min === min) return this;
        this.min = min;
        $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "min", min);
        return this;
    }
    setMax(maxDate) {
        const max = maxDate instanceof Date ? $7b57b57eaf5a9648$export$3d7fedfb21962874(maxDate ?? null, false) ?? void 0 : maxDate;
        if (this.max === max) return this;
        this.max = max;
        $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "max", max);
        return this;
    }
    setStep(step) {
        if (this.step === step) return this;
        this.step = step;
        $7b57b57eaf5a9648$var$_addOrRemoveAttribute(this.eInput, "step", step);
        return this;
    }
    getDate() {
        if (!this.eInput.validity.valid) return void 0;
        return $7b57b57eaf5a9648$export$26ded2d88c01b527(this.getValue()) ?? void 0;
    }
    setDate(date, silent) {
        this.setValue($7b57b57eaf5a9648$export$3d7fedfb21962874(date ?? null, false), silent);
    }
};
var $7b57b57eaf5a9648$var$AgInputDateFieldSelector = {
    selector: "AG-INPUT-DATE-FIELD",
    component: $7b57b57eaf5a9648$export$9e01ec8ba43de612
};
// community-modules/core/src/edit/cellEditors/dateCellEditor.ts
var $7b57b57eaf5a9648$var$DateCellEditorInput = class {
    getTemplate() {
        return /* html */ `<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>`;
    }
    getAgComponents() {
        return [
            $7b57b57eaf5a9648$var$AgInputDateFieldSelector
        ];
    }
    init(eInput, params) {
        this.eInput = eInput;
        this.params = params;
        if (params.min != null) eInput.setMin(params.min);
        if (params.max != null) eInput.setMax(params.max);
        if (params.step != null) eInput.setStep(params.step);
    }
    getValue() {
        const value = this.eInput.getDate();
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(value) && !$7b57b57eaf5a9648$export$25d27f17d3af40f7(this.params.value)) return this.params.value;
        return value ?? null;
    }
    getStartValue() {
        const { value: value  } = this.params;
        if (!(value instanceof Date)) return void 0;
        return $7b57b57eaf5a9648$export$3d7fedfb21962874(value, false);
    }
};
var $7b57b57eaf5a9648$export$e458dd9c8f847882 = class extends $7b57b57eaf5a9648$var$SimpleCellEditor {
    constructor(){
        super(new $7b57b57eaf5a9648$var$DateCellEditorInput());
    }
};
// community-modules/core/src/edit/cellEditors/dateStringCellEditor.ts
var $7b57b57eaf5a9648$var$DateStringCellEditorInput = class {
    constructor(getDataTypeService){
        this.getDataTypeService = getDataTypeService;
    }
    getTemplate() {
        return /* html */ `<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>`;
    }
    getAgComponents() {
        return [
            $7b57b57eaf5a9648$var$AgInputDateFieldSelector
        ];
    }
    init(eInput, params) {
        this.eInput = eInput;
        this.params = params;
        if (params.min != null) eInput.setMin(params.min);
        if (params.max != null) eInput.setMax(params.max);
        if (params.step != null) eInput.setStep(params.step);
    }
    getValue() {
        const value = this.formatDate(this.eInput.getDate());
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(value) && !$7b57b57eaf5a9648$export$25d27f17d3af40f7(this.params.value)) return this.params.value;
        return this.params.parseValue(value ?? "");
    }
    getStartValue() {
        return $7b57b57eaf5a9648$export$3d7fedfb21962874(this.parseDate(this.params.value ?? void 0) ?? null, false);
    }
    parseDate(value) {
        const dataTypeService = this.getDataTypeService();
        return dataTypeService ? dataTypeService.getDateParserFunction(this.params.column)(value) : $7b57b57eaf5a9648$export$26ded2d88c01b527(value) ?? void 0;
    }
    formatDate(value) {
        const dataTypeService = this.getDataTypeService();
        return dataTypeService ? dataTypeService.getDateFormatterFunction(this.params.column)(value) : $7b57b57eaf5a9648$export$3d7fedfb21962874(value ?? null, false) ?? void 0;
    }
};
var $7b57b57eaf5a9648$export$54060a84075c35d1 = class extends $7b57b57eaf5a9648$var$SimpleCellEditor {
    wireBeans(beans) {
        this.dataTypeService = beans.dataTypeService;
    }
    constructor(){
        super(new $7b57b57eaf5a9648$var$DateStringCellEditorInput(()=>this.dataTypeService));
    }
};
// community-modules/core/src/edit/cellEditors/checkboxCellEditor.ts
var $7b57b57eaf5a9648$export$64a4d9c7e8236d55 = class extends $7b57b57eaf5a9648$export$9fac2d040f3ed438 {
    constructor(){
        super(/* html */ `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`, [
            $7b57b57eaf5a9648$export$2e2c317d2e31f2ca
        ]);
        this.eCheckbox = $7b57b57eaf5a9648$export$6c811454646ed8be;
    }
    init(params) {
        this.params = params;
        const isSelected = params.value ?? void 0;
        this.eCheckbox.setValue(isSelected);
        const inputEl = this.eCheckbox.getInputElement();
        inputEl.setAttribute("tabindex", "-1");
        this.setAriaLabel(isSelected);
        this.addManagedListeners(this.eCheckbox, {
            fieldValueChanged: (event)=>this.setAriaLabel(event.selected)
        });
    }
    getValue() {
        return this.eCheckbox.getValue();
    }
    focusIn() {
        this.eCheckbox.getFocusableElement().focus();
    }
    afterGuiAttached() {
        if (this.params.cellStartedEdit) this.focusIn();
    }
    isPopup() {
        return false;
    }
    setAriaLabel(isSelected) {
        const translate = this.localeService.getLocaleTextFunc();
        const stateName = $7b57b57eaf5a9648$var$_getAriaCheckboxStateName(translate, isSelected);
        const ariaLabel = translate("ariaToggleCellValue", "Press SPACE to toggle cell value");
        this.eCheckbox.setInputAriaLabel(`${ariaLabel} (${stateName})`);
    }
};
// community-modules/core/src/undoRedo/undoRedoStack.ts
var $7b57b57eaf5a9648$var$UndoRedoAction = class {
    constructor(cellValueChanges){
        this.cellValueChanges = cellValueChanges;
    }
};
var $7b57b57eaf5a9648$var$RangeUndoRedoAction = class extends $7b57b57eaf5a9648$var$UndoRedoAction {
    constructor(cellValueChanges, initialRange, finalRange, ranges){
        super(cellValueChanges);
        this.initialRange = initialRange;
        this.finalRange = finalRange;
        this.ranges = ranges;
    }
};
var $7b57b57eaf5a9648$var$DEFAULT_STACK_SIZE = 10;
var $7b57b57eaf5a9648$var$UndoRedoStack = class {
    constructor(maxStackSize){
        this.actionStack = [];
        this.maxStackSize = maxStackSize ? maxStackSize : $7b57b57eaf5a9648$var$DEFAULT_STACK_SIZE;
        this.actionStack = new Array(this.maxStackSize);
    }
    pop() {
        return this.actionStack.pop();
    }
    push(item) {
        const shouldAddActions = item.cellValueChanges && item.cellValueChanges.length > 0;
        if (!shouldAddActions) return;
        if (this.actionStack.length === this.maxStackSize) this.actionStack.shift();
        this.actionStack.push(item);
    }
    clear() {
        this.actionStack = [];
    }
    getCurrentStackSize() {
        return this.actionStack.length;
    }
};
// community-modules/core/src/undoRedo/undoRedoService.ts
var $7b57b57eaf5a9648$var$UndoRedoService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "undoRedoService";
        this.cellValueChanges = [];
        this.activeCellEdit = null;
        this.activeRowEdit = null;
        this.isPasting = false;
        this.isRangeInAction = false;
        this.onCellValueChanged = (event)=>{
            const eventCell = {
                column: event.column,
                rowIndex: event.rowIndex,
                rowPinned: event.rowPinned
            };
            const isCellEditing = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, eventCell);
            const isRowEditing = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, eventCell);
            const shouldCaptureAction = isCellEditing || isRowEditing || this.isPasting || this.isRangeInAction;
            if (!shouldCaptureAction) return;
            const { rowPinned: rowPinned , rowIndex: rowIndex , column: column , oldValue: oldValue , value: value  } = event;
            const cellValueChange = {
                rowPinned: rowPinned,
                rowIndex: rowIndex,
                columnId: column.getColId(),
                newValue: value,
                oldValue: oldValue
            };
            this.cellValueChanges.push(cellValueChange);
        };
        this.clearStacks = ()=>{
            this.undoStack.clear();
            this.redoStack.clear();
        };
    }
    wireBeans(beans) {
        this.focusService = beans.focusService;
        this.ctrlsService = beans.ctrlsService;
        this.cellPositionUtils = beans.cellPositionUtils;
        this.rowPositionUtils = beans.rowPositionUtils;
        this.columnModel = beans.columnModel;
        this.rangeService = beans.rangeService;
    }
    postConstruct() {
        if (!this.gos.get("undoRedoCellEditing")) return;
        const undoRedoLimit = this.gos.get("undoRedoCellEditingLimit");
        if (undoRedoLimit <= 0) return;
        this.undoStack = new $7b57b57eaf5a9648$var$UndoRedoStack(undoRedoLimit);
        this.redoStack = new $7b57b57eaf5a9648$var$UndoRedoStack(undoRedoLimit);
        this.addListeners();
        const listener = this.clearStacks.bind(this);
        this.addManagedEventListeners({
            cellValueChanged: this.onCellValueChanged.bind(this),
            // undo / redo is restricted to actual editing so we clear the stacks when other operations are
            // performed that change the order of the row / cols.
            modelUpdated: (e)=>{
                if (!e.keepUndoRedoStack) this.clearStacks();
            },
            columnPivotModeChanged: listener,
            newColumnsLoaded: listener,
            columnGroupOpened: listener,
            columnRowGroupChanged: listener,
            columnMoved: listener,
            columnPinned: listener,
            columnVisible: listener,
            rowDragEnd: listener
        });
        this.ctrlsService.whenReady((p)=>{
            this.gridBodyCtrl = p.gridBodyCtrl;
        });
    }
    getCurrentUndoStackSize() {
        return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
    }
    getCurrentRedoStackSize() {
        return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
    }
    undo(source) {
        const startEvent = {
            type: "undoStarted",
            source: source
        };
        this.eventService.dispatchEvent(startEvent);
        const operationPerformed = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo");
        const endEvent = {
            type: "undoEnded",
            source: source,
            operationPerformed: operationPerformed
        };
        this.eventService.dispatchEvent(endEvent);
    }
    redo(source) {
        const startEvent = {
            type: "redoStarted",
            source: source
        };
        this.eventService.dispatchEvent(startEvent);
        const operationPerformed = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo");
        const endEvent = {
            type: "redoEnded",
            source: source,
            operationPerformed: operationPerformed
        };
        this.eventService.dispatchEvent(endEvent);
    }
    undoRedo(undoRedoStack, opposingUndoRedoStack, rangeProperty, cellValueChangeProperty, source) {
        if (!undoRedoStack) return false;
        const undoRedoAction = undoRedoStack.pop();
        if (!undoRedoAction || !undoRedoAction.cellValueChanges) return false;
        this.processAction(undoRedoAction, (cellValueChange)=>cellValueChange[cellValueChangeProperty], source);
        if (undoRedoAction instanceof $7b57b57eaf5a9648$var$RangeUndoRedoAction) this.processRange(this.rangeService, undoRedoAction.ranges || [
            undoRedoAction[rangeProperty]
        ]);
        else this.processCell(undoRedoAction.cellValueChanges);
        opposingUndoRedoStack.push(undoRedoAction);
        return true;
    }
    processAction(action, valueExtractor, source) {
        action.cellValueChanges.forEach((cellValueChange)=>{
            const { rowIndex: rowIndex , rowPinned: rowPinned , columnId: columnId  } = cellValueChange;
            const rowPosition = {
                rowIndex: rowIndex,
                rowPinned: rowPinned
            };
            const currentRow = this.rowPositionUtils.getRowNode(rowPosition);
            if (!currentRow.displayed) return;
            currentRow.setDataValue(columnId, valueExtractor(cellValueChange), source);
        });
    }
    processRange(rangeService, ranges) {
        let lastFocusedCell;
        rangeService.removeAllCellRanges(true);
        ranges.forEach((range, idx)=>{
            if (!range) return;
            const startRow = range.startRow;
            const endRow = range.endRow;
            if (idx === ranges.length - 1) {
                lastFocusedCell = {
                    rowPinned: startRow.rowPinned,
                    rowIndex: startRow.rowIndex,
                    columnId: range.startColumn.getColId()
                };
                this.setLastFocusedCell(lastFocusedCell);
            }
            const cellRangeParams = {
                rowStartIndex: startRow.rowIndex,
                rowStartPinned: startRow.rowPinned,
                rowEndIndex: endRow.rowIndex,
                rowEndPinned: endRow.rowPinned,
                columnStart: range.startColumn,
                columns: range.columns
            };
            rangeService.addCellRange(cellRangeParams);
        });
    }
    processCell(cellValueChanges) {
        const cellValueChange = cellValueChanges[0];
        const { rowIndex: rowIndex , rowPinned: rowPinned  } = cellValueChange;
        const rowPosition = {
            rowIndex: rowIndex,
            rowPinned: rowPinned
        };
        const row = this.rowPositionUtils.getRowNode(rowPosition);
        const lastFocusedCell = {
            rowPinned: cellValueChange.rowPinned,
            rowIndex: row.rowIndex,
            columnId: cellValueChange.columnId
        };
        this.setLastFocusedCell(lastFocusedCell, this.rangeService);
    }
    setLastFocusedCell(lastFocusedCell, rangeService) {
        const { rowIndex: rowIndex , columnId: columnId , rowPinned: rowPinned  } = lastFocusedCell;
        const scrollFeature = this.gridBodyCtrl.getScrollFeature();
        const column = this.columnModel.getCol(columnId);
        if (!column) return;
        scrollFeature.ensureIndexVisible(rowIndex);
        scrollFeature.ensureColumnVisible(column);
        const cellPosition = {
            rowIndex: rowIndex,
            column: column,
            rowPinned: rowPinned
        };
        this.focusService.setFocusedCell({
            ...cellPosition,
            forceBrowserFocus: true
        });
        rangeService?.setRangeToCell(cellPosition);
    }
    addListeners() {
        this.addManagedEventListeners({
            rowEditingStarted: (e)=>{
                this.activeRowEdit = {
                    rowIndex: e.rowIndex,
                    rowPinned: e.rowPinned
                };
            },
            rowEditingStopped: ()=>{
                const action = new $7b57b57eaf5a9648$var$UndoRedoAction(this.cellValueChanges);
                this.pushActionsToUndoStack(action);
                this.activeRowEdit = null;
            },
            cellEditingStarted: (e)=>{
                this.activeCellEdit = {
                    column: e.column,
                    rowIndex: e.rowIndex,
                    rowPinned: e.rowPinned
                };
            },
            cellEditingStopped: (e)=>{
                this.activeCellEdit = null;
                const shouldPushAction = e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction;
                if (shouldPushAction) {
                    const action = new $7b57b57eaf5a9648$var$UndoRedoAction(this.cellValueChanges);
                    this.pushActionsToUndoStack(action);
                }
            },
            pasteStart: ()=>{
                this.isPasting = true;
            },
            pasteEnd: ()=>{
                const action = new $7b57b57eaf5a9648$var$UndoRedoAction(this.cellValueChanges);
                this.pushActionsToUndoStack(action);
                this.isPasting = false;
            },
            fillStart: ()=>{
                this.isRangeInAction = true;
            },
            fillEnd: (event)=>{
                const action = new $7b57b57eaf5a9648$var$RangeUndoRedoAction(this.cellValueChanges, event.initialRange, event.finalRange);
                this.pushActionsToUndoStack(action);
                this.isRangeInAction = false;
            },
            keyShortcutChangedCellStart: ()=>{
                this.isRangeInAction = true;
            },
            keyShortcutChangedCellEnd: ()=>{
                let action;
                if (this.rangeService && this.gos.get("enableRangeSelection")) action = new $7b57b57eaf5a9648$var$RangeUndoRedoAction(this.cellValueChanges, void 0, void 0, [
                    ...this.rangeService.getCellRanges()
                ]);
                else action = new $7b57b57eaf5a9648$var$UndoRedoAction(this.cellValueChanges);
                this.pushActionsToUndoStack(action);
                this.isRangeInAction = false;
            }
        });
    }
    pushActionsToUndoStack(action) {
        this.undoStack.push(action);
        this.cellValueChanges = [];
        this.redoStack.clear();
    }
};
// community-modules/core/src/api/scrollApi.ts
function $7b57b57eaf5a9648$var$getVerticalPixelRange(beans) {
    return beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
}
function $7b57b57eaf5a9648$var$getHorizontalPixelRange(beans) {
    return beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getHScrollPosition();
}
function $7b57b57eaf5a9648$var$ensureColumnVisible(beans, key, position = "auto") {
    beans.frameworkOverrides.wrapIncoming(()=>beans.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(key, position), "ensureVisible");
}
function $7b57b57eaf5a9648$var$ensureIndexVisible(beans, index, position) {
    beans.frameworkOverrides.wrapIncoming(()=>beans.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureIndexVisible(index, position), "ensureVisible");
}
function $7b57b57eaf5a9648$var$ensureNodeVisible(beans, nodeSelector, position = null) {
    beans.frameworkOverrides.wrapIncoming(()=>beans.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureNodeVisible(nodeSelector, position), "ensureVisible");
}
// community-modules/core/src/edit/editApi.ts
function $7b57b57eaf5a9648$var$undoCellEditing(beans) {
    beans.undoRedoService?.undo("api");
}
function $7b57b57eaf5a9648$var$redoCellEditing(beans) {
    beans.undoRedoService?.redo("api");
}
function $7b57b57eaf5a9648$var$getCellEditorInstances(beans, params = {}) {
    const res = beans.rowRenderer.getCellEditorInstances(params);
    const unwrapped = res.map($7b57b57eaf5a9648$export$213d4c63c3df47e4);
    return unwrapped;
}
function $7b57b57eaf5a9648$var$getEditingCells(beans) {
    return beans.rowRenderer.getEditingCells();
}
function $7b57b57eaf5a9648$var$stopEditing(beans, cancel = false) {
    beans.rowRenderer.stopEditing(cancel);
}
function $7b57b57eaf5a9648$var$startEditingCell(beans, params) {
    const column = beans.columnModel.getCol(params.colKey);
    if (!column) {
        $7b57b57eaf5a9648$export$2cf41453020eef66(`no column found for ${params.colKey}`);
        return;
    }
    const cellPosition = {
        rowIndex: params.rowIndex,
        rowPinned: params.rowPinned || null,
        column: column
    };
    const notPinned = params.rowPinned == null;
    if (notPinned) $7b57b57eaf5a9648$var$ensureIndexVisible(beans, params.rowIndex);
    $7b57b57eaf5a9648$var$ensureColumnVisible(beans, params.colKey);
    const cell = beans.navigationService.getCellByPosition(cellPosition);
    if (!cell) return;
    if (!beans.focusService.isCellFocused(cellPosition)) beans.focusService.setFocusedCell(cellPosition);
    cell.startRowOrCellEdit(params.key);
}
function $7b57b57eaf5a9648$var$getCurrentUndoSize(beans) {
    return beans.undoRedoService?.getCurrentUndoStackSize() ?? 0;
}
function $7b57b57eaf5a9648$var$getCurrentRedoSize(beans) {
    return beans.undoRedoService?.getCurrentRedoStackSize() ?? 0;
}
// community-modules/core/src/edit/editService.ts
var $7b57b57eaf5a9648$var$EditService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "editService";
    }
    wireBeans(beans) {
        this.navigationService = beans.navigationService;
        this.userComponentFactory = beans.userComponentFactory;
        this.valueService = beans.valueService;
    }
    startEditing(cellCtrl, key = null, cellStartedEdit = false, event = null) {
        const editorParams = this.createCellEditorParams(cellCtrl, key, cellStartedEdit);
        const colDef = cellCtrl.getColumn().getColDef();
        const compDetails = this.userComponentFactory.getCellEditorDetails(colDef, editorParams);
        const popup = compDetails?.popupFromSelector != null ? compDetails.popupFromSelector : !!colDef.cellEditorPopup;
        const position = compDetails?.popupPositionFromSelector != null ? compDetails.popupPositionFromSelector : colDef.cellEditorPopupPosition;
        cellCtrl.setEditing(true, compDetails);
        cellCtrl.getComp().setEditDetails(compDetails, popup, position, this.gos.get("reactiveCustomComponents"));
        const e = cellCtrl.createEvent(event, "cellEditingStarted");
        this.eventService.dispatchEvent(e);
    }
    stopEditing(cellCtrl, cancel) {
        const cellComp = cellCtrl.getComp();
        const { newValue: newValue , newValueExists: newValueExists  } = this.takeValueFromCellEditor(cancel, cellComp);
        const rowNode = cellCtrl.getRowNode();
        const column = cellCtrl.getColumn();
        const oldValue = rowNode.getValueFromValueService(column);
        let valueChanged = false;
        if (newValueExists) valueChanged = this.saveNewValue(cellCtrl, oldValue, newValue, rowNode, column);
        cellCtrl.setEditing(false, void 0);
        cellComp.setEditDetails();
        cellCtrl.updateAndFormatValue(false);
        cellCtrl.refreshCell({
            forceRefresh: true,
            suppressFlash: true
        });
        const event = {
            ...cellCtrl.createEvent(null, "cellEditingStopped"),
            oldValue: oldValue,
            newValue: newValue,
            valueChanged: valueChanged
        };
        this.eventService.dispatchEvent(event);
        return valueChanged;
    }
    handleColDefChanged(cellCtrl) {
        const cellEditor = cellCtrl.getCellEditor();
        if (cellEditor?.refresh) {
            const { eventKey: eventKey , cellStartedEdit: cellStartedEdit  } = cellCtrl.getEditCompDetails().params;
            const editorParams = this.createCellEditorParams(cellCtrl, eventKey, cellStartedEdit);
            const colDef = cellCtrl.getColumn().getColDef();
            const compDetails = this.userComponentFactory.getCellEditorDetails(colDef, editorParams);
            cellEditor.refresh(compDetails.params);
        }
    }
    setFocusOutOnEditor(cellCtrl) {
        const cellEditor = cellCtrl.getComp().getCellEditor();
        if (cellEditor && cellEditor.focusOut) cellEditor.focusOut();
    }
    setFocusInOnEditor(cellCtrl) {
        const cellEditor = cellCtrl.getComp().getCellEditor();
        if (cellEditor && cellEditor.focusIn) cellEditor.focusIn();
        else cellCtrl.focusCell(true);
    }
    stopEditingAndFocus(cellCtrl, suppressNavigateAfterEdit = false, shiftKey = false) {
        cellCtrl.stopRowOrCellEdit();
        cellCtrl.focusCell(true);
        if (!suppressNavigateAfterEdit) this.navigateAfterEdit(shiftKey, cellCtrl.getCellPosition());
    }
    createPopupEditorWrapper(params) {
        return new $7b57b57eaf5a9648$export$fdd61bfa9577e25(params);
    }
    takeValueFromCellEditor(cancel, cellComp) {
        const noValueResult = {
            newValueExists: false
        };
        if (cancel) return noValueResult;
        const cellEditor = cellComp.getCellEditor();
        if (!cellEditor) return noValueResult;
        const userWantsToCancel = cellEditor.isCancelAfterEnd && cellEditor.isCancelAfterEnd();
        if (userWantsToCancel) return noValueResult;
        const newValue = cellEditor.getValue();
        return {
            newValue: newValue,
            newValueExists: true
        };
    }
    /**
   * @returns `True` if the value changes, otherwise `False`.
   */ saveNewValue(cellCtrl, oldValue, newValue, rowNode, column) {
        if (newValue === oldValue) return false;
        cellCtrl.setSuppressRefreshCell(true);
        const valueChanged = rowNode.setDataValue(column, newValue, "edit");
        cellCtrl.setSuppressRefreshCell(false);
        return valueChanged;
    }
    createCellEditorParams(cellCtrl, key, cellStartedEdit) {
        const column = cellCtrl.getColumn();
        const rowNode = cellCtrl.getRowNode();
        return this.gos.addGridCommonParams({
            value: rowNode.getValueFromValueService(column),
            eventKey: key,
            column: column,
            colDef: column.getColDef(),
            rowIndex: cellCtrl.getCellPosition().rowIndex,
            node: rowNode,
            data: rowNode.data,
            cellStartedEdit: cellStartedEdit,
            onKeyDown: cellCtrl.onKeyDown.bind(cellCtrl),
            stopEditing: cellCtrl.stopEditingAndFocus.bind(cellCtrl),
            eGridCell: cellCtrl.getGui(),
            parseValue: (newValue)=>this.valueService.parseValue(column, rowNode, newValue, cellCtrl.getValue()),
            formatValue: cellCtrl.formatValue.bind(cellCtrl)
        });
    }
    navigateAfterEdit(shiftKey, cellPosition) {
        const enterNavigatesVerticallyAfterEdit = this.gos.get("enterNavigatesVerticallyAfterEdit");
        if (enterNavigatesVerticallyAfterEdit) {
            const key = shiftKey ? $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP : $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN;
            this.navigationService.navigateToNextCell(null, key, cellPosition, false);
        }
    }
};
// community-modules/core/src/edit/rowEditService.ts
var $7b57b57eaf5a9648$var$RowEditService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowEditService";
    }
    startEditing(rowCtrl, key = null, sourceRenderedCell = null, event = null) {
        const atLeastOneEditing = rowCtrl.getAllCellCtrls().reduce((prev, cellCtrl)=>{
            const cellStartedEdit = cellCtrl === sourceRenderedCell;
            if (cellStartedEdit) cellCtrl.startEditing(key, cellStartedEdit, event);
            else cellCtrl.startEditing(null, cellStartedEdit, event);
            if (prev) return true;
            return cellCtrl.isEditing();
        }, false);
        if (atLeastOneEditing) this.setEditing(rowCtrl, true);
    }
    stopEditing(rowCtrl, cancel = false) {
        const cellControls = rowCtrl.getAllCellCtrls();
        const isRowEdit = rowCtrl.isEditing();
        rowCtrl.setStoppingRowEdit(true);
        let fireRowEditEvent = false;
        for (const ctrl of cellControls){
            const valueChanged = ctrl.stopEditing(cancel);
            if (isRowEdit && !cancel && !fireRowEditEvent && valueChanged) fireRowEditEvent = true;
        }
        if (fireRowEditEvent) {
            const event = rowCtrl.createRowEvent("rowValueChanged");
            this.eventService.dispatchEvent(event);
        }
        if (isRowEdit) this.setEditing(rowCtrl, false);
        rowCtrl.setStoppingRowEdit(false);
    }
    setEditing(rowCtrl, value) {
        rowCtrl.setEditingRow(value);
        rowCtrl.forEachGui(void 0, (gui)=>gui.rowComp.addOrRemoveCssClass("ag-row-editing", value));
        const event = value ? rowCtrl.createRowEvent("rowEditingStarted") : rowCtrl.createRowEvent("rowEditingStopped");
        this.eventService.dispatchEvent(event);
    }
};
// community-modules/core/src/edit/editModule.ts
var $7b57b57eaf5a9648$export$12c61a50add34259 = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/edit-core",
    beans: [
        $7b57b57eaf5a9648$var$EditService
    ]
};
var $7b57b57eaf5a9648$var$EditApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/edit-api",
    apiFunctions: {
        undoCellEditing: $7b57b57eaf5a9648$var$undoCellEditing,
        redoCellEditing: $7b57b57eaf5a9648$var$redoCellEditing,
        getCellEditorInstances: $7b57b57eaf5a9648$var$getCellEditorInstances,
        getEditingCells: $7b57b57eaf5a9648$var$getEditingCells,
        stopEditing: $7b57b57eaf5a9648$var$stopEditing,
        startEditingCell: $7b57b57eaf5a9648$var$startEditingCell,
        getCurrentUndoSize: $7b57b57eaf5a9648$var$getCurrentUndoSize,
        getCurrentRedoSize: $7b57b57eaf5a9648$var$getCurrentRedoSize
    },
    dependantModules: [
        $7b57b57eaf5a9648$export$12c61a50add34259
    ]
};
var $7b57b57eaf5a9648$var$UndoRedoEditModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/undo-redo-edit",
    beans: [
        $7b57b57eaf5a9648$var$UndoRedoService
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$12c61a50add34259
    ]
};
var $7b57b57eaf5a9648$var$FullRowEditModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/full-row-edit",
    beans: [
        $7b57b57eaf5a9648$var$RowEditService
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$12c61a50add34259
    ]
};
var $7b57b57eaf5a9648$var$DefaultEditorModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/default-editor",
    userComponents: [
        {
            name: "agCellEditor",
            classImp: $7b57b57eaf5a9648$export$6e94bf0a822a6a81
        }
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$12c61a50add34259
    ]
};
var $7b57b57eaf5a9648$var$DataTypeEditorsModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/data-type-editors",
    userComponents: [
        {
            name: "agTextCellEditor",
            classImp: $7b57b57eaf5a9648$export$6e94bf0a822a6a81
        },
        {
            name: "agNumberCellEditor",
            classImp: $7b57b57eaf5a9648$export$b0b5b22313882d92
        },
        {
            name: "agDateCellEditor",
            classImp: $7b57b57eaf5a9648$export$e458dd9c8f847882
        },
        {
            name: "agDateStringCellEditor",
            classImp: $7b57b57eaf5a9648$export$54060a84075c35d1
        },
        {
            name: "agCheckboxCellEditor",
            classImp: $7b57b57eaf5a9648$export$64a4d9c7e8236d55
        }
    ],
    dependantModules: [
        $7b57b57eaf5a9648$var$DefaultEditorModule
    ]
};
var $7b57b57eaf5a9648$var$SelectEditorModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/select-editor",
    userComponents: [
        {
            name: "agSelectCellEditor",
            classImp: $7b57b57eaf5a9648$export$638f87cb94a2e5dc
        }
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$12c61a50add34259
    ]
};
var $7b57b57eaf5a9648$var$LargeTextEditorModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/large-text-editor",
    userComponents: [
        {
            name: "agLargeTextCellEditor",
            classImp: $7b57b57eaf5a9648$export$98890d6e078b4910
        }
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$12c61a50add34259
    ]
};
var $7b57b57eaf5a9648$var$AllCommunityEditorsModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/all-editors",
    dependantModules: [
        $7b57b57eaf5a9648$var$DefaultEditorModule,
        $7b57b57eaf5a9648$var$DataTypeEditorsModule,
        $7b57b57eaf5a9648$var$SelectEditorModule,
        $7b57b57eaf5a9648$var$LargeTextEditorModule
    ]
};
var $7b57b57eaf5a9648$var$EditModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/editing",
    dependantModules: [
        $7b57b57eaf5a9648$export$12c61a50add34259,
        $7b57b57eaf5a9648$var$UndoRedoEditModule,
        $7b57b57eaf5a9648$var$FullRowEditModule,
        $7b57b57eaf5a9648$var$AllCommunityEditorsModule,
        $7b57b57eaf5a9648$var$EditApiModule
    ]
};
// community-modules/core/src/rendering/autoWidthCalculator.ts
var $7b57b57eaf5a9648$export$cc129c761c9af6b5 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "autoWidthCalculator";
    }
    wireBeans(beans) {
        this.rowRenderer = beans.rowRenderer;
        this.ctrlsService = beans.ctrlsService;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            this.centerRowContainerCtrl = p.center;
        });
    }
    // this is the trick: we create a dummy container and clone all the cells
    // into the dummy, then check the dummy's width. then destroy the dummy
    // as we don't need it any more.
    // drawback: only the cells visible on the screen are considered
    getPreferredWidthForColumn(column, skipHeader) {
        const eHeaderCell = this.getHeaderCellForColumn(column);
        if (!eHeaderCell) return -1;
        const elements = this.rowRenderer.getAllCellsForColumn(column);
        if (!skipHeader) elements.push(eHeaderCell);
        return this.addElementsToContainerAndGetWidth(elements);
    }
    getPreferredWidthForColumnGroup(columnGroup) {
        const eHeaderCell = this.getHeaderCellForColumn(columnGroup);
        if (!eHeaderCell) return -1;
        return this.addElementsToContainerAndGetWidth([
            eHeaderCell
        ]);
    }
    addElementsToContainerAndGetWidth(elements) {
        const eDummyContainer = document.createElement("form");
        eDummyContainer.style.position = "fixed";
        const eBodyContainer = this.centerRowContainerCtrl.getContainerElement();
        elements.forEach((el)=>this.cloneItemIntoDummy(el, eDummyContainer));
        eBodyContainer.appendChild(eDummyContainer);
        const dummyContainerWidth = eDummyContainer.offsetWidth;
        eBodyContainer.removeChild(eDummyContainer);
        const autoSizePadding = this.getAutoSizePadding();
        return dummyContainerWidth + autoSizePadding;
    }
    getAutoSizePadding() {
        return this.gos.get("autoSizePadding");
    }
    getHeaderCellForColumn(column) {
        let element = null;
        this.ctrlsService.getHeaderRowContainerCtrls().forEach((container)=>{
            const res = container.getHtmlElementForColumnHeader(column);
            if (res != null) element = res;
        });
        return element;
    }
    cloneItemIntoDummy(eCell, eDummyContainer) {
        const eCellClone = eCell.cloneNode(true);
        eCellClone.style.width = "";
        eCellClone.style.position = "static";
        eCellClone.style.left = "";
        const eCloneParent = document.createElement("div");
        const eCloneParentClassList = eCloneParent.classList;
        const isHeader = [
            "ag-header-cell",
            "ag-header-group-cell"
        ].some((cls)=>eCellClone.classList.contains(cls));
        if (isHeader) {
            eCloneParentClassList.add("ag-header", "ag-header-row");
            eCloneParent.style.position = "static";
        } else eCloneParentClassList.add("ag-row");
        let pointer = eCell.parentElement;
        while(pointer){
            const isRow = [
                "ag-header-row",
                "ag-row"
            ].some((cls)=>pointer.classList.contains(cls));
            if (isRow) {
                for(let i = 0; i < pointer.classList.length; i++){
                    const item = pointer.classList[i];
                    if (item != "ag-row-position-absolute") eCloneParentClassList.add(item);
                }
                break;
            }
            pointer = pointer.parentElement;
        }
        eCloneParent.appendChild(eCellClone);
        eDummyContainer.appendChild(eCloneParent);
    }
};
// community-modules/core/src/rendering/features/stickyRowFeature.ts
var $7b57b57eaf5a9648$var$StickyRowFeature = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(createRowCon, destroyRowCtrls){
        super();
        this.createRowCon = createRowCon;
        this.destroyRowCtrls = destroyRowCtrls;
        this.stickyTopRowCtrls = [];
        this.stickyBottomRowCtrls = [];
        this.topContainerHeight = 0;
        this.bottomContainerHeight = 0;
        // sticky rows pulls in extra rows from other pages which impacts row position
        this.extraTopHeight = 0;
        this.extraBottomHeight = 0;
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.rowRenderer = beans.rowRenderer;
        this.ctrlsService = beans.ctrlsService;
        this.pageBoundsService = beans.pageBoundsService;
    }
    postConstruct() {
        this.isClientSide = this.rowModel.getType() === "clientSide";
        this.ctrlsService.whenReady((params)=>{
            this.gridBodyCtrl = params.gridBodyCtrl;
        });
    }
    getStickyTopRowCtrls() {
        return this.stickyTopRowCtrls;
    }
    getStickyBottomRowCtrls() {
        return this.stickyBottomRowCtrls;
    }
    setOffsetTop(offset) {
        if (this.extraTopHeight === offset) return;
        this.extraTopHeight = offset;
        const event = {
            type: "stickyTopOffsetChanged",
            offset: offset
        };
        this.eventService.dispatchEvent(event);
    }
    setOffsetBottom(offset) {
        if (this.extraBottomHeight === offset) return;
        this.extraBottomHeight = offset;
    }
    resetOffsets() {
        this.setOffsetBottom(0);
        this.setOffsetTop(0);
    }
    getExtraTopHeight() {
        return this.extraTopHeight;
    }
    getExtraBottomHeight() {
        return this.extraBottomHeight;
    }
    /**
   * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
   */ getLastPixelOfGroup(row) {
        return this.isClientSide ? this.getClientSideLastPixelOfGroup(row) : this.getServerSideLastPixelOfGroup(row);
    }
    /**
   * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
   */ getFirstPixelOfGroup(row) {
        if (row.footer) return row.sibling.rowTop + row.sibling.rowHeight - 1;
        if (row.hasChildren()) return row.rowTop - 1;
        return 0;
    }
    getServerSideLastPixelOfGroup(row) {
        if (this.isClientSide) throw new Error("This func should only be called in server side row model.");
        if (row.isExpandable() || row.footer) {
            if (row.master) return row.detailNode.rowTop + row.detailNode.rowHeight;
            const noOrContiguousSiblings = !row.sibling || Math.abs(row.sibling.rowIndex - row.rowIndex) === 1;
            if (noOrContiguousSiblings) {
                let storeBounds = row.childStore?.getStoreBounds();
                if (row.footer) storeBounds = row.sibling.childStore?.getStoreBounds();
                return (storeBounds?.heightPx ?? 0) + (storeBounds?.topPx ?? 0);
            }
            if (row.footer) return row.rowTop + row.rowHeight;
            return row.sibling.rowTop + row.sibling.rowHeight;
        }
        return Number.MAX_SAFE_INTEGER;
    }
    getClientSideLastPixelOfGroup(row) {
        if (!this.isClientSide) throw new Error("This func should only be called in client side row model.");
        if (row.isExpandable() || row.footer) {
            const grandTotalAtTop = row.footer && row.rowIndex === 0;
            if (grandTotalAtTop) return Number.MAX_SAFE_INTEGER;
            const noOrContiguousSiblings = !row.sibling || Math.abs(row.sibling.rowIndex - row.rowIndex) === 1;
            if (noOrContiguousSiblings) {
                let lastAncestor = row.footer ? row.sibling : row;
                while(lastAncestor.isExpandable() && lastAncestor.expanded){
                    if (lastAncestor.master) lastAncestor = lastAncestor.detailNode;
                    else if (lastAncestor.childrenAfterSort) {
                        if (lastAncestor.childrenAfterSort.length === 0) break;
                        lastAncestor = $7b57b57eaf5a9648$export$236389741107357f(lastAncestor.childrenAfterSort);
                    }
                }
                return lastAncestor.rowTop + lastAncestor.rowHeight;
            }
            if (row.footer) return row.rowTop + row.rowHeight;
            return row.sibling.rowTop + row.sibling.rowHeight;
        }
        return Number.MAX_SAFE_INTEGER;
    }
    updateStickyRows(container) {
        const isTop = container === "top";
        let newStickyContainerHeight = 0;
        if (!this.canRowsBeSticky()) return this.refreshNodesAndContainerHeight(container, /* @__PURE__ */ new Set(), newStickyContainerHeight);
        const pixelAtContainerBoundary = isTop ? this.rowRenderer.getFirstVisibleVerticalPixel() - this.extraTopHeight : this.rowRenderer.getLastVisibleVerticalPixel() - this.extraTopHeight;
        const newStickyRows = /* @__PURE__ */ new Set();
        const addStickyRow = (stickyRow)=>{
            newStickyRows.add(stickyRow);
            if (isTop) {
                const lastChildBottom = this.getLastPixelOfGroup(stickyRow);
                const stickRowBottom = pixelAtContainerBoundary + newStickyContainerHeight + stickyRow.rowHeight;
                if (lastChildBottom < stickRowBottom) stickyRow.stickyRowTop = newStickyContainerHeight + (lastChildBottom - stickRowBottom);
                else stickyRow.stickyRowTop = newStickyContainerHeight;
            } else {
                const lastChildBottom = this.getFirstPixelOfGroup(stickyRow);
                const stickRowTop = pixelAtContainerBoundary - (newStickyContainerHeight + stickyRow.rowHeight);
                if (lastChildBottom > stickRowTop) stickyRow.stickyRowTop = newStickyContainerHeight - (lastChildBottom - stickRowTop);
                else stickyRow.stickyRowTop = newStickyContainerHeight;
            }
            newStickyContainerHeight = 0;
            newStickyRows.forEach((rowNode)=>{
                const thisRowLastPx = rowNode.stickyRowTop + rowNode.rowHeight;
                if (newStickyContainerHeight < thisRowLastPx) newStickyContainerHeight = thisRowLastPx;
            });
        };
        const suppressFootersSticky = this.areFooterRowsStickySuppressed();
        const suppressGroupsSticky = this.gos.get("suppressGroupRowsSticky");
        const isRowSticky = (row)=>{
            if (!row.displayed) return false;
            if (row.footer) {
                if (suppressFootersSticky === true) return false;
                if (suppressFootersSticky === "grand" && row.level === -1) return false;
                if (suppressFootersSticky === "group" && row.level > -1) return false;
                const alreadySticking = newStickyRows.has(row);
                return !alreadySticking;
            }
            if (row.isExpandable()) {
                if (suppressGroupsSticky === true) return false;
                const alreadySticking = newStickyRows.has(row);
                return !alreadySticking && row.expanded;
            }
            return false;
        };
        for(let i = 0; i < 100; i++){
            let firstPixelAfterStickyRows = pixelAtContainerBoundary + newStickyContainerHeight;
            if (!isTop) firstPixelAfterStickyRows = pixelAtContainerBoundary - newStickyContainerHeight;
            const firstIndex = this.rowModel.getRowIndexAtPixel(firstPixelAfterStickyRows);
            const firstRow = this.rowModel.getRow(firstIndex);
            if (firstRow == null) break;
            const ancestors = this.getStickyAncestors(firstRow);
            const firstMissingParent = ancestors.find((parent)=>(isTop ? parent.rowIndex < firstIndex : parent.rowIndex > firstIndex) && isRowSticky(parent));
            if (firstMissingParent) {
                addStickyRow(firstMissingParent);
                continue;
            }
            const isFirstRowOutsideViewport = isTop ? firstRow.rowTop < firstPixelAfterStickyRows : firstRow.rowTop + firstRow.rowHeight > firstPixelAfterStickyRows;
            if (isFirstRowOutsideViewport && isRowSticky(firstRow)) {
                addStickyRow(firstRow);
                continue;
            }
            break;
        }
        if (!isTop) newStickyRows.forEach((rowNode)=>{
            rowNode.stickyRowTop = newStickyContainerHeight - (rowNode.stickyRowTop + rowNode.rowHeight);
        });
        return this.refreshNodesAndContainerHeight(container, newStickyRows, newStickyContainerHeight);
    }
    areFooterRowsStickySuppressed() {
        const suppressFootersSticky = this.gos.get("suppressStickyTotalRow");
        if (suppressFootersSticky === true) return true;
        const suppressGroupRows = !!this.gos.get("groupIncludeFooter") || suppressFootersSticky === "group";
        const suppressGrandRows = !!this.gos.get("groupIncludeTotalFooter") || suppressFootersSticky === "grand";
        if (suppressGroupRows && suppressGrandRows) return true;
        if (suppressGrandRows) return "grand";
        if (suppressGroupRows) return "group";
        return false;
    }
    canRowsBeSticky() {
        const isStickyEnabled = this.gos.isGroupRowsSticky();
        const suppressFootersSticky = this.areFooterRowsStickySuppressed();
        const suppressGroupsSticky = this.gos.get("suppressGroupRowsSticky");
        return isStickyEnabled && (!suppressFootersSticky || !suppressGroupsSticky);
    }
    getStickyAncestors(rowNode) {
        const ancestors = [];
        let p = rowNode.footer ? rowNode.sibling : rowNode.parent;
        while(p){
            if (p.sibling) ancestors.push(p.sibling);
            ancestors.push(p);
            p = p.parent;
        }
        return ancestors.reverse();
    }
    checkStickyRows() {
        const hasTopUpdated = this.updateStickyRows("top");
        const hasBottomUpdated = this.updateStickyRows("bottom");
        return hasTopUpdated || hasBottomUpdated;
    }
    destroyStickyCtrls() {
        this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0);
        this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
    }
    refreshStickyNode(stickRowNode) {
        const allStickyNodes = /* @__PURE__ */ new Set();
        if (this.stickyTopRowCtrls.some((ctrl)=>ctrl.getRowNode() === stickRowNode)) {
            for(let i = 0; i < this.stickyTopRowCtrls.length; i++){
                const currentNode = this.stickyTopRowCtrls[i].getRowNode();
                if (currentNode !== stickRowNode) allStickyNodes.add(currentNode);
            }
            if (this.refreshNodesAndContainerHeight("top", allStickyNodes, this.topContainerHeight)) this.checkStickyRows();
            return;
        }
        for(let i = 0; i < this.stickyBottomRowCtrls.length; i++){
            const currentNode = this.stickyBottomRowCtrls[i].getRowNode();
            if (currentNode !== stickRowNode) allStickyNodes.add(currentNode);
        }
        if (this.refreshNodesAndContainerHeight("bottom", allStickyNodes, this.bottomContainerHeight)) this.checkStickyRows();
    }
    /**
   * Destroy old ctrls and create new ctrls where necessary.
   */ refreshNodesAndContainerHeight(container, newStickyNodes, height) {
        const isTop = container === "top";
        const previousCtrls = isTop ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls;
        const removedCtrlsMap = {};
        const remainingCtrls = [];
        for(let i = 0; i < previousCtrls.length; i++){
            const node = previousCtrls[i].getRowNode();
            const hasBeenRemoved = !newStickyNodes.has(node);
            if (hasBeenRemoved) {
                removedCtrlsMap[node.id] = previousCtrls[i];
                node.sticky = false;
                continue;
            }
            remainingCtrls.push(previousCtrls[i]);
        }
        const existingNodes = /* @__PURE__ */ new Set();
        for(let i = 0; i < remainingCtrls.length; i++)existingNodes.add(remainingCtrls[i].getRowNode());
        const newCtrls = [];
        newStickyNodes.forEach((node)=>{
            if (existingNodes.has(node)) return;
            node.sticky = true;
            newCtrls.push(this.createRowCon(node, false, false));
        });
        let hasSomethingChanged = !!newCtrls.length || remainingCtrls.length !== previousCtrls.length;
        if (isTop) {
            if (this.topContainerHeight !== height) {
                this.topContainerHeight = height;
                this.gridBodyCtrl.setStickyTopHeight(height);
                hasSomethingChanged = true;
            }
        } else if (this.bottomContainerHeight !== height) {
            this.bottomContainerHeight = height;
            this.gridBodyCtrl.setStickyBottomHeight(height);
            hasSomethingChanged = true;
        }
        this.destroyRowCtrls(removedCtrlsMap, false);
        const newCtrlsList = [
            ...remainingCtrls,
            ...newCtrls
        ];
        newCtrlsList.sort((a, b)=>b.getRowNode().rowIndex - a.getRowNode().rowIndex);
        if (!isTop) newCtrlsList.reverse();
        newCtrlsList.forEach((ctrl)=>ctrl.setRowTop(ctrl.getRowNode().stickyRowTop));
        let extraHeight = 0;
        if (isTop) {
            newStickyNodes.forEach((node)=>{
                if (node.rowIndex < this.pageBoundsService.getFirstRow()) extraHeight += node.rowHeight;
            });
            if (extraHeight > this.topContainerHeight) extraHeight = this.topContainerHeight;
            this.setOffsetTop(extraHeight);
        } else {
            newStickyNodes.forEach((node)=>{
                if (node.rowIndex > this.pageBoundsService.getLastRow()) extraHeight += node.rowHeight;
            });
            if (extraHeight > this.bottomContainerHeight) extraHeight = this.bottomContainerHeight;
            this.setOffsetBottom(extraHeight);
        }
        if (!hasSomethingChanged) return false;
        if (isTop) this.stickyTopRowCtrls = newCtrlsList;
        else this.stickyBottomRowCtrls = newCtrlsList;
        return true;
    }
    ensureRowHeightsValid() {
        let anyChange = false;
        const updateRowHeight = (ctrl)=>{
            const rowNode = ctrl.getRowNode();
            if (rowNode.rowHeightEstimated) {
                const rowHeight = this.gos.getRowHeightForNode(rowNode);
                rowNode.setRowHeight(rowHeight.height);
                anyChange = true;
            }
        };
        this.stickyTopRowCtrls.forEach(updateRowHeight);
        this.stickyBottomRowCtrls.forEach(updateRowHeight);
        return anyChange;
    }
};
// community-modules/core/src/rendering/rowRenderer.ts
var $7b57b57eaf5a9648$export$a41edaea3b7c09c8 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowRenderer";
        this.destroyFuncsForColumnListeners = [];
        // map of row ids to row objects. keeps track of which elements
        // are rendered for which rows in the dom.
        this.rowCtrlsByRowIndex = {};
        this.zombieRowCtrls = {};
        this.allRowCtrls = [];
        this.topRowCtrls = [];
        this.bottomRowCtrls = [];
        // we only allow one refresh at a time, otherwise the internal memory structure here
        // will get messed up. this can happen if the user has a cellRenderer, and inside the
        // renderer they call an API method that results in another pass of the refresh,
        // then it will be trying to draw rows in the middle of a refresh.
        this.refreshInProgress = false;
        this.dataFirstRenderedFired = false;
        this.setupRangeSelectionListeners = ()=>{
            const onRangeSelectionChanged = ()=>{
                this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.onRangeSelectionChanged());
            };
            const onColumnMovedPinnedVisible = ()=>{
                this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.updateRangeBordersIfRangeCount());
            };
            const addRangeSelectionListeners = ()=>{
                this.eventService.addEventListener("rangeSelectionChanged", onRangeSelectionChanged);
                this.eventService.addEventListener("columnMoved", onColumnMovedPinnedVisible);
                this.eventService.addEventListener("columnPinned", onColumnMovedPinnedVisible);
                this.eventService.addEventListener("columnVisible", onColumnMovedPinnedVisible);
            };
            const removeRangeSelectionListeners = ()=>{
                this.eventService.removeEventListener("rangeSelectionChanged", onRangeSelectionChanged);
                this.eventService.removeEventListener("columnMoved", onColumnMovedPinnedVisible);
                this.eventService.removeEventListener("columnPinned", onColumnMovedPinnedVisible);
                this.eventService.removeEventListener("columnVisible", onColumnMovedPinnedVisible);
            };
            this.addDestroyFunc(()=>removeRangeSelectionListeners());
            this.addManagedPropertyListener("enableRangeSelection", (params)=>{
                const isEnabled = params.currentValue;
                if (isEnabled) addRangeSelectionListeners();
                else removeRangeSelectionListeners();
            });
            const rangeSelectionEnabled = this.gos.get("enableRangeSelection");
            if (rangeSelectionEnabled) addRangeSelectionListeners();
        };
    }
    wireBeans(beans) {
        this.animationFrameService = beans.animationFrameService;
        this.paginationService = beans.paginationService;
        this.pageBoundsService = beans.pageBoundsService;
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.rowModel = beans.rowModel;
        this.focusService = beans.focusService;
        this.beans = beans;
        this.rowContainerHeightService = beans.rowContainerHeightService;
        this.ctrlsService = beans.ctrlsService;
        this.environment = beans.environment;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            this.gridBodyCtrl = p.gridBodyCtrl;
            this.initialise();
        });
    }
    initialise() {
        this.addManagedEventListeners({
            paginationChanged: this.onPageLoaded.bind(this),
            pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
            displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
            bodyScroll: this.onBodyScroll.bind(this),
            bodyHeightChanged: this.redraw.bind(this)
        });
        this.addManagedPropertyListeners([
            "domLayout",
            "embedFullWidthRows"
        ], ()=>this.onDomLayoutChanged());
        this.addManagedPropertyListeners([
            "suppressMaxRenderedRowRestriction",
            "rowBuffer"
        ], ()=>this.redraw());
        this.addManagedPropertyListeners([
            "suppressCellFocus",
            "getBusinessKeyForNode",
            "fullWidthCellRenderer",
            "fullWidthCellRendererParams",
            "rowStyle",
            "getRowStyle",
            "rowClass",
            "getRowClass",
            "rowClassRules",
            "suppressStickyTotalRow",
            "groupRowRenderer",
            "groupRowRendererParams",
            // maybe only needs to refresh FW rows...
            "loadingCellRenderer",
            "loadingCellRendererParams",
            "detailCellRenderer",
            "detailCellRendererParams",
            "enableRangeSelection",
            "enableCellTextSelection"
        ], ()=>this.redrawRows());
        if (this.gos.isGroupRowsSticky()) {
            const rowModelType = this.rowModel.getType();
            if (rowModelType === "clientSide" || rowModelType === "serverSide") this.stickyRowFeature = this.createManagedBean(new $7b57b57eaf5a9648$var$StickyRowFeature(this.createRowCon.bind(this), this.destroyRowCtrls.bind(this)));
        }
        this.registerCellEventListeners();
        this.initialiseCache();
        this.printLayout = this.gos.isDomLayout("print");
        this.embedFullWidthRows = this.printLayout || this.gos.get("embedFullWidthRows");
        this.redrawAfterModelUpdate();
    }
    initialiseCache() {
        if (this.gos.get("keepDetailRows")) {
            const countProp = this.getKeepDetailRowsCount();
            const count = countProp != null ? countProp : 3;
            this.cachedRowCtrls = new $7b57b57eaf5a9648$var$RowCtrlCache(count);
        }
    }
    getKeepDetailRowsCount() {
        return this.gos.get("keepDetailRowsCount");
    }
    getStickyTopRowCtrls() {
        if (!this.stickyRowFeature) return [];
        return this.stickyRowFeature.getStickyTopRowCtrls();
    }
    getStickyBottomRowCtrls() {
        if (!this.stickyRowFeature) return [];
        return this.stickyRowFeature.getStickyBottomRowCtrls();
    }
    updateAllRowCtrls() {
        const liveList = $7b57b57eaf5a9648$export$2f52ef471f042094(this.rowCtrlsByRowIndex);
        const zombieList = $7b57b57eaf5a9648$export$2f52ef471f042094(this.zombieRowCtrls);
        const cachedList = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
        if (zombieList.length > 0 || cachedList.length > 0) this.allRowCtrls = [
            ...liveList,
            ...zombieList,
            ...cachedList
        ];
        else this.allRowCtrls = liveList;
    }
    onCellFocusChanged(event) {
        this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.onCellFocused(event));
        this.getFullWidthRowCtrls().forEach((rowCtrl)=>rowCtrl.onFullWidthRowFocused(event));
    }
    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
    // registering and de-registering for events is a performance bottleneck. so we register here once and inform
    // all active cells.
    registerCellEventListeners() {
        this.addManagedEventListeners({
            cellFocused: (event)=>{
                this.onCellFocusChanged(event);
            },
            cellFocusCleared: ()=>this.onCellFocusChanged(),
            flashCells: (event)=>{
                this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.onFlashCells(event));
            },
            columnHoverChanged: ()=>{
                this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.onColumnHover());
            },
            displayedColumnsChanged: ()=>{
                this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.onDisplayedColumnsChanged());
            },
            displayedColumnsWidthChanged: ()=>{
                if (this.printLayout) this.getAllCellCtrls().forEach((cellCtrl)=>cellCtrl.onLeftChanged());
            }
        });
        this.setupRangeSelectionListeners();
        this.refreshListenersToColumnsForCellComps();
        this.addManagedEventListeners({
            gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
        });
        this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
    }
    // executes all functions in destroyFuncsForColumnListeners and then clears the list
    removeGridColumnListeners() {
        this.destroyFuncsForColumnListeners.forEach((func)=>func());
        this.destroyFuncsForColumnListeners.length = 0;
    }
    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
    // once instead.
    refreshListenersToColumnsForCellComps() {
        this.removeGridColumnListeners();
        const cols = this.columnModel.getCols();
        cols.forEach((col)=>{
            const forEachCellWithThisCol = (callback)=>{
                this.getAllCellCtrls().forEach((cellCtrl)=>{
                    if (cellCtrl.getColumn() === col) callback(cellCtrl);
                });
            };
            const leftChangedListener = ()=>{
                forEachCellWithThisCol((cellCtrl)=>cellCtrl.onLeftChanged());
            };
            const widthChangedListener = ()=>{
                forEachCellWithThisCol((cellCtrl)=>cellCtrl.onWidthChanged());
            };
            const firstRightPinnedChangedListener = ()=>{
                forEachCellWithThisCol((cellCtrl)=>cellCtrl.onFirstRightPinnedChanged());
            };
            const lastLeftPinnedChangedListener = ()=>{
                forEachCellWithThisCol((cellCtrl)=>cellCtrl.onLastLeftPinnedChanged());
            };
            const colDefChangedListener = ()=>{
                forEachCellWithThisCol((cellCtrl)=>cellCtrl.onColDefChanged());
            };
            col.addEventListener("leftChanged", leftChangedListener);
            col.addEventListener("widthChanged", widthChangedListener);
            col.addEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
            col.addEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
            col.addEventListener("colDefChanged", colDefChangedListener);
            this.destroyFuncsForColumnListeners.push(()=>{
                col.removeEventListener("leftChanged", leftChangedListener);
                col.removeEventListener("widthChanged", widthChangedListener);
                col.removeEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
                col.removeEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
                col.removeEventListener("colDefChanged", colDefChangedListener);
            });
        });
    }
    onDomLayoutChanged() {
        const printLayout = this.gos.isDomLayout("print");
        const embedFullWidthRows = printLayout || this.gos.get("embedFullWidthRows");
        const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;
        this.printLayout = printLayout;
        this.embedFullWidthRows = embedFullWidthRows;
        if (destroyRows) this.redrawAfterModelUpdate({
            domLayoutChanged: true
        });
    }
    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
    datasourceChanged() {
        this.firstRenderedRow = 0;
        this.lastRenderedRow = -1;
        const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
        this.removeRowCtrls(rowIndexesToRemove);
    }
    onPageLoaded(event) {
        const params = {
            recycleRows: event.keepRenderedRows,
            animate: event.animate,
            newData: event.newData,
            newPage: event.newPage,
            // because this is a model updated event (not pinned rows), we
            // can skip updating the pinned rows. this is needed so that if user
            // is doing transaction updates, the pinned rows are not getting constantly
            // trashed - or editing cells in pinned rows are not refreshed and put into read mode
            onlyBody: true
        };
        this.redrawAfterModelUpdate(params);
    }
    getAllCellsForColumn(column) {
        const res = [];
        this.getAllRowCtrls().forEach((rowCtrl)=>{
            const eCell = rowCtrl.getCellElement(column);
            if (eCell) res.push(eCell);
        });
        return res;
    }
    refreshFloatingRowComps() {
        this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowNodes());
        this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowNodes());
    }
    getTopRowCtrls() {
        return this.topRowCtrls;
    }
    getCentreRowCtrls() {
        return this.allRowCtrls;
    }
    getBottomRowCtrls() {
        return this.bottomRowCtrls;
    }
    /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */ refreshFloatingRows(rowCtrls, rowNodes) {
        const nodeMap = Object.fromEntries(rowNodes.map((node)=>[
                node.id,
                node
            ]));
        const rowCtrlMap = Object.fromEntries(rowCtrls.map((ctrl)=>[
                ctrl.getRowNode().id,
                ctrl
            ]));
        for(let i = 0; i < rowNodes.length; i++){
            const node = rowNodes[i];
            const rowCtrl = rowCtrls[i];
            if (rowCtrl && nodeMap[rowCtrl.getRowNode().id] === void 0) {
                rowCtrl.destroyFirstPass();
                rowCtrl.destroySecondPass();
            }
            if (node.id in rowCtrlMap) {
                rowCtrls[i] = rowCtrlMap[node.id];
                delete rowCtrlMap[node.id];
            } else rowCtrls[i] = new $7b57b57eaf5a9648$export$e449e57ac30326ed(node, this.beans, false, false, this.printLayout);
        }
        rowCtrls.length = rowNodes.length;
    }
    onPinnedRowDataChanged() {
        const params = {
            recycleRows: true
        };
        this.redrawAfterModelUpdate(params);
    }
    redrawRow(rowNode, suppressEvent = false) {
        if (rowNode.sticky) this.stickyRowFeature.refreshStickyNode(rowNode);
        else if (this.cachedRowCtrls?.has(rowNode)) {
            this.cachedRowCtrls.removeRow(rowNode);
            return;
        } else {
            const destroyAndRecreateCtrl = (dataStruct)=>{
                const ctrl = dataStruct[rowNode.rowIndex];
                if (!ctrl) return;
                if (ctrl.getRowNode() !== rowNode) return;
                ctrl.destroyFirstPass();
                ctrl.destroySecondPass();
                dataStruct[rowNode.rowIndex] = this.createRowCon(rowNode, false, false);
            };
            switch(rowNode.rowPinned){
                case "top":
                    destroyAndRecreateCtrl(this.topRowCtrls);
                    break;
                case "bottom":
                    destroyAndRecreateCtrl(this.bottomRowCtrls);
                    break;
                default:
                    destroyAndRecreateCtrl(this.rowCtrlsByRowIndex);
                    this.updateAllRowCtrls();
            }
        }
        if (!suppressEvent) this.dispatchDisplayedRowsChanged(false);
    }
    redrawRows(rowNodes) {
        const partialRefresh = rowNodes != null;
        if (partialRefresh) {
            rowNodes?.forEach((node)=>this.redrawRow(node, true));
            this.dispatchDisplayedRowsChanged(false);
            return;
        }
        this.redrawAfterModelUpdate();
    }
    getCellToRestoreFocusToAfterRefresh(params) {
        const focusedCell = params?.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();
        if (focusedCell == null) return null;
        const activeElement = this.gos.getActiveDomElement();
        const cellDomData = this.gos.getDomData(activeElement, $7b57b57eaf5a9648$export$4fd76abbfd48a7b6.DOM_DATA_KEY_CELL_CTRL);
        const rowDomData = this.gos.getDomData(activeElement, $7b57b57eaf5a9648$export$e449e57ac30326ed.DOM_DATA_KEY_ROW_CTRL);
        const gridElementFocused = cellDomData || rowDomData;
        return gridElementFocused ? focusedCell : null;
    }
    // gets called from:
    // +) initialisation (in registerGridComp) params = null
    // +) onDomLayoutChanged, params = null
    // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
    // +) onPinnedRowDataChanged, recycleRows = true
    // +) redrawRows (from Grid API), recycleRows = true/false
    redrawAfterModelUpdate(params = {}) {
        this.getLockOnRefresh();
        const focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);
        this.updateContainerHeights();
        this.scrollToTopIfNewData(params);
        const recycleRows = !params.domLayoutChanged && !!params.recycleRows;
        const animate = params.animate && this.gos.isAnimateRows();
        const rowsToRecycle = recycleRows ? this.getRowsToRecycle() : null;
        if (!recycleRows) this.removeAllRowComps();
        this.workOutFirstAndLastRowsToRender();
        if (this.stickyRowFeature) {
            this.stickyRowFeature.checkStickyRows();
            const extraHeight = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
            if (extraHeight) this.updateContainerHeights(extraHeight);
        }
        this.recycleRows(rowsToRecycle, animate);
        this.gridBodyCtrl.updateRowCount();
        if (!params.onlyBody) this.refreshFloatingRowComps();
        this.dispatchDisplayedRowsChanged();
        if (focusedCell != null) this.restoreFocusedCell(focusedCell);
        this.releaseLockOnRefresh();
    }
    scrollToTopIfNewData(params) {
        const scrollToTop = params.newData || params.newPage;
        const suppressScrollToTop = this.gos.get("suppressScrollOnNewData");
        if (scrollToTop && !suppressScrollToTop) {
            this.gridBodyCtrl.getScrollFeature().scrollToTop();
            this.stickyRowFeature?.resetOffsets();
        }
    }
    updateContainerHeights(additionalHeight = 0) {
        if (this.printLayout) {
            this.rowContainerHeightService.setModelHeight(null);
            return;
        }
        let containerHeight = this.pageBoundsService.getCurrentPageHeight();
        if (containerHeight === 0) containerHeight = 1;
        this.rowContainerHeightService.setModelHeight(containerHeight + additionalHeight);
    }
    getLockOnRefresh() {
        if (this.refreshInProgress) {
            const frameworkMessage = this.frameworkOverrides.getLockOnRefreshError?.() ?? "";
            throw new Error("AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace." + frameworkMessage);
        }
        this.refreshInProgress = true;
        this.frameworkOverrides.getLockOnRefresh?.();
    }
    releaseLockOnRefresh() {
        this.refreshInProgress = false;
        this.frameworkOverrides.releaseLockOnRefresh?.();
    }
    isRefreshInProgress() {
        return this.refreshInProgress;
    }
    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
    // edited cell).
    restoreFocusedCell(cellPosition) {
        if (!cellPosition) return;
        setTimeout(()=>{
            this.focusService.setRestoreFocusedCell(cellPosition);
            this.onCellFocusChanged(this.gos.addGridCommonParams({
                rowIndex: cellPosition.rowIndex,
                column: cellPosition.column,
                rowPinned: cellPosition.rowPinned,
                forceBrowserFocus: true,
                preventScrollOnBrowserFocus: true,
                type: "cellFocused"
            }));
        });
    }
    stopEditing(cancel = false) {
        this.getAllRowCtrls().forEach((rowCtrl)=>{
            rowCtrl.stopEditing(cancel);
        });
    }
    getAllCellCtrls() {
        const res = [];
        const rowCtrls = this.getAllRowCtrls();
        const rowCtrlsLength = rowCtrls.length;
        for(let i = 0; i < rowCtrlsLength; i++){
            const cellCtrls = rowCtrls[i].getAllCellCtrls();
            const cellCtrlsLength = cellCtrls.length;
            for(let j = 0; j < cellCtrlsLength; j++)res.push(cellCtrls[j]);
        }
        return res;
    }
    getAllRowCtrls() {
        const stickyTopRowCtrls = this.stickyRowFeature && this.stickyRowFeature.getStickyTopRowCtrls() || [];
        const stickyBottomRowCtrls = this.stickyRowFeature && this.stickyRowFeature.getStickyBottomRowCtrls() || [];
        const res = [
            ...this.topRowCtrls,
            ...this.bottomRowCtrls,
            ...stickyTopRowCtrls,
            ...stickyBottomRowCtrls
        ];
        for(const key in this.rowCtrlsByRowIndex)res.push(this.rowCtrlsByRowIndex[key]);
        return res;
    }
    addRenderedRowListener(eventName, rowIndex, callback) {
        const rowComp = this.rowCtrlsByRowIndex[rowIndex];
        if (rowComp) rowComp.addEventListener(eventName, callback);
    }
    flashCells(params = {}) {
        this.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl)=>cellCtrl.flashCell(params));
    }
    refreshCells(params = {}) {
        const refreshCellParams = {
            forceRefresh: params.force,
            newData: false,
            suppressFlash: params.suppressFlash
        };
        for (const cellCtrl of this.getCellCtrls(params.rowNodes, params.columns))cellCtrl.refreshOrDestroyCell(refreshCellParams);
        this.refreshFullWidth(params.rowNodes);
    }
    refreshFullWidth(rowNodes) {
        if (!rowNodes) return;
        let cellFocused = null;
        if (this.stickyRowFeature && $7b57b57eaf5a9648$var$_browserSupportsPreventScroll()) cellFocused = this.getCellToRestoreFocusToAfterRefresh() || null;
        for (const rowCtrl of this.getRowCtrls(rowNodes)){
            if (!rowCtrl.isFullWidth()) continue;
            const refreshed = rowCtrl.refreshFullWidth();
            if (!refreshed) this.redrawRow(rowCtrl.getRowNode(), true);
        }
        this.dispatchDisplayedRowsChanged(false);
        if (cellFocused) this.restoreFocusedCell(cellFocused);
    }
    getCellRendererInstances(params) {
        const cellRenderers = this.getCellCtrls(params.rowNodes, params.columns).map((cellCtrl)=>cellCtrl.getCellRenderer()).filter((renderer)=>renderer != null);
        if (params.columns?.length) return cellRenderers;
        const fullWidthRenderers = [];
        const rowIdMap = this.mapRowNodes(params.rowNodes);
        this.getAllRowCtrls().forEach((rowCtrl)=>{
            if (rowIdMap && !this.isRowInMap(rowCtrl.getRowNode(), rowIdMap)) return;
            if (!rowCtrl.isFullWidth()) return;
            const renderers = rowCtrl.getFullWidthCellRenderers();
            for(let i = 0; i < renderers.length; i++){
                const renderer = renderers[i];
                if (renderer != null) fullWidthRenderers.push(renderer);
            }
        });
        return [
            ...fullWidthRenderers,
            ...cellRenderers
        ];
    }
    getCellEditorInstances(params) {
        const res = [];
        this.getCellCtrls(params.rowNodes, params.columns).forEach((cellCtrl)=>{
            const cellEditor = cellCtrl.getCellEditor();
            if (cellEditor) res.push(cellEditor);
        });
        return res;
    }
    getEditingCells() {
        const res = [];
        this.getAllCellCtrls().forEach((cellCtrl)=>{
            if (cellCtrl.isEditing()) {
                const cellPosition = cellCtrl.getCellPosition();
                res.push(cellPosition);
            }
        });
        return res;
    }
    mapRowNodes(rowNodes) {
        if (!rowNodes) return;
        const res = {
            top: {},
            bottom: {},
            normal: {}
        };
        rowNodes.forEach((rowNode)=>{
            const id = rowNode.id;
            switch(rowNode.rowPinned){
                case "top":
                    res.top[id] = rowNode;
                    break;
                case "bottom":
                    res.bottom[id] = rowNode;
                    break;
                default:
                    res.normal[id] = rowNode;
                    break;
            }
        });
        return res;
    }
    isRowInMap(rowNode, rowIdsMap) {
        const id = rowNode.id;
        const floating = rowNode.rowPinned;
        switch(floating){
            case "top":
                return rowIdsMap.top[id] != null;
            case "bottom":
                return rowIdsMap.bottom[id] != null;
            default:
                return rowIdsMap.normal[id] != null;
        }
    }
    /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */ getRowCtrls(rowNodes) {
        const rowIdsMap = this.mapRowNodes(rowNodes);
        const allRowCtrls = this.getAllRowCtrls();
        if (!rowNodes || !rowIdsMap) return allRowCtrls;
        return allRowCtrls.filter((rowCtrl)=>{
            const rowNode = rowCtrl.getRowNode();
            return this.isRowInMap(rowNode, rowIdsMap);
        });
    }
    // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
    // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
    getCellCtrls(rowNodes, columns) {
        let colIdsMap;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(columns)) {
            colIdsMap = {};
            columns.forEach((colKey)=>{
                const column = this.columnModel.getCol(colKey);
                if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(column)) colIdsMap[column.getId()] = true;
            });
        }
        const res = [];
        this.getRowCtrls(rowNodes).forEach((rowCtrl)=>{
            rowCtrl.getAllCellCtrls().forEach((cellCtrl)=>{
                const colId = cellCtrl.getColumn().getId();
                const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];
                if (excludeColFromRefresh) return;
                res.push(cellCtrl);
            });
        });
        return res;
    }
    destroy() {
        this.removeAllRowComps();
        super.destroy();
    }
    removeAllRowComps() {
        const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
        this.removeRowCtrls(rowIndexesToRemove);
        if (this.stickyRowFeature) this.stickyRowFeature.destroyStickyCtrls();
    }
    getRowsToRecycle() {
        const stubNodeIndexes = [];
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(this.rowCtrlsByRowIndex, (index, rowCtrl)=>{
            const stubNode = rowCtrl.getRowNode().id == null;
            if (stubNode) stubNodeIndexes.push(index);
        });
        this.removeRowCtrls(stubNodeIndexes);
        const ctrlsByIdMap = {};
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(this.rowCtrlsByRowIndex, (_, rowCtrl)=>{
            const rowNode = rowCtrl.getRowNode();
            ctrlsByIdMap[rowNode.id] = rowCtrl;
        });
        this.rowCtrlsByRowIndex = {};
        return ctrlsByIdMap;
    }
    // takes array of row indexes
    removeRowCtrls(rowsToRemove, suppressAnimation = false) {
        rowsToRemove.forEach((indexToRemove)=>{
            const rowCtrl = this.rowCtrlsByRowIndex[indexToRemove];
            if (rowCtrl) {
                rowCtrl.destroyFirstPass(suppressAnimation);
                rowCtrl.destroySecondPass();
            }
            delete this.rowCtrlsByRowIndex[indexToRemove];
        });
    }
    onBodyScroll(e) {
        if (e.direction !== "vertical") return;
        this.redraw({
            afterScroll: true
        });
    }
    // gets called when rows don't change, but viewport does, so after:
    // 1) height of grid body changes, ie number of displayed rows has changed
    // 2) grid scrolled to new position
    // 3) ensure index visible (which is a scroll)
    redraw(params = {}) {
        const { afterScroll: afterScroll  } = params;
        let cellFocused;
        if (this.stickyRowFeature && $7b57b57eaf5a9648$var$_browserSupportsPreventScroll()) cellFocused = this.getCellToRestoreFocusToAfterRefresh() || void 0;
        const oldFirstRow = this.firstRenderedRow;
        const oldLastRow = this.lastRenderedRow;
        this.workOutFirstAndLastRowsToRender();
        let hasStickyRowChanges = false;
        if (this.stickyRowFeature) {
            hasStickyRowChanges = this.stickyRowFeature.checkStickyRows();
            const extraHeight = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
            if (extraHeight) this.updateContainerHeights(extraHeight);
        }
        const rangeChanged = this.firstRenderedRow !== oldFirstRow || this.lastRenderedRow !== oldLastRow;
        if (afterScroll && !hasStickyRowChanges && !rangeChanged) return;
        this.getLockOnRefresh();
        this.recycleRows(null, false, afterScroll);
        this.releaseLockOnRefresh();
        this.dispatchDisplayedRowsChanged(afterScroll && !hasStickyRowChanges);
        if (cellFocused != null) {
            const newFocusedCell = this.getCellToRestoreFocusToAfterRefresh();
            if (cellFocused != null && newFocusedCell == null) {
                this.animationFrameService.flushAllFrames();
                this.restoreFocusedCell(cellFocused);
            }
        }
    }
    removeRowCompsNotToDraw(indexesToDraw, suppressAnimation) {
        const indexesToDrawMap = {};
        indexesToDraw.forEach((index)=>indexesToDrawMap[index] = true);
        const existingIndexes = Object.keys(this.rowCtrlsByRowIndex);
        const indexesNotToDraw = existingIndexes.filter((index)=>!indexesToDrawMap[index]);
        this.removeRowCtrls(indexesNotToDraw, suppressAnimation);
    }
    calculateIndexesToDraw(rowsToRecycle) {
        const indexesToDraw = $7b57b57eaf5a9648$var$_createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);
        const checkRowToDraw = (indexStr, rowComp)=>{
            const index = rowComp.getRowNode().rowIndex;
            if (index == null) return;
            if (index < this.firstRenderedRow || index > this.lastRenderedRow) {
                if (this.doNotUnVirtualiseRow(rowComp)) indexesToDraw.push(index);
            }
        };
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(this.rowCtrlsByRowIndex, checkRowToDraw);
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(rowsToRecycle, checkRowToDraw);
        indexesToDraw.sort((a, b)=>a - b);
        const ret = [];
        for(let i = 0; i < indexesToDraw.length; i++){
            const currRow = indexesToDraw[i];
            const rowNode = this.rowModel.getRow(currRow);
            if (rowNode && !rowNode.sticky) ret.push(currRow);
        }
        return ret;
    }
    recycleRows(rowsToRecycle, animate = false, afterScroll = false) {
        const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);
        if (this.printLayout || afterScroll) animate = false;
        this.removeRowCompsNotToDraw(indexesToDraw, !animate);
        const rowCtrls = [];
        indexesToDraw.forEach((rowIndex)=>{
            const rowCtrl = this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);
            if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(rowCtrl)) rowCtrls.push(rowCtrl);
        });
        if (rowsToRecycle) {
            const useAnimationFrame = afterScroll && !this.gos.get("suppressAnimationFrame") && !this.printLayout;
            if (useAnimationFrame) this.beans.animationFrameService.addDestroyTask(()=>{
                this.destroyRowCtrls(rowsToRecycle, animate);
                this.updateAllRowCtrls();
                this.dispatchDisplayedRowsChanged();
            });
            else this.destroyRowCtrls(rowsToRecycle, animate);
        }
        this.updateAllRowCtrls();
    }
    dispatchDisplayedRowsChanged(afterScroll = false) {
        const event = {
            type: "displayedRowsChanged",
            afterScroll: afterScroll
        };
        this.eventService.dispatchEvent(event);
    }
    onDisplayedColumnsChanged() {
        const pinningLeft = this.visibleColsService.isPinningLeft();
        const pinningRight = this.visibleColsService.isPinningRight();
        const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;
        if (atLeastOneChanged) {
            this.pinningLeft = pinningLeft;
            this.pinningRight = pinningRight;
            if (this.embedFullWidthRows) this.redrawFullWidthEmbeddedRows();
        }
    }
    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
    // then it should go into the pinned left area if pinning left, or the center area if not pinning.
    redrawFullWidthEmbeddedRows() {
        const rowsToRemove = [];
        this.getFullWidthRowCtrls().forEach((fullWidthCtrl)=>{
            const rowIndex = fullWidthCtrl.getRowNode().rowIndex;
            rowsToRemove.push(rowIndex.toString());
        });
        this.refreshFloatingRowComps();
        this.removeRowCtrls(rowsToRemove);
        this.redraw({
            afterScroll: true
        });
    }
    getFullWidthRowCtrls(rowNodes) {
        const rowNodesMap = this.mapRowNodes(rowNodes);
        return this.getAllRowCtrls().filter((rowCtrl)=>{
            if (!rowCtrl.isFullWidth()) return false;
            const rowNode = rowCtrl.getRowNode();
            if (rowNodesMap != null && !this.isRowInMap(rowNode, rowNodesMap)) return false;
            return true;
        });
    }
    createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll) {
        let rowNode;
        let rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
        if (!rowCtrl) {
            rowNode = this.rowModel.getRow(rowIndex);
            if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(rowNode) && $7b57b57eaf5a9648$export$25d27f17d3af40f7(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {
                rowCtrl = rowsToRecycle[rowNode.id];
                rowsToRecycle[rowNode.id] = null;
            }
        }
        const creatingNewRowCtrl = !rowCtrl;
        if (creatingNewRowCtrl) {
            if (!rowNode) rowNode = this.rowModel.getRow(rowIndex);
            if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(rowNode)) rowCtrl = this.createRowCon(rowNode, animate, afterScroll);
            else return;
        }
        if (rowNode) rowNode.alreadyRendered = true;
        this.rowCtrlsByRowIndex[rowIndex] = rowCtrl;
        return rowCtrl;
    }
    destroyRowCtrls(rowCtrlsMap, animate) {
        const executeInAWhileFuncs = [];
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(rowCtrlsMap, (nodeId, rowCtrl)=>{
            if (!rowCtrl) return;
            if (this.cachedRowCtrls && rowCtrl.isCacheable()) {
                this.cachedRowCtrls.addRow(rowCtrl);
                return;
            }
            rowCtrl.destroyFirstPass(!animate);
            if (animate) {
                this.zombieRowCtrls[rowCtrl.getInstanceId()] = rowCtrl;
                executeInAWhileFuncs.push(()=>{
                    rowCtrl.destroySecondPass();
                    delete this.zombieRowCtrls[rowCtrl.getInstanceId()];
                });
            } else rowCtrl.destroySecondPass();
        });
        if (animate) {
            executeInAWhileFuncs.push(()=>{
                this.updateAllRowCtrls();
                this.dispatchDisplayedRowsChanged();
            });
            $7b57b57eaf5a9648$var$_executeInAWhile(executeInAWhileFuncs);
        }
    }
    getRowBuffer() {
        return this.gos.get("rowBuffer");
    }
    getRowBufferInPixels() {
        const rowsToBuffer = this.getRowBuffer();
        const defaultRowHeight = this.gos.getRowHeightAsNumber();
        return rowsToBuffer * defaultRowHeight;
    }
    workOutFirstAndLastRowsToRender() {
        this.rowContainerHeightService.updateOffset();
        let newFirst;
        let newLast;
        if (!this.rowModel.isRowsToRender()) {
            newFirst = 0;
            newLast = -1;
        } else if (this.printLayout) {
            this.environment.refreshRowHeightVariable();
            newFirst = this.pageBoundsService.getFirstRow();
            newLast = this.pageBoundsService.getLastRow();
        } else {
            const bufferPixels = this.getRowBufferInPixels();
            const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
            const suppressRowVirtualisation = this.gos.get("suppressRowVirtualisation");
            let rowHeightsChanged = false;
            let firstPixel;
            let lastPixel;
            do {
                const paginationOffset = this.pageBoundsService.getPixelOffset();
                const { pageFirstPixel: pageFirstPixel , pageLastPixel: pageLastPixel  } = this.pageBoundsService.getCurrentPagePixelRange();
                const divStretchOffset = this.rowContainerHeightService.getDivStretchOffset();
                const bodyVRange = gridBodyCtrl.getScrollFeature().getVScrollPosition();
                const bodyTopPixel = bodyVRange.top;
                const bodyBottomPixel = bodyVRange.bottom;
                if (suppressRowVirtualisation) {
                    firstPixel = pageFirstPixel + divStretchOffset;
                    lastPixel = pageLastPixel + divStretchOffset;
                } else {
                    firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;
                    lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;
                }
                this.firstVisibleVPixel = Math.max(bodyTopPixel + paginationOffset, pageFirstPixel) + divStretchOffset;
                this.lastVisibleVPixel = Math.min(bodyBottomPixel + paginationOffset, pageLastPixel) + divStretchOffset;
                rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);
            }while (rowHeightsChanged);
            let firstRowIndex = this.rowModel.getRowIndexAtPixel(firstPixel);
            let lastRowIndex = this.rowModel.getRowIndexAtPixel(lastPixel);
            const pageFirstRow = this.pageBoundsService.getFirstRow();
            const pageLastRow = this.pageBoundsService.getLastRow();
            if (firstRowIndex < pageFirstRow) firstRowIndex = pageFirstRow;
            if (lastRowIndex > pageLastRow) lastRowIndex = pageLastRow;
            newFirst = firstRowIndex;
            newLast = lastRowIndex;
        }
        const rowLayoutNormal = this.gos.isDomLayout("normal");
        const suppressRowCountRestriction = this.gos.get("suppressMaxRenderedRowRestriction");
        const rowBufferMaxSize = Math.max(this.getRowBuffer(), 500);
        if (rowLayoutNormal && !suppressRowCountRestriction) {
            if (newLast - newFirst > rowBufferMaxSize) newLast = newFirst + rowBufferMaxSize;
        }
        const firstDiffers = newFirst !== this.firstRenderedRow;
        const lastDiffers = newLast !== this.lastRenderedRow;
        if (firstDiffers || lastDiffers) {
            this.firstRenderedRow = newFirst;
            this.lastRenderedRow = newLast;
            const event = {
                type: "viewportChanged",
                firstRow: newFirst,
                lastRow: newLast
            };
            this.eventService.dispatchEvent(event);
        }
    }
    /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */ dispatchFirstDataRenderedEvent() {
        if (this.dataFirstRenderedFired) return;
        this.dataFirstRenderedFired = true;
        const event = {
            type: "firstDataRendered",
            firstRow: this.firstRenderedRow,
            lastRow: this.lastRenderedRow
        };
        window.requestAnimationFrame(()=>{
            this.beans.eventService.dispatchEvent(event);
        });
    }
    ensureAllRowsInRangeHaveHeightsCalculated(topPixel, bottomPixel) {
        const pinnedRowHeightsChanged = this.pinnedRowModel?.ensureRowHeightsValid();
        const stickyHeightsChanged = this.stickyRowFeature?.ensureRowHeightsValid();
        const rowModelHeightsChanged = this.rowModel.ensureRowHeightsValid(topPixel, bottomPixel, this.pageBoundsService.getFirstRow(), this.pageBoundsService.getLastRow());
        if (rowModelHeightsChanged || stickyHeightsChanged) this.eventService.dispatchEvent({
            type: "recalculateRowBounds"
        });
        if (stickyHeightsChanged || rowModelHeightsChanged || pinnedRowHeightsChanged) {
            this.updateContainerHeights();
            return true;
        }
        return false;
    }
    getFirstVisibleVerticalPixel() {
        return this.firstVisibleVPixel;
    }
    getLastVisibleVerticalPixel() {
        return this.lastVisibleVPixel;
    }
    getFirstVirtualRenderedRow() {
        return this.firstRenderedRow;
    }
    getLastVirtualRenderedRow() {
        return this.lastRenderedRow;
    }
    // check that none of the rows to remove are editing or focused as:
    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
    //    the edit is reset - so we want to keep it rendered.
    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
    //    otherwise the user can range select and drag (with focus cell going out of the viewport)
    //    and then ctrl+c, nothing will happen if cell is removed from dom.
    // c) if detail record of master detail, as users complained that the context of detail rows
    //    was getting lost when detail row out of view. eg user expands to show detail row,
    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
    //    after detail panel is scrolled out of / into view.
    doNotUnVirtualiseRow(rowComp) {
        const REMOVE_ROW = false;
        const KEEP_ROW = true;
        const rowNode = rowComp.getRowNode();
        const rowHasFocus = this.focusService.isRowNodeFocused(rowNode);
        const rowIsEditing = rowComp.isEditing();
        const rowIsDetail = rowNode.detail;
        const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;
        if (!mightWantToKeepRow) return REMOVE_ROW;
        const rowNodePresent = this.isRowPresent(rowNode);
        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;
    }
    isRowPresent(rowNode) {
        if (!this.rowModel.isRowPresent(rowNode)) return false;
        return this.paginationService ? this.paginationService.isRowPresent(rowNode) : true;
    }
    createRowCon(rowNode, animate, afterScroll) {
        const rowCtrlFromCache = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(rowNode) : null;
        if (rowCtrlFromCache) return rowCtrlFromCache;
        const suppressAnimationFrame = this.gos.get("suppressAnimationFrame");
        const useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;
        const res = new $7b57b57eaf5a9648$export$e449e57ac30326ed(rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout);
        return res;
    }
    getRenderedNodes() {
        const renderedRows = this.rowCtrlsByRowIndex;
        return Object.values(renderedRows).map((rowCtrl)=>rowCtrl.getRowNode());
    }
    getRowByPosition(rowPosition) {
        let rowCtrl;
        const { rowIndex: rowIndex  } = rowPosition;
        switch(rowPosition.rowPinned){
            case "top":
                rowCtrl = this.topRowCtrls[rowIndex];
                break;
            case "bottom":
                rowCtrl = this.bottomRowCtrls[rowIndex];
                break;
            default:
                rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
                if (!rowCtrl) {
                    rowCtrl = this.getStickyTopRowCtrls().find((ctrl)=>ctrl.getRowNode().rowIndex === rowIndex) || null;
                    if (!rowCtrl) rowCtrl = this.getStickyBottomRowCtrls().find((ctrl)=>ctrl.getRowNode().rowIndex === rowIndex) || null;
                }
                break;
        }
        return rowCtrl;
    }
    // returns true if any row between startIndex and endIndex is rendered. used by
    // SSRM or IRM, as they don't want to purge visible blocks from cache.
    isRangeInRenderedViewport(startIndex, endIndex) {
        const parentClosed = startIndex == null || endIndex == null;
        if (parentClosed) return false;
        const blockAfterViewport = startIndex > this.lastRenderedRow;
        const blockBeforeViewport = endIndex < this.firstRenderedRow;
        const blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;
        return blockInsideViewport;
    }
};
var $7b57b57eaf5a9648$var$RowCtrlCache = class {
    constructor(maxCount){
        // map for fast access
        this.entriesMap = {};
        // list for keeping order
        this.entriesList = [];
        this.maxCount = maxCount;
    }
    addRow(rowCtrl) {
        this.entriesMap[rowCtrl.getRowNode().id] = rowCtrl;
        this.entriesList.push(rowCtrl);
        rowCtrl.setCached(true);
        if (this.entriesList.length > this.maxCount) {
            const rowCtrlToDestroy = this.entriesList[0];
            rowCtrlToDestroy.destroyFirstPass();
            rowCtrlToDestroy.destroySecondPass();
            this.removeFromCache(rowCtrlToDestroy);
        }
    }
    getRow(rowNode) {
        if (rowNode == null || rowNode.id == null) return null;
        const res = this.entriesMap[rowNode.id];
        if (!res) return null;
        this.removeFromCache(res);
        res.setCached(false);
        const rowNodeMismatch = res.getRowNode() != rowNode;
        return rowNodeMismatch ? null : res;
    }
    has(rowNode) {
        return this.entriesMap[rowNode.id] != null;
    }
    removeRow(rowNode) {
        const rowNodeId = rowNode.id;
        const ctrl = this.entriesMap[rowNodeId];
        delete this.entriesMap[rowNodeId];
        $7b57b57eaf5a9648$export$83a881c8b5120679(this.entriesList, ctrl);
    }
    removeFromCache(rowCtrl) {
        const rowNodeId = rowCtrl.getRowNode().id;
        delete this.entriesMap[rowNodeId];
        $7b57b57eaf5a9648$export$83a881c8b5120679(this.entriesList, rowCtrl);
    }
    getEntries() {
        return this.entriesList;
    }
};
// community-modules/core/src/pinnedRowModel/pinnedRowModel.ts
var $7b57b57eaf5a9648$export$d44126a5f53c99d9 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "pinnedRowModel";
        this.nextId = 0;
    }
    wireBeans(beans) {
        this.beans = beans;
    }
    postConstruct() {
        this.setPinnedTopRowData();
        this.setPinnedBottomRowData();
        this.addManagedPropertyListener("pinnedTopRowData", ()=>this.setPinnedTopRowData());
        this.addManagedPropertyListener("pinnedBottomRowData", ()=>this.setPinnedBottomRowData());
        this.addManagedEventListeners({
            gridStylesChanged: this.onGridStylesChanges.bind(this)
        });
    }
    isEmpty(floating) {
        const rows = floating === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
        return $7b57b57eaf5a9648$export$c15f339f10321853(rows);
    }
    isRowsToRender(floating) {
        return !this.isEmpty(floating);
    }
    getRowAtPixel(pixel, floating) {
        const rows = floating === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
        if ($7b57b57eaf5a9648$export$c15f339f10321853(rows)) return 0;
        for(let i = 0; i < rows.length; i++){
            const rowNode = rows[i];
            const rowTopPixel = rowNode.rowTop + rowNode.rowHeight - 1;
            if (rowTopPixel >= pixel) return i;
        }
        return rows.length - 1;
    }
    onGridStylesChanges(e) {
        if (e.rowHeightChanged) {
            const estimateRowHeight = (rowNode)=>{
                rowNode.setRowHeight(rowNode.rowHeight, true);
            };
            this.pinnedBottomRows.forEach(estimateRowHeight);
            this.pinnedTopRows.forEach(estimateRowHeight);
        }
    }
    ensureRowHeightsValid() {
        let anyChange = false;
        let rowTop = 0;
        const updateRowHeight = (rowNode)=>{
            if (rowNode.rowHeightEstimated) {
                const rowHeight = this.gos.getRowHeightForNode(rowNode);
                rowNode.setRowTop(rowTop);
                rowNode.setRowHeight(rowHeight.height);
                rowTop += rowHeight.height;
                anyChange = true;
            }
        };
        this.pinnedBottomRows?.forEach(updateRowHeight);
        rowTop = 0;
        this.pinnedTopRows?.forEach(updateRowHeight);
        const event = {
            type: "pinnedHeightChanged"
        };
        this.eventService.dispatchEvent(event);
        return anyChange;
    }
    setPinnedTopRowData() {
        const rowData = this.gos.get("pinnedTopRowData");
        this.pinnedTopRows = this.createNodesFromData(rowData, true);
        const event = {
            type: "pinnedRowDataChanged"
        };
        this.eventService.dispatchEvent(event);
    }
    setPinnedBottomRowData() {
        const rowData = this.gos.get("pinnedBottomRowData");
        this.pinnedBottomRows = this.createNodesFromData(rowData, false);
        const event = {
            type: "pinnedRowDataChanged"
        };
        this.eventService.dispatchEvent(event);
    }
    createNodesFromData(allData, isTop) {
        const rowNodes = [];
        if (allData) {
            const getRowId = this.gos.getRowIdCallback();
            const idPrefix = isTop ? $7b57b57eaf5a9648$export$6af91cd58ec2edf9.ID_PREFIX_TOP_PINNED : $7b57b57eaf5a9648$export$6af91cd58ec2edf9.ID_PREFIX_BOTTOM_PINNED;
            let nextRowTop = 0;
            const pinned = isTop ? "top" : "bottom";
            allData.forEach((dataItem, index)=>{
                const rowNode = new $7b57b57eaf5a9648$export$6af91cd58ec2edf9(this.beans);
                rowNode.data = dataItem;
                rowNode.id = getRowId?.({
                    data: dataItem,
                    level: 0,
                    rowPinned: pinned
                }) ?? idPrefix + this.nextId++;
                rowNode.rowPinned = pinned;
                rowNode.setRowTop(nextRowTop);
                rowNode.setRowHeight(this.gos.getRowHeightForNode(rowNode).height);
                rowNode.setRowIndex(index);
                nextRowTop += rowNode.rowHeight;
                rowNodes.push(rowNode);
            });
        }
        return rowNodes;
    }
    getPinnedTopRowNodes() {
        return this.pinnedTopRows;
    }
    getPinnedBottomRowNodes() {
        return this.pinnedBottomRows;
    }
    getPinnedTopTotalHeight() {
        return this.getTotalHeight(this.pinnedTopRows);
    }
    getPinnedTopRowCount() {
        return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
    }
    getPinnedBottomRowCount() {
        return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
    }
    getPinnedTopRow(index) {
        return this.pinnedTopRows[index];
    }
    getPinnedBottomRow(index) {
        return this.pinnedBottomRows[index];
    }
    forEachPinnedTopRow(callback) {
        if ($7b57b57eaf5a9648$export$c15f339f10321853(this.pinnedTopRows)) return;
        this.pinnedTopRows.forEach(callback);
    }
    forEachPinnedBottomRow(callback) {
        if ($7b57b57eaf5a9648$export$c15f339f10321853(this.pinnedBottomRows)) return;
        this.pinnedBottomRows.forEach(callback);
    }
    getPinnedBottomTotalHeight() {
        return this.getTotalHeight(this.pinnedBottomRows);
    }
    getTotalHeight(rowNodes) {
        if (!rowNodes || rowNodes.length === 0) return 0;
        const lastNode = $7b57b57eaf5a9648$export$236389741107357f(rowNodes);
        return lastNode.rowTop + lastNode.rowHeight;
    }
};
// community-modules/core/src/interfaces/serverSideTransaction.ts
var $7b57b57eaf5a9648$export$58e95be8934cbc38 = /* @__PURE__ */ ((ServerSideTransactionResultStatus2)=>{
    ServerSideTransactionResultStatus2["Applied"] = "Applied";
    ServerSideTransactionResultStatus2["StoreNotFound"] = "StoreNotFound";
    ServerSideTransactionResultStatus2["StoreLoading"] = "StoreLoading";
    ServerSideTransactionResultStatus2["StoreWaitingToLoad"] = "StoreWaitingToLoad";
    ServerSideTransactionResultStatus2["StoreLoadingFailed"] = "StoreLoadingFailed";
    ServerSideTransactionResultStatus2["StoreWrongType"] = "StoreWrongType";
    ServerSideTransactionResultStatus2["Cancelled"] = "Cancelled";
    ServerSideTransactionResultStatus2["StoreNotStarted"] = "StoreNotStarted";
    return ServerSideTransactionResultStatus2;
})($7b57b57eaf5a9648$export$58e95be8934cbc38 || {});
// community-modules/core/src/rowNodeCache/rowNodeBlock.ts
var $7b57b57eaf5a9648$export$eb7378abb0bca09e = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(id){
        super();
        this.state = "needsLoading";
        this.version = 0;
        this.id = id;
    }
    getId() {
        return this.id;
    }
    load() {
        this.state = "loading";
        this.loadFromDatasource();
    }
    getVersion() {
        return this.version;
    }
    setStateWaitingToLoad() {
        this.version++;
        this.state = "needsLoading";
    }
    getState() {
        return this.state;
    }
    pageLoadFailed(version) {
        const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);
        if (requestMostRecentAndLive) {
            this.state = "failed";
            this.processServerFail();
        }
        this.dispatchLoadCompleted(false);
    }
    success(version, params) {
        this.successCommon(version, params);
    }
    pageLoaded(version, rows, lastRow) {
        this.successCommon(version, {
            rowData: rows,
            rowCount: lastRow
        });
    }
    isRequestMostRecentAndLive(version) {
        const thisIsMostRecentRequest = version === this.version;
        const weAreNotDestroyed = this.isAlive();
        return thisIsMostRecentRequest && weAreNotDestroyed;
    }
    successCommon(version, params) {
        this.dispatchLoadCompleted();
        const requestMostRecentAndLive = this.isRequestMostRecentAndLive(version);
        if (requestMostRecentAndLive) {
            this.state = "loaded";
            this.processServerResult(params);
        }
    }
    dispatchLoadCompleted(success = true) {
        const event = {
            type: "loadComplete",
            success: success,
            block: this
        };
        this.dispatchLocalEvent(event);
    }
};
// community-modules/core/src/rowNodeCache/rowNodeBlockLoader.ts
var $7b57b57eaf5a9648$export$6bcc4682a6134db1 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowNodeBlockLoader";
        this.activeBlockLoadsCount = 0;
        this.blocks = [];
        this.active = true;
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
    }
    postConstruct() {
        this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
        const blockLoadDebounceMillis = this.gos.get("blockLoadDebounceMillis");
        if (blockLoadDebounceMillis && blockLoadDebounceMillis > 0) this.checkBlockToLoadDebounce = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.performCheckBlocksToLoad.bind(this), blockLoadDebounceMillis);
    }
    getMaxConcurrentDatasourceRequests() {
        const res = this.gos.get("maxConcurrentDatasourceRequests");
        if (res == null) return 2;
        if (res <= 0) return;
        return res;
    }
    addBlock(block) {
        this.blocks.push(block);
        block.addEventListener("loadComplete", this.loadComplete.bind(this));
        this.checkBlockToLoad();
    }
    removeBlock(block) {
        $7b57b57eaf5a9648$export$83a881c8b5120679(this.blocks, block);
    }
    destroy() {
        super.destroy();
        this.active = false;
    }
    loadComplete() {
        this.activeBlockLoadsCount--;
        this.checkBlockToLoad();
        this.dispatchLocalEvent({
            type: "blockLoaded"
        });
        if (this.activeBlockLoadsCount == 0) this.dispatchLocalEvent({
            type: "blockLoaderFinished"
        });
    }
    checkBlockToLoad() {
        if (this.checkBlockToLoadDebounce) this.checkBlockToLoadDebounce();
        else this.performCheckBlocksToLoad();
    }
    performCheckBlocksToLoad() {
        if (!this.active) return;
        this.printCacheStatus();
        if (this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
            if (this.gos.get("debug")) $7b57b57eaf5a9648$export$1ce471ee7a8b4d23(`RowNodeBlockLoader - checkBlockToLoad: max loads exceeded`);
            return;
        }
        const loadAvailability = this.getAvailableLoadingCount();
        const blocksToLoad = this.blocks.filter((block)=>block.getState() === "needsLoading").slice(0, loadAvailability);
        this.registerLoads(blocksToLoad.length);
        blocksToLoad.forEach((block)=>block.load());
        this.printCacheStatus();
    }
    getBlockState() {
        if (this.gos.isRowModelType("serverSide")) {
            const ssrm = this.rowModel;
            return ssrm.getBlockStates();
        }
        const result = {};
        this.blocks.forEach((block)=>{
            const { id: id , state: state  } = block.getBlockStateJson();
            result[id] = state;
        });
        return result;
    }
    printCacheStatus() {
        if (this.gos.get("debug")) $7b57b57eaf5a9648$export$1ce471ee7a8b4d23(`RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`);
    }
    isLoading() {
        return this.activeBlockLoadsCount > 0;
    }
    registerLoads(count) {
        this.activeBlockLoadsCount += count;
    }
    getAvailableLoadingCount() {
        return this.maxConcurrentRequests !== void 0 ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0;
    }
};
// community-modules/core/src/rowNodeCache/rowNodeBlockModule.ts
var $7b57b57eaf5a9648$export$452a5acb3d5a3102 = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/row-node-block",
    beans: [
        $7b57b57eaf5a9648$export$6bcc4682a6134db1
    ]
};
// community-modules/core/src/selection/rowRangeSelectionContext.ts
var $7b57b57eaf5a9648$var$RowRangeSelectionContext = class {
    constructor(){
        this.root = null;
        /**
     * Note that the "end" `RowNode` may come before or after the "root" `RowNode` in the
     * actual grid.
     */ this.end = null;
        this.cachedRange = [];
    }
    init(rowModel) {
        this.rowModel = rowModel;
    }
    reset() {
        this.root = null;
        this.end = null;
        this.cachedRange.length = 0;
    }
    setRoot(node) {
        this.root = node;
        this.end = null;
        this.cachedRange.length = 0;
    }
    setEndRange(end) {
        this.end = end;
        this.cachedRange.length = 0;
    }
    getRange() {
        if (this.cachedRange.length === 0) {
            const root = this.getRoot();
            const end = this.getEnd();
            if (root == null || end == null) return this.cachedRange;
            this.cachedRange = this.rowModel.getNodesInRangeForSelection(root, end);
        }
        return this.cachedRange;
    }
    isInRange(node) {
        if (this.root === null) return false;
        return this.getRange().some((nodeInRange)=>nodeInRange.id === node.id);
    }
    getRoot() {
        if (this.root && this.root?.key === null) this.root = this.rowModel.getRowNode(this.root.id) ?? null;
        return this.root;
    }
    getEnd() {
        if (this.end && this.end?.key === null) this.end = this.rowModel.getRowNode(this.end.id) ?? null;
        return this.end;
    }
    /**
   * Truncates the range to the given node (assumed to be within the current range).
   * Returns nodes that remain in the current range and those that should be removed
   *
   * @param node - Node at which to truncate the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */ truncate(node) {
        const range = this.getRange();
        if (range.length === 0) return {
            keep: [],
            discard: []
        };
        const discardAfter = range[0].id === this.root.id;
        const idx = range.findIndex((rowNode)=>rowNode.id === node.id);
        if (idx > -1) {
            const above = range.slice(0, idx);
            const below = range.slice(idx + 1);
            this.setEndRange(node);
            return discardAfter ? {
                keep: above,
                discard: below
            } : {
                keep: below,
                discard: above
            };
        } else return {
            keep: range,
            discard: []
        };
    }
    /**
   * Extends the range to the given node. Returns nodes that remain in the current range
   * and those that should be removed.
   *
   * @param node - Node marking the new end of the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */ extend(node, groupSelectsChildren = false) {
        const root = this.getRoot();
        if (root == null) {
            const keep = this.getRange().slice();
            if (groupSelectsChildren) node.depthFirstSearch((node2)=>!node2.group && keep.push(node2));
            keep.push(node);
            this.setRoot(node);
            return {
                keep: keep,
                discard: []
            };
        }
        const newRange = this.rowModel.getNodesInRangeForSelection(root, node);
        if (newRange.find((newRangeNode)=>newRangeNode.id === this.end?.id)) {
            this.setEndRange(node);
            return {
                keep: this.getRange(),
                discard: []
            };
        } else {
            const discard = this.getRange().slice();
            this.setEndRange(node);
            return {
                keep: this.getRange(),
                discard: discard
            };
        }
    }
};
// community-modules/core/src/styling/stylingService.ts
var $7b57b57eaf5a9648$export$cf53ce5e31dacc9f = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "stylingService";
    }
    wireBeans(beans) {
        this.expressionService = beans.expressionService;
    }
    processAllCellClasses(colDef, params, onApplicableClass, onNotApplicableClass) {
        this.processClassRules(void 0, colDef.cellClassRules, params, onApplicableClass, onNotApplicableClass);
        this.processStaticCellClasses(colDef, params, onApplicableClass);
    }
    processClassRules(previousClassRules, classRules, params, onApplicableClass, onNotApplicableClass) {
        if (classRules == null && previousClassRules == null) return;
        const classesToApply = {};
        const classesToRemove = {};
        const forEachSingleClass = (className, callback)=>{
            className.split(" ").forEach((singleClass)=>{
                if (singleClass.trim() == "") return;
                callback(singleClass);
            });
        };
        if (classRules) {
            const classNames = Object.keys(classRules);
            for(let i = 0; i < classNames.length; i++){
                const className = classNames[i];
                const rule = classRules[className];
                let resultOfRule;
                if (typeof rule === "string") resultOfRule = this.expressionService.evaluate(rule, params);
                else if (typeof rule === "function") resultOfRule = rule(params);
                forEachSingleClass(className, (singleClass)=>{
                    resultOfRule ? classesToApply[singleClass] = true : classesToRemove[singleClass] = true;
                });
            }
        }
        if (previousClassRules && onNotApplicableClass) Object.keys(previousClassRules).forEach((className)=>forEachSingleClass(className, (singleClass)=>{
                if (!classesToApply[singleClass]) classesToRemove[singleClass] = true;
            }));
        if (onNotApplicableClass) Object.keys(classesToRemove).forEach(onNotApplicableClass);
        Object.keys(classesToApply).forEach(onApplicableClass);
    }
    getStaticCellClasses(colDef, params) {
        const { cellClass: cellClass  } = colDef;
        if (!cellClass) return [];
        let classOrClasses;
        if (typeof cellClass === "function") {
            const cellClassFunc = cellClass;
            classOrClasses = cellClassFunc(params);
        } else classOrClasses = cellClass;
        if (typeof classOrClasses === "string") classOrClasses = [
            classOrClasses
        ];
        return classOrClasses || [];
    }
    processStaticCellClasses(colDef, params, onApplicableClass) {
        const classOrClasses = this.getStaticCellClasses(colDef, params);
        classOrClasses.forEach((cssClassItem)=>{
            onApplicableClass(cssClassItem);
        });
    }
};
// community-modules/core/src/widgets/agToggleButton.ts
var $7b57b57eaf5a9648$export$167b21bf245ce0bf = class extends $7b57b57eaf5a9648$export$b00c508c1ae18d07 {
    constructor(config){
        super(config, "ag-toggle-button");
    }
    setValue(value, silent) {
        super.setValue(value, silent);
        this.addOrRemoveCssClass("ag-selected", this.getValue());
        return this;
    }
};
var $7b57b57eaf5a9648$export$b825a5135f318030 = {
    selector: "AG-TOGGLE-BUTTON",
    component: $7b57b57eaf5a9648$export$167b21bf245ce0bf
};
// community-modules/core/src/widgets/tabGuardCtrl.ts
var $7b57b57eaf5a9648$export$3be5727576441c72 = /* @__PURE__ */ ((TabGuardClassNames2)=>{
    TabGuardClassNames2["TAB_GUARD"] = "ag-tab-guard";
    TabGuardClassNames2["TAB_GUARD_TOP"] = "ag-tab-guard-top";
    TabGuardClassNames2["TAB_GUARD_BOTTOM"] = "ag-tab-guard-bottom";
    return TabGuardClassNames2;
})($7b57b57eaf5a9648$export$3be5727576441c72 || {});
var $7b57b57eaf5a9648$export$3074753638c3772c = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(params){
        super();
        this.skipTabGuardFocus = false;
        this.forcingFocusOut = false;
        // Used when `isFocusableContainer` enabled
        this.allowFocus = false;
        const { comp: comp , eTopGuard: eTopGuard , eBottomGuard: eBottomGuard , focusTrapActive: focusTrapActive , forceFocusOutWhenTabGuardsAreEmpty: forceFocusOutWhenTabGuardsAreEmpty , isFocusableContainer: isFocusableContainer , focusInnerElement: focusInnerElement , onFocusIn: onFocusIn , onFocusOut: onFocusOut , shouldStopEventPropagation: shouldStopEventPropagation , onTabKeyDown: onTabKeyDown , handleKeyDown: handleKeyDown , eFocusableElement: eFocusableElement  } = params;
        this.comp = comp;
        this.eTopGuard = eTopGuard;
        this.eBottomGuard = eBottomGuard;
        this.providedFocusInnerElement = focusInnerElement;
        this.eFocusableElement = eFocusableElement;
        this.focusTrapActive = !!focusTrapActive;
        this.forceFocusOutWhenTabGuardsAreEmpty = !!forceFocusOutWhenTabGuardsAreEmpty;
        this.isFocusableContainer = !!isFocusableContainer;
        this.providedFocusIn = onFocusIn;
        this.providedFocusOut = onFocusOut;
        this.providedShouldStopEventPropagation = shouldStopEventPropagation;
        this.providedOnTabKeyDown = onTabKeyDown;
        this.providedHandleKeyDown = handleKeyDown;
    }
    wireBeans(beans) {
        this.focusService = beans.focusService;
    }
    postConstruct() {
        this.createManagedBean(new $7b57b57eaf5a9648$export$5510e53ed3962582(this.eFocusableElement, {
            shouldStopEventPropagation: ()=>this.shouldStopEventPropagation(),
            onTabKeyDown: (e)=>this.onTabKeyDown(e),
            handleKeyDown: (e)=>this.handleKeyDown(e),
            onFocusIn: (e)=>this.onFocusIn(e),
            onFocusOut: (e)=>this.onFocusOut(e)
        }));
        this.activateTabGuards();
        [
            this.eTopGuard,
            this.eBottomGuard
        ].forEach((guard)=>this.addManagedElementListeners(guard, {
                focus: this.onFocus.bind(this)
            }));
    }
    handleKeyDown(e) {
        if (this.providedHandleKeyDown) this.providedHandleKeyDown(e);
    }
    tabGuardsAreActive() {
        return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
    }
    shouldStopEventPropagation() {
        if (this.providedShouldStopEventPropagation) return this.providedShouldStopEventPropagation();
        return false;
    }
    activateTabGuards() {
        if (this.forcingFocusOut) return;
        const tabIndex = this.gos.get("tabIndex");
        this.comp.setTabIndex(tabIndex.toString());
    }
    deactivateTabGuards() {
        this.comp.setTabIndex();
    }
    onFocus(e) {
        if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget)) {
            if (!this.allowFocus) {
                this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
                return;
            }
        }
        if (this.skipTabGuardFocus) {
            this.skipTabGuardFocus = false;
            return;
        }
        if (this.forceFocusOutWhenTabGuardsAreEmpty) {
            const isEmpty = this.focusService.findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0;
            if (isEmpty) {
                this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
                return;
            }
        }
        if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget)) return;
        const fromBottom = e.target === this.eBottomGuard;
        if (this.providedFocusInnerElement) this.providedFocusInnerElement(fromBottom);
        else this.focusInnerElement(fromBottom);
    }
    findNextElementOutsideAndFocus(up) {
        const eDocument = this.gos.getDocument();
        const focusableEls = this.focusService.findFocusableElements(eDocument.body, null, true);
        const index = focusableEls.indexOf(up ? this.eTopGuard : this.eBottomGuard);
        if (index === -1) return;
        let start;
        let end;
        if (up) {
            start = 0;
            end = index;
        } else {
            start = index + 1;
            end = focusableEls.length;
        }
        const focusableRange = focusableEls.slice(start, end);
        const targetTabIndex = this.gos.get("tabIndex");
        focusableRange.sort((a, b)=>{
            const indexA = parseInt(a.getAttribute("tabindex") || "0");
            const indexB = parseInt(b.getAttribute("tabindex") || "0");
            if (indexB === targetTabIndex) return 1;
            if (indexA === targetTabIndex) return -1;
            if (indexA === 0) return 1;
            if (indexB === 0) return -1;
            return indexA - indexB;
        });
        focusableRange[up ? focusableRange.length - 1 : 0].focus();
    }
    onFocusIn(e) {
        if (this.focusTrapActive || this.forcingFocusOut) return;
        if (this.providedFocusIn) this.providedFocusIn(e);
        if (!this.isFocusableContainer) this.deactivateTabGuards();
    }
    onFocusOut(e) {
        if (this.focusTrapActive) return;
        if (this.providedFocusOut) this.providedFocusOut(e);
        if (!this.eFocusableElement.contains(e.relatedTarget)) this.activateTabGuards();
    }
    onTabKeyDown(e) {
        if (this.providedOnTabKeyDown) {
            this.providedOnTabKeyDown(e);
            return;
        }
        if (this.focusTrapActive) return;
        if (e.defaultPrevented) return;
        const tabGuardsAreActive = this.tabGuardsAreActive();
        if (tabGuardsAreActive) this.deactivateTabGuards();
        const nextRoot = this.getNextFocusableElement(e.shiftKey);
        if (tabGuardsAreActive) setTimeout(()=>this.activateTabGuards(), 0);
        if (!nextRoot) return;
        nextRoot.focus();
        e.preventDefault();
    }
    focusInnerElement(fromBottom = false) {
        const focusable = this.focusService.findFocusableElements(this.eFocusableElement);
        if (this.tabGuardsAreActive()) {
            focusable.splice(0, 1);
            focusable.splice(focusable.length - 1, 1);
        }
        if (!focusable.length) return;
        focusable[fromBottom ? focusable.length - 1 : 0].focus({
            preventScroll: true
        });
    }
    getNextFocusableElement(backwards) {
        return this.focusService.findNextFocusableElement(this.eFocusableElement, false, backwards);
    }
    forceFocusOutOfContainer(up = false) {
        if (this.forcingFocusOut) return;
        const tabGuardToFocus = up ? this.eTopGuard : this.eBottomGuard;
        this.activateTabGuards();
        this.skipTabGuardFocus = true;
        this.forcingFocusOut = true;
        tabGuardToFocus.focus();
        window.setTimeout(()=>{
            this.forcingFocusOut = false;
            this.activateTabGuards();
        });
    }
    isTabGuard(element, bottom) {
        return element === this.eTopGuard && !bottom || element === this.eBottomGuard && (bottom ?? true);
    }
    setAllowFocus(allowFocus) {
        this.allowFocus = allowFocus;
    }
};
// community-modules/core/src/widgets/tabGuardFeature.ts
var $7b57b57eaf5a9648$export$299cbf451479e921 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(comp){
        super();
        this.comp = comp;
    }
    initialiseTabGuard(params) {
        this.eTopGuard = this.createTabGuard("top");
        this.eBottomGuard = this.createTabGuard("bottom");
        this.eFocusableElement = this.comp.getFocusableElement();
        const { eTopGuard: eTopGuard , eBottomGuard: eBottomGuard , eFocusableElement: eFocusableElement  } = this;
        const tabGuards = [
            eTopGuard,
            eBottomGuard
        ];
        const compProxy = {
            setTabIndex: (tabIndex)=>{
                tabGuards.forEach((tabGuard)=>tabIndex != null ? tabGuard.setAttribute("tabindex", tabIndex) : tabGuard.removeAttribute("tabindex"));
            }
        };
        this.addTabGuards(eTopGuard, eBottomGuard);
        const { focusTrapActive: focusTrapActive = false , onFocusIn: onFocusIn , onFocusOut: onFocusOut , focusInnerElement: focusInnerElement , handleKeyDown: handleKeyDown , onTabKeyDown: onTabKeyDown , shouldStopEventPropagation: shouldStopEventPropagation , forceFocusOutWhenTabGuardsAreEmpty: forceFocusOutWhenTabGuardsAreEmpty , isFocusableContainer: isFocusableContainer  } = params;
        this.tabGuardCtrl = this.createManagedBean(new $7b57b57eaf5a9648$export$3074753638c3772c({
            comp: compProxy,
            focusTrapActive: focusTrapActive,
            eTopGuard: eTopGuard,
            eBottomGuard: eBottomGuard,
            eFocusableElement: eFocusableElement,
            onFocusIn: onFocusIn,
            onFocusOut: onFocusOut,
            focusInnerElement: focusInnerElement,
            handleKeyDown: handleKeyDown,
            onTabKeyDown: onTabKeyDown,
            shouldStopEventPropagation: shouldStopEventPropagation,
            forceFocusOutWhenTabGuardsAreEmpty: forceFocusOutWhenTabGuardsAreEmpty,
            isFocusableContainer: isFocusableContainer
        }));
    }
    getTabGuardCtrl() {
        return this.tabGuardCtrl;
    }
    createTabGuard(side) {
        const tabGuard = this.gos.getDocument().createElement("div");
        const cls = side === "top" ? "ag-tab-guard-top" /* TAB_GUARD_TOP */  : "ag-tab-guard-bottom" /* TAB_GUARD_BOTTOM */ ;
        tabGuard.classList.add("ag-tab-guard" /* TAB_GUARD */ , cls);
        $7b57b57eaf5a9648$export$f8d01fa01787902(tabGuard, "presentation");
        return tabGuard;
    }
    addTabGuards(topTabGuard, bottomTabGuard) {
        this.eFocusableElement.insertAdjacentElement("afterbegin", topTabGuard);
        this.eFocusableElement.insertAdjacentElement("beforeend", bottomTabGuard);
    }
    removeAllChildrenExceptTabGuards() {
        const tabGuards = [
            this.eTopGuard,
            this.eBottomGuard
        ];
        $7b57b57eaf5a9648$export$69e6e10709eabd91(this.comp.getFocusableElement());
        this.addTabGuards(...tabGuards);
    }
    forceFocusOutOfContainer(up = false) {
        this.tabGuardCtrl.forceFocusOutOfContainer(up);
    }
    appendChild(appendChild, newChild, container) {
        if (!$7b57b57eaf5a9648$export$6e6303ef478b0c94(newChild)) newChild = newChild.getGui();
        const { eBottomGuard: bottomTabGuard  } = this;
        if (bottomTabGuard) bottomTabGuard.insertAdjacentElement("beforebegin", newChild);
        else appendChild(newChild, container);
    }
};
// community-modules/core/src/widgets/tabGuardComp.ts
var $7b57b57eaf5a9648$export$5a26e3abd1c845b6 = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    initialiseTabGuard(params) {
        this.tabGuardFeature = this.createManagedBean(new $7b57b57eaf5a9648$export$299cbf451479e921(this));
        this.tabGuardFeature.initialiseTabGuard(params);
    }
    forceFocusOutOfContainer(up = false) {
        this.tabGuardFeature.forceFocusOutOfContainer(up);
    }
    appendChild(newChild, container) {
        this.tabGuardFeature.appendChild(super.appendChild.bind(this), newChild, container);
    }
};
// community-modules/core/src/widgets/popupService.ts
var $7b57b57eaf5a9648$var$instanceIdSeq = 0;
var $7b57b57eaf5a9648$var$WAIT_FOR_POPUP_CONTENT_RESIZE = 200;
var $7b57b57eaf5a9648$export$27497a369f7303c1 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "popupService";
        this.popupList = [];
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
        this.resizeObserverService = beans.resizeObserverService;
        this.environment = beans.environment;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            this.gridCtrl = p.gridCtrl;
        });
        this.addManagedEventListeners({
            gridStylesChanged: this.handleThemeChange.bind(this)
        });
    }
    getPopupParent() {
        const ePopupParent = this.gos.get("popupParent");
        if (ePopupParent) return ePopupParent;
        return this.gridCtrl.getGui();
    }
    positionPopupForMenu(params) {
        const { eventSource: eventSource , ePopup: ePopup  } = params;
        const popupIdx = this.getPopupIndex(ePopup);
        if (popupIdx !== -1) {
            const popup = this.popupList[popupIdx];
            popup.alignedToElement = eventSource;
        }
        const sourceRect = eventSource.getBoundingClientRect();
        const parentRect = this.getParentRect();
        const y = this.keepXYWithinBounds(ePopup, sourceRect.top - parentRect.top, 0 /* vertical */ );
        const minWidth = ePopup.clientWidth > 0 ? ePopup.clientWidth : 200;
        ePopup.style.minWidth = `${minWidth}px`;
        const widthOfParent = parentRect.right - parentRect.left;
        const maxX = widthOfParent - minWidth;
        let x;
        if (this.gos.get("enableRtl")) {
            x = xLeftPosition();
            if (x < 0) {
                x = xRightPosition();
                this.setAlignedStyles(ePopup, "left");
            }
            if (x > maxX) {
                x = 0;
                this.setAlignedStyles(ePopup, "right");
            }
        } else {
            x = xRightPosition();
            if (x > maxX) {
                x = xLeftPosition();
                this.setAlignedStyles(ePopup, "right");
            }
            if (x < 0) {
                x = 0;
                this.setAlignedStyles(ePopup, "left");
            }
        }
        ePopup.style.left = `${x}px`;
        ePopup.style.top = `${y}px`;
        function xRightPosition() {
            return sourceRect.right - parentRect.left - 2;
        }
        function xLeftPosition() {
            return sourceRect.left - parentRect.left - minWidth;
        }
    }
    positionPopupUnderMouseEvent(params) {
        const { ePopup: ePopup , nudgeX: nudgeX , nudgeY: nudgeY , skipObserver: skipObserver  } = params;
        this.positionPopup({
            ePopup: ePopup,
            nudgeX: nudgeX,
            nudgeY: nudgeY,
            keepWithinBounds: true,
            skipObserver: skipObserver,
            updatePosition: ()=>this.calculatePointerAlign(params.mouseEvent),
            postProcessCallback: ()=>this.callPostProcessPopup(params.type, params.ePopup, null, params.mouseEvent, params.column, params.rowNode)
        });
    }
    calculatePointerAlign(e) {
        const parentRect = this.getParentRect();
        return {
            x: e.clientX - parentRect.left,
            y: e.clientY - parentRect.top
        };
    }
    positionPopupByComponent(params) {
        const { ePopup: ePopup , nudgeX: nudgeX , nudgeY: nudgeY , keepWithinBounds: keepWithinBounds , eventSource: eventSource , alignSide: alignSide = "left" , position: position = "over" , column: column , rowNode: rowNode , type: type  } = params;
        const sourceRect = eventSource.getBoundingClientRect();
        const parentRect = this.getParentRect();
        const popupIdx = this.getPopupIndex(ePopup);
        if (popupIdx !== -1) {
            const popup = this.popupList[popupIdx];
            popup.alignedToElement = eventSource;
        }
        const updatePosition = ()=>{
            let x = sourceRect.left - parentRect.left;
            if (alignSide === "right") x -= ePopup.offsetWidth - sourceRect.width;
            let y;
            if (position === "over") {
                y = sourceRect.top - parentRect.top;
                this.setAlignedStyles(ePopup, "over");
            } else {
                this.setAlignedStyles(ePopup, "under");
                const alignSide2 = this.shouldRenderUnderOrAbove(ePopup, sourceRect, parentRect, params.nudgeY || 0);
                if (alignSide2 === "under") y = sourceRect.top - parentRect.top + sourceRect.height;
                else y = sourceRect.top - ePopup.offsetHeight - (nudgeY || 0) * 2 - parentRect.top;
            }
            return {
                x: x,
                y: y
            };
        };
        this.positionPopup({
            ePopup: ePopup,
            nudgeX: nudgeX,
            nudgeY: nudgeY,
            keepWithinBounds: keepWithinBounds,
            updatePosition: updatePosition,
            postProcessCallback: ()=>this.callPostProcessPopup(type, ePopup, eventSource, null, column, rowNode)
        });
    }
    shouldRenderUnderOrAbove(ePopup, targetCompRect, parentRect, nudgeY) {
        const spaceAvailableUnder = parentRect.bottom - targetCompRect.bottom;
        const spaceAvailableAbove = targetCompRect.top - parentRect.top;
        const spaceRequired = ePopup.offsetHeight + nudgeY;
        if (spaceAvailableUnder > spaceRequired) return "under";
        if (spaceAvailableAbove > spaceRequired || spaceAvailableAbove > spaceAvailableUnder) return "above";
        return "under";
    }
    setAlignedStyles(ePopup, positioned) {
        const popupIdx = this.getPopupIndex(ePopup);
        if (popupIdx === -1) return;
        const popup = this.popupList[popupIdx];
        const { alignedToElement: alignedToElement  } = popup;
        if (!alignedToElement) return;
        const positions = [
            "right",
            "left",
            "over",
            "above",
            "under"
        ];
        positions.forEach((position)=>{
            alignedToElement.classList.remove(`ag-has-popup-positioned-${position}`);
            ePopup.classList.remove(`ag-popup-positioned-${position}`);
        });
        if (!positioned) return;
        alignedToElement.classList.add(`ag-has-popup-positioned-${positioned}`);
        ePopup.classList.add(`ag-popup-positioned-${positioned}`);
    }
    callPostProcessPopup(type, ePopup, eventSource, mouseEvent, column, rowNode) {
        const callback = this.gos.getCallback("postProcessPopup");
        if (callback) {
            const params = {
                column: column,
                rowNode: rowNode,
                ePopup: ePopup,
                type: type,
                eventSource: eventSource,
                mouseEvent: mouseEvent
            };
            callback(params);
        }
    }
    positionPopup(params) {
        const { ePopup: ePopup , keepWithinBounds: keepWithinBounds , nudgeX: nudgeX , nudgeY: nudgeY , skipObserver: skipObserver , updatePosition: updatePosition  } = params;
        const lastSize = {
            width: 0,
            height: 0
        };
        const updatePopupPosition = (fromResizeObserver = false)=>{
            let { x: x , y: y  } = updatePosition();
            if (fromResizeObserver && ePopup.clientWidth === lastSize.width && ePopup.clientHeight === lastSize.height) return;
            lastSize.width = ePopup.clientWidth;
            lastSize.height = ePopup.clientHeight;
            if (nudgeX) x += nudgeX;
            if (nudgeY) y += nudgeY;
            if (keepWithinBounds) {
                x = this.keepXYWithinBounds(ePopup, x, 1 /* horizontal */ );
                y = this.keepXYWithinBounds(ePopup, y, 0 /* vertical */ );
            }
            ePopup.style.left = `${x}px`;
            ePopup.style.top = `${y}px`;
            if (params.postProcessCallback) params.postProcessCallback();
        };
        updatePopupPosition();
        if (!skipObserver) {
            const resizeObserverDestroyFunc = this.resizeObserverService.observeResize(ePopup, ()=>updatePopupPosition(true));
            setTimeout(()=>resizeObserverDestroyFunc(), $7b57b57eaf5a9648$var$WAIT_FOR_POPUP_CONTENT_RESIZE);
        }
    }
    getActivePopups() {
        return this.popupList.map((popup)=>popup.element);
    }
    getPopupList() {
        return this.popupList;
    }
    getParentRect() {
        const eDocument = this.gos.getDocument();
        let popupParent = this.getPopupParent();
        if (popupParent === eDocument.body) popupParent = eDocument.documentElement;
        else if (getComputedStyle(popupParent).position === "static") popupParent = popupParent.offsetParent;
        return $7b57b57eaf5a9648$var$_getElementRectWithOffset(popupParent);
    }
    keepXYWithinBounds(ePopup, position, direction) {
        const isVertical = direction === 0 /* vertical */ ;
        const sizeProperty = isVertical ? "clientHeight" : "clientWidth";
        const anchorProperty = isVertical ? "top" : "left";
        const offsetProperty = isVertical ? "height" : "width";
        const scrollPositionProperty = isVertical ? "scrollTop" : "scrollLeft";
        const eDocument = this.gos.getDocument();
        const docElement = eDocument.documentElement;
        const popupParent = this.getPopupParent();
        const popupRect = ePopup.getBoundingClientRect();
        const parentRect = popupParent.getBoundingClientRect();
        const documentRect = eDocument.documentElement.getBoundingClientRect();
        const isBody = popupParent === eDocument.body;
        const offsetSize = Math.ceil(popupRect[offsetProperty]);
        const getSize = isVertical ? $7b57b57eaf5a9648$export$d23c22492e0f7c0c : $7b57b57eaf5a9648$export$642efcb17474eb51;
        let sizeOfParent = isBody ? getSize(docElement) + docElement[scrollPositionProperty] : popupParent[sizeProperty];
        if (isBody) sizeOfParent -= Math.abs(documentRect[anchorProperty] - parentRect[anchorProperty]);
        const max = sizeOfParent - offsetSize;
        return Math.min(Math.max(position, 0), Math.abs(max));
    }
    addPopup(params) {
        const eDocument = this.gos.getDocument();
        const { eChild: eChild , ariaLabel: ariaLabel , alwaysOnTop: alwaysOnTop , positionCallback: positionCallback , anchorToElement: anchorToElement  } = params;
        if (!eDocument) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("could not find the document, document is empty");
            return {
                hideFunc: ()=>{}
            };
        }
        const pos = this.getPopupIndex(eChild);
        if (pos !== -1) {
            const popup = this.popupList[pos];
            return {
                hideFunc: popup.hideFunc
            };
        }
        this.initialisePopupPosition(eChild);
        const wrapperEl = this.createPopupWrapper(eChild, ariaLabel, !!alwaysOnTop);
        const removeListeners = this.addEventListenersToPopup({
            ...params,
            wrapperEl: wrapperEl
        });
        if (positionCallback) positionCallback();
        this.addPopupToPopupList(eChild, wrapperEl, removeListeners, anchorToElement);
        return {
            hideFunc: removeListeners
        };
    }
    initialisePopupPosition(element) {
        const ePopupParent = this.getPopupParent();
        const ePopupParentRect = ePopupParent.getBoundingClientRect();
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(element.style.top)) element.style.top = `${ePopupParentRect.top * -1}px`;
        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(element.style.left)) element.style.left = `${ePopupParentRect.left * -1}px`;
    }
    createPopupWrapper(element, ariaLabel, alwaysOnTop) {
        const ePopupParent = this.getPopupParent();
        const eWrapper = document.createElement("div");
        this.environment.applyThemeClasses(eWrapper);
        eWrapper.classList.add("ag-popup");
        element.classList.add(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child");
        if (!element.hasAttribute("role")) $7b57b57eaf5a9648$export$f8d01fa01787902(element, "dialog");
        $7b57b57eaf5a9648$export$e81cb0dd07f289f6(element, ariaLabel);
        eWrapper.appendChild(element);
        ePopupParent.appendChild(eWrapper);
        if (alwaysOnTop) this.setAlwaysOnTop(element, true);
        else this.bringPopupToFront(element);
        return eWrapper;
    }
    handleThemeChange(e) {
        if (e.themeChanged) for (const popup of this.popupList)this.environment.applyThemeClasses(popup.wrapper);
    }
    addEventListenersToPopup(params) {
        const eDocument = this.gos.getDocument();
        const ePopupParent = this.getPopupParent();
        const { wrapperEl: wrapperEl , eChild: popupEl , closedCallback: closedCallback , afterGuiAttached: afterGuiAttached , closeOnEsc: closeOnEsc , modal: modal  } = params;
        let popupHidden = false;
        const hidePopupOnKeyboardEvent = (event)=>{
            if (!wrapperEl.contains(this.gos.getActiveDomElement())) return;
            const key = event.key;
            if (key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ESCAPE && !$7b57b57eaf5a9648$export$9a48e23524c6d58(event)) removeListeners({
                keyboardEvent: event
            });
        };
        const hidePopupOnMouseEvent = (event)=>removeListeners({
                mouseEvent: event
            });
        const hidePopupOnTouchEvent = (event)=>removeListeners({
                touchEvent: event
            });
        const removeListeners = (popupParams = {})=>{
            const { mouseEvent: mouseEvent , touchEvent: touchEvent , keyboardEvent: keyboardEvent , forceHide: forceHide  } = popupParams;
            if (!forceHide && // we don't hide popup if the event was on the child, or any
            // children of this child
            (this.isEventFromCurrentPopup({
                mouseEvent: mouseEvent,
                touchEvent: touchEvent
            }, popupEl) || // this method should only be called once. the client can have different
            // paths, each one wanting to close, so this method may be called multiple times.
            popupHidden)) return;
            popupHidden = true;
            ePopupParent.removeChild(wrapperEl);
            eDocument.removeEventListener("keydown", hidePopupOnKeyboardEvent);
            eDocument.removeEventListener("mousedown", hidePopupOnMouseEvent);
            eDocument.removeEventListener("touchstart", hidePopupOnTouchEvent);
            eDocument.removeEventListener("contextmenu", hidePopupOnMouseEvent);
            this.eventService.removeEventListener("dragStarted", hidePopupOnMouseEvent);
            if (closedCallback) closedCallback(mouseEvent || touchEvent || keyboardEvent);
            this.removePopupFromPopupList(popupEl);
        };
        if (afterGuiAttached) afterGuiAttached({
            hidePopup: removeListeners
        });
        window.setTimeout(()=>{
            if (closeOnEsc) eDocument.addEventListener("keydown", hidePopupOnKeyboardEvent);
            if (modal) {
                eDocument.addEventListener("mousedown", hidePopupOnMouseEvent);
                this.eventService.addEventListener("dragStarted", hidePopupOnMouseEvent);
                eDocument.addEventListener("touchstart", hidePopupOnTouchEvent);
                eDocument.addEventListener("contextmenu", hidePopupOnMouseEvent);
            }
        }, 0);
        return removeListeners;
    }
    addPopupToPopupList(element, wrapperEl, removeListeners, anchorToElement) {
        this.popupList.push({
            element: element,
            wrapper: wrapperEl,
            hideFunc: removeListeners,
            instanceId: $7b57b57eaf5a9648$var$instanceIdSeq++,
            isAnchored: !!anchorToElement
        });
        if (anchorToElement) this.setPopupPositionRelatedToElement(element, anchorToElement);
    }
    getPopupIndex(el) {
        return this.popupList.findIndex((p)=>p.element === el);
    }
    setPopupPositionRelatedToElement(popupEl, relativeElement) {
        const popupIndex = this.getPopupIndex(popupEl);
        if (popupIndex === -1) return;
        const popup = this.popupList[popupIndex];
        if (popup.stopAnchoringPromise) popup.stopAnchoringPromise.then((destroyFunc)=>destroyFunc && destroyFunc());
        popup.stopAnchoringPromise = void 0;
        popup.isAnchored = false;
        if (!relativeElement) return;
        const destroyPositionTracker = this.keepPopupPositionedRelativeTo({
            element: relativeElement,
            ePopup: popupEl,
            hidePopup: popup.hideFunc
        });
        popup.stopAnchoringPromise = destroyPositionTracker;
        popup.isAnchored = true;
        return destroyPositionTracker;
    }
    removePopupFromPopupList(element) {
        this.setAlignedStyles(element, null);
        this.setPopupPositionRelatedToElement(element, null);
        this.popupList = this.popupList.filter((p)=>p.element !== element);
    }
    keepPopupPositionedRelativeTo(params) {
        const eParent = this.getPopupParent();
        const parentRect = eParent.getBoundingClientRect();
        const { element: element , ePopup: ePopup  } = params;
        const sourceRect = element.getBoundingClientRect();
        const initialDiffTop = parentRect.top - sourceRect.top;
        const initialDiffLeft = parentRect.left - sourceRect.left;
        let lastDiffTop = initialDiffTop;
        let lastDiffLeft = initialDiffLeft;
        const topPx = ePopup.style.top;
        const top = parseInt(topPx.substring(0, topPx.length - 1), 10);
        const leftPx = ePopup.style.left;
        const left = parseInt(leftPx.substring(0, leftPx.length - 1), 10);
        const fwOverrides = this.getFrameworkOverrides();
        return new $7b57b57eaf5a9648$export$30ec7836a4847721((resolve)=>{
            fwOverrides.wrapIncoming(()=>{
                fwOverrides.setInterval(()=>{
                    const pRect = eParent.getBoundingClientRect();
                    const sRect = element.getBoundingClientRect();
                    const elementNotInDom = sRect.top == 0 && sRect.left == 0 && sRect.height == 0 && sRect.width == 0;
                    if (elementNotInDom) {
                        params.hidePopup();
                        return;
                    }
                    const currentDiffTop = pRect.top - sRect.top;
                    if (currentDiffTop != lastDiffTop) {
                        const newTop = this.keepXYWithinBounds(ePopup, top + initialDiffTop - currentDiffTop, 0 /* vertical */ );
                        ePopup.style.top = `${newTop}px`;
                    }
                    lastDiffTop = currentDiffTop;
                    const currentDiffLeft = pRect.left - sRect.left;
                    if (currentDiffLeft != lastDiffLeft) {
                        const newLeft = this.keepXYWithinBounds(ePopup, left + initialDiffLeft - currentDiffLeft, 1 /* horizontal */ );
                        ePopup.style.left = `${newLeft}px`;
                    }
                    lastDiffLeft = currentDiffLeft;
                }, 200).then((intervalId)=>{
                    const result = ()=>{
                        if (intervalId != null) window.clearInterval(intervalId);
                    };
                    resolve(result);
                });
            }, "popupPositioning");
        });
    }
    hasAnchoredPopup() {
        return this.popupList.some((popup)=>popup.isAnchored);
    }
    isEventFromCurrentPopup(params, target) {
        const { mouseEvent: mouseEvent , touchEvent: touchEvent  } = params;
        const event = mouseEvent ? mouseEvent : touchEvent;
        if (!event) return false;
        const indexOfThisChild = this.getPopupIndex(target);
        if (indexOfThisChild === -1) return false;
        for(let i = indexOfThisChild; i < this.popupList.length; i++){
            const popup = this.popupList[i];
            if ($7b57b57eaf5a9648$export$b5446458166e97b4(popup.element, event)) return true;
        }
        return this.isElementWithinCustomPopup(event.target);
    }
    isElementWithinCustomPopup(el) {
        const eDocument = this.gos.getDocument();
        while(el && el !== eDocument.body){
            if (el.classList.contains("ag-custom-component-popup") || el.parentElement === null) return true;
            el = el.parentElement;
        }
        return false;
    }
    getWrapper(ePopup) {
        while(!ePopup.classList.contains("ag-popup") && ePopup.parentElement)ePopup = ePopup.parentElement;
        return ePopup.classList.contains("ag-popup") ? ePopup : null;
    }
    setAlwaysOnTop(ePopup, alwaysOnTop) {
        const eWrapper = this.getWrapper(ePopup);
        if (!eWrapper) return;
        eWrapper.classList.toggle("ag-always-on-top", !!alwaysOnTop);
        if (alwaysOnTop) this.bringPopupToFront(eWrapper);
    }
    /** @return true if moved */ bringPopupToFront(ePopup) {
        const parent = this.getPopupParent();
        const popupList = Array.prototype.slice.call(parent.querySelectorAll(".ag-popup"));
        const popupLen = popupList.length;
        const alwaysOnTopList = Array.prototype.slice.call(parent.querySelectorAll(".ag-popup.ag-always-on-top"));
        const onTopLength = alwaysOnTopList.length;
        const eWrapper = this.getWrapper(ePopup);
        if (!eWrapper || popupLen <= 1 || !parent.contains(ePopup)) return false;
        const pos = popupList.indexOf(eWrapper);
        const innerEls = eWrapper.querySelectorAll("div");
        const innerElsScrollMap = [];
        innerEls.forEach((el)=>{
            if (el.scrollTop !== 0) innerElsScrollMap.push([
                el,
                el.scrollTop
            ]);
        });
        let result = false;
        if (onTopLength) {
            const isPopupAlwaysOnTop = eWrapper.classList.contains("ag-always-on-top");
            if (isPopupAlwaysOnTop) {
                if (pos !== popupLen - 1) {
                    $7b57b57eaf5a9648$export$236389741107357f(alwaysOnTopList).insertAdjacentElement("afterend", eWrapper);
                    result = true;
                }
            } else if (pos !== popupLen - onTopLength - 1) {
                alwaysOnTopList[0].insertAdjacentElement("beforebegin", eWrapper);
                result = true;
            }
        } else if (pos !== popupLen - 1) {
            $7b57b57eaf5a9648$export$236389741107357f(popupList).insertAdjacentElement("afterend", eWrapper);
            result = true;
        }
        while(innerElsScrollMap.length){
            const currentEl = innerElsScrollMap.pop();
            currentEl[0].scrollTop = currentEl[1];
        }
        return result;
    }
};
// community-modules/core/src/vanillaFrameworkOverrides.ts
var $7b57b57eaf5a9648$var$PASSIVE_EVENTS2 = [
    "touchstart",
    "touchend",
    "touchmove",
    "touchcancel"
];
var $7b57b57eaf5a9648$export$8174ad74937c6482 = class {
    constructor(frameworkName = "javascript"){
        this.frameworkName = frameworkName;
        this.renderingEngine = "vanilla";
        this.wrapIncoming = (callback)=>callback();
        this.wrapOutgoing = (callback)=>callback();
    }
    setInterval(action, timeout) {
        return new $7b57b57eaf5a9648$export$30ec7836a4847721((resolve)=>{
            resolve(window.setInterval(action, timeout));
        });
    }
    // for Vanilla JS, we just add the event to the element
    addEventListener(element, type, listener, useCapture) {
        const isPassive = $7b57b57eaf5a9648$export$fccf016a6caa651d($7b57b57eaf5a9648$var$PASSIVE_EVENTS2, type);
        element.addEventListener(type, listener, {
            capture: !!useCapture,
            passive: isPassive
        });
    }
    get shouldWrapOutgoing() {
        return false;
    }
    frameworkComponent(name) {
        return null;
    }
    isFrameworkComponent(comp) {
        return false;
    }
    getDocLink(path) {
        const framework = this.frameworkName === "solid" ? "react" : this.frameworkName;
        return `https://www.ag-grid.com/${framework}-data-grid${path ? `/${path}` : ""}`;
    }
};
// community-modules/core/src/cellNavigationService.ts
var $7b57b57eaf5a9648$export$672e779a12850b13 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "cellNavigationService";
    }
    wireBeans(beans) {
        this.visibleColsService = beans.visibleColsService;
        this.rowModel = beans.rowModel;
        this.rowRenderer = beans.rowRenderer;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.paginationService = beans.paginationService;
        this.pageBoundsService = beans.pageBoundsService;
    }
    // returns null if no cell to focus on, ie at the end of the grid
    getNextCellToFocus(key, focusedCell, ctrlPressed = false) {
        if (ctrlPressed) return this.getNextCellToFocusWithCtrlPressed(key, focusedCell);
        return this.getNextCellToFocusWithoutCtrlPressed(key, focusedCell);
    }
    getNextCellToFocusWithCtrlPressed(key, focusedCell) {
        const upKey = key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP;
        const downKey = key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN;
        const leftKey = key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT;
        let column;
        let rowIndex;
        if (upKey || downKey) {
            rowIndex = upKey ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow();
            column = focusedCell.column;
        } else {
            const allColumns = this.visibleColsService.getAllCols();
            const isRtl = this.gos.get("enableRtl");
            rowIndex = focusedCell.rowIndex;
            column = leftKey !== isRtl ? allColumns[0] : $7b57b57eaf5a9648$export$236389741107357f(allColumns);
        }
        return {
            rowIndex: rowIndex,
            rowPinned: null,
            column: column
        };
    }
    getNextCellToFocusWithoutCtrlPressed(key, focusedCell) {
        let pointer = focusedCell;
        let finished = false;
        while(!finished){
            switch(key){
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.UP:
                    pointer = this.getCellAbove(pointer);
                    break;
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.DOWN:
                    pointer = this.getCellBelow(pointer);
                    break;
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.RIGHT:
                    if (this.gos.get("enableRtl")) pointer = this.getCellToLeft(pointer);
                    else pointer = this.getCellToRight(pointer);
                    break;
                case $7b57b57eaf5a9648$export$e9e0d96f49f57c33.LEFT:
                    if (this.gos.get("enableRtl")) pointer = this.getCellToRight(pointer);
                    else pointer = this.getCellToLeft(pointer);
                    break;
                default:
                    pointer = null;
                    $7b57b57eaf5a9648$export$2cf41453020eef66("unknown key for navigation ", key);
                    break;
            }
            if (pointer) finished = this.isCellGoodToFocusOn(pointer);
            else finished = true;
        }
        return pointer;
    }
    isCellGoodToFocusOn(gridCell) {
        const column = gridCell.column;
        let rowNode;
        switch(gridCell.rowPinned){
            case "top":
                rowNode = this.pinnedRowModel.getPinnedTopRow(gridCell.rowIndex);
                break;
            case "bottom":
                rowNode = this.pinnedRowModel.getPinnedBottomRow(gridCell.rowIndex);
                break;
            default:
                rowNode = this.rowModel.getRow(gridCell.rowIndex);
                break;
        }
        if (!rowNode) return false;
        const suppressNavigable = column.isSuppressNavigable(rowNode);
        return !suppressNavigable;
    }
    getCellToLeft(lastCell) {
        if (!lastCell) return null;
        const colToLeft = this.visibleColsService.getColBefore(lastCell.column);
        if (!colToLeft) return null;
        return {
            rowIndex: lastCell.rowIndex,
            column: colToLeft,
            rowPinned: lastCell.rowPinned
        };
    }
    getCellToRight(lastCell) {
        if (!lastCell) return null;
        const colToRight = this.visibleColsService.getColAfter(lastCell.column);
        if (!colToRight) return null;
        return {
            rowIndex: lastCell.rowIndex,
            column: colToRight,
            rowPinned: lastCell.rowPinned
        };
    }
    getRowBelow(rowPosition) {
        const index = rowPosition.rowIndex;
        const pinned = rowPosition.rowPinned;
        if (this.isLastRowInContainer(rowPosition)) switch(pinned){
            case "bottom":
                return null;
            case "top":
                if (this.rowModel.isRowsToRender()) return {
                    rowIndex: this.pageBoundsService.getFirstRow(),
                    rowPinned: null
                };
                if (this.pinnedRowModel.isRowsToRender("bottom")) return {
                    rowIndex: 0,
                    rowPinned: "bottom"
                };
                return null;
            default:
                if (this.pinnedRowModel.isRowsToRender("bottom")) return {
                    rowIndex: 0,
                    rowPinned: "bottom"
                };
                return null;
        }
        const rowNode = this.rowModel.getRow(rowPosition.rowIndex);
        const nextStickyPosition = this.getNextStickyPosition(rowNode);
        if (nextStickyPosition) return nextStickyPosition;
        return {
            rowIndex: index + 1,
            rowPinned: pinned
        };
    }
    getNextStickyPosition(rowNode, up) {
        if (!this.gos.isGroupRowsSticky() || !rowNode || !rowNode.sticky) return;
        const isTopCtrls = this.rowRenderer.getStickyTopRowCtrls().some((ctrl)=>ctrl.getRowNode().rowIndex === rowNode.rowIndex);
        let stickyRowCtrls = [];
        if (isTopCtrls) stickyRowCtrls = [
            ...this.rowRenderer.getStickyTopRowCtrls()
        ].sort((a, b)=>a.getRowNode().rowIndex - b.getRowNode().rowIndex);
        else stickyRowCtrls = [
            ...this.rowRenderer.getStickyBottomRowCtrls()
        ].sort((a, b)=>b.getRowNode().rowIndex - a.getRowNode().rowIndex);
        const diff = up ? -1 : 1;
        const idx = stickyRowCtrls.findIndex((ctrl)=>ctrl.getRowNode().rowIndex === rowNode.rowIndex);
        const nextCtrl = stickyRowCtrls[idx + diff];
        if (nextCtrl) return {
            rowIndex: nextCtrl.getRowNode().rowIndex,
            rowPinned: null
        };
    }
    getCellBelow(lastCell) {
        if (!lastCell) return null;
        const rowBelow = this.getRowBelow(lastCell);
        if (rowBelow) return {
            rowIndex: rowBelow.rowIndex,
            column: lastCell.column,
            rowPinned: rowBelow.rowPinned
        };
        return null;
    }
    isLastRowInContainer(rowPosition) {
        const pinned = rowPosition.rowPinned;
        const index = rowPosition.rowIndex;
        if (pinned === "top") {
            const lastTopIndex = this.pinnedRowModel.getPinnedTopRowNodes().length - 1;
            return lastTopIndex <= index;
        }
        if (pinned === "bottom") {
            const lastBottomIndex = this.pinnedRowModel.getPinnedBottomRowNodes().length - 1;
            return lastBottomIndex <= index;
        }
        const lastBodyIndex = this.pageBoundsService.getLastRow();
        return lastBodyIndex <= index;
    }
    getRowAbove(rowPosition) {
        const index = rowPosition.rowIndex;
        const pinned = rowPosition.rowPinned;
        const isFirstRow = pinned ? index === 0 : index === this.pageBoundsService.getFirstRow();
        if (isFirstRow) {
            if (pinned === "top") return null;
            if (!pinned) {
                if (this.pinnedRowModel.isRowsToRender("top")) return this.getLastFloatingTopRow();
                return null;
            }
            if (this.rowModel.isRowsToRender()) return this.getLastBodyCell();
            if (this.pinnedRowModel.isRowsToRender("top")) return this.getLastFloatingTopRow();
            return null;
        }
        const rowNode = this.rowModel.getRow(rowPosition.rowIndex);
        const nextStickyPosition = this.getNextStickyPosition(rowNode, true);
        if (nextStickyPosition) return nextStickyPosition;
        return {
            rowIndex: index - 1,
            rowPinned: pinned
        };
    }
    getCellAbove(lastCell) {
        if (!lastCell) return null;
        const rowAbove = this.getRowAbove({
            rowIndex: lastCell.rowIndex,
            rowPinned: lastCell.rowPinned
        });
        if (rowAbove) return {
            rowIndex: rowAbove.rowIndex,
            column: lastCell.column,
            rowPinned: rowAbove.rowPinned
        };
        return null;
    }
    getLastBodyCell() {
        const lastBodyRow = this.pageBoundsService.getLastRow();
        return {
            rowIndex: lastBodyRow,
            rowPinned: null
        };
    }
    getLastFloatingTopRow() {
        const lastFloatingRow = this.pinnedRowModel.getPinnedTopRowNodes().length - 1;
        return {
            rowIndex: lastFloatingRow,
            rowPinned: "top"
        };
    }
    getNextTabbedCell(gridCell, backwards) {
        if (backwards) return this.getNextTabbedCellBackwards(gridCell);
        return this.getNextTabbedCellForwards(gridCell);
    }
    getNextTabbedCellForwards(gridCell) {
        const displayedColumns = this.visibleColsService.getAllCols();
        let newRowIndex = gridCell.rowIndex;
        let newFloating = gridCell.rowPinned;
        let newColumn = this.visibleColsService.getColAfter(gridCell.column);
        if (!newColumn) {
            newColumn = displayedColumns[0];
            const rowBelow = this.getRowBelow(gridCell);
            if ($7b57b57eaf5a9648$export$672d9e47bc342bac(rowBelow)) return null;
            if (!rowBelow.rowPinned && !(this.paginationService?.isRowInPage(rowBelow) ?? true)) return null;
            newRowIndex = rowBelow ? rowBelow.rowIndex : null;
            newFloating = rowBelow ? rowBelow.rowPinned : null;
        }
        return {
            rowIndex: newRowIndex,
            column: newColumn,
            rowPinned: newFloating
        };
    }
    getNextTabbedCellBackwards(gridCell) {
        const displayedColumns = this.visibleColsService.getAllCols();
        let newRowIndex = gridCell.rowIndex;
        let newFloating = gridCell.rowPinned;
        let newColumn = this.visibleColsService.getColBefore(gridCell.column);
        if (!newColumn) {
            newColumn = $7b57b57eaf5a9648$export$236389741107357f(displayedColumns);
            const rowAbove = this.getRowAbove({
                rowIndex: gridCell.rowIndex,
                rowPinned: gridCell.rowPinned
            });
            if ($7b57b57eaf5a9648$export$672d9e47bc342bac(rowAbove)) return null;
            if (!rowAbove.rowPinned && !(this.paginationService?.isRowInPage(rowAbove) ?? true)) return null;
            newRowIndex = rowAbove ? rowAbove.rowIndex : null;
            newFloating = rowAbove ? rowAbove.rowPinned : null;
        }
        return {
            rowIndex: newRowIndex,
            column: newColumn,
            rowPinned: newFloating
        };
    }
};
// community-modules/core/src/api/apiFunctionService.ts
function $7b57b57eaf5a9648$var$dispatchEvent(beans, event) {
    beans.eventService.dispatchEvent(event);
}
var $7b57b57eaf5a9648$var$ApiFunctionService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "apiFunctionService";
        this.functions = {
            dispatchEvent: // this is used by frameworks
            // also used by aligned grids to identify a grid api instance
            $7b57b57eaf5a9648$var$dispatchEvent
        };
        this.isDestroyed = false;
    }
    wireBeans(beans) {
        this.beans = beans;
    }
    postConstruct() {
        this.preDestroyLink = this.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
    }
    callFunction(functionName, args) {
        const func = this.functions[functionName];
        if (func) return func.apply(func, [
            this.beans,
            ...args
        ]);
        if (this.isDestroyed) return this.destroyedHandler(functionName);
        if (this.isFrameworkMethod(functionName)) return void 0;
        this.beans.validationService?.warnMissingApiFunction(functionName);
        return void 0;
    }
    addFunction(functionName, func) {
        const { validationService: validationService  } = this.beans;
        if (validationService) func = validationService.validateApiFunction(functionName, func);
        this.functions[functionName] = func;
    }
    destroy() {
        this.functions = {};
        this.isDestroyed = true;
        super.destroy();
    }
    destroyedHandler(functionName) {
        if (functionName === "isDestroyed") return true;
        if (functionName === "destroy") return;
        $7b57b57eaf5a9648$export$2cf41453020eef66(`Grid API function ${functionName}() cannot be called as the grid has been destroyed.
Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${this.preDestroyLink}`);
        return;
    }
    isFrameworkMethod(functionName) {
        return [
            "preWireBeans",
            "wireBeans",
            "preConstruct",
            "postConstruct"
        ].includes(functionName);
    }
};
// community-modules/core/src/api/apiUtils.ts
function $7b57b57eaf5a9648$var$createApi(context) {
    const apiFunctionService = context.getBean("apiFunctionService");
    return new Proxy(apiFunctionService, {
        get (target, prop) {
            if (prop === "then") return;
            return (...args)=>target.callFunction(prop, args);
        }
    });
}
function $7b57b57eaf5a9648$var$createApiProxy(context) {
    return {
        beanName: "gridApi",
        bean: $7b57b57eaf5a9648$var$createApi(context)
    };
}
// community-modules/core/src/columns/columnDefFactory.ts
var $7b57b57eaf5a9648$var$ColumnDefFactory = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnDefFactory";
    }
    buildColumnDefs(cols, rowGroupColumns, pivotColumns) {
        const res = [];
        const colGroupDefs = {};
        cols.forEach((col)=>{
            const colDef = this.createDefFromColumn(col, rowGroupColumns, pivotColumns);
            let addToResult = true;
            let childDef = colDef;
            let pointer = col.getOriginalParent();
            let lastPointer = null;
            while(pointer){
                let parentDef = null;
                if (pointer.isPadding()) {
                    pointer = pointer.getOriginalParent();
                    continue;
                }
                const existingParentDef = colGroupDefs[pointer.getGroupId()];
                if (existingParentDef) {
                    existingParentDef.children.push(childDef);
                    addToResult = false;
                    break;
                }
                parentDef = this.createDefFromGroup(pointer);
                if (parentDef) {
                    parentDef.children = [
                        childDef
                    ];
                    colGroupDefs[parentDef.groupId] = parentDef;
                    childDef = parentDef;
                    pointer = pointer.getOriginalParent();
                }
                if (pointer != null && lastPointer === pointer) {
                    addToResult = false;
                    break;
                }
                lastPointer = pointer;
            }
            if (addToResult) res.push(childDef);
        });
        return res;
    }
    createDefFromGroup(group) {
        const defCloned = $7b57b57eaf5a9648$var$_deepCloneDefinition(group.getColGroupDef(), [
            "children"
        ]);
        if (defCloned) defCloned.groupId = group.getGroupId();
        return defCloned;
    }
    createDefFromColumn(col, rowGroupColumns, pivotColumns) {
        const colDefCloned = $7b57b57eaf5a9648$var$_deepCloneDefinition(col.getColDef());
        colDefCloned.colId = col.getColId();
        colDefCloned.width = col.getActualWidth();
        colDefCloned.rowGroup = col.isRowGroupActive();
        colDefCloned.rowGroupIndex = col.isRowGroupActive() ? rowGroupColumns.indexOf(col) : null;
        colDefCloned.pivot = col.isPivotActive();
        colDefCloned.pivotIndex = col.isPivotActive() ? pivotColumns.indexOf(col) : null;
        colDefCloned.aggFunc = col.isValueActive() ? col.getAggFunc() : null;
        colDefCloned.hide = col.isVisible() ? void 0 : true;
        colDefCloned.pinned = col.isPinned() ? col.getPinned() : null;
        colDefCloned.sort = col.getSort() ? col.getSort() : null;
        colDefCloned.sortIndex = col.getSortIndex() != null ? col.getSortIndex() : null;
        return colDefCloned;
    }
};
// community-modules/core/src/columns/columnEventDispatcher.ts
var $7b57b57eaf5a9648$var$ColumnEventDispatcher = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnEventDispatcher";
    }
    visibleCols() {
        const event = {
            type: "displayedColumnsChanged"
        };
        this.eventService.dispatchEvent(event);
    }
    gridColumns() {
        const event = {
            type: "gridColumnsChanged"
        };
        this.eventService.dispatchEvent(event);
    }
    headerHeight(col) {
        const event = {
            type: "columnHeaderHeightChanged",
            column: col,
            columns: [
                col
            ],
            source: "autosizeColumnHeaderHeight"
        };
        this.eventService.dispatchEvent(event);
    }
    groupOpened(impactedGroups) {
        const event = {
            type: "columnGroupOpened",
            columnGroup: impactedGroups.length === 1 ? impactedGroups[0] : void 0,
            columnGroups: impactedGroups
        };
        this.eventService.dispatchEvent(event);
    }
    rowGroupChanged(impactedColumns, source) {
        const event = {
            type: "columnRowGroupChanged",
            columns: impactedColumns,
            column: impactedColumns.length === 1 ? impactedColumns[0] : null,
            source: source
        };
        this.eventService.dispatchEvent(event);
    }
    genericColumnEvent(eventType, masterList, source) {
        const event = {
            type: eventType,
            columns: masterList,
            column: masterList.length === 1 ? masterList[0] : null,
            source: source
        };
        this.eventService.dispatchEvent(event);
    }
    pivotModeChanged() {
        const event = {
            type: "columnPivotModeChanged"
        };
        this.eventService.dispatchEvent(event);
    }
    virtualColumnsChanged(afterScroll) {
        const event = {
            type: "virtualColumnsChanged",
            afterScroll: afterScroll
        };
        this.eventService.dispatchEvent(event);
    }
    newColumnsLoaded(source) {
        const newColumnsLoadedEvent = {
            type: "newColumnsLoaded",
            source: source
        };
        this.eventService.dispatchEvent(newColumnsLoadedEvent);
    }
    everythingChanged(source) {
        const eventEverythingChanged = {
            type: "columnEverythingChanged",
            source: source
        };
        this.eventService.dispatchEvent(eventEverythingChanged);
    }
    columnMoved(params) {
        const { movedColumns: movedColumns , source: source , toIndex: toIndex , finished: finished  } = params;
        const event = {
            type: "columnMoved",
            columns: movedColumns,
            column: movedColumns && movedColumns.length === 1 ? movedColumns[0] : null,
            toIndex: toIndex,
            finished: finished,
            source: source
        };
        this.eventService.dispatchEvent(event);
    }
    columnPinned(changedColumns, source) {
        if (!changedColumns.length) return;
        const column = changedColumns.length === 1 ? changedColumns[0] : null;
        const pinned = this.getCommonValue(changedColumns, (col)=>col.getPinned());
        const event = {
            type: "columnPinned",
            // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
            pinned: pinned != null ? pinned : null,
            columns: changedColumns,
            column: column,
            source: source
        };
        this.eventService.dispatchEvent(event);
    }
    columnVisible(changedColumns, source) {
        if (!changedColumns.length) return;
        const column = changedColumns.length === 1 ? changedColumns[0] : null;
        const visible = this.getCommonValue(changedColumns, (col)=>col.isVisible());
        const event = {
            type: "columnVisible",
            visible: visible,
            columns: changedColumns,
            column: column,
            source: source
        };
        this.eventService.dispatchEvent(event);
    }
    getCommonValue(cols, valueGetter) {
        if (!cols || cols.length == 0) return void 0;
        const firstValue = valueGetter(cols[0]);
        for(let i = 1; i < cols.length; i++){
            if (firstValue !== valueGetter(cols[i])) return void 0;
        }
        return firstValue;
    }
    columnChanged(type, columns, source) {
        const event = {
            type: type,
            columns: columns,
            column: columns && columns.length == 1 ? columns[0] : null,
            source: source
        };
        this.eventService.dispatchEvent(event);
    }
    columnResized(columns, finished, source, flexColumns = null) {
        if (columns && columns.length) {
            const event = {
                type: "columnResized",
                columns: columns,
                column: columns.length === 1 ? columns[0] : null,
                flexColumns: flexColumns,
                finished: finished,
                source: source
            };
            this.eventService.dispatchEvent(event);
        }
    }
};
// community-modules/core/src/columns/columnGetStateService.ts
var $7b57b57eaf5a9648$var$ColumnGetStateService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnGetStateService";
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.funcColsService = beans.funcColsService;
    }
    getColumnState() {
        const primaryCols = this.columnModel.getColDefCols();
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(primaryCols) || !this.columnModel.isAlive()) return [];
        const colsForState = this.columnModel.getAllCols();
        const res = colsForState.map(this.createStateItemFromColumn.bind(this));
        this.orderColumnStateList(res);
        return res;
    }
    createStateItemFromColumn(column) {
        const rowGorupColumns = this.funcColsService.getRowGroupColumns();
        const pivotColumns = this.funcColsService.getPivotColumns();
        const rowGroupIndex = column.isRowGroupActive() ? rowGorupColumns.indexOf(column) : null;
        const pivotIndex = column.isPivotActive() ? pivotColumns.indexOf(column) : null;
        const aggFunc = column.isValueActive() ? column.getAggFunc() : null;
        const sort = column.getSort() != null ? column.getSort() : null;
        const sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;
        const flex = column.getFlex() != null && column.getFlex() > 0 ? column.getFlex() : null;
        const res = {
            colId: column.getColId(),
            width: column.getActualWidth(),
            hide: !column.isVisible(),
            pinned: column.getPinned(),
            sort: sort,
            sortIndex: sortIndex,
            aggFunc: aggFunc,
            rowGroup: column.isRowGroupActive(),
            rowGroupIndex: rowGroupIndex,
            pivot: column.isPivotActive(),
            pivotIndex: pivotIndex,
            flex: flex
        };
        return res;
    }
    orderColumnStateList(columnStateList) {
        const gridColumns = this.columnModel.getCols();
        const colIdToGridIndexMap = new Map(gridColumns.map((col, index)=>[
                col.getColId(),
                index
            ]));
        columnStateList.sort((itemA, itemB)=>{
            const posA = colIdToGridIndexMap.has(itemA.colId) ? colIdToGridIndexMap.get(itemA.colId) : -1;
            const posB = colIdToGridIndexMap.has(itemB.colId) ? colIdToGridIndexMap.get(itemB.colId) : -1;
            return posA - posB;
        });
    }
};
// community-modules/core/src/columns/columnGroupStateService.ts
var $7b57b57eaf5a9648$var$ColumnGroupStateService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnGroupStateService";
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.columnAnimationService = beans.columnAnimationService;
        this.eventDispatcher = beans.columnEventDispatcher;
        this.visibleColsService = beans.visibleColsService;
    }
    getColumnGroupState() {
        const columnGroupState = [];
        const gridBalancedTree = this.columnModel.getColTree();
        $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(null, gridBalancedTree, (node)=>{
            if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(node)) columnGroupState.push({
                groupId: node.getGroupId(),
                open: node.isExpanded()
            });
        });
        return columnGroupState;
    }
    resetColumnGroupState(source) {
        const primaryColumnTree = this.columnModel.getColDefColTree();
        if (!primaryColumnTree) return;
        const stateItems = [];
        $7b57b57eaf5a9648$var$depthFirstOriginalTreeSearch(null, primaryColumnTree, (child)=>{
            if ($7b57b57eaf5a9648$export$bb4bfad2b594b78e(child)) {
                const colGroupDef = child.getColGroupDef();
                const groupState = {
                    groupId: child.getGroupId(),
                    open: !colGroupDef ? void 0 : colGroupDef.openByDefault
                };
                stateItems.push(groupState);
            }
        });
        this.setColumnGroupState(stateItems, source);
    }
    setColumnGroupState(stateItems, source) {
        const gridBalancedTree = this.columnModel.getColTree();
        if (!gridBalancedTree) return;
        this.columnAnimationService.start();
        const impactedGroups = [];
        stateItems.forEach((stateItem)=>{
            const groupKey = stateItem.groupId;
            const newValue = stateItem.open;
            const providedColumnGroup = this.columnModel.getProvidedColGroup(groupKey);
            if (!providedColumnGroup) return;
            if (providedColumnGroup.isExpanded() === newValue) return;
            providedColumnGroup.setExpanded(newValue);
            impactedGroups.push(providedColumnGroup);
        });
        this.visibleColsService.refresh(source, true);
        if (impactedGroups.length) this.eventDispatcher.groupOpened(impactedGroups);
        this.columnAnimationService.finish();
    }
};
// community-modules/core/src/columns/columnViewportService.ts
var $7b57b57eaf5a9648$var$ColumnViewportService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnViewportService";
        // cols in center that are in the viewport
        this.colsWithinViewport = [];
        // same as colsWithinViewport, except we always include columns with headerAutoHeight
        this.headerColsWithinViewport = [];
        // A hash key to keep track of changes in viewport columns
        this.colsWithinViewportHash = "";
        // all columns & groups to be rendered, index by row.
        // used by header rows to get all items to render for that row.
        this.rowsOfHeadersToRenderLeft = {};
        this.rowsOfHeadersToRenderRight = {};
        this.rowsOfHeadersToRenderCenter = {};
    }
    wireBeans(beans) {
        this.visibleColsService = beans.visibleColsService;
        this.columnModel = beans.columnModel;
        this.eventDispatcher = beans.columnEventDispatcher;
    }
    postConstruct() {
        this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
    }
    setScrollPosition(scrollWidth, scrollPosition, afterScroll = false) {
        const bodyWidthDirty = this.visibleColsService.isBodyWidthDirty();
        const noChange = scrollWidth === this.scrollWidth && scrollPosition === this.scrollPosition && !bodyWidthDirty;
        if (noChange) return;
        this.scrollWidth = scrollWidth;
        this.scrollPosition = scrollPosition;
        this.visibleColsService.setBodyWidthDirty();
        if (this.gos.get("enableRtl")) {
            const bodyWidth = this.visibleColsService.getBodyContainerWidth();
            this.viewportLeft = bodyWidth - this.scrollPosition - this.scrollWidth;
            this.viewportRight = bodyWidth - this.scrollPosition;
        } else {
            this.viewportLeft = this.scrollPosition;
            this.viewportRight = this.scrollWidth + this.scrollPosition;
        }
        if (this.columnModel.isReady()) this.checkViewportColumns(afterScroll);
    }
    getHeadersToRender(type, dept) {
        let result;
        switch(type){
            case "left":
                result = this.rowsOfHeadersToRenderLeft[dept];
                break;
            case "right":
                result = this.rowsOfHeadersToRenderRight[dept];
                break;
            default:
                result = this.rowsOfHeadersToRenderCenter[dept];
                break;
        }
        return result || [];
    }
    extractViewportColumns() {
        const displayedColumnsCenter = this.visibleColsService.getCenterCols();
        if (this.isColumnVirtualisationSuppressed()) {
            this.colsWithinViewport = displayedColumnsCenter;
            this.headerColsWithinViewport = displayedColumnsCenter;
        } else {
            this.colsWithinViewport = displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this));
            this.headerColsWithinViewport = displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this));
        }
    }
    isColumnVirtualisationSuppressed() {
        return this.suppressColumnVirtualisation || this.viewportRight === 0;
    }
    clear() {
        this.rowsOfHeadersToRenderLeft = {};
        this.rowsOfHeadersToRenderRight = {};
        this.rowsOfHeadersToRenderCenter = {};
        this.colsWithinViewportHash = "";
    }
    isColumnInHeaderViewport(col) {
        if (col.isAutoHeaderHeight()) return true;
        return this.isColumnInRowViewport(col);
    }
    isColumnInRowViewport(col) {
        if (col.isAutoHeight()) return true;
        const columnLeft = col.getLeft() || 0;
        const columnRight = columnLeft + col.getActualWidth();
        const leftBounds = this.viewportLeft - 200;
        const rightBounds = this.viewportRight + 200;
        const columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;
        const columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;
        return !columnToMuchLeft && !columnToMuchRight;
    }
    // used by Grid API only
    getViewportColumns() {
        const leftCols = this.visibleColsService.getLeftCols();
        const rightCols = this.visibleColsService.getRightCols();
        const res = this.colsWithinViewport.concat(leftCols).concat(rightCols);
        return res;
    }
    // + rowRenderer
    // if we are not column spanning, this just returns back the virtual centre columns,
    // however if we are column spanning, then different rows can have different virtual
    // columns, so we have to work out the list for each individual row.
    getColsWithinViewport(rowNode) {
        if (!this.columnModel.isColSpanActive()) return this.colsWithinViewport;
        const emptySpaceBeforeColumn = (col)=>{
            const left = col.getLeft();
            return $7b57b57eaf5a9648$export$25d27f17d3af40f7(left) && left > this.viewportLeft;
        };
        const inViewportCallback = this.isColumnVirtualisationSuppressed() ? null : this.isColumnInRowViewport.bind(this);
        const displayedColumnsCenter = this.visibleColsService.getColsCenter();
        return this.visibleColsService.getColsForRow(rowNode, displayedColumnsCenter, inViewportCallback, emptySpaceBeforeColumn);
    }
    // checks what columns are currently displayed due to column virtualisation. dispatches an event
    // if the list of columns has changed.
    // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
    checkViewportColumns(afterScroll = false) {
        const viewportColumnsChanged = this.extractViewport();
        if (viewportColumnsChanged) this.eventDispatcher.virtualColumnsChanged(afterScroll);
    }
    calculateHeaderRows() {
        this.rowsOfHeadersToRenderLeft = {};
        this.rowsOfHeadersToRenderRight = {};
        this.rowsOfHeadersToRenderCenter = {};
        const renderedColIds = {};
        const renderedColsLeft = this.visibleColsService.getLeftCols();
        const renderedColsRight = this.visibleColsService.getRightCols();
        const allRenderedCols = this.headerColsWithinViewport.concat(renderedColsLeft).concat(renderedColsRight);
        allRenderedCols.forEach((col)=>renderedColIds[col.getId()] = true);
        const testGroup = (children, result, dept)=>{
            let returnValue = false;
            for(let i = 0; i < children.length; i++){
                const child = children[i];
                let addThisItem = false;
                if ($7b57b57eaf5a9648$export$891484e65a02ec71(child)) addThisItem = renderedColIds[child.getId()] === true;
                else {
                    const columnGroup = child;
                    const displayedChildren = columnGroup.getDisplayedChildren();
                    if (displayedChildren) addThisItem = testGroup(displayedChildren, result, dept + 1);
                }
                if (addThisItem) {
                    returnValue = true;
                    if (!result[dept]) result[dept] = [];
                    result[dept].push(child);
                }
            }
            return returnValue;
        };
        testGroup(this.visibleColsService.getTreeLeft(), this.rowsOfHeadersToRenderLeft, 0);
        testGroup(this.visibleColsService.getTreeRight(), this.rowsOfHeadersToRenderRight, 0);
        testGroup(this.visibleColsService.getTreeCenter(), this.rowsOfHeadersToRenderCenter, 0);
    }
    extractViewport() {
        const hashColumn = (c)=>`${c.getId()}-${c.getPinned() || "normal"}`;
        this.extractViewportColumns();
        const newHash = this.getViewportColumns().map(hashColumn).join("#");
        const changed = this.colsWithinViewportHash !== newHash;
        if (changed) {
            this.colsWithinViewportHash = newHash;
            this.calculateHeaderRows();
        }
        return changed;
    }
};
// community-modules/core/src/components/framework/agComponentUtils.ts
var $7b57b57eaf5a9648$var$AgComponentUtils = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "agComponentUtils";
    }
    wireBeans(beans) {
        this.componentMetadataProvider = beans.componentMetadataProvider;
    }
    adaptFunction(propertyName, jsCompFunc) {
        const metadata = this.componentMetadataProvider.retrieve(propertyName);
        if (metadata && metadata.functionAdapter) return metadata.functionAdapter(jsCompFunc);
        return null;
    }
    adaptCellRendererFunction(callback) {
        class Adapter {
            refresh() {
                return false;
            }
            getGui() {
                return this.eGui;
            }
            init(params) {
                const callbackResult = callback(params);
                const type = typeof callbackResult;
                if (type === "string" || type === "number" || type === "boolean") {
                    this.eGui = $7b57b57eaf5a9648$export$b1f57d075ca6d5fb("<span>" + callbackResult + "</span>");
                    return;
                }
                if (callbackResult == null) {
                    this.eGui = $7b57b57eaf5a9648$export$b1f57d075ca6d5fb("<span></span>");
                    return;
                }
                this.eGui = callbackResult;
            }
        }
        return Adapter;
    }
    doesImplementIComponent(candidate) {
        if (!candidate) return false;
        return candidate.prototype && "getGui" in candidate.prototype;
    }
};
// community-modules/core/src/components/framework/componentMetadataProvider.ts
var $7b57b57eaf5a9648$var$ComponentMetadataProvider = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "componentMetadataProvider";
    }
    wireBeans(beans) {
        this.agComponentUtils = beans.agComponentUtils;
    }
    postConstruct() {
        this.componentMetaData = {
            dateComponent: {
                mandatoryMethodList: [
                    "getDate",
                    "setDate"
                ],
                optionalMethodList: [
                    "afterGuiAttached",
                    "setInputPlaceholder",
                    "setInputAriaLabel",
                    "setDisabled",
                    "onParamsUpdated",
                    "refresh"
                ]
            },
            detailCellRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "refresh"
                ],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            headerComponent: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "refresh"
                ]
            },
            headerGroupComponent: {
                mandatoryMethodList: [],
                optionalMethodList: []
            },
            loadingCellRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: [],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            loadingOverlayComponent: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "refresh"
                ]
            },
            noRowsOverlayComponent: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "refresh"
                ]
            },
            floatingFilterComponent: {
                mandatoryMethodList: [
                    "onParentModelChanged"
                ],
                optionalMethodList: [
                    "afterGuiAttached",
                    "onParamsUpdated",
                    "refresh"
                ]
            },
            cellRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "refresh",
                    "afterGuiAttached"
                ],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            cellEditor: {
                mandatoryMethodList: [
                    "getValue"
                ],
                optionalMethodList: [
                    "isPopup",
                    "isCancelBeforeStart",
                    "isCancelAfterEnd",
                    "getPopupPosition",
                    "focusIn",
                    "focusOut",
                    "afterGuiAttached",
                    "refresh"
                ]
            },
            innerRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "afterGuiAttached"
                ],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            fullWidthCellRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "refresh",
                    "afterGuiAttached"
                ],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            groupRowRenderer: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "afterGuiAttached"
                ],
                functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
            },
            filter: {
                mandatoryMethodList: [
                    "isFilterActive",
                    "doesFilterPass",
                    "getModel",
                    "setModel"
                ],
                optionalMethodList: [
                    "afterGuiAttached",
                    "afterGuiDetached",
                    "onNewRowsLoaded",
                    "getModelAsString",
                    "onFloatingFilterChanged",
                    "onAnyFilterChanged",
                    "refresh"
                ]
            },
            statusPanel: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "refresh"
                ]
            },
            toolPanel: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "refresh",
                    "getState"
                ]
            },
            tooltipComponent: {
                mandatoryMethodList: [],
                optionalMethodList: []
            },
            menuItem: {
                mandatoryMethodList: [],
                optionalMethodList: [
                    "setActive",
                    "select",
                    "setExpanded",
                    "configureDefaults"
                ]
            }
        };
    }
    retrieve(name) {
        return this.componentMetaData[name];
    }
};
// community-modules/core/src/context/gridBeanComparator.ts
var $7b57b57eaf5a9648$var$orderedCoreBeans = [
    // core beans only
    "rowPositionUtils",
    "cellPositionUtils",
    "headerPositionUtils",
    "paginationAutoPageSizeService",
    "apiFunctionService",
    "gridApi",
    "userComponentRegistry",
    "agComponentUtils",
    "componentMetadataProvider",
    "resizeObserverService",
    "userComponentFactory",
    "rowContainerHeightService",
    "horizontalResizeService",
    "localeService",
    "validationService",
    "pinnedRowModel",
    "dragService",
    "visibleColsService",
    "eventService",
    "gos",
    "popupService",
    "selectionService",
    "columnFilterService",
    "quickFilterService",
    "filterManager",
    "columnModel",
    "headerNavigationService",
    "pageBoundsService",
    "paginationService",
    "pageBoundsListener",
    "rowRenderer",
    "expressionService",
    "columnFactory",
    "alignedGridsService",
    "navigationService",
    "valueCache",
    "valueService",
    "loggerFactory",
    "autoWidthCalculator",
    "filterMenuFactory",
    "dragAndDropService",
    "focusService",
    "mouseEventService",
    "environment",
    "cellNavigationService",
    "stylingService",
    "scrollVisibleService",
    "sortController",
    "columnHoverService",
    "columnAnimationService",
    "selectableService",
    "autoColService",
    "changeDetectionService",
    "animationFrameService",
    "undoRedoService",
    "columnDefFactory",
    "rowCssClassCalculator",
    "rowNodeBlockLoader",
    "rowNodeSorter",
    "ctrlsService",
    "pinnedWidthService",
    "rowNodeEventThrottle",
    "ctrlsFactory",
    "dataTypeService",
    "syncService",
    "overlayService",
    "stateService",
    "expansionService",
    "apiEventService",
    "ariaAnnouncementService",
    "menuService",
    "columnApplyStateService",
    "columnEventDispatcher",
    "columnMoveService",
    "columnAutosizeService",
    "columnGetStateService",
    "columnGroupStateService",
    "columnSizeService",
    "funcColsService",
    "columnNameService",
    "columnViewportService",
    "pivotResultColsService",
    "showRowGroupColsService"
];
var $7b57b57eaf5a9648$var$beanNamePosition = Object.fromEntries($7b57b57eaf5a9648$var$orderedCoreBeans.map((beanName, index)=>[
        beanName,
        index
    ]));
function $7b57b57eaf5a9648$var$gridBeanInitComparator(bean1, bean2) {
    const index1 = (bean1.beanName ? $7b57b57eaf5a9648$var$beanNamePosition[bean1.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
    const index2 = (bean2.beanName ? $7b57b57eaf5a9648$var$beanNamePosition[bean2.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
    return index1 - index2;
}
function $7b57b57eaf5a9648$var$gridBeanDestroyComparator(bean1, bean2) {
    return bean1?.beanName === "gridDestroyService" ? -1 : 0;
}
// community-modules/core/src/ctrlsFactory.ts
var $7b57b57eaf5a9648$var$CtrlsFactory = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "ctrlsFactory";
        this.registry = {};
    }
    register(meta) {
        this.registry[meta.name] = meta.classImp;
    }
    getInstance(name, ...args) {
        const ControllerClass = this.registry[name];
        if (ControllerClass == null) return void 0;
        return new ControllerClass(...args);
    }
};
// community-modules/core/src/ctrlsService.ts
var $7b57b57eaf5a9648$export$1ec35376f0ed6145 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "ctrlsService";
        this.params = {};
        this.ready = false;
        this.readyCallbacks = [];
    }
    checkReady() {
        const params = this.params;
        this.ready = params.gridCtrl != null && params.gridBodyCtrl != null && params.center != null && params.left != null && params.right != null && params.bottomCenter != null && params.bottomLeft != null && params.bottomRight != null && params.topCenter != null && params.topLeft != null && params.topRight != null && params.stickyTopCenter != null && params.stickyTopLeft != null && params.stickyTopRight != null && params.stickyBottomCenter != null && params.stickyBottomLeft != null && params.stickyBottomRight != null && params.centerHeader != null && params.leftHeader != null && params.rightHeader != null && params.fakeHScrollComp != null && params.fakeVScrollComp != null && params.gridHeaderCtrl != null;
        if (this.ready) {
            this.readyCallbacks.forEach((c)=>c(params));
            this.readyCallbacks.length = 0;
        }
    }
    whenReady(callback) {
        if (this.ready) callback(this.params);
        else this.readyCallbacks.push(callback);
    }
    register(ctrlType, ctrl) {
        this.params[ctrlType] = ctrl;
        this.checkReady();
    }
    registerHeaderContainer(ctrl, pinned) {
        const params = this.params;
        switch(pinned){
            case "left":
                params.leftHeader = ctrl;
                break;
            case "right":
                params.rightHeader = ctrl;
                break;
            default:
                params.centerHeader = ctrl;
                break;
        }
        this.checkReady();
    }
    get(ctrlType) {
        return this.params[ctrlType];
    }
    getParams() {
        return this.params;
    }
    getGridBodyCtrl() {
        return this.params.gridBodyCtrl;
    }
    getHeaderRowContainerCtrls() {
        const { leftHeader: leftHeader , centerHeader: centerHeader , rightHeader: rightHeader  } = this.params;
        return [
            leftHeader,
            rightHeader,
            centerHeader
        ];
    }
    getHeaderRowContainerCtrl(pinned) {
        const params = this.params;
        switch(pinned){
            case "left":
                return params.leftHeader;
            case "right":
                return params.rightHeader;
            default:
                return params.centerHeader;
        }
    }
};
// community-modules/core/src/entities/cellPositionUtils.ts
var $7b57b57eaf5a9648$export$d4b97c43369f9635 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "cellPositionUtils";
    }
    createId(cellPosition) {
        const { rowIndex: rowIndex , rowPinned: rowPinned , column: column  } = cellPosition;
        return this.createIdFromValues({
            rowIndex: rowIndex,
            column: column,
            rowPinned: rowPinned
        });
    }
    createIdFromValues(cellPosition) {
        const { rowIndex: rowIndex , rowPinned: rowPinned , column: column  } = cellPosition;
        return `${rowIndex}.${rowPinned == null ? "null" : rowPinned}.${column.getId()}`;
    }
    equals(cellA, cellB) {
        const colsMatch = cellA.column === cellB.column;
        const floatingMatch = cellA.rowPinned === cellB.rowPinned;
        const indexMatch = cellA.rowIndex === cellB.rowIndex;
        return colsMatch && floatingMatch && indexMatch;
    }
};
// community-modules/core/src/entities/rowNodeEventThrottle.ts
var $7b57b57eaf5a9648$var$RowNodeEventThrottle = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowNodeEventThrottle";
        this.events = [];
    }
    wireBeans(beans) {
        this.animationFrameService = beans.animationFrameService;
        this.rowModel = beans.rowModel;
    }
    postConstruct() {
        if (this.rowModel.getType() == "clientSide") this.clientSideRowModel = this.rowModel;
    }
    // because the user can call rowNode.setExpanded() many times in one VM turn,
    // we throttle the calls to ClientSideRowModel using animationFrameService. this means for 100
    // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
    // CSRM has updated.
    //
    // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
    // to re-render 100+ times, which would be a performance lag.
    //
    // we use animationFrameService
    // rather than debounce() so this will get done if anyone flushes the animationFrameService
    // (eg user calls api.ensureRowVisible(), which in turn flushes ).
    dispatchExpanded(event, forceSync) {
        if (this.clientSideRowModel == null) {
            this.eventService.dispatchEvent(event);
            return;
        }
        this.events.push(event);
        const func = ()=>{
            if (this.clientSideRowModel) this.clientSideRowModel.onRowGroupOpened();
            this.events.forEach((e)=>this.eventService.dispatchEvent(e));
            this.events = [];
        };
        if (forceSync) func();
        else {
            if (this.dispatchExpandedDebounced == null) this.dispatchExpandedDebounced = this.animationFrameService.debounce(func);
            this.dispatchExpandedDebounced();
        }
    }
};
// community-modules/core/src/entities/rowPositionUtils.ts
var $7b57b57eaf5a9648$export$27e6ff2feb462d0f = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowPositionUtils";
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.pageBoundsService = beans.pageBoundsService;
    }
    getFirstRow() {
        let rowIndex = 0;
        let rowPinned;
        if (this.pinnedRowModel.getPinnedTopRowCount()) rowPinned = "top";
        else if (this.rowModel.getRowCount()) {
            rowPinned = null;
            rowIndex = this.pageBoundsService.getFirstRow();
        } else if (this.pinnedRowModel.getPinnedBottomRowCount()) rowPinned = "bottom";
        return rowPinned === void 0 ? null : {
            rowIndex: rowIndex,
            rowPinned: rowPinned
        };
    }
    getLastRow() {
        let rowIndex;
        let rowPinned = null;
        const pinnedBottomCount = this.pinnedRowModel.getPinnedBottomRowCount();
        const pinnedTopCount = this.pinnedRowModel.getPinnedTopRowCount();
        if (pinnedBottomCount) {
            rowPinned = "bottom";
            rowIndex = pinnedBottomCount - 1;
        } else if (this.rowModel.getRowCount()) {
            rowPinned = null;
            rowIndex = this.pageBoundsService.getLastRow();
        } else if (pinnedTopCount) {
            rowPinned = "top";
            rowIndex = pinnedTopCount - 1;
        }
        return rowIndex === void 0 ? null : {
            rowIndex: rowIndex,
            rowPinned: rowPinned
        };
    }
    getRowNode(gridRow) {
        switch(gridRow.rowPinned){
            case "top":
                return this.pinnedRowModel.getPinnedTopRowNodes()[gridRow.rowIndex];
            case "bottom":
                return this.pinnedRowModel.getPinnedBottomRowNodes()[gridRow.rowIndex];
            default:
                return this.rowModel.getRow(gridRow.rowIndex);
        }
    }
    sameRow(rowA, rowB) {
        if (!rowA && !rowB) return true;
        if (rowA && !rowB || !rowA && rowB) return false;
        return rowA.rowIndex === rowB.rowIndex && rowA.rowPinned == rowB.rowPinned;
    }
    // tests if this row selection is before the other row selection
    before(rowA, rowB) {
        switch(rowA.rowPinned){
            case "top":
                if (rowB.rowPinned !== "top") return true;
                break;
            case "bottom":
                if (rowB.rowPinned !== "bottom") return false;
                break;
            default:
                if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(rowB.rowPinned)) return rowB.rowPinned !== "top";
                break;
        }
        return rowA.rowIndex < rowB.rowIndex;
    }
};
// community-modules/core/src/environment.ts
var $7b57b57eaf5a9648$var$ROW_HEIGHT = {
    cssName: "--ag-row-height",
    changeKey: "rowHeightChanged",
    defaultValue: 42
};
var $7b57b57eaf5a9648$var$HEADER_HEIGHT = {
    cssName: "--ag-header-height",
    changeKey: "headerHeightChanged",
    defaultValue: 48
};
var $7b57b57eaf5a9648$var$LIST_ITEM_HEIGHT = {
    cssName: "--ag-list-item-height",
    changeKey: "listItemHeightChanged",
    defaultValue: 24
};
var $7b57b57eaf5a9648$export$7dc6752a22ab011a = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "environment";
        this.sizeEls = /* @__PURE__ */ new Map();
        this.lastKnownValues = /* @__PURE__ */ new Map();
        this.themeClasses = [];
        this.eThemeAncestor = null;
        this.eMeasurementContainer = null;
        this.sizesMeasured = false;
    }
    wireBeans(beans) {
        this.resizeObserverService = beans.resizeObserverService;
        this.eGridDiv = beans.eGridDiv;
    }
    postConstruct() {
        this.addManagedPropertyListener("rowHeight", ()=>this.refreshRowHeightVariable());
        this.themeClasses = this.getAncestorThemeClasses();
        this.setUpThemeClassObservers();
        this.getSizeEl($7b57b57eaf5a9648$var$ROW_HEIGHT);
        this.getSizeEl($7b57b57eaf5a9648$var$HEADER_HEIGHT);
        this.getSizeEl($7b57b57eaf5a9648$var$LIST_ITEM_HEIGHT);
    }
    getDefaultRowHeight() {
        return this.getCSSVariablePixelValue($7b57b57eaf5a9648$var$ROW_HEIGHT);
    }
    getDefaultHeaderHeight() {
        return this.getCSSVariablePixelValue($7b57b57eaf5a9648$var$HEADER_HEIGHT);
    }
    getDefaultListItemHeight() {
        return this.getCSSVariablePixelValue($7b57b57eaf5a9648$var$LIST_ITEM_HEIGHT);
    }
    hasMeasuredSizes() {
        return this.sizesMeasured;
    }
    getThemeClasses() {
        return this.themeClasses;
    }
    applyThemeClasses(el) {
        for (const className of Array.from(el.classList))if (className.startsWith("ag-theme-") && !this.themeClasses.includes(className)) el.classList.remove(className);
        for (const className of this.themeClasses)if (!el.classList.contains(className)) el.classList.add(className);
    }
    getThemeAncestorElement() {
        return this.eThemeAncestor;
    }
    refreshRowHeightVariable() {
        const oldRowHeight = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim();
        const height = this.gos.get("rowHeight");
        if (height == null || isNaN(height) || !isFinite(height)) {
            if (oldRowHeight !== null) this.eGridDiv.style.setProperty("--ag-line-height", null);
            return -1;
        }
        const newRowHeight = `${height}px`;
        if (oldRowHeight != newRowHeight) {
            this.eGridDiv.style.setProperty("--ag-line-height", newRowHeight);
            return height;
        }
        return oldRowHeight != "" ? parseFloat(oldRowHeight) : -1;
    }
    getCSSVariablePixelValue(variable) {
        const cached = this.lastKnownValues.get(variable);
        if (cached != null) return cached;
        const measurement = this.measureSizeEl(variable);
        if (measurement === "detached" || measurement === "no-styles") return variable.defaultValue;
        this.lastKnownValues.set(variable, measurement);
        return measurement;
    }
    measureSizeEl(variable) {
        const sizeEl = this.getSizeEl(variable);
        if (sizeEl.offsetParent == null) return "detached";
        const newSize = sizeEl.offsetWidth;
        if (newSize === $7b57b57eaf5a9648$var$NO_VALUE_SENTINEL) return "no-styles";
        this.sizesMeasured = true;
        return newSize;
    }
    getSizeEl(variable) {
        let sizeEl = this.sizeEls.get(variable);
        if (sizeEl) return sizeEl;
        let container = this.eMeasurementContainer;
        if (!container) {
            container = this.eMeasurementContainer = document.createElement("div");
            container.className = "ag-measurement-container";
            this.eGridDiv.appendChild(container);
        }
        sizeEl = document.createElement("div");
        sizeEl.style.width = `var(${variable.cssName}, ${$7b57b57eaf5a9648$var$NO_VALUE_SENTINEL}px)`;
        container.appendChild(sizeEl);
        this.sizeEls.set(variable, sizeEl);
        let lastMeasurement = this.measureSizeEl(variable);
        if (lastMeasurement === "no-styles") $7b57b57eaf5a9648$export$2cf41453020eef66(`no value for ${variable.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${variable.defaultValue} will be used and updated when styles load.`);
        const unsubscribe = this.resizeObserverService.observeResize(sizeEl, ()=>{
            const newMeasurement = this.measureSizeEl(variable);
            if (newMeasurement === "detached" || newMeasurement === "no-styles") return;
            this.lastKnownValues.set(variable, newMeasurement);
            if (newMeasurement !== lastMeasurement) {
                lastMeasurement = newMeasurement;
                this.fireGridStylesChangedEvent(variable.changeKey);
            }
        });
        this.addDestroyFunc(()=>unsubscribe());
        return sizeEl;
    }
    fireGridStylesChangedEvent(change) {
        const event = {
            type: "gridStylesChanged",
            [change]: true
        };
        this.eventService.dispatchEvent(event);
    }
    setUpThemeClassObservers() {
        const observer = new MutationObserver(()=>{
            const newThemeClasses = this.getAncestorThemeClasses();
            if (!$7b57b57eaf5a9648$var$arraysEqual(newThemeClasses, this.themeClasses)) {
                this.themeClasses = newThemeClasses;
                this.fireGridStylesChangedEvent("themeChanged");
            }
        });
        let node = this.eGridDiv;
        while(node){
            observer.observe(node || this.eGridDiv, {
                attributes: true,
                attributeFilter: [
                    "class"
                ]
            });
            node = node.parentElement;
        }
    }
    getAncestorThemeClasses() {
        let el = this.eGridDiv;
        const allThemeClasses = [];
        this.eThemeAncestor = null;
        while(el){
            const themeClasses = Array.from(el.classList).filter((c)=>c.startsWith("ag-theme-"));
            for (const themeClass of themeClasses){
                this.eThemeAncestor = el;
                if (!allThemeClasses.includes(themeClass)) allThemeClasses.unshift(themeClass);
            }
            el = el.parentElement;
        }
        return Object.freeze(allThemeClasses);
    }
};
var $7b57b57eaf5a9648$var$arraysEqual = (a, b)=>a.length === b.length && a.findIndex((_, i)=>a[i] !== b[i]) === -1;
var $7b57b57eaf5a9648$var$NO_VALUE_SENTINEL = 15538;
// community-modules/core/src/eventService.ts
var $7b57b57eaf5a9648$export$895d7dc49f082ca1 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "eventService";
        this.globalEventService = new $7b57b57eaf5a9648$export$820da7696a401cdc();
    }
    wireBeans(beans) {
        this.globalEventListener = beans.globalEventListener;
        this.globalSyncEventListener = beans.globalSyncEventListener;
    }
    postConstruct() {
        if (this.globalEventListener) {
            const async = this.gos.useAsyncEvents();
            this.addGlobalListener(this.globalEventListener, async);
        }
        if (this.globalSyncEventListener) this.addGlobalListener(this.globalSyncEventListener, false);
    }
    addEventListener(eventType, listener, async) {
        this.globalEventService.addEventListener(eventType, listener, async);
    }
    removeEventListener(eventType, listener, async) {
        this.globalEventService.removeEventListener(eventType, listener, async);
    }
    addGlobalListener(listener, async = false) {
        this.globalEventService.addGlobalListener(listener, async);
    }
    removeGlobalListener(listener, async = false) {
        this.globalEventService.removeGlobalListener(listener, async);
    }
    /** @deprecated DO NOT FIRE LOCAL EVENTS OFF THE EVENT SERVICE */ dispatchLocalEvent() {}
    dispatchEvent(event) {
        this.globalEventService.dispatchEvent(this.gos.addGridCommonParams(event));
    }
    dispatchEventOnce(event) {
        this.globalEventService.dispatchEventOnce(this.gos.addGridCommonParams(event));
    }
};
// community-modules/core/src/focusService.ts
var $7b57b57eaf5a9648$var$_FocusService = class _FocusService extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "focusService";
    }
    wireBeans(beans) {
        this.eGridDiv = beans.eGridDiv;
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
        this.headerNavigationService = beans.headerNavigationService;
        this.headerPositionUtils = beans.headerPositionUtils;
        this.rowRenderer = beans.rowRenderer;
        this.rowPositionUtils = beans.rowPositionUtils;
        this.cellPositionUtils = beans.cellPositionUtils;
        this.navigationService = beans.navigationService;
        this.ctrlsService = beans.ctrlsService;
        this.filterManager = beans.filterManager;
        this.rangeService = beans.rangeService;
        this.advancedFilterService = beans.advancedFilterService;
    }
    static addKeyboardModeEvents(doc) {
        if (this.instanceCount > 0) return;
        doc.addEventListener("keydown", _FocusService.toggleKeyboardMode);
        doc.addEventListener("mousedown", _FocusService.toggleKeyboardMode);
    }
    static removeKeyboardModeEvents(doc) {
        if (this.instanceCount > 0) return;
        doc.addEventListener("keydown", _FocusService.toggleKeyboardMode);
        doc.addEventListener("mousedown", _FocusService.toggleKeyboardMode);
    }
    static toggleKeyboardMode(event) {
        const isKeyboardActive = _FocusService.keyboardModeActive;
        const isKeyboardEvent = event.type === "keydown";
        if (isKeyboardEvent) {
            if (event.ctrlKey || event.metaKey || event.altKey) return;
        }
        if (isKeyboardActive === isKeyboardEvent) return;
        _FocusService.keyboardModeActive = isKeyboardEvent;
    }
    static unregisterGridCompController(doc) {
        _FocusService.removeKeyboardModeEvents(doc);
    }
    postConstruct() {
        const clearFocusedCellListener = this.clearFocusedCell.bind(this);
        this.addManagedEventListeners({
            columnPivotModeChanged: clearFocusedCellListener,
            newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
            columnGroupOpened: clearFocusedCellListener,
            columnRowGroupChanged: clearFocusedCellListener
        });
        this.registerKeyboardFocusEvents();
        this.ctrlsService.whenReady((p)=>{
            this.gridCtrl = p.gridCtrl;
        });
    }
    registerKeyboardFocusEvents() {
        const eDocument = this.gos.getDocument();
        _FocusService.addKeyboardModeEvents(eDocument);
        _FocusService.instanceCount++;
        this.addDestroyFunc(()=>{
            _FocusService.instanceCount--;
            _FocusService.unregisterGridCompController(eDocument);
        });
    }
    onColumnEverythingChanged() {
        if (!this.focusedCellPosition) return;
        const col = this.focusedCellPosition.column;
        const colFromColumnModel = this.columnModel.getCol(col.getId());
        if (col !== colFromColumnModel) this.clearFocusedCell();
    }
    isKeyboardMode() {
        return _FocusService.keyboardModeActive;
    }
    // we check if the browser is focusing something, and if it is, and
    // it's the cell we think is focused, then return the cell. so this
    // methods returns the cell if a) we think it has focus and b) the
    // browser thinks it has focus. this then returns nothing if we
    // first focus a cell, then second click outside the grid, as then the
    // grid cell will still be focused as far as the grid is concerned,
    // however the browser focus will have moved somewhere else.
    getFocusCellToUseAfterRefresh() {
        if (this.gos.get("suppressFocusAfterRefresh") || !this.focusedCellPosition) return null;
        if (this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), $7b57b57eaf5a9648$export$e449e57ac30326ed.DOM_DATA_KEY_ROW_CTRL)) return null;
        return this.focusedCellPosition;
    }
    getFocusHeaderToUseAfterRefresh() {
        if (this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeaderPosition) return null;
        if (this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), $7b57b57eaf5a9648$export$879ff627d5a4d5c.DOM_DATA_KEY_HEADER_CTRL)) return null;
        return this.focusedHeaderPosition;
    }
    isDomDataMissingInHierarchy(eBrowserCell, key) {
        let ePointer = eBrowserCell;
        while(ePointer){
            const data = this.gos.getDomData(ePointer, key);
            if (data) return false;
            ePointer = ePointer.parentNode;
        }
        return true;
    }
    getFocusedCell() {
        return this.focusedCellPosition;
    }
    shouldRestoreFocus(cell) {
        if (this.isCellRestoreFocused(cell)) {
            setTimeout(()=>{
                this.restoredFocusedCellPosition = null;
            }, 0);
            return true;
        }
        return false;
    }
    isCellRestoreFocused(cellPosition) {
        if (this.restoredFocusedCellPosition == null) return false;
        return this.cellPositionUtils.equals(cellPosition, this.restoredFocusedCellPosition);
    }
    setRestoreFocusedCell(cellPosition) {
        if (this.getFrameworkOverrides().renderingEngine === "react") this.restoredFocusedCellPosition = cellPosition;
    }
    getFocusEventParams() {
        const { rowIndex: rowIndex , rowPinned: rowPinned , column: column  } = this.focusedCellPosition;
        const params = {
            rowIndex: rowIndex,
            rowPinned: rowPinned,
            column: column,
            isFullWidthCell: false
        };
        const rowCtrl = this.rowRenderer.getRowByPosition({
            rowIndex: rowIndex,
            rowPinned: rowPinned
        });
        if (rowCtrl) params.isFullWidthCell = rowCtrl.isFullWidth();
        return params;
    }
    clearFocusedCell() {
        this.restoredFocusedCellPosition = null;
        if (this.focusedCellPosition == null) return;
        const event = {
            type: "cellFocusCleared",
            ...this.getFocusEventParams()
        };
        this.focusedCellPosition = null;
        this.eventService.dispatchEvent(event);
    }
    setFocusedCell(params) {
        const { column: column , rowIndex: rowIndex , rowPinned: rowPinned , forceBrowserFocus: forceBrowserFocus = false , preventScrollOnBrowserFocus: preventScrollOnBrowserFocus = false  } = params;
        const gridColumn = this.columnModel.getCol(column);
        if (!gridColumn) {
            this.focusedCellPosition = null;
            return;
        }
        this.focusedCellPosition = gridColumn ? {
            rowIndex: rowIndex,
            rowPinned: $7b57b57eaf5a9648$export$4978424c4f7b5fc0(rowPinned),
            column: gridColumn
        } : null;
        const event = {
            type: "cellFocused",
            ...this.getFocusEventParams(),
            forceBrowserFocus: forceBrowserFocus,
            preventScrollOnBrowserFocus: preventScrollOnBrowserFocus
        };
        this.eventService.dispatchEvent(event);
    }
    isCellFocused(cellPosition) {
        if (this.focusedCellPosition == null) return false;
        return this.cellPositionUtils.equals(cellPosition, this.focusedCellPosition);
    }
    isRowNodeFocused(rowNode) {
        return this.isRowFocused(rowNode.rowIndex, rowNode.rowPinned);
    }
    isHeaderWrapperFocused(headerCtrl) {
        if (this.focusedHeaderPosition == null) return false;
        const column = headerCtrl.getColumnGroupChild();
        const headerRowIndex = headerCtrl.getRowIndex();
        const pinned = headerCtrl.getPinned();
        const { column: focusedColumn , headerRowIndex: focusedHeaderRowIndex  } = this.focusedHeaderPosition;
        return column === focusedColumn && headerRowIndex === focusedHeaderRowIndex && pinned == focusedColumn.getPinned();
    }
    clearFocusedHeader() {
        this.focusedHeaderPosition = null;
    }
    getFocusedHeader() {
        return this.focusedHeaderPosition;
    }
    setFocusedHeader(headerRowIndex, column) {
        this.focusedHeaderPosition = {
            headerRowIndex: headerRowIndex,
            column: column
        };
    }
    focusHeaderPosition(params) {
        if (this.gos.get("suppressHeaderFocus")) return false;
        const { direction: direction , fromTab: fromTab , allowUserOverride: allowUserOverride , event: event , fromCell: fromCell , rowWithoutSpanValue: rowWithoutSpanValue  } = params;
        let { headerPosition: headerPosition  } = params;
        if (fromCell && this.filterManager?.isAdvancedFilterHeaderActive()) return this.focusAdvancedFilter(headerPosition);
        if (allowUserOverride) {
            const currentPosition = this.getFocusedHeader();
            const headerRowCount = this.headerNavigationService.getHeaderRowCount();
            if (fromTab) {
                const userFunc = this.gos.getCallback("tabToNextHeader");
                if (userFunc) headerPosition = this.getHeaderPositionFromUserFunc({
                    userFunc: userFunc,
                    direction: direction,
                    currentPosition: currentPosition,
                    headerPosition: headerPosition,
                    headerRowCount: headerRowCount
                });
            } else {
                const userFunc = this.gos.getCallback("navigateToNextHeader");
                if (userFunc && event) {
                    const params2 = {
                        key: event.key,
                        previousHeaderPosition: currentPosition,
                        nextHeaderPosition: headerPosition,
                        headerRowCount: headerRowCount,
                        event: event
                    };
                    headerPosition = userFunc(params2);
                }
            }
        }
        if (!headerPosition) return false;
        return this.focusProvidedHeaderPosition({
            headerPosition: headerPosition,
            direction: direction,
            event: event,
            fromCell: fromCell,
            rowWithoutSpanValue: rowWithoutSpanValue
        });
    }
    focusHeaderPositionFromUserFunc(params) {
        if (this.gos.get("suppressHeaderFocus")) return false;
        const { userFunc: userFunc , headerPosition: headerPosition , direction: direction , event: event  } = params;
        const currentPosition = this.getFocusedHeader();
        const headerRowCount = this.headerNavigationService.getHeaderRowCount();
        const newHeaderPosition = this.getHeaderPositionFromUserFunc({
            userFunc: userFunc,
            direction: direction,
            currentPosition: currentPosition,
            headerPosition: headerPosition,
            headerRowCount: headerRowCount
        });
        return !!newHeaderPosition && this.focusProvidedHeaderPosition({
            headerPosition: newHeaderPosition,
            direction: direction,
            event: event
        });
    }
    getHeaderPositionFromUserFunc(params) {
        const { userFunc: userFunc , direction: direction , currentPosition: currentPosition , headerPosition: headerPosition , headerRowCount: headerRowCount  } = params;
        const userFuncParams = {
            backwards: direction === "Before",
            previousHeaderPosition: currentPosition,
            nextHeaderPosition: headerPosition,
            headerRowCount: headerRowCount
        };
        const userResult = userFunc(userFuncParams);
        if (userResult === true || userResult === null) {
            if (userResult === null) $7b57b57eaf5a9648$export$2cf41453020eef66("Since v31.3 Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour.");
            return currentPosition;
        }
        if (userResult === false) return null;
        return userResult;
    }
    focusProvidedHeaderPosition(params) {
        const { headerPosition: headerPosition , direction: direction , fromCell: fromCell , rowWithoutSpanValue: rowWithoutSpanValue , event: event  } = params;
        const { column: column , headerRowIndex: headerRowIndex  } = headerPosition;
        if (headerRowIndex === -1) {
            if (this.filterManager?.isAdvancedFilterHeaderActive()) return this.focusAdvancedFilter(headerPosition);
            return this.focusGridView(column);
        }
        this.headerNavigationService.scrollToColumn(column, direction);
        const headerRowContainerCtrl = this.ctrlsService.getHeaderRowContainerCtrl(column.getPinned());
        const focusSuccess = headerRowContainerCtrl.focusHeader(headerPosition.headerRowIndex, column, event);
        if (focusSuccess && (rowWithoutSpanValue != null || fromCell)) this.headerNavigationService.setCurrentHeaderRowWithoutSpan(rowWithoutSpanValue ?? -1);
        return focusSuccess;
    }
    focusFirstHeader() {
        let firstColumn = this.visibleColsService.getAllCols()[0];
        if (!firstColumn) return false;
        if (firstColumn.getParent()) firstColumn = this.visibleColsService.getColGroupAtLevel(firstColumn, 0);
        const headerPosition = this.headerPositionUtils.getHeaderIndexToFocus(firstColumn, 0);
        return this.focusHeaderPosition({
            headerPosition: headerPosition,
            rowWithoutSpanValue: 0
        });
    }
    focusLastHeader(event) {
        const headerRowIndex = this.headerNavigationService.getHeaderRowCount() - 1;
        const column = $7b57b57eaf5a9648$export$236389741107357f(this.visibleColsService.getAllCols());
        return this.focusHeaderPosition({
            headerPosition: {
                headerRowIndex: headerRowIndex,
                column: column
            },
            rowWithoutSpanValue: -1,
            event: event
        });
    }
    focusPreviousFromFirstCell(event) {
        if (this.filterManager?.isAdvancedFilterHeaderActive()) return this.focusAdvancedFilter(null);
        return this.focusLastHeader(event);
    }
    isAnyCellFocused() {
        return !!this.focusedCellPosition;
    }
    isRowFocused(rowIndex, rowPinnedType) {
        if (this.focusedCellPosition == null) return false;
        return this.focusedCellPosition.rowIndex === rowIndex && this.focusedCellPosition.rowPinned === $7b57b57eaf5a9648$export$4978424c4f7b5fc0(rowPinnedType);
    }
    findFocusableElements(rootNode, exclude, onlyUnmanaged = false) {
        const focusableString = $7b57b57eaf5a9648$var$FOCUSABLE_SELECTOR;
        let excludeString = $7b57b57eaf5a9648$var$FOCUSABLE_EXCLUDE;
        if (exclude) excludeString += ", " + exclude;
        if (onlyUnmanaged) excludeString += ', [tabindex="-1"]';
        const nodes = Array.prototype.slice.apply(rootNode.querySelectorAll(focusableString)).filter((node)=>{
            return $7b57b57eaf5a9648$export$2badf4aa566524cb(node);
        });
        const excludeNodes = Array.prototype.slice.apply(rootNode.querySelectorAll(excludeString));
        if (!excludeNodes.length) return nodes;
        const diff = (a, b)=>a.filter((element)=>b.indexOf(element) === -1);
        return diff(nodes, excludeNodes);
    }
    focusInto(rootNode, up = false, onlyUnmanaged = false) {
        const focusableElements = this.findFocusableElements(rootNode, null, onlyUnmanaged);
        const toFocus = up ? $7b57b57eaf5a9648$export$236389741107357f(focusableElements) : focusableElements[0];
        if (toFocus) {
            toFocus.focus({
                preventScroll: true
            });
            return true;
        }
        return false;
    }
    findFocusableElementBeforeTabGuard(rootNode, referenceElement) {
        if (!referenceElement) return null;
        const focusableElements = this.findFocusableElements(rootNode);
        const referenceIndex = focusableElements.indexOf(referenceElement);
        if (referenceIndex === -1) return null;
        let lastTabGuardIndex = -1;
        for(let i = referenceIndex - 1; i >= 0; i--)if (focusableElements[i].classList.contains("ag-tab-guard-top" /* TAB_GUARD_TOP */ )) {
            lastTabGuardIndex = i;
            break;
        }
        if (lastTabGuardIndex <= 0) return null;
        return focusableElements[lastTabGuardIndex - 1];
    }
    findNextFocusableElement(rootNode = this.eGridDiv, onlyManaged, backwards) {
        const focusable = this.findFocusableElements(rootNode, onlyManaged ? ':not([tabindex="-1"])' : null);
        const activeEl = this.gos.getActiveDomElement();
        let currentIndex;
        if (onlyManaged) currentIndex = focusable.findIndex((el)=>el.contains(activeEl));
        else currentIndex = focusable.indexOf(activeEl);
        const nextIndex = currentIndex + (backwards ? -1 : 1);
        if (nextIndex < 0 || nextIndex >= focusable.length) return null;
        return focusable[nextIndex];
    }
    isTargetUnderManagedComponent(rootNode, target) {
        if (!target) return false;
        const managedContainers = rootNode.querySelectorAll(`.${$7b57b57eaf5a9648$export$5510e53ed3962582.FOCUS_MANAGED_CLASS}`);
        if (!managedContainers.length) return false;
        for(let i = 0; i < managedContainers.length; i++){
            if (managedContainers[i].contains(target)) return true;
        }
        return false;
    }
    findTabbableParent(node, limit = 5) {
        let counter = 0;
        while(node && $7b57b57eaf5a9648$var$_getTabIndex(node) === null && ++counter <= limit)node = node.parentElement;
        if ($7b57b57eaf5a9648$var$_getTabIndex(node) === null) return null;
        return node;
    }
    focusGridView(column, backwards) {
        if (this.gos.get("suppressCellFocus")) {
            if (backwards) {
                if (!this.gos.get("suppressHeaderFocus")) return this.focusLastHeader();
                return this.focusNextGridCoreContainer(true, true);
            }
            return this.focusNextGridCoreContainer(false);
        }
        const nextRow = backwards ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
        if (!nextRow) return false;
        const { rowIndex: rowIndex , rowPinned: rowPinned  } = nextRow;
        const focusedHeader = this.getFocusedHeader();
        if (!column && focusedHeader) column = focusedHeader.column;
        if (rowIndex == null || !column) return false;
        this.navigationService.ensureCellVisible({
            rowIndex: rowIndex,
            column: column,
            rowPinned: rowPinned
        });
        this.setFocusedCell({
            rowIndex: rowIndex,
            column: column,
            rowPinned: $7b57b57eaf5a9648$export$4978424c4f7b5fc0(rowPinned),
            forceBrowserFocus: true
        });
        this.rangeService?.setRangeToCell({
            rowIndex: rowIndex,
            rowPinned: rowPinned,
            column: column
        });
        return true;
    }
    focusNextGridCoreContainer(backwards, forceOut = false) {
        if (!forceOut && this.gridCtrl.focusNextInnerContainer(backwards)) return true;
        if (forceOut || !backwards && !this.gridCtrl.isDetailGrid()) this.gridCtrl.forceFocusOutOfContainer(backwards);
        return false;
    }
    focusAdvancedFilter(position) {
        this.advancedFilterFocusColumn = position?.column;
        return this.advancedFilterService?.getCtrl().focusHeaderComp() ?? false;
    }
    focusNextFromAdvancedFilter(backwards, forceFirstColumn) {
        const column = (forceFirstColumn ? void 0 : this.advancedFilterFocusColumn) ?? this.visibleColsService.getAllCols()?.[0];
        if (backwards) return this.focusHeaderPosition({
            headerPosition: {
                column: column,
                headerRowIndex: this.headerNavigationService.getHeaderRowCount() - 1
            }
        });
        else return this.focusGridView(column);
    }
    clearAdvancedFilterColumn() {
        this.advancedFilterFocusColumn = void 0;
    }
    addFocusableContainer(container) {
        this.gridCtrl.addFocusableContainer(container);
    }
    removeFocusableContainer(container) {
        this.gridCtrl.removeFocusableContainer(container);
    }
    focusGridInnerElement(fromBottom) {
        return this.gridCtrl.focusInnerElement(fromBottom);
    }
};
$7b57b57eaf5a9648$var$_FocusService.keyboardModeActive = false;
$7b57b57eaf5a9648$var$_FocusService.instanceCount = 0;
var $7b57b57eaf5a9648$export$a48e931b7fcc2862 = $7b57b57eaf5a9648$var$_FocusService;
// community-modules/core/src/gridBodyComp/pinnedWidthService.ts
var $7b57b57eaf5a9648$var$PinnedWidthService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "pinnedWidthService";
    }
    wireBeans(beans) {
        this.visibleColsService = beans.visibleColsService;
    }
    postConstruct() {
        const listener = this.checkContainerWidths.bind(this);
        this.addManagedEventListeners({
            displayedColumnsChanged: listener,
            displayedColumnsWidthChanged: listener
        });
        this.addManagedPropertyListener("domLayout", listener);
    }
    checkContainerWidths() {
        const printLayout = this.gos.isDomLayout("print");
        const newLeftWidth = printLayout ? 0 : this.visibleColsService.getColsLeftWidth();
        const newRightWidth = printLayout ? 0 : this.visibleColsService.getDisplayedColumnsRightWidth();
        if (newLeftWidth != this.leftWidth) {
            this.leftWidth = newLeftWidth;
            this.eventService.dispatchEvent({
                type: "leftPinnedWidthChanged"
            });
        }
        if (newRightWidth != this.rightWidth) {
            this.rightWidth = newRightWidth;
            this.eventService.dispatchEvent({
                type: "rightPinnedWidthChanged"
            });
        }
    }
    getPinnedRightWidth() {
        return this.rightWidth;
    }
    getPinnedLeftWidth() {
        return this.leftWidth;
    }
};
// community-modules/core/src/gridComp/gridCtrl.ts
var $7b57b57eaf5a9648$export$f3c741dac0be9745 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.additionalFocusableContainers = /* @__PURE__ */ new Set();
    }
    wireBeans(beans) {
        this.beans = beans;
        this.focusService = beans.focusService;
        this.visibleColsService = beans.visibleColsService;
    }
    setComp(view, eGridDiv, eGui) {
        this.view = view;
        this.eGridHostDiv = eGridDiv;
        this.eGui = eGui;
        this.eGui.setAttribute("grid-id", this.gridId);
        const { dragAndDropService: dragAndDropService , mouseEventService: mouseEventService , ctrlsService: ctrlsService , resizeObserverService: resizeObserverService  } = this.beans;
        dragAndDropService.addDropTarget({
            getContainer: ()=>this.eGui,
            isInterestedIn: (type)=>type === 1 /* HeaderCell */  || type === 0 /* ToolPanel */ ,
            getIconName: ()=>"notAllowed"
        });
        mouseEventService.stampTopLevelGridCompWithGridInstance(eGridDiv);
        this.createManagedBean(new $7b57b57eaf5a9648$var$LayoutFeature(this.view));
        this.addRtlSupport();
        const unsubscribeFromResize = resizeObserverService.observeResize(this.eGridHostDiv, this.onGridSizeChanged.bind(this));
        this.addDestroyFunc(()=>unsubscribeFromResize());
        ctrlsService.register("gridCtrl", this);
    }
    isDetailGrid() {
        const el = this.focusService.findTabbableParent(this.getGui());
        return el?.getAttribute("row-id")?.startsWith("detail") || false;
    }
    getOptionalSelectors() {
        const beans = this.beans;
        return {
            paginationSelector: beans.paginationService?.getPaginationSelector(),
            gridHeaderDropZonesSelector: beans.columnDropZonesService?.getDropZoneSelector(),
            sideBarSelector: beans.sideBarService?.getSideBarSelector(),
            statusBarSelector: beans.statusBarService?.getStatusPanelSelector(),
            watermarkSelector: beans.licenseManager?.getWatermarkSelector()
        };
    }
    onGridSizeChanged() {
        const event = {
            type: "gridSizeChanged",
            clientWidth: this.eGridHostDiv.clientWidth,
            clientHeight: this.eGridHostDiv.clientHeight
        };
        this.eventService.dispatchEvent(event);
    }
    addRtlSupport() {
        const cssClass = this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr";
        this.view.setRtlClass(cssClass);
    }
    destroyGridUi() {
        this.view.destroyGridUi();
    }
    getGui() {
        return this.eGui;
    }
    setResizeCursor(on) {
        this.view.setCursor(on ? "ew-resize" : null);
    }
    disableUserSelect(on) {
        this.view.setUserSelect(on ? "none" : null);
    }
    focusNextInnerContainer(backwards) {
        const focusableContainers = this.getFocusableContainers();
        const activeEl = this.gos.getActiveDomElement();
        const idxWithFocus = focusableContainers.findIndex((container)=>container.getGui().contains(activeEl));
        const nextIdx = idxWithFocus + (backwards ? -1 : 1);
        if (nextIdx < 0 || nextIdx >= focusableContainers.length) return false;
        if (nextIdx === 0) {
            if (idxWithFocus > 0) {
                const allColumns = this.visibleColsService.getAllCols();
                const lastColumn = $7b57b57eaf5a9648$export$236389741107357f(allColumns);
                if (this.focusService.focusGridView(lastColumn, true)) return true;
            }
            return false;
        }
        return this.focusContainer(focusableContainers[nextIdx], backwards);
    }
    focusInnerElement(fromBottom) {
        const focusableContainers = this.getFocusableContainers();
        const allColumns = this.visibleColsService.getAllCols();
        const userCallbackFunction = this.gos.getCallback("focusGridInnerElement");
        if (userCallbackFunction && userCallbackFunction({
            fromBottom: !!fromBottom
        })) return true;
        if (fromBottom) {
            if (focusableContainers.length > 1) return this.focusContainer($7b57b57eaf5a9648$export$236389741107357f(focusableContainers), true);
            const lastColumn = $7b57b57eaf5a9648$export$236389741107357f(allColumns);
            if (this.focusService.focusGridView(lastColumn, true)) return true;
        }
        if (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus")) {
            if (this.focusService.focusGridView(allColumns[0])) return true;
            for(let i = 1; i < focusableContainers.length; i++){
                if (this.focusService.focusInto(focusableContainers[i].getGui())) return true;
            }
            return false;
        }
        return this.focusService.focusFirstHeader();
    }
    forceFocusOutOfContainer(up = false) {
        this.view.forceFocusOutOfContainer(up);
    }
    addFocusableContainer(container) {
        this.additionalFocusableContainers.add(container);
    }
    removeFocusableContainer(container) {
        this.additionalFocusableContainers.delete(container);
    }
    focusContainer(comp, up) {
        comp?.setAllowFocus?.(true);
        const result = this.focusService.focusInto(comp.getGui(), up);
        comp?.setAllowFocus?.(false);
        return result;
    }
    getFocusableContainers() {
        return [
            ...this.view.getFocusableContainers(),
            ...this.additionalFocusableContainers.values()
        ];
    }
    destroy() {
        this.additionalFocusableContainers.clear();
        super.destroy();
    }
};
// community-modules/core/src/gridComp/gridComp.ts
var $7b57b57eaf5a9648$export$f29859a2c0c53119 = class extends $7b57b57eaf5a9648$export$5a26e3abd1c845b6 {
    constructor(eGridDiv){
        super();
        this.gridBody = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.sideBar = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.pagination = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.rootWrapperBody = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.eGridDiv = eGridDiv;
    }
    postConstruct() {
        const compProxy = {
            destroyGridUi: ()=>this.destroyBean(this),
            setRtlClass: (cssClass)=>this.addCssClass(cssClass),
            forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
            updateLayoutClasses: this.updateLayoutClasses.bind(this),
            getFocusableContainers: this.getFocusableContainers.bind(this),
            setUserSelect: (value)=>{
                this.getGui().style.userSelect = value != null ? value : "";
                this.getGui().style.webkitUserSelect = value != null ? value : "";
            },
            setCursor: (value)=>{
                this.getGui().style.cursor = value != null ? value : "";
            }
        };
        const ctrl = this.createManagedBean(new $7b57b57eaf5a9648$export$f3c741dac0be9745());
        const comps = ctrl.getOptionalSelectors();
        const template = this.createTemplate(comps);
        const requiredComps = [
            $7b57b57eaf5a9648$var$GridBodySelector,
            ...Object.values(comps).filter((c)=>!!c)
        ];
        this.setTemplate(template, requiredComps);
        ctrl.setComp(compProxy, this.eGridDiv, this.getGui());
        this.insertGridIntoDom();
        this.initialiseTabGuard({
            // we want to override the default behaviour to do nothing for onTabKeyDown
            onTabKeyDown: ()=>void 0,
            focusInnerElement: (fromBottom)=>ctrl.focusInnerElement(fromBottom),
            forceFocusOutWhenTabGuardsAreEmpty: true
        });
    }
    insertGridIntoDom() {
        const eGui = this.getGui();
        this.eGridDiv.appendChild(eGui);
        this.addDestroyFunc(()=>{
            this.eGridDiv.removeChild(eGui);
            if (this.gos.get("debug")) $7b57b57eaf5a9648$export$1ce471ee7a8b4d23("Grid removed from DOM");
        });
    }
    updateLayoutClasses(cssClass, params) {
        const eRootWrapperBodyClassList = this.rootWrapperBody.classList;
        eRootWrapperBodyClassList.toggle("ag-layout-auto-height" /* AUTO_HEIGHT */ , params.autoHeight);
        eRootWrapperBodyClassList.toggle("ag-layout-normal" /* NORMAL */ , params.normal);
        eRootWrapperBodyClassList.toggle("ag-layout-print" /* PRINT */ , params.print);
        this.addOrRemoveCssClass("ag-layout-auto-height" /* AUTO_HEIGHT */ , params.autoHeight);
        this.addOrRemoveCssClass("ag-layout-normal" /* NORMAL */ , params.normal);
        this.addOrRemoveCssClass("ag-layout-print" /* PRINT */ , params.print);
    }
    createTemplate(params) {
        const dropZones = params.gridHeaderDropZonesSelector ? "<ag-grid-header-drop-zones></ag-grid-header-drop-zones>" : "";
        const sideBar = params.sideBarSelector ? '<ag-side-bar data-ref="sideBar"></ag-side-bar>' : "";
        const statusBar = params.statusBarSelector ? "<ag-status-bar></ag-status-bar>" : "";
        const watermark = params.watermarkSelector ? "<ag-watermark></ag-watermark>" : "";
        const pagination = params.paginationSelector ? '<ag-pagination data-ref="pagination"></ag-pagination>' : "";
        const template = /* html */ `<div class="ag-root-wrapper" role="presentation">
                ${dropZones}
                <div class="ag-root-wrapper-body" data-ref="rootWrapperBody" role="presentation">
                    <ag-grid-body data-ref="gridBody"></ag-grid-body>
                    ${sideBar}
                </div>
                ${statusBar}
                ${pagination}
                ${watermark}
            </div>`;
        return template;
    }
    getFocusableElement() {
        return this.rootWrapperBody;
    }
    forceFocusOutOfContainer(up = false) {
        if (!up && this.pagination?.isDisplayed()) {
            this.pagination.forceFocusOutOfContainer(up);
            return;
        }
        super.forceFocusOutOfContainer(up);
    }
    getFocusableContainers() {
        const focusableContainers = [
            this.gridBody
        ];
        [
            this.sideBar,
            this.pagination
        ].forEach((comp)=>{
            if (comp) focusableContainers.push(comp);
        });
        return focusableContainers.filter((el)=>$7b57b57eaf5a9648$export$2badf4aa566524cb(el.getGui()));
    }
};
// community-modules/core/src/alignedGridsService.ts
var $7b57b57eaf5a9648$var$AlignedGridsService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "alignedGridsService";
        // flag to mark if we are consuming. to avoid cyclic events (ie other grid firing back to master
        // while processing a master event) we mark this if consuming an event, and if we are, then
        // we don't fire back any events.
        this.consuming = false;
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.columnSizeService = beans.columnSizeService;
        this.ctrlsService = beans.ctrlsService;
        this.columnApplyStateService = beans.columnApplyStateService;
    }
    getAlignedGridApis() {
        let alignedGrids = this.gos.get("alignedGrids") ?? [];
        const isCallbackConfig = typeof alignedGrids === "function";
        if (typeof alignedGrids === "function") alignedGrids = alignedGrids();
        const seeUrl = ()=>`See ${this.getFrameworkOverrides().getDocLink("aligned-grids")}`;
        const apis = alignedGrids.map((alignedGrid)=>{
            if (!alignedGrid) {
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`alignedGrids contains an undefined option.`);
                if (!isCallbackConfig) $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`);
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(seeUrl());
                return;
            }
            if (this.isGridApi(alignedGrid)) return alignedGrid;
            const refOrComp = alignedGrid;
            if ("current" in refOrComp) return refOrComp.current?.api;
            if (!refOrComp.api) $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${seeUrl()}`);
            return refOrComp.api;
        }).filter((api)=>!!api && !api.isDestroyed());
        return apis;
    }
    isGridApi(ref) {
        return !!ref && !!ref.dispatchEvent;
    }
    postConstruct() {
        const fireColumnEvent = this.fireColumnEvent.bind(this);
        this.addManagedEventListeners({
            columnMoved: fireColumnEvent,
            columnVisible: fireColumnEvent,
            columnPinned: fireColumnEvent,
            columnGroupOpened: fireColumnEvent,
            columnResized: fireColumnEvent,
            bodyScroll: this.fireScrollEvent.bind(this),
            alignedGridColumn: ({ event: event  })=>this.onColumnEvent(event),
            alignedGridScroll: ({ event: event  })=>this.onScrollEvent(event)
        });
    }
    // common logic across all the fire methods
    fireEvent(event) {
        if (this.consuming) return;
        this.getAlignedGridApis().forEach((api)=>{
            if (api.isDestroyed()) return;
            api.dispatchEvent(event);
        });
    }
    // common logic across all consume methods. very little common logic, however extracting
    // guarantees consistency across the methods.
    onEvent(callback) {
        this.consuming = true;
        callback();
        this.consuming = false;
    }
    fireColumnEvent(columnEvent) {
        const event = {
            type: "alignedGridColumn",
            event: columnEvent
        };
        this.fireEvent(event);
    }
    fireScrollEvent(scrollEvent) {
        if (scrollEvent.direction !== "horizontal") return;
        const event = {
            type: "alignedGridScroll",
            event: scrollEvent
        };
        this.fireEvent(event);
    }
    onScrollEvent(event) {
        this.onEvent(()=>{
            const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
            gridBodyCon.getScrollFeature().setHorizontalScrollPosition(event.left, true);
        });
    }
    getMasterColumns(event) {
        const result = [];
        if (event.columns) event.columns.forEach((column)=>{
            result.push(column);
        });
        else if (event.column) result.push(event.column);
        return result;
    }
    getColumnIds(event) {
        const result = [];
        if (event.columns) event.columns.forEach((column)=>{
            result.push(column.getColId());
        });
        else if (event.column) result.push(event.column.getColId());
        return result;
    }
    onColumnEvent(event) {
        this.onEvent(()=>{
            switch(event.type){
                case "columnMoved":
                case "columnVisible":
                case "columnPinned":
                case "columnResized":
                    {
                        const colEvent = event;
                        this.processColumnEvent(colEvent);
                        break;
                    }
                case "columnGroupOpened":
                    {
                        const groupOpenedEvent = event;
                        this.processGroupOpenedEvent(groupOpenedEvent);
                        break;
                    }
                case "columnPivotChanged":
                    $7b57b57eaf5a9648$export$2cf41453020eef66("pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.");
                    break;
            }
        });
    }
    processGroupOpenedEvent(groupOpenedEvent) {
        groupOpenedEvent.columnGroups.forEach((masterGroup)=>{
            let otherColumnGroup = null;
            if (masterGroup) {
                const groupId = masterGroup.getGroupId();
                otherColumnGroup = this.columnModel.getProvidedColGroup(groupId);
            }
            if (masterGroup && !otherColumnGroup) return;
            this.columnModel.setColumnGroupOpened(otherColumnGroup, masterGroup.isExpanded(), "alignedGridChanged");
        });
    }
    processColumnEvent(colEvent) {
        const masterColumn = colEvent.column;
        let otherColumn = null;
        if (masterColumn) otherColumn = this.columnModel.getColDefCol(masterColumn.getColId());
        if (masterColumn && !otherColumn) return;
        const masterColumns = this.getMasterColumns(colEvent);
        switch(colEvent.type){
            case "columnMoved":
                {
                    const srcColState = colEvent.api.getColumnState();
                    const destColState = srcColState.map((s)=>({
                            colId: s.colId
                        }));
                    this.columnApplyStateService.applyColumnState({
                        state: destColState,
                        applyOrder: true
                    }, "alignedGridChanged");
                }
                break;
            case "columnVisible":
                {
                    const srcColState = colEvent.api.getColumnState();
                    const destColState = srcColState.map((s)=>({
                            colId: s.colId,
                            hide: s.hide
                        }));
                    this.columnApplyStateService.applyColumnState({
                        state: destColState
                    }, "alignedGridChanged");
                }
                break;
            case "columnPinned":
                {
                    const srcColState = colEvent.api.getColumnState();
                    const destColState = srcColState.map((s)=>({
                            colId: s.colId,
                            pinned: s.pinned
                        }));
                    this.columnApplyStateService.applyColumnState({
                        state: destColState
                    }, "alignedGridChanged");
                }
                break;
            case "columnResized":
                {
                    const resizedEvent = colEvent;
                    const columnWidths = {};
                    masterColumns.forEach((column)=>{
                        columnWidths[column.getId()] = {
                            key: column.getColId(),
                            newWidth: column.getActualWidth()
                        };
                    });
                    resizedEvent.flexColumns?.forEach((col)=>{
                        if (columnWidths[col.getId()]) delete columnWidths[col.getId()];
                    });
                    this.columnSizeService.setColumnWidths(Object.values(columnWidths), false, resizedEvent.finished, "alignedGridChanged");
                    break;
                }
        }
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        const isVerticalScrollShowing = gridBodyCon.isVerticalScrollShowing();
        this.getAlignedGridApis().forEach((api)=>{
            api.setGridOption("alwaysShowVerticalScroll", isVerticalScrollShowing);
        });
    }
};
// community-modules/core/src/alignedGridsModule.ts
var $7b57b57eaf5a9648$var$AlignedGridsModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/aligned-grid",
    beans: [
        $7b57b57eaf5a9648$var$AlignedGridsService
    ]
};
// community-modules/core/src/columns/columnApi.ts
function $7b57b57eaf5a9648$var$getColumnDef(beans, key) {
    const column = beans.columnModel.getColDefCol(key);
    if (column) return column.getColDef();
    return null;
}
function $7b57b57eaf5a9648$var$getColumnDefs(beans) {
    return beans.columnModel.getColumnDefs();
}
function $7b57b57eaf5a9648$var$sizeColumnsToFit(beans, paramsOrGridWidth) {
    if (typeof paramsOrGridWidth === "number") beans.columnSizeService.sizeColumnsToFit(paramsOrGridWidth, "api");
    else beans.ctrlsService.getGridBodyCtrl().sizeColumnsToFit(paramsOrGridWidth);
}
function $7b57b57eaf5a9648$var$setColumnGroupOpened(beans, group, newValue) {
    beans.columnModel.setColumnGroupOpened(group, newValue, "api");
}
function $7b57b57eaf5a9648$var$getColumnGroup(beans, name, instanceId) {
    return beans.visibleColsService.getColumnGroup(name, instanceId);
}
function $7b57b57eaf5a9648$var$getProvidedColumnGroup(beans, name) {
    return beans.columnModel.getProvidedColGroup(name);
}
function $7b57b57eaf5a9648$var$getDisplayNameForColumn(beans, column, location) {
    return beans.columnNameService.getDisplayNameForColumn(column, location) || "";
}
function $7b57b57eaf5a9648$var$getDisplayNameForColumnGroup(beans, columnGroup, location) {
    return beans.columnNameService.getDisplayNameForColumnGroup(columnGroup, location) || "";
}
function $7b57b57eaf5a9648$var$getColumn(beans, key) {
    return beans.columnModel.getColDefCol(key);
}
function $7b57b57eaf5a9648$var$getColumns(beans) {
    return beans.columnModel.getColDefCols();
}
function $7b57b57eaf5a9648$var$applyColumnState(beans, params) {
    return beans.columnApplyStateService.applyColumnState(params, "api");
}
function $7b57b57eaf5a9648$var$getColumnState(beans) {
    return beans.columnGetStateService.getColumnState();
}
function $7b57b57eaf5a9648$var$resetColumnState(beans) {
    beans.columnApplyStateService.resetColumnState("api");
}
function $7b57b57eaf5a9648$var$getColumnGroupState(beans) {
    return beans.columnGroupStateService.getColumnGroupState();
}
function $7b57b57eaf5a9648$var$setColumnGroupState(beans, stateItems) {
    beans.columnGroupStateService.setColumnGroupState(stateItems, "api");
}
function $7b57b57eaf5a9648$var$resetColumnGroupState(beans) {
    beans.columnGroupStateService.resetColumnGroupState("api");
}
function $7b57b57eaf5a9648$var$isPinning(beans) {
    return beans.visibleColsService.isPinningLeft() || beans.visibleColsService.isPinningRight();
}
function $7b57b57eaf5a9648$var$isPinningLeft(beans) {
    return beans.visibleColsService.isPinningLeft();
}
function $7b57b57eaf5a9648$var$isPinningRight(beans) {
    return beans.visibleColsService.isPinningRight();
}
function $7b57b57eaf5a9648$var$getDisplayedColAfter(beans, col) {
    return beans.visibleColsService.getColAfter(col);
}
function $7b57b57eaf5a9648$var$getDisplayedColBefore(beans, col) {
    return beans.visibleColsService.getColBefore(col);
}
function $7b57b57eaf5a9648$var$setColumnVisible(beans, key, visible) {
    beans.columnModel.setColsVisible([
        key
    ], visible, "api");
}
function $7b57b57eaf5a9648$var$setColumnsVisible(beans, keys, visible) {
    beans.columnModel.setColsVisible(keys, visible, "api");
}
function $7b57b57eaf5a9648$var$setColumnPinned(beans, key, pinned) {
    beans.columnModel.setColsPinned([
        key
    ], pinned, "api");
}
function $7b57b57eaf5a9648$var$setColumnsPinned(beans, keys, pinned) {
    beans.columnModel.setColsPinned(keys, pinned, "api");
}
function $7b57b57eaf5a9648$var$getAllGridColumns(beans) {
    return beans.columnModel.getCols();
}
function $7b57b57eaf5a9648$var$getDisplayedLeftColumns(beans) {
    return beans.visibleColsService.getLeftCols();
}
function $7b57b57eaf5a9648$var$getDisplayedCenterColumns(beans) {
    return beans.visibleColsService.getCenterCols();
}
function $7b57b57eaf5a9648$var$getDisplayedRightColumns(beans) {
    return beans.visibleColsService.getRightCols();
}
function $7b57b57eaf5a9648$var$getAllDisplayedColumns(beans) {
    return beans.visibleColsService.getAllCols();
}
function $7b57b57eaf5a9648$var$getAllDisplayedVirtualColumns(beans) {
    return beans.columnViewportService.getViewportColumns();
}
function $7b57b57eaf5a9648$var$moveColumn(beans, key, toIndex) {
    beans.columnMoveService.moveColumns([
        key
    ], toIndex, "api");
}
function $7b57b57eaf5a9648$var$moveColumnByIndex(beans, fromIndex, toIndex) {
    beans.columnMoveService.moveColumnByIndex(fromIndex, toIndex, "api");
}
function $7b57b57eaf5a9648$var$moveColumns2(beans, columnsToMoveKeys, toIndex) {
    beans.columnMoveService.moveColumns(columnsToMoveKeys, toIndex, "api");
}
function $7b57b57eaf5a9648$var$setColumnWidth(beans, key, newWidth, finished = true, source = "api") {
    beans.columnSizeService.setColumnWidths([
        {
            key: key,
            newWidth: newWidth
        }
    ], false, finished, source);
}
function $7b57b57eaf5a9648$var$setColumnWidths(beans, columnWidths, finished = true, source = "api") {
    beans.columnSizeService.setColumnWidths(columnWidths, false, finished, source);
}
function $7b57b57eaf5a9648$var$getLeftDisplayedColumnGroups(beans) {
    return beans.visibleColsService.getTreeLeft();
}
function $7b57b57eaf5a9648$var$getCenterDisplayedColumnGroups(beans) {
    return beans.visibleColsService.getTreeCenter();
}
function $7b57b57eaf5a9648$var$getRightDisplayedColumnGroups(beans) {
    return beans.visibleColsService.getTreeRight();
}
function $7b57b57eaf5a9648$var$getAllDisplayedColumnGroups(beans) {
    return beans.visibleColsService.getAllTrees();
}
function $7b57b57eaf5a9648$var$autoSizeColumn(beans, key, skipHeader) {
    return beans.columnAutosizeService.autoSizeCols({
        colKeys: [
            key
        ],
        skipHeader: skipHeader,
        source: "api"
    });
}
function $7b57b57eaf5a9648$var$autoSizeColumns(beans, keys, skipHeader) {
    beans.columnAutosizeService.autoSizeCols({
        colKeys: keys,
        skipHeader: skipHeader,
        source: "api"
    });
}
function $7b57b57eaf5a9648$var$autoSizeAllColumns(beans, skipHeader) {
    beans.columnAutosizeService.autoSizeAllColumns("api", skipHeader);
}
// community-modules/core/src/columns/dataTypeService.ts
var $7b57b57eaf5a9648$var$MONTH_LOCALE_TEXT = {
    january: "January",
    february: "February",
    march: "March",
    april: "April",
    may: "May",
    june: "June",
    july: "July",
    august: "August",
    september: "September",
    october: "October",
    november: "November",
    december: "December"
};
var $7b57b57eaf5a9648$var$MONTH_KEYS = [
    "january",
    "february",
    "march",
    "april",
    "may",
    "june",
    "july",
    "august",
    "september",
    "october",
    "november",
    "december"
];
var $7b57b57eaf5a9648$export$167d98081c349dc = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "dataTypeService";
        this.dataTypeDefinitions = {};
        this.isWaitingForRowData = false;
        this.isColumnTypeOverrideInDataTypeDefinitions = false;
        // keep track of any column state updates whilst waiting for data types to be inferred
        this.columnStateUpdatesPendingInference = {};
        this.columnStateUpdateListenerDestroyFuncs = [];
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.columnModel = beans.columnModel;
        this.funcColsService = beans.funcColsService;
        this.valueService = beans.valueService;
        this.columnApplyStateService = beans.columnApplyStateService;
    }
    postConstruct() {
        this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
        this.addManagedPropertyListener("groupHideOpenParents", ()=>{
            this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
        });
        this.processDataTypeDefinitions();
        this.addManagedPropertyListener("dataTypeDefinitions", (event)=>{
            this.processDataTypeDefinitions();
            this.columnModel.recreateColumnDefs($7b57b57eaf5a9648$var$convertSourceType(event.source));
        });
    }
    processDataTypeDefinitions() {
        const defaultDataTypes = this.getDefaultDataTypes();
        this.dataTypeDefinitions = {};
        this.formatValueFuncs = {};
        const generateFormatValueFunc = (dataTypeDefinition)=>{
            return (params)=>{
                const { column: column , node: node , value: value  } = params;
                let valueFormatter = column.getColDef().valueFormatter;
                if (valueFormatter === dataTypeDefinition.groupSafeValueFormatter) valueFormatter = dataTypeDefinition.valueFormatter;
                return this.valueService.formatValue(column, node, value, valueFormatter);
            };
        };
        Object.entries(defaultDataTypes).forEach(([cellDataType, dataTypeDefinition])=>{
            const mergedDataTypeDefinition = {
                ...dataTypeDefinition,
                groupSafeValueFormatter: this.createGroupSafeValueFormatter(dataTypeDefinition)
            };
            this.dataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
            this.formatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
        });
        const dataTypeDefinitions = this.gos.get("dataTypeDefinitions") ?? {};
        this.dataTypeMatchers = {};
        Object.entries(dataTypeDefinitions).forEach(([cellDataType, dataTypeDefinition])=>{
            const mergedDataTypeDefinition = this.processDataTypeDefinition(dataTypeDefinition, dataTypeDefinitions, [
                cellDataType
            ], defaultDataTypes);
            if (mergedDataTypeDefinition) {
                this.dataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
                if (dataTypeDefinition.dataTypeMatcher) this.dataTypeMatchers[cellDataType] = dataTypeDefinition.dataTypeMatcher;
                this.formatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
            }
        });
        this.checkObjectValueHandlers(defaultDataTypes);
        [
            "dateString",
            "text",
            "number",
            "boolean",
            "date"
        ].forEach((cellDataType)=>{
            const overriddenDataTypeMatcher = this.dataTypeMatchers[cellDataType];
            if (overriddenDataTypeMatcher) delete this.dataTypeMatchers[cellDataType];
            this.dataTypeMatchers[cellDataType] = overriddenDataTypeMatcher ?? defaultDataTypes[cellDataType].dataTypeMatcher;
        });
    }
    mergeDataTypeDefinitions(parentDataTypeDefinition, childDataTypeDefinition) {
        const mergedDataTypeDefinition = {
            ...parentDataTypeDefinition,
            ...childDataTypeDefinition
        };
        if (parentDataTypeDefinition.columnTypes && childDataTypeDefinition.columnTypes && childDataTypeDefinition.appendColumnTypes) mergedDataTypeDefinition.columnTypes = [
            ...$7b57b57eaf5a9648$var$convertColumnTypes(parentDataTypeDefinition.columnTypes),
            ...$7b57b57eaf5a9648$var$convertColumnTypes(childDataTypeDefinition.columnTypes)
        ];
        return mergedDataTypeDefinition;
    }
    processDataTypeDefinition(dataTypeDefinition, dataTypeDefinitions, alreadyProcessedDataTypes, defaultDataTypes) {
        let mergedDataTypeDefinition;
        const extendsCellDataType = dataTypeDefinition.extendsDataType;
        if (dataTypeDefinition.columnTypes) this.isColumnTypeOverrideInDataTypeDefinitions = true;
        if (dataTypeDefinition.extendsDataType === dataTypeDefinition.baseDataType) {
            let baseDataTypeDefinition = defaultDataTypes[extendsCellDataType];
            const overriddenBaseDataTypeDefinition = dataTypeDefinitions[extendsCellDataType];
            if (baseDataTypeDefinition && overriddenBaseDataTypeDefinition) baseDataTypeDefinition = overriddenBaseDataTypeDefinition;
            if (!this.validateDataTypeDefinition(dataTypeDefinition, baseDataTypeDefinition, extendsCellDataType)) return void 0;
            mergedDataTypeDefinition = this.mergeDataTypeDefinitions(baseDataTypeDefinition, dataTypeDefinition);
        } else {
            if (alreadyProcessedDataTypes.includes(extendsCellDataType)) {
                $7b57b57eaf5a9648$export$2cf41453020eef66('Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.');
                return void 0;
            }
            const extendedDataTypeDefinition = dataTypeDefinitions[extendsCellDataType];
            if (!this.validateDataTypeDefinition(dataTypeDefinition, extendedDataTypeDefinition, extendsCellDataType)) return void 0;
            const mergedExtendedDataTypeDefinition = this.processDataTypeDefinition(extendedDataTypeDefinition, dataTypeDefinitions, [
                ...alreadyProcessedDataTypes,
                extendsCellDataType
            ], defaultDataTypes);
            if (!mergedExtendedDataTypeDefinition) return void 0;
            mergedDataTypeDefinition = this.mergeDataTypeDefinitions(mergedExtendedDataTypeDefinition, dataTypeDefinition);
        }
        return {
            ...mergedDataTypeDefinition,
            groupSafeValueFormatter: this.createGroupSafeValueFormatter(mergedDataTypeDefinition)
        };
    }
    validateDataTypeDefinition(dataTypeDefinition, parentDataTypeDefinition, parentCellDataType) {
        if (!parentDataTypeDefinition) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`The data type definition ${parentCellDataType} does not exist.`);
            return false;
        }
        if (parentDataTypeDefinition.baseDataType !== dataTypeDefinition.baseDataType) {
            $7b57b57eaf5a9648$export$2cf41453020eef66('The "baseDataType" property of a data type definition must match that of its parent.');
            return false;
        }
        return true;
    }
    createGroupSafeValueFormatter(dataTypeDefinition) {
        if (!dataTypeDefinition.valueFormatter) return void 0;
        return (params)=>{
            if (params.node?.group) {
                const aggFunc = params.column.getAggFunc();
                if (aggFunc) {
                    if (aggFunc === "first" || aggFunc === "last") return dataTypeDefinition.valueFormatter(params);
                    if (dataTypeDefinition.baseDataType === "number" && aggFunc !== "count") {
                        if (typeof params.value === "number") return dataTypeDefinition.valueFormatter(params);
                        if (typeof params.value === "object") {
                            if (!params.value) return void 0;
                            if ("toNumber" in params.value) return dataTypeDefinition.valueFormatter({
                                ...params,
                                value: params.value.toNumber()
                            });
                            if ("value" in params.value) return dataTypeDefinition.valueFormatter({
                                ...params,
                                value: params.value.value
                            });
                        }
                    }
                }
                if (!this.gos.get("suppressGroupMaintainValueType")) return void 0;
            } else if (this.groupHideOpenParents && params.column.isRowGroupActive()) {
                if (typeof params.value !== "string" || dataTypeDefinition.dataTypeMatcher?.(params.value)) return dataTypeDefinition.valueFormatter(params);
                if (!this.gos.get("suppressGroupMaintainValueType")) return void 0;
            }
            return dataTypeDefinition.valueFormatter(params);
        };
    }
    updateColDefAndGetColumnType(colDef, userColDef, colId) {
        let { cellDataType: cellDataType  } = userColDef;
        const { field: field  } = userColDef;
        if (cellDataType === void 0) cellDataType = colDef.cellDataType;
        if (cellDataType == null || cellDataType === true) cellDataType = this.canInferCellDataType(colDef, userColDef) ? this.inferCellDataType(field, colId) : false;
        if (!cellDataType) {
            colDef.cellDataType = false;
            return void 0;
        }
        const dataTypeDefinition = this.dataTypeDefinitions[cellDataType];
        if (!dataTypeDefinition) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`Missing data type definition - "${cellDataType}"`);
            return void 0;
        }
        colDef.cellDataType = cellDataType;
        if (dataTypeDefinition.groupSafeValueFormatter) colDef.valueFormatter = dataTypeDefinition.groupSafeValueFormatter;
        if (dataTypeDefinition.valueParser) colDef.valueParser = dataTypeDefinition.valueParser;
        if (!dataTypeDefinition.suppressDefaultProperties) this.setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId);
        return dataTypeDefinition.columnTypes;
    }
    addColumnListeners(column) {
        if (!this.isWaitingForRowData) return;
        const columnStateUpdates = this.columnStateUpdatesPendingInference[column.getColId()];
        if (!columnStateUpdates) return;
        const columnListener = (event)=>{
            columnStateUpdates.add(event.key);
        };
        column.addEventListener("columnStateUpdated", columnListener);
        this.columnStateUpdateListenerDestroyFuncs.push(()=>column.removeEventListener("columnStateUpdated", columnListener));
    }
    canInferCellDataType(colDef, userColDef) {
        if (this.rowModel.getType() !== "clientSide") return false;
        const propsToCheckForInference = {
            cellRenderer: true,
            valueGetter: true,
            valueParser: true,
            refData: true
        };
        if (this.doColDefPropsPreventInference(userColDef, propsToCheckForInference)) return false;
        const columnTypes = userColDef.type === null ? colDef.type : userColDef.type;
        if (columnTypes) {
            const columnTypeDefs = this.gos.get("columnTypes") ?? {};
            const hasPropsPreventingInference = $7b57b57eaf5a9648$var$convertColumnTypes(columnTypes).some((columnType)=>{
                const columnTypeDef = columnTypeDefs[columnType.trim()];
                return columnTypeDef && this.doColDefPropsPreventInference(columnTypeDef, propsToCheckForInference);
            });
            if (hasPropsPreventingInference) return false;
        }
        return !this.doColDefPropsPreventInference(colDef, propsToCheckForInference);
    }
    doColDefPropsPreventInference(colDef, propsToCheckForInference) {
        return [
            [
                "cellRenderer",
                "agSparklineCellRenderer"
            ],
            [
                "valueGetter",
                void 0
            ],
            [
                "valueParser",
                void 0
            ],
            [
                "refData",
                void 0
            ]
        ].some(([prop, comparisonValue])=>this.doesColDefPropPreventInference(colDef, propsToCheckForInference, prop, comparisonValue));
    }
    doesColDefPropPreventInference(colDef, checkProps, prop, comparisonValue) {
        if (!checkProps[prop]) return false;
        const value = colDef[prop];
        if (value === null) {
            checkProps[prop] = false;
            return false;
        } else return comparisonValue === void 0 ? !!value : value === comparisonValue;
    }
    inferCellDataType(field, colId) {
        if (!field) return void 0;
        let value;
        const initialData = this.getInitialData();
        if (initialData) {
            const fieldContainsDots = field.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
            value = $7b57b57eaf5a9648$var$_getValueUsingField(initialData, field, fieldContainsDots);
        } else this.initWaitForRowData(colId);
        if (value == null) return void 0;
        const [cellDataType] = Object.entries(this.dataTypeMatchers).find(([_cellDataType, dataTypeMatcher])=>dataTypeMatcher(value)) ?? [
            "object"
        ];
        return cellDataType;
    }
    getInitialData() {
        const rowData = this.gos.get("rowData");
        if (rowData?.length) return rowData[0];
        else if (this.initialData) return this.initialData;
        else {
            const rowNodes = this.rowModel.getRootNode().allLeafChildren;
            if (rowNodes?.length) return rowNodes[0].data;
        }
        return null;
    }
    initWaitForRowData(colId) {
        this.columnStateUpdatesPendingInference[colId] = /* @__PURE__ */ new Set();
        if (this.isWaitingForRowData) return;
        this.isWaitingForRowData = true;
        const columnTypeOverridesExist = this.isColumnTypeOverrideInDataTypeDefinitions;
        if (columnTypeOverridesExist) this.columnModel.queueResizeOperations();
        const [destroyFunc] = this.addManagedEventListeners({
            rowDataUpdateStarted: (event)=>{
                const { firstRowData: firstRowData  } = event;
                if (!firstRowData) return;
                destroyFunc?.();
                this.isWaitingForRowData = false;
                this.processColumnsPendingInference(firstRowData, columnTypeOverridesExist);
                this.columnStateUpdatesPendingInference = {};
                if (columnTypeOverridesExist) this.columnModel.processResizeOperations();
                const dataTypesInferredEvent = {
                    type: "dataTypesInferred"
                };
                this.eventService.dispatchEvent(dataTypesInferredEvent);
            }
        });
    }
    isPendingInference() {
        return this.isWaitingForRowData;
    }
    processColumnsPendingInference(firstRowData, columnTypeOverridesExist) {
        this.initialData = firstRowData;
        const state = [];
        this.destroyColumnStateUpdateListeners();
        const newRowGroupColumnStateWithoutIndex = {};
        const newPivotColumnStateWithoutIndex = {};
        Object.entries(this.columnStateUpdatesPendingInference).forEach(([colId, columnStateUpdates])=>{
            const column = this.columnModel.getCol(colId);
            if (!column) return;
            const oldColDef = column.getColDef();
            if (!this.columnModel.resetColDefIntoCol(column, "cellDataTypeInferred")) return;
            const newColDef = column.getColDef();
            if (columnTypeOverridesExist && newColDef.type && newColDef.type !== oldColDef.type) {
                const updatedColumnState = this.getUpdatedColumnState(column, columnStateUpdates);
                if (updatedColumnState.rowGroup && updatedColumnState.rowGroupIndex == null) newRowGroupColumnStateWithoutIndex[colId] = updatedColumnState;
                if (updatedColumnState.pivot && updatedColumnState.pivotIndex == null) newPivotColumnStateWithoutIndex[colId] = updatedColumnState;
                state.push(updatedColumnState);
            }
        });
        if (columnTypeOverridesExist) state.push(...this.funcColsService.generateColumnStateForRowGroupAndPivotIndexes(newRowGroupColumnStateWithoutIndex, newPivotColumnStateWithoutIndex));
        if (state.length) this.columnApplyStateService.applyColumnState({
            state: state
        }, "cellDataTypeInferred");
        this.initialData = null;
    }
    getUpdatedColumnState(column, columnStateUpdates) {
        const columnState = this.columnApplyStateService.getColumnStateFromColDef(column);
        columnStateUpdates.forEach((key)=>{
            delete columnState[key];
            if (key === "rowGroup") delete columnState.rowGroupIndex;
            else if (key === "pivot") delete columnState.pivotIndex;
        });
        return columnState;
    }
    checkObjectValueHandlers(defaultDataTypes) {
        const resolvedObjectDataTypeDefinition = this.dataTypeDefinitions.object;
        const defaultObjectDataTypeDefinition = defaultDataTypes.object;
        this.hasObjectValueParser = resolvedObjectDataTypeDefinition.valueParser !== defaultObjectDataTypeDefinition.valueParser;
        this.hasObjectValueFormatter = resolvedObjectDataTypeDefinition.valueFormatter !== defaultObjectDataTypeDefinition.valueFormatter;
    }
    getDateStringTypeDefinition(column) {
        if (!column) return this.dataTypeDefinitions.dateString;
        return this.getDataTypeDefinition(column) ?? this.dataTypeDefinitions.dateString;
    }
    getDateParserFunction(column) {
        return this.getDateStringTypeDefinition(column).dateParser;
    }
    getDateFormatterFunction(column) {
        return this.getDateStringTypeDefinition(column).dateFormatter;
    }
    getDataTypeDefinition(column) {
        const colDef = column.getColDef();
        if (!colDef.cellDataType) return void 0;
        return this.dataTypeDefinitions[colDef.cellDataType];
    }
    getBaseDataType(column) {
        return this.getDataTypeDefinition(column)?.baseDataType;
    }
    checkType(column, value) {
        if (value == null) return true;
        const dataTypeMatcher = this.getDataTypeDefinition(column)?.dataTypeMatcher;
        if (!dataTypeMatcher) return true;
        return dataTypeMatcher(value);
    }
    validateColDef(colDef) {
        if (colDef.cellDataType === "object") {
            if (colDef.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter) $7b57b57eaf5a9648$export$2cf41453020eef66('Cell data type is "object" but no value formatter has been provided. Please either provide an object data type definition with a value formatter, or set "colDef.valueFormatter"');
            if (colDef.editable && colDef.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser) $7b57b57eaf5a9648$export$2cf41453020eef66('Cell data type is "object" but no value parser has been provided. Please either provide an object data type definition with a value parser, or set "colDef.valueParser"');
        }
    }
    getFormatValue(cellDataType) {
        return this.formatValueFuncs[cellDataType];
    }
    setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId) {
        const formatValue = this.formatValueFuncs[cellDataType];
        const usingSetFilter = $7b57b57eaf5a9648$export$dc053975cc7f6c11.__isRegistered("@ag-grid-enterprise/set-filter" /* SetFilterModule */ , this.gridId);
        const translate = this.localeService.getLocaleTextFunc();
        const mergeFilterParams = (params)=>{
            const { filterParams: filterParams  } = colDef;
            colDef.filterParams = typeof filterParams === "object" ? {
                ...filterParams,
                ...params
            } : params;
        };
        switch(dataTypeDefinition.baseDataType){
            case "number":
                colDef.cellEditor = "agNumberCellEditor";
                if (usingSetFilter) mergeFilterParams({
                    comparator: (a, b)=>{
                        const valA = a == null ? 0 : parseInt(a);
                        const valB = b == null ? 0 : parseInt(b);
                        if (valA === valB) return 0;
                        return valA > valB ? 1 : -1;
                    }
                });
                break;
            case "boolean":
                colDef.cellEditor = "agCheckboxCellEditor";
                colDef.cellRenderer = "agCheckboxCellRenderer";
                colDef.suppressKeyboardEvent = (params)=>!!params.colDef.editable && params.event.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.SPACE;
                if (usingSetFilter) mergeFilterParams({
                    valueFormatter: (params)=>{
                        if (!$7b57b57eaf5a9648$export$25d27f17d3af40f7(params.value)) return translate("blanks", "(Blanks)");
                        return translate(String(params.value), params.value ? "True" : "False");
                    }
                });
                else mergeFilterParams({
                    maxNumConditions: 1,
                    debounceMs: 0,
                    filterOptions: [
                        "empty",
                        {
                            displayKey: "true",
                            displayName: "True",
                            predicate: (_filterValues, cellValue)=>cellValue,
                            numberOfInputs: 0
                        },
                        {
                            displayKey: "false",
                            displayName: "False",
                            predicate: (_filterValues, cellValue)=>cellValue === false,
                            numberOfInputs: 0
                        }
                    ]
                });
                break;
            case "date":
                colDef.cellEditor = "agDateCellEditor";
                colDef.keyCreator = formatValue;
                if (usingSetFilter) mergeFilterParams({
                    valueFormatter: (params)=>{
                        const valueFormatted = formatValue(params);
                        return $7b57b57eaf5a9648$export$25d27f17d3af40f7(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
                    },
                    treeList: true,
                    treeListFormatter: (pathKey, level)=>{
                        if (level === 1 && pathKey != null) {
                            const monthKey = $7b57b57eaf5a9648$var$MONTH_KEYS[Number(pathKey) - 1];
                            return translate(monthKey, $7b57b57eaf5a9648$var$MONTH_LOCALE_TEXT[monthKey]);
                        }
                        return pathKey ?? translate("blanks", "(Blanks)");
                    }
                });
                break;
            case "dateString":
                {
                    colDef.cellEditor = "agDateStringCellEditor";
                    colDef.keyCreator = formatValue;
                    const convertToDate = dataTypeDefinition.dateParser;
                    if (usingSetFilter) mergeFilterParams({
                        valueFormatter: (params)=>{
                            const valueFormatted = formatValue(params);
                            return $7b57b57eaf5a9648$export$25d27f17d3af40f7(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
                        },
                        treeList: true,
                        treeListPathGetter: (value)=>{
                            const date = convertToDate(value ?? void 0);
                            return date ? [
                                String(date.getFullYear()),
                                String(date.getMonth() + 1),
                                String(date.getDate())
                            ] : null;
                        },
                        treeListFormatter: (pathKey, level)=>{
                            if (level === 1 && pathKey != null) {
                                const monthKey = $7b57b57eaf5a9648$var$MONTH_KEYS[Number(pathKey) - 1];
                                return translate(monthKey, $7b57b57eaf5a9648$var$MONTH_LOCALE_TEXT[monthKey]);
                            }
                            return pathKey ?? translate("blanks", "(Blanks)");
                        }
                    });
                    else mergeFilterParams({
                        comparator: (filterDate, cellValue)=>{
                            const cellAsDate = convertToDate(cellValue);
                            if (cellValue == null || cellAsDate < filterDate) return -1;
                            if (cellAsDate > filterDate) return 1;
                            return 0;
                        }
                    });
                    break;
                }
            case "object":
                colDef.cellEditorParams = {
                    useFormatter: true
                };
                colDef.comparator = (a, b)=>{
                    const column = this.columnModel.getColDefCol(colId);
                    const colDef2 = column?.getColDef();
                    if (!column || !colDef2) return 0;
                    const valA = a == null ? "" : formatValue({
                        column: column,
                        node: null,
                        value: a
                    });
                    const valB = b == null ? "" : formatValue({
                        column: column,
                        node: null,
                        value: b
                    });
                    if (valA === valB) return 0;
                    return valA > valB ? 1 : -1;
                };
                colDef.keyCreator = formatValue;
                if (usingSetFilter) mergeFilterParams({
                    valueFormatter: (params)=>{
                        const valueFormatted = formatValue(params);
                        return $7b57b57eaf5a9648$export$25d27f17d3af40f7(valueFormatted) ? valueFormatted : translate("blanks", "(Blanks)");
                    }
                });
                else colDef.filterValueGetter = (params)=>formatValue({
                        column: params.column,
                        node: params.node,
                        value: this.valueService.getValue(params.column, params.node)
                    });
                break;
        }
    }
    getDefaultDataTypes() {
        const defaultDateFormatMatcher = (value)=>!!value.match("^\\d{4}-\\d{2}-\\d{2}$");
        const translate = this.localeService.getLocaleTextFunc();
        return {
            number: {
                baseDataType: "number",
                // can be empty space with legacy copy
                valueParser: (params)=>params.newValue?.trim?.() === "" ? null : Number(params.newValue),
                valueFormatter: (params)=>{
                    if (params.value == null) return "";
                    if (typeof params.value !== "number" || isNaN(params.value)) return translate("invalidNumber", "Invalid Number");
                    return String(params.value);
                },
                dataTypeMatcher: (value)=>typeof value === "number"
            },
            text: {
                baseDataType: "text",
                valueParser: (params)=>params.newValue === "" ? null : $7b57b57eaf5a9648$export$2a74c29220d5c88e(params.newValue),
                dataTypeMatcher: (value)=>typeof value === "string"
            },
            boolean: {
                baseDataType: "boolean",
                valueParser: (params)=>{
                    if (params.newValue == null) return params.newValue;
                    return params.newValue?.trim?.() === "" ? null : String(params.newValue).toLowerCase() === "true";
                },
                valueFormatter: (params)=>params.value == null ? "" : String(params.value),
                dataTypeMatcher: (value)=>typeof value === "boolean"
            },
            date: {
                baseDataType: "date",
                valueParser: (params)=>$7b57b57eaf5a9648$export$26ded2d88c01b527(params.newValue == null ? null : String(params.newValue)),
                valueFormatter: (params)=>{
                    if (params.value == null) return "";
                    if (!(params.value instanceof Date) || isNaN(params.value.getTime())) return translate("invalidDate", "Invalid Date");
                    return $7b57b57eaf5a9648$export$3d7fedfb21962874(params.value, false) ?? "";
                },
                dataTypeMatcher: (value)=>value instanceof Date
            },
            dateString: {
                baseDataType: "dateString",
                dateParser: (value)=>$7b57b57eaf5a9648$export$26ded2d88c01b527(value) ?? void 0,
                dateFormatter: (value)=>$7b57b57eaf5a9648$export$3d7fedfb21962874(value ?? null, false) ?? void 0,
                valueParser: (params)=>defaultDateFormatMatcher(String(params.newValue)) ? params.newValue : null,
                valueFormatter: (params)=>defaultDateFormatMatcher(String(params.value)) ? params.value : "",
                dataTypeMatcher: (value)=>typeof value === "string" && defaultDateFormatMatcher(value)
            },
            object: {
                baseDataType: "object",
                valueParser: ()=>null,
                valueFormatter: (params)=>$7b57b57eaf5a9648$export$2a74c29220d5c88e(params.value) ?? ""
            }
        };
    }
    destroyColumnStateUpdateListeners() {
        this.columnStateUpdateListenerDestroyFuncs.forEach((destroyFunc)=>destroyFunc());
        this.columnStateUpdateListenerDestroyFuncs = [];
    }
    destroy() {
        this.dataTypeDefinitions = {};
        this.dataTypeMatchers = {};
        this.formatValueFuncs = {};
        this.columnStateUpdatesPendingInference = {};
        this.destroyColumnStateUpdateListeners();
        super.destroy();
    }
};
// community-modules/core/src/columns/columnModule.ts
var $7b57b57eaf5a9648$var$DataTypeModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/data-type",
    beans: [
        $7b57b57eaf5a9648$export$167d98081c349dc
    ]
};
var $7b57b57eaf5a9648$var$ColumnApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/column-api",
    apiFunctions: {
        getColumnDef: $7b57b57eaf5a9648$var$getColumnDef,
        getColumnDefs: $7b57b57eaf5a9648$var$getColumnDefs,
        sizeColumnsToFit: $7b57b57eaf5a9648$var$sizeColumnsToFit,
        setColumnGroupOpened: $7b57b57eaf5a9648$var$setColumnGroupOpened,
        getColumnGroup: $7b57b57eaf5a9648$var$getColumnGroup,
        getProvidedColumnGroup: $7b57b57eaf5a9648$var$getProvidedColumnGroup,
        getDisplayNameForColumn: $7b57b57eaf5a9648$var$getDisplayNameForColumn,
        getDisplayNameForColumnGroup: $7b57b57eaf5a9648$var$getDisplayNameForColumnGroup,
        getColumn: $7b57b57eaf5a9648$var$getColumn,
        getColumns: $7b57b57eaf5a9648$var$getColumns,
        applyColumnState: $7b57b57eaf5a9648$var$applyColumnState,
        getColumnState: $7b57b57eaf5a9648$var$getColumnState,
        resetColumnState: $7b57b57eaf5a9648$var$resetColumnState,
        getColumnGroupState: $7b57b57eaf5a9648$var$getColumnGroupState,
        setColumnGroupState: $7b57b57eaf5a9648$var$setColumnGroupState,
        resetColumnGroupState: $7b57b57eaf5a9648$var$resetColumnGroupState,
        isPinning: $7b57b57eaf5a9648$var$isPinning,
        isPinningLeft: $7b57b57eaf5a9648$var$isPinningLeft,
        isPinningRight: $7b57b57eaf5a9648$var$isPinningRight,
        getDisplayedColAfter: $7b57b57eaf5a9648$var$getDisplayedColAfter,
        getDisplayedColBefore: $7b57b57eaf5a9648$var$getDisplayedColBefore,
        setColumnVisible: $7b57b57eaf5a9648$var$setColumnVisible,
        setColumnsVisible: $7b57b57eaf5a9648$var$setColumnsVisible,
        setColumnPinned: $7b57b57eaf5a9648$var$setColumnPinned,
        setColumnsPinned: $7b57b57eaf5a9648$var$setColumnsPinned,
        getAllGridColumns: $7b57b57eaf5a9648$var$getAllGridColumns,
        getDisplayedLeftColumns: $7b57b57eaf5a9648$var$getDisplayedLeftColumns,
        getDisplayedCenterColumns: $7b57b57eaf5a9648$var$getDisplayedCenterColumns,
        getDisplayedRightColumns: $7b57b57eaf5a9648$var$getDisplayedRightColumns,
        getAllDisplayedColumns: $7b57b57eaf5a9648$var$getAllDisplayedColumns,
        getAllDisplayedVirtualColumns: $7b57b57eaf5a9648$var$getAllDisplayedVirtualColumns,
        moveColumn: $7b57b57eaf5a9648$var$moveColumn,
        moveColumnByIndex: $7b57b57eaf5a9648$var$moveColumnByIndex,
        moveColumns: $7b57b57eaf5a9648$var$moveColumns2,
        setColumnWidth: $7b57b57eaf5a9648$var$setColumnWidth,
        setColumnWidths: $7b57b57eaf5a9648$var$setColumnWidths,
        getLeftDisplayedColumnGroups: $7b57b57eaf5a9648$var$getLeftDisplayedColumnGroups,
        getCenterDisplayedColumnGroups: $7b57b57eaf5a9648$var$getCenterDisplayedColumnGroups,
        getRightDisplayedColumnGroups: $7b57b57eaf5a9648$var$getRightDisplayedColumnGroups,
        getAllDisplayedColumnGroups: $7b57b57eaf5a9648$var$getAllDisplayedColumnGroups,
        autoSizeColumn: $7b57b57eaf5a9648$var$autoSizeColumn,
        autoSizeColumns: $7b57b57eaf5a9648$var$autoSizeColumns,
        autoSizeAllColumns: $7b57b57eaf5a9648$var$autoSizeAllColumns
    }
};
// community-modules/core/src/dragAndDrop/dragApi.ts
function $7b57b57eaf5a9648$var$addRowDropZone(beans, params) {
    beans.ctrlsService.getGridBodyCtrl().getRowDragFeature().addRowDropZone(params);
}
function $7b57b57eaf5a9648$var$removeRowDropZone(beans, params) {
    const activeDropTarget = beans.dragAndDropService.findExternalZone(params);
    if (activeDropTarget) beans.dragAndDropService.removeDropTarget(activeDropTarget);
}
function $7b57b57eaf5a9648$var$getRowDropZoneParams(beans, events) {
    return beans.ctrlsService.getGridBodyCtrl().getRowDragFeature().getRowDropZone(events);
}
// community-modules/core/src/dragAndDrop/dragModule.ts
var $7b57b57eaf5a9648$var$DragApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/drag-api",
    apiFunctions: {
        addRowDropZone: $7b57b57eaf5a9648$var$addRowDropZone,
        removeRowDropZone: $7b57b57eaf5a9648$var$removeRowDropZone,
        getRowDropZoneParams: $7b57b57eaf5a9648$var$getRowDropZoneParams
    }
};
// community-modules/core/src/pinnedRowModel/pinnedRowApi.ts
function $7b57b57eaf5a9648$var$getPinnedTopRowCount(beans) {
    return beans.pinnedRowModel.getPinnedTopRowCount();
}
function $7b57b57eaf5a9648$var$getPinnedBottomRowCount(beans) {
    return beans.pinnedRowModel.getPinnedBottomRowCount();
}
function $7b57b57eaf5a9648$var$getPinnedTopRow(beans, index) {
    return beans.pinnedRowModel.getPinnedTopRow(index);
}
function $7b57b57eaf5a9648$var$getPinnedBottomRow(beans, index) {
    return beans.pinnedRowModel.getPinnedBottomRow(index);
}
// community-modules/core/src/pinnedRowModel/pinnedRowModule.ts
var $7b57b57eaf5a9648$var$PinnedRowApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/pinned-row-api",
    apiFunctions: {
        getPinnedTopRowCount: $7b57b57eaf5a9648$var$getPinnedTopRowCount,
        getPinnedBottomRowCount: $7b57b57eaf5a9648$var$getPinnedBottomRowCount,
        getPinnedTopRow: $7b57b57eaf5a9648$var$getPinnedTopRow,
        getPinnedBottomRow: $7b57b57eaf5a9648$var$getPinnedBottomRow
    }
};
// community-modules/core/src/rendering/overlays/overlayApi.ts
function $7b57b57eaf5a9648$var$showLoadingOverlay(beans) {
    beans.overlayService.showLoadingOverlay();
}
function $7b57b57eaf5a9648$var$showNoRowsOverlay(beans) {
    beans.overlayService.showNoRowsOverlay();
}
function $7b57b57eaf5a9648$var$hideOverlay(beans) {
    beans.overlayService.hideOverlay();
}
// community-modules/core/src/rendering/overlays/overlayModule.ts
var $7b57b57eaf5a9648$var$OverlayApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/overlay-api",
    apiFunctions: {
        showLoadingOverlay: $7b57b57eaf5a9648$var$showLoadingOverlay,
        showNoRowsOverlay: $7b57b57eaf5a9648$var$showNoRowsOverlay,
        hideOverlay: $7b57b57eaf5a9648$var$hideOverlay
    }
};
// community-modules/core/src/rendering/renderApi.ts
function $7b57b57eaf5a9648$var$setGridAriaProperty(beans, property, value) {
    if (!property) return;
    const eGrid = beans.ctrlsService.getGridBodyCtrl().getGui();
    const ariaProperty = `aria-${property}`;
    if (value === null) eGrid.removeAttribute(ariaProperty);
    else eGrid.setAttribute(ariaProperty, value);
}
function $7b57b57eaf5a9648$var$refreshCells(beans, params = {}) {
    beans.frameworkOverrides.wrapIncoming(()=>beans.rowRenderer.refreshCells(params));
}
function $7b57b57eaf5a9648$var$flashCells(beans, params = {}) {
    const warning = (prop)=>$7b57b57eaf5a9648$export$2cf41453020eef66(`Since v31.1 api.flashCells parameter '${prop}Delay' is deprecated. Please use '${prop}Duration' instead.`);
    if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(params.fadeDelay)) warning("fade");
    if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(params.flashDelay)) warning("flash");
    beans.frameworkOverrides.wrapIncoming(()=>beans.rowRenderer.flashCells(params));
}
function $7b57b57eaf5a9648$var$refreshHeader(beans) {
    beans.frameworkOverrides.wrapIncoming(()=>beans.ctrlsService.getHeaderRowContainerCtrls().forEach((c)=>c.refresh()));
}
function $7b57b57eaf5a9648$var$isAnimationFrameQueueEmpty(beans) {
    return beans.animationFrameService.isQueueEmpty();
}
function $7b57b57eaf5a9648$var$flushAllAnimationFrames(beans) {
    beans.animationFrameService.flushAllFrames();
}
function $7b57b57eaf5a9648$var$getSizesForCurrentTheme(beans) {
    return {
        rowHeight: beans.gos.getRowHeightAsNumber(),
        headerHeight: beans.columnModel.getHeaderHeight()
    };
}
function $7b57b57eaf5a9648$var$getCellRendererInstances(beans, params = {}) {
    const res = beans.rowRenderer.getCellRendererInstances(params);
    const unwrapped = res.map($7b57b57eaf5a9648$export$213d4c63c3df47e4);
    return unwrapped;
}
// community-modules/core/src/rendering/renderModule.ts
var $7b57b57eaf5a9648$var$RenderApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/render-api",
    apiFunctions: {
        setGridAriaProperty: $7b57b57eaf5a9648$var$setGridAriaProperty,
        refreshCells: $7b57b57eaf5a9648$var$refreshCells,
        flashCells: $7b57b57eaf5a9648$var$flashCells,
        refreshHeader: $7b57b57eaf5a9648$var$refreshHeader,
        isAnimationFrameQueueEmpty: $7b57b57eaf5a9648$var$isAnimationFrameQueueEmpty,
        flushAllAnimationFrames: $7b57b57eaf5a9648$var$flushAllAnimationFrames,
        getSizesForCurrentTheme: $7b57b57eaf5a9648$var$getSizesForCurrentTheme,
        getCellRendererInstances: $7b57b57eaf5a9648$var$getCellRendererInstances
    }
};
// community-modules/core/src/api/cellApi.ts
function $7b57b57eaf5a9648$var$expireValueCache(beans) {
    beans.valueCache.expire();
}
function $7b57b57eaf5a9648$var$getValue(beans, colKey, rowNode) {
    return $7b57b57eaf5a9648$var$getCellValue(beans, {
        colKey: colKey,
        rowNode: rowNode
    });
}
function $7b57b57eaf5a9648$var$getCellValue(beans, params) {
    const { colKey: colKey , rowNode: rowNode , useFormatter: useFormatter  } = params;
    const column = beans.columnModel.getColDefCol(colKey) ?? beans.columnModel.getCol(colKey);
    if ($7b57b57eaf5a9648$export$672d9e47bc342bac(column)) return null;
    const value = beans.valueService.getValue(column, rowNode);
    if (useFormatter) {
        const formattedValue = beans.valueService.formatValue(column, rowNode, value);
        return formattedValue ?? $7b57b57eaf5a9648$export$3df06b741968da82(value, true);
    }
    return value;
}
// community-modules/core/src/api/coreApi.ts
function $7b57b57eaf5a9648$var$getGridId(beans) {
    return beans.context.getGridId();
}
function $7b57b57eaf5a9648$var$destroy(beans) {
    beans.gridDestroyService.destroy();
}
function $7b57b57eaf5a9648$var$isDestroyed(beans) {
    return beans.gridDestroyService.isDestroyCalled();
}
function $7b57b57eaf5a9648$var$getGridOption(beans, key) {
    return beans.gos.get(key);
}
function $7b57b57eaf5a9648$var$setGridOption(beans, key, value) {
    $7b57b57eaf5a9648$var$updateGridOptions(beans, {
        [key]: value
    });
}
function $7b57b57eaf5a9648$var$updateGridOptions(beans, options) {
    beans.gos.updateGridOptions({
        options: options
    });
}
// community-modules/core/src/api/eventApi.ts
function $7b57b57eaf5a9648$var$addEventListener(beans, eventType, listener) {
    beans.apiEventService.addEventListener(eventType, listener);
}
function $7b57b57eaf5a9648$var$removeEventListener(beans, eventType, listener) {
    beans.apiEventService.removeEventListener(eventType, listener);
}
function $7b57b57eaf5a9648$var$addGlobalListener(beans, listener) {
    beans.apiEventService.addGlobalListener(listener);
}
function $7b57b57eaf5a9648$var$removeGlobalListener(beans, listener) {
    beans.apiEventService.removeGlobalListener(listener);
}
// community-modules/core/src/api/keyboardNavigationApi.ts
function $7b57b57eaf5a9648$var$getFocusedCell(beans) {
    return beans.focusService.getFocusedCell();
}
function $7b57b57eaf5a9648$var$clearFocusedCell(beans) {
    return beans.focusService.clearFocusedCell();
}
function $7b57b57eaf5a9648$var$setFocusedCell(beans, rowIndex, colKey, rowPinned) {
    beans.focusService.setFocusedCell({
        rowIndex: rowIndex,
        column: colKey,
        rowPinned: rowPinned,
        forceBrowserFocus: true
    });
}
function $7b57b57eaf5a9648$var$tabToNextCell(beans, event) {
    return beans.navigationService.tabToNextCell(false, event);
}
function $7b57b57eaf5a9648$var$tabToPreviousCell(beans, event) {
    return beans.navigationService.tabToNextCell(true, event);
}
function $7b57b57eaf5a9648$var$setFocusedHeader(beans, colKey, floatingFilter = false) {
    const headerPosition = beans.headerNavigationService.getHeaderPositionForColumn(colKey, floatingFilter);
    if (!headerPosition) return;
    beans.focusService.focusHeaderPosition({
        headerPosition: headerPosition
    });
}
// community-modules/core/src/api/menuApi.ts
function $7b57b57eaf5a9648$var$showColumnMenuAfterButtonClick(beans, colKey, buttonElement) {
    const column = beans.columnModel.getCol(colKey);
    beans.menuService.showColumnMenu({
        column: column,
        buttonElement: buttonElement,
        positionBy: "button"
    });
}
function $7b57b57eaf5a9648$var$showColumnMenuAfterMouseClick(beans, colKey, mouseEvent) {
    let column = beans.columnModel.getCol(colKey);
    if (!column) column = beans.columnModel.getColDefCol(colKey);
    if (!column) {
        $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`column '${colKey}' not found`);
        return;
    }
    beans.menuService.showColumnMenu({
        column: column,
        mouseEvent: mouseEvent,
        positionBy: "mouse"
    });
}
function $7b57b57eaf5a9648$var$showColumnMenu(beans, colKey) {
    const column = beans.columnModel.getCol(colKey);
    if (!column) {
        $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`column '${colKey}' not found`);
        return;
    }
    beans.menuService.showColumnMenu({
        column: column,
        positionBy: "auto"
    });
}
function $7b57b57eaf5a9648$var$hidePopupMenu(beans) {
    beans.menuService.hidePopupMenu();
}
// community-modules/core/src/api/rowApi.ts
function $7b57b57eaf5a9648$var$redrawRows(beans, params = {}) {
    const rowNodes = params ? params.rowNodes : void 0;
    beans.frameworkOverrides.wrapIncoming(()=>beans.rowRenderer.redrawRows(rowNodes));
}
function $7b57b57eaf5a9648$var$setRowNodeExpanded(beans, rowNode, expanded, expandParents, forceSync) {
    beans.expansionService.setRowNodeExpanded(rowNode, expanded, expandParents, forceSync);
}
function $7b57b57eaf5a9648$var$getRowNode(beans, id) {
    return beans.rowModel.getRowNode(id);
}
function $7b57b57eaf5a9648$var$addRenderedRowListener(beans, eventName, rowIndex, callback) {
    beans.rowRenderer.addRenderedRowListener(eventName, rowIndex, callback);
}
function $7b57b57eaf5a9648$var$getRenderedNodes(beans) {
    return beans.rowRenderer.getRenderedNodes();
}
function $7b57b57eaf5a9648$var$forEachNode(beans, callback, includeFooterNodes) {
    beans.rowModel.forEachNode(callback, includeFooterNodes);
}
function $7b57b57eaf5a9648$var$getFirstDisplayedRow(beans) {
    return $7b57b57eaf5a9648$var$getFirstDisplayedRowIndex(beans);
}
function $7b57b57eaf5a9648$var$getFirstDisplayedRowIndex(beans) {
    return beans.rowRenderer.getFirstVirtualRenderedRow();
}
function $7b57b57eaf5a9648$var$getLastDisplayedRow(beans) {
    return $7b57b57eaf5a9648$var$getLastDisplayedRowIndex(beans);
}
function $7b57b57eaf5a9648$var$getLastDisplayedRowIndex(beans) {
    return beans.rowRenderer.getLastVirtualRenderedRow();
}
function $7b57b57eaf5a9648$var$getDisplayedRowAtIndex(beans, index) {
    return beans.rowModel.getRow(index);
}
function $7b57b57eaf5a9648$var$getDisplayedRowCount(beans) {
    return beans.rowModel.getRowCount();
}
function $7b57b57eaf5a9648$var$getModel(beans) {
    return beans.rowModel;
}
// community-modules/core/src/api/rowSelectionApi.ts
function $7b57b57eaf5a9648$var$setNodesSelected(beans, params) {
    const allNodesValid = params.nodes.every((node)=>{
        if (node.rowPinned) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("cannot select pinned rows");
            return false;
        }
        if (node.id === void 0) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("cannot select node until id for node is known");
            return false;
        }
        return true;
    });
    if (!allNodesValid) return;
    const { nodes: nodes , source: source , newValue: newValue  } = params;
    const nodesAsRowNode = nodes;
    beans.selectionService.setNodesSelected({
        nodes: nodesAsRowNode,
        source: source ?? "api",
        newValue: newValue
    });
}
function $7b57b57eaf5a9648$var$selectAll(beans, source = "apiSelectAll") {
    beans.selectionService.selectAllRowNodes({
        source: source
    });
}
function $7b57b57eaf5a9648$var$deselectAll(beans, source = "apiSelectAll") {
    beans.selectionService.deselectAllRowNodes({
        source: source
    });
}
function $7b57b57eaf5a9648$var$selectAllFiltered(beans, source = "apiSelectAllFiltered") {
    beans.selectionService.selectAllRowNodes({
        source: source,
        justFiltered: true
    });
}
function $7b57b57eaf5a9648$var$deselectAllFiltered(beans, source = "apiSelectAllFiltered") {
    beans.selectionService.deselectAllRowNodes({
        source: source,
        justFiltered: true
    });
}
function $7b57b57eaf5a9648$var$selectAllOnCurrentPage(beans, source = "apiSelectAllCurrentPage") {
    beans.selectionService.selectAllRowNodes({
        source: source,
        justCurrentPage: true
    });
}
function $7b57b57eaf5a9648$var$deselectAllOnCurrentPage(beans, source = "apiSelectAllCurrentPage") {
    beans.selectionService.deselectAllRowNodes({
        source: source,
        justCurrentPage: true
    });
}
function $7b57b57eaf5a9648$var$getSelectedNodes(beans) {
    return beans.selectionService.getSelectedNodes();
}
function $7b57b57eaf5a9648$var$getSelectedRows(beans) {
    return beans.selectionService.getSelectedRows();
}
// community-modules/core/src/api/sortApi.ts
function $7b57b57eaf5a9648$var$onSortChanged(beans) {
    beans.sortController.onSortChanged("api");
}
// community-modules/core/src/api/apiModule.ts
var $7b57b57eaf5a9648$var$CoreApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/core-api",
    apiFunctions: {
        getGridId: $7b57b57eaf5a9648$var$getGridId,
        destroy: $7b57b57eaf5a9648$var$destroy,
        isDestroyed: $7b57b57eaf5a9648$var$isDestroyed,
        getGridOption: $7b57b57eaf5a9648$var$getGridOption,
        setGridOption: $7b57b57eaf5a9648$var$setGridOption,
        updateGridOptions: $7b57b57eaf5a9648$var$updateGridOptions
    }
};
var $7b57b57eaf5a9648$var$RowSelectionApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/row-selection-api",
    apiFunctions: {
        setNodesSelected: $7b57b57eaf5a9648$var$setNodesSelected,
        selectAll: $7b57b57eaf5a9648$var$selectAll,
        deselectAll: $7b57b57eaf5a9648$var$deselectAll,
        selectAllFiltered: $7b57b57eaf5a9648$var$selectAllFiltered,
        deselectAllFiltered: $7b57b57eaf5a9648$var$deselectAllFiltered,
        selectAllOnCurrentPage: $7b57b57eaf5a9648$var$selectAllOnCurrentPage,
        deselectAllOnCurrentPage: $7b57b57eaf5a9648$var$deselectAllOnCurrentPage,
        getSelectedNodes: $7b57b57eaf5a9648$var$getSelectedNodes,
        getSelectedRows: $7b57b57eaf5a9648$var$getSelectedRows
    }
};
var $7b57b57eaf5a9648$var$RowApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/row-api",
    apiFunctions: {
        redrawRows: $7b57b57eaf5a9648$var$redrawRows,
        setRowNodeExpanded: $7b57b57eaf5a9648$var$setRowNodeExpanded,
        getRowNode: $7b57b57eaf5a9648$var$getRowNode,
        addRenderedRowListener: $7b57b57eaf5a9648$var$addRenderedRowListener,
        getRenderedNodes: $7b57b57eaf5a9648$var$getRenderedNodes,
        forEachNode: $7b57b57eaf5a9648$var$forEachNode,
        getFirstDisplayedRow: $7b57b57eaf5a9648$var$getFirstDisplayedRow,
        getFirstDisplayedRowIndex: $7b57b57eaf5a9648$var$getFirstDisplayedRowIndex,
        getLastDisplayedRow: $7b57b57eaf5a9648$var$getLastDisplayedRow,
        getLastDisplayedRowIndex: $7b57b57eaf5a9648$var$getLastDisplayedRowIndex,
        getDisplayedRowAtIndex: $7b57b57eaf5a9648$var$getDisplayedRowAtIndex,
        getDisplayedRowCount: $7b57b57eaf5a9648$var$getDisplayedRowCount,
        getModel: $7b57b57eaf5a9648$var$getModel
    }
};
var $7b57b57eaf5a9648$var$ScrollApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/scroll-api",
    apiFunctions: {
        getVerticalPixelRange: $7b57b57eaf5a9648$var$getVerticalPixelRange,
        getHorizontalPixelRange: $7b57b57eaf5a9648$var$getHorizontalPixelRange,
        ensureColumnVisible: $7b57b57eaf5a9648$var$ensureColumnVisible,
        ensureIndexVisible: $7b57b57eaf5a9648$var$ensureIndexVisible,
        ensureNodeVisible: $7b57b57eaf5a9648$var$ensureNodeVisible
    }
};
var $7b57b57eaf5a9648$var$KeyboardNavigationApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/keyboard-navigation-api",
    apiFunctions: {
        getFocusedCell: $7b57b57eaf5a9648$var$getFocusedCell,
        clearFocusedCell: $7b57b57eaf5a9648$var$clearFocusedCell,
        setFocusedCell: $7b57b57eaf5a9648$var$setFocusedCell,
        setFocusedHeader: $7b57b57eaf5a9648$var$setFocusedHeader,
        tabToNextCell: $7b57b57eaf5a9648$var$tabToNextCell,
        tabToPreviousCell: $7b57b57eaf5a9648$var$tabToPreviousCell
    }
};
var $7b57b57eaf5a9648$var$EventApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/event-api",
    apiFunctions: {
        addEventListener: $7b57b57eaf5a9648$var$addEventListener,
        addGlobalListener: $7b57b57eaf5a9648$var$addGlobalListener,
        removeEventListener: $7b57b57eaf5a9648$var$removeEventListener,
        removeGlobalListener: $7b57b57eaf5a9648$var$removeGlobalListener
    }
};
var $7b57b57eaf5a9648$var$CellApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/cell-api",
    apiFunctions: {
        expireValueCache: $7b57b57eaf5a9648$var$expireValueCache,
        getValue: $7b57b57eaf5a9648$var$getValue,
        getCellValue: $7b57b57eaf5a9648$var$getCellValue
    }
};
var $7b57b57eaf5a9648$export$4ff511e43a5b287a = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/menu-api",
    apiFunctions: {
        showColumnMenuAfterButtonClick: $7b57b57eaf5a9648$var$showColumnMenuAfterButtonClick,
        showColumnMenuAfterMouseClick: $7b57b57eaf5a9648$var$showColumnMenuAfterMouseClick,
        showColumnMenu: $7b57b57eaf5a9648$var$showColumnMenu,
        hidePopupMenu: $7b57b57eaf5a9648$var$hidePopupMenu
    }
};
var $7b57b57eaf5a9648$var$SortApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/sort-api",
    apiFunctions: {
        onSortChanged: $7b57b57eaf5a9648$var$onSortChanged
    }
};
var $7b57b57eaf5a9648$var$CommunityApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/api",
    dependantModules: [
        $7b57b57eaf5a9648$var$CoreApiModule,
        $7b57b57eaf5a9648$var$PinnedRowApiModule,
        $7b57b57eaf5a9648$var$RowSelectionApiModule,
        $7b57b57eaf5a9648$var$ColumnApiModule,
        $7b57b57eaf5a9648$var$RowApiModule,
        $7b57b57eaf5a9648$var$DragApiModule,
        $7b57b57eaf5a9648$var$ScrollApiModule,
        $7b57b57eaf5a9648$var$OverlayApiModule,
        $7b57b57eaf5a9648$var$KeyboardNavigationApiModule,
        $7b57b57eaf5a9648$var$EventApiModule,
        $7b57b57eaf5a9648$var$RenderApiModule,
        $7b57b57eaf5a9648$var$CellApiModule,
        $7b57b57eaf5a9648$export$4ff511e43a5b287a,
        $7b57b57eaf5a9648$var$SortApiModule
    ]
};
// community-modules/core/src/misc/state/stateApi.ts
function $7b57b57eaf5a9648$var$getState(beans) {
    return beans.stateService?.getState() ?? {};
}
// community-modules/core/src/misc/state/stateService.ts
var $7b57b57eaf5a9648$var$StateService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "stateService";
        this.suppressEvents = true;
        this.queuedUpdateSources = /* @__PURE__ */ new Set();
        this.dispatchStateUpdateEventDebounced = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(()=>this.dispatchQueuedStateUpdateEvents(), 0);
        // If user is doing a manual expand all node by node, we don't want to process one at a time.
        // EVENT_ROW_GROUP_OPENED is already async, so no impact of making the state async here.
        this.onRowGroupOpenedDebounced = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(()=>this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), 0);
        // similar to row expansion, want to debounce. However, selection is synchronous, so need to mark as stale in case `getState` is called.
        this.onRowSelectedDebounced = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(()=>{
            this.staleStateKeys.delete("rowSelection");
            this.updateCachedState("rowSelection", this.getRowSelectionState());
        }, 0);
        this.staleStateKeys = /* @__PURE__ */ new Set();
    }
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
        this.ctrlsService = beans.ctrlsService;
        this.pivotResultColsService = beans.pivotResultColsService;
        this.focusService = beans.focusService;
        this.columnModel = beans.columnModel;
        this.visibleColsService = beans.visibleColsService;
        this.columnGroupStateService = beans.columnGroupStateService;
        this.columnGetStateService = beans.columnGetStateService;
        this.paginationService = beans.paginationService;
        this.rowModel = beans.rowModel;
        this.selectionService = beans.selectionService;
        this.expansionService = beans.expansionService;
        this.columnAnimationService = beans.columnAnimationService;
        this.columnApplyStateService = beans.columnApplyStateService;
        this.sideBarService = beans.sideBarService;
        this.rangeService = beans.rangeService;
    }
    postConstruct() {
        this.isClientSideRowModel = this.rowModel.getType() === "clientSide";
        this.cachedState = this.gos.get("initialState") ?? {};
        this.ctrlsService.whenReady(()=>this.suppressEventsAndDispatchInitEvent(()=>this.setupStateOnGridReady()));
        const [newColumnsLoadedDestroyFunc, rowCountReadyDestroyFunc, firstDataRenderedDestroyFunc] = this.addManagedEventListeners({
            newColumnsLoaded: ({ source: source  })=>{
                if (source === "gridInitializing") {
                    newColumnsLoadedDestroyFunc();
                    this.suppressEventsAndDispatchInitEvent(()=>this.setupStateOnColumnsInitialised());
                }
            },
            rowCountReady: ()=>{
                rowCountReadyDestroyFunc?.();
                this.suppressEventsAndDispatchInitEvent(()=>this.setupStateOnRowCountReady());
            },
            firstDataRendered: ()=>{
                firstDataRenderedDestroyFunc?.();
                this.suppressEventsAndDispatchInitEvent(()=>this.setupStateOnFirstDataRendered());
            }
        });
    }
    getState() {
        if (this.staleStateKeys.size) this.refreshStaleState();
        return this.cachedState;
    }
    setupStateOnGridReady() {
        this.updateCachedState("sideBar", this.getSideBarState());
        const stateUpdater = ()=>this.updateCachedState("sideBar", this.getSideBarState());
        this.addManagedEventListeners({
            toolPanelVisibleChanged: stateUpdater,
            sideBarUpdated: stateUpdater
        });
    }
    setupStateOnColumnsInitialised() {
        const initialState = this.gos.get("initialState") ?? {};
        this.setColumnState(initialState);
        this.setColumnGroupState(initialState);
        this.updateColumnState([
            "aggregation",
            "columnOrder",
            "columnPinning",
            "columnSizing",
            "columnVisibility",
            "pivot",
            "pivot",
            "rowGroup",
            "sort"
        ]);
        this.updateCachedState("columnGroup", this.getColumnGroupState());
        this.addManagedEventListeners({
            columnValueChanged: ()=>this.updateColumnState([
                    "aggregation"
                ]),
            columnMoved: ()=>this.updateColumnState([
                    "columnOrder"
                ]),
            columnPinned: ()=>this.updateColumnState([
                    "columnPinning"
                ]),
            columnResized: ()=>this.updateColumnState([
                    "columnSizing"
                ]),
            columnVisible: ()=>this.updateColumnState([
                    "columnVisibility"
                ]),
            columnPivotChanged: ()=>this.updateColumnState([
                    "pivot"
                ]),
            columnPivotModeChanged: ()=>this.updateColumnState([
                    "pivot"
                ]),
            columnRowGroupChanged: ()=>this.updateColumnState([
                    "rowGroup"
                ]),
            sortChanged: ()=>this.updateColumnState([
                    "sort"
                ]),
            newColumnsLoaded: ()=>this.updateColumnState([
                    "aggregation",
                    "columnOrder",
                    "columnPinning",
                    "columnSizing",
                    "columnVisibility",
                    "pivot",
                    "rowGroup",
                    "sort"
                ]),
            columnGroupOpened: ()=>this.updateCachedState("columnGroup", this.getColumnGroupState())
        });
    }
    setupStateOnRowCountReady() {
        const { filter: filterState , rowGroupExpansion: rowGroupExpansionState , rowSelection: rowSelectionState , pagination: paginationState  } = this.gos.get("initialState") ?? {};
        const advancedFilterModel = this.gos.get("advancedFilterModel");
        if (filterState || advancedFilterModel) this.setFilterState(filterState, advancedFilterModel);
        if (rowGroupExpansionState) this.setRowGroupExpansionState(rowGroupExpansionState);
        if (rowSelectionState) this.setRowSelectionState(rowSelectionState);
        if (paginationState) this.setPaginationState(paginationState);
        this.updateCachedState("filter", this.getFilterState());
        this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState());
        this.updateCachedState("rowSelection", this.getRowSelectionState());
        this.updateCachedState("pagination", this.getPaginationState());
        this.addManagedEventListeners({
            filterChanged: ()=>this.updateCachedState("filter", this.getFilterState()),
            rowGroupOpened: ()=>this.onRowGroupOpenedDebounced(),
            expandOrCollapseAll: ()=>this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()),
            selectionChanged: ()=>{
                this.staleStateKeys.add("rowSelection");
                this.onRowSelectedDebounced();
            },
            paginationChanged: (event)=>{
                if (event.newPage || event.newPageSize) this.updateCachedState("pagination", this.getPaginationState());
            }
        });
    }
    setupStateOnFirstDataRendered() {
        const { scroll: scrollState , rangeSelection: rangeSelectionState , focusedCell: focusedCellState , columnOrder: columnOrderState  } = this.gos.get("initialState") ?? {};
        if (focusedCellState) this.setFocusedCellState(focusedCellState);
        if (rangeSelectionState) this.setRangeSelectionState(rangeSelectionState);
        if (scrollState) this.setScrollState(scrollState);
        this.setColumnPivotState(!!columnOrderState?.orderedColIds);
        this.updateCachedState("sideBar", this.getSideBarState());
        this.updateCachedState("focusedCell", this.getFocusedCellState());
        this.updateCachedState("rangeSelection", this.getRangeSelectionState());
        this.updateCachedState("scroll", this.getScrollState());
        this.addManagedEventListeners({
            cellFocused: ()=>this.updateCachedState("focusedCell", this.getFocusedCellState()),
            rangeSelectionChanged: (event)=>{
                if (event.finished) this.updateCachedState("rangeSelection", this.getRangeSelectionState());
            },
            bodyScrollEnd: ()=>this.updateCachedState("scroll", this.getScrollState())
        });
    }
    getColumnState() {
        const pivotMode = this.columnModel.isPivotMode();
        const sortColumns = [];
        const groupColIds = [];
        const aggregationColumns = [];
        const pivotColIds = [];
        const leftColIds = [];
        const rightColIds = [];
        const hiddenColIds = [];
        const columnSizes = [];
        const columns = [];
        const columnState = this.columnGetStateService.getColumnState();
        for(let i = 0; i < columnState.length; i++){
            const { colId: colId , sort: sort , sortIndex: sortIndex , rowGroup: rowGroup , rowGroupIndex: rowGroupIndex , aggFunc: aggFunc , pivot: pivot , pivotIndex: pivotIndex , pinned: pinned , hide: hide , width: width , flex: flex  } = columnState[i];
            columns.push(colId);
            if (sort) sortColumns[sortIndex ?? 0] = {
                colId: colId,
                sort: sort
            };
            if (rowGroup) groupColIds[rowGroupIndex ?? 0] = colId;
            if (typeof aggFunc === "string") aggregationColumns.push({
                colId: colId,
                aggFunc: aggFunc
            });
            if (pivot) pivotColIds[pivotIndex ?? 0] = colId;
            if (pinned) (pinned === "right" ? rightColIds : leftColIds).push(colId);
            if (hide) hiddenColIds.push(colId);
            if (flex || width) columnSizes.push({
                colId: colId,
                flex: flex ?? void 0,
                width: width
            });
        }
        return {
            sort: sortColumns.length ? {
                sortModel: sortColumns
            } : void 0,
            rowGroup: groupColIds.length ? {
                groupColIds: groupColIds
            } : void 0,
            aggregation: aggregationColumns.length ? {
                aggregationModel: aggregationColumns
            } : void 0,
            pivot: pivotColIds.length || pivotMode ? {
                pivotMode: pivotMode,
                pivotColIds: pivotColIds
            } : void 0,
            columnPinning: leftColIds.length || rightColIds.length ? {
                leftColIds: leftColIds,
                rightColIds: rightColIds
            } : void 0,
            columnVisibility: hiddenColIds.length ? {
                hiddenColIds: hiddenColIds
            } : void 0,
            columnSizing: columnSizes.length ? {
                columnSizingModel: columnSizes
            } : void 0,
            columnOrder: columns.length ? {
                orderedColIds: columns
            } : void 0
        };
    }
    setColumnState(initialState) {
        const { sort: sortState , rowGroup: groupState , aggregation: aggregationState , pivot: pivotState , columnPinning: columnPinningState , columnVisibility: columnVisibilityState , columnSizing: columnSizingState , columnOrder: columnOrderState  } = initialState;
        const columnStateMap = {};
        const getColumnState2 = (colId)=>{
            let columnState = columnStateMap[colId];
            if (columnState) return columnState;
            columnState = {
                colId: colId
            };
            columnStateMap[colId] = columnState;
            return columnState;
        };
        if (sortState) sortState.sortModel.forEach(({ colId: colId , sort: sort  }, sortIndex)=>{
            const columnState = getColumnState2(colId);
            columnState.sort = sort;
            columnState.sortIndex = sortIndex;
        });
        if (groupState) groupState.groupColIds.forEach((colId, rowGroupIndex)=>{
            const columnState = getColumnState2(colId);
            columnState.rowGroup = true;
            columnState.rowGroupIndex = rowGroupIndex;
        });
        if (aggregationState) aggregationState.aggregationModel.forEach(({ colId: colId , aggFunc: aggFunc  })=>{
            getColumnState2(colId).aggFunc = aggFunc;
        });
        if (pivotState) {
            pivotState.pivotColIds.forEach((colId, pivotIndex)=>{
                const columnState = getColumnState2(colId);
                columnState.pivot = true;
                columnState.pivotIndex = pivotIndex;
            });
            this.gos.updateGridOptions({
                options: {
                    pivotMode: pivotState.pivotMode
                },
                source: "gridInitializing"
            });
        }
        if (columnPinningState) {
            columnPinningState.leftColIds.forEach((colId)=>{
                getColumnState2(colId).pinned = "left";
            });
            columnPinningState.rightColIds.forEach((colId)=>{
                getColumnState2(colId).pinned = "right";
            });
        }
        if (columnVisibilityState) columnVisibilityState.hiddenColIds.forEach((colId)=>{
            getColumnState2(colId).hide = true;
        });
        if (columnSizingState) columnSizingState.columnSizingModel.forEach(({ colId: colId , flex: flex , width: width  })=>{
            const columnState = getColumnState2(colId);
            columnState.flex = flex ?? null;
            columnState.width = width;
        });
        const columns = columnOrderState?.orderedColIds;
        const applyOrder = !!columns?.length;
        const columnStates = applyOrder ? columns.map((colId)=>getColumnState2(colId)) : Object.values(columnStateMap);
        if (columnStates.length) {
            this.columnStates = columnStates;
            const defaultState = {
                sort: null,
                sortIndex: null,
                rowGroup: null,
                rowGroupIndex: null,
                aggFunc: null,
                pivot: null,
                pivotIndex: null,
                pinned: null,
                hide: null,
                flex: null
            };
            this.columnApplyStateService.applyColumnState({
                state: columnStates,
                applyOrder: applyOrder,
                defaultState: defaultState
            }, "gridInitializing");
        }
    }
    setColumnPivotState(applyOrder) {
        const columnStates = this.columnStates;
        this.columnStates = void 0;
        const columnGroupStates = this.columnGroupStates;
        this.columnGroupStates = void 0;
        if (!this.pivotResultColsService.isPivotResultColsPresent()) return;
        if (columnStates) {
            const secondaryColumnStates = [];
            for (const columnState of columnStates)if (this.pivotResultColsService.getPivotResultCol(columnState.colId)) secondaryColumnStates.push(columnState);
            this.columnApplyStateService.applyColumnState({
                state: secondaryColumnStates,
                applyOrder: applyOrder
            }, "gridInitializing");
        }
        if (columnGroupStates) this.columnGroupStateService.setColumnGroupState(columnGroupStates, "gridInitializing");
    }
    getColumnGroupState() {
        const columnGroupState = this.columnGroupStateService.getColumnGroupState();
        const openColumnGroups = [];
        columnGroupState.forEach(({ groupId: groupId , open: open  })=>{
            if (open) openColumnGroups.push(groupId);
        });
        return openColumnGroups.length ? {
            openColumnGroupIds: openColumnGroups
        } : void 0;
    }
    setColumnGroupState(initialState) {
        if (!Object.prototype.hasOwnProperty.call(initialState, "columnGroup")) return;
        const openColumnGroups = new Set(initialState.columnGroup?.openColumnGroupIds);
        const existingColumnGroupState = this.columnGroupStateService.getColumnGroupState();
        const stateItems = existingColumnGroupState.map(({ groupId: groupId  })=>{
            const open = openColumnGroups.has(groupId);
            if (open) openColumnGroups.delete(groupId);
            return {
                groupId: groupId,
                open: open
            };
        });
        openColumnGroups.forEach((groupId)=>{
            stateItems.push({
                groupId: groupId,
                open: true
            });
        });
        if (stateItems.length) this.columnGroupStates = stateItems;
        this.columnGroupStateService.setColumnGroupState(stateItems, "gridInitializing");
    }
    getFilterState() {
        let filterModel = this.filterManager?.getFilterModel();
        if (filterModel && Object.keys(filterModel).length === 0) filterModel = void 0;
        const advancedFilterModel = this.filterManager?.getAdvancedFilterModel() ?? void 0;
        return filterModel || advancedFilterModel ? {
            filterModel: filterModel,
            advancedFilterModel: advancedFilterModel
        } : void 0;
    }
    setFilterState(filterState, gridOptionAdvancedFilterModel) {
        const { filterModel: filterModel , advancedFilterModel: advancedFilterModel  } = filterState ?? {
            advancedFilterModel: gridOptionAdvancedFilterModel
        };
        if (filterModel) this.filterManager?.setFilterModel(filterModel, "columnFilter");
        if (advancedFilterModel) this.filterManager?.setAdvancedFilterModel(advancedFilterModel);
    }
    getRangeSelectionState() {
        const cellRanges = this.rangeService?.getCellRanges().map((cellRange)=>{
            const { id: id , type: type , startRow: startRow , endRow: endRow , columns: columns , startColumn: startColumn  } = cellRange;
            return {
                id: id,
                type: type,
                startRow: startRow,
                endRow: endRow,
                colIds: columns.map((column)=>column.getColId()),
                startColId: startColumn.getColId()
            };
        });
        return cellRanges?.length ? {
            cellRanges: cellRanges
        } : void 0;
    }
    setRangeSelectionState(rangeSelectionState) {
        if (!this.gos.get("enableRangeSelection") || !this.rangeService) return;
        const cellRanges = [];
        rangeSelectionState.cellRanges.forEach((cellRange)=>{
            const columns = [];
            cellRange.colIds.forEach((colId)=>{
                const column = this.columnModel.getCol(colId);
                if (column) columns.push(column);
            });
            if (!columns.length) return;
            let startColumn = this.columnModel.getCol(cellRange.startColId);
            if (!startColumn) {
                const allColumns = this.visibleColsService.getAllCols();
                const columnSet = new Set(columns);
                startColumn = allColumns.find((column)=>columnSet.has(column));
            }
            cellRanges.push({
                ...cellRange,
                columns: columns,
                startColumn: startColumn
            });
        });
        this.rangeService.setCellRanges(cellRanges);
    }
    getScrollState() {
        if (!this.isClientSideRowModel) return void 0;
        const scrollFeature = this.ctrlsService.getGridBodyCtrl()?.getScrollFeature();
        const { left: left  } = scrollFeature?.getHScrollPosition() ?? {
            left: 0
        };
        const { top: top  } = scrollFeature?.getVScrollPosition() ?? {
            top: 0
        };
        return top || left ? {
            top: top,
            left: left
        } : void 0;
    }
    setScrollState(scrollState) {
        if (!this.isClientSideRowModel) return;
        const { top: top , left: left  } = scrollState;
        this.ctrlsService.getGridBodyCtrl()?.getScrollFeature().setScrollPosition(top, left);
    }
    getSideBarState() {
        return this.sideBarService?.getSideBarComp()?.getState();
    }
    getFocusedCellState() {
        if (!this.isClientSideRowModel) return void 0;
        const focusedCell = this.focusService.getFocusedCell();
        if (focusedCell) {
            const { column: column , rowIndex: rowIndex , rowPinned: rowPinned  } = focusedCell;
            return {
                colId: column.getColId(),
                rowIndex: rowIndex,
                rowPinned: rowPinned
            };
        }
        return void 0;
    }
    setFocusedCellState(focusedCellState) {
        if (!this.isClientSideRowModel) return;
        const { colId: colId , rowIndex: rowIndex , rowPinned: rowPinned  } = focusedCellState;
        this.focusService.setFocusedCell({
            column: this.columnModel.getCol(colId),
            rowIndex: rowIndex,
            rowPinned: rowPinned,
            forceBrowserFocus: true,
            preventScrollOnBrowserFocus: true
        });
    }
    getPaginationState() {
        if (!this.paginationService) return void 0;
        const page = this.paginationService.getCurrentPage();
        const pageSize = !this.gos.get("paginationAutoPageSize") ? this.paginationService.getPageSize() : void 0;
        if (!page && !pageSize) return;
        return {
            page: page,
            pageSize: pageSize
        };
    }
    setPaginationState(paginationState) {
        if (!this.paginationService) return;
        if (paginationState.pageSize && !this.gos.get("paginationAutoPageSize")) this.paginationService.setPageSize(paginationState.pageSize, "initialState");
        if (typeof paginationState.page === "number") this.paginationService.setPage(paginationState.page);
    }
    getRowSelectionState() {
        const selectionState = this.selectionService.getSelectionState();
        const noSelections = !selectionState || !Array.isArray(selectionState) && (selectionState.selectAll === false || selectionState.selectAllChildren === false) && !selectionState?.toggledNodes?.length;
        return noSelections ? void 0 : selectionState;
    }
    setRowSelectionState(rowSelectionState) {
        this.selectionService.setSelectionState(rowSelectionState, "gridInitializing");
    }
    getRowGroupExpansionState() {
        const expandedRowGroups = this.expansionService.getExpandedRows();
        return expandedRowGroups.length ? {
            expandedRowGroupIds: expandedRowGroups
        } : void 0;
    }
    setRowGroupExpansionState(rowGroupExpansionState) {
        this.expansionService.expandRows(rowGroupExpansionState.expandedRowGroupIds);
    }
    updateColumnState(features) {
        const newColumnState = this.getColumnState();
        let hasChanged = false;
        Object.entries(newColumnState).forEach(([key, value])=>{
            if (!$7b57b57eaf5a9648$export$dbc2068cc90f5875(value, this.cachedState[key])) hasChanged = true;
        });
        this.cachedState = {
            ...this.cachedState,
            ...newColumnState
        };
        if (hasChanged) this.dispatchStateUpdateEvent(features);
    }
    updateCachedState(key, value) {
        const existingValue = this.cachedState[key];
        this.setCachedStateValue(key, value);
        if (!$7b57b57eaf5a9648$export$dbc2068cc90f5875(value, existingValue)) this.dispatchStateUpdateEvent([
            key
        ]);
    }
    setCachedStateValue(key, value) {
        this.cachedState = {
            ...this.cachedState,
            [key]: value
        };
    }
    refreshStaleState() {
        this.staleStateKeys.forEach((key)=>{
            switch(key){
                case "rowSelection":
                    this.setCachedStateValue(key, this.getRowSelectionState());
                    break;
            }
        });
        this.staleStateKeys.clear();
    }
    dispatchStateUpdateEvent(sources) {
        if (this.suppressEvents) return;
        sources.forEach((source)=>this.queuedUpdateSources.add(source));
        this.dispatchStateUpdateEventDebounced();
    }
    dispatchQueuedStateUpdateEvents() {
        const sources = Array.from(this.queuedUpdateSources);
        this.queuedUpdateSources.clear();
        const event = {
            type: "stateUpdated",
            sources: sources,
            state: this.cachedState
        };
        this.eventService.dispatchEvent(event);
    }
    suppressEventsAndDispatchInitEvent(updateFunc) {
        this.suppressEvents = true;
        this.columnAnimationService.setSuppressAnimation(true);
        updateFunc();
        setTimeout(()=>{
            this.suppressEvents = false;
            this.queuedUpdateSources.clear();
            if (!this.isAlive()) return;
            this.columnAnimationService.setSuppressAnimation(false);
            this.dispatchStateUpdateEvent([
                "gridInitializing"
            ]);
        });
    }
};
// community-modules/core/src/misc/state/stateModule.ts
var $7b57b57eaf5a9648$var$StateCoreModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/state-core",
    beans: [
        $7b57b57eaf5a9648$var$StateService
    ]
};
var $7b57b57eaf5a9648$var$StateApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/state-api",
    apiFunctions: {
        getState: $7b57b57eaf5a9648$var$getState
    },
    dependantModules: [
        $7b57b57eaf5a9648$var$StateCoreModule
    ]
};
var $7b57b57eaf5a9648$var$StateModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/state",
    dependantModules: [
        $7b57b57eaf5a9648$var$StateCoreModule,
        $7b57b57eaf5a9648$var$StateApiModule
    ]
};
// community-modules/core/src/pagination/paginationApi.ts
function $7b57b57eaf5a9648$var$paginationIsLastPageFound(beans) {
    return beans.rowModel.isLastRowIndexKnown();
}
function $7b57b57eaf5a9648$var$paginationGetPageSize(beans) {
    return beans.paginationService?.getPageSize() ?? 100;
}
function $7b57b57eaf5a9648$var$paginationGetCurrentPage(beans) {
    return beans.paginationService?.getCurrentPage() ?? 0;
}
function $7b57b57eaf5a9648$var$paginationGetTotalPages(beans) {
    return beans.paginationService?.getTotalPages() ?? 1;
}
function $7b57b57eaf5a9648$var$paginationGetRowCount(beans) {
    return beans.paginationService ? beans.paginationService.getMasterRowCount() : beans.rowModel.getRowCount();
}
function $7b57b57eaf5a9648$var$paginationGoToNextPage(beans) {
    beans.paginationService?.goToNextPage();
}
function $7b57b57eaf5a9648$var$paginationGoToPreviousPage(beans) {
    beans.paginationService?.goToPreviousPage();
}
function $7b57b57eaf5a9648$var$paginationGoToFirstPage(beans) {
    beans.paginationService?.goToFirstPage();
}
function $7b57b57eaf5a9648$var$paginationGoToLastPage(beans) {
    beans.paginationService?.goToLastPage();
}
function $7b57b57eaf5a9648$var$paginationGoToPage(beans, page) {
    beans.paginationService?.goToPage(page);
}
// community-modules/core/src/pagination/paginationAutoPageSizeService.ts
var $7b57b57eaf5a9648$var$PaginationAutoPageSizeService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "paginationAutoPageSizeService";
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
        this.paginationService = beans.paginationService;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>{
            this.centerRowsCtrl = p.center;
            const listener = this.checkPageSize.bind(this);
            this.addManagedEventListeners({
                bodyHeightChanged: listener,
                scrollVisibilityChanged: listener
            });
            this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this));
            this.checkPageSize();
        });
    }
    notActive() {
        return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
    }
    onPaginationAutoSizeChanged() {
        if (this.notActive()) this.paginationService.unsetAutoCalculatedPageSize();
        else this.checkPageSize();
    }
    checkPageSize() {
        if (this.notActive()) return;
        const bodyHeight = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight();
        if (bodyHeight > 0) {
            const update = ()=>{
                const rowHeight = Math.max(this.gos.getRowHeightAsNumber(), 1);
                const newPageSize = Math.floor(bodyHeight / rowHeight);
                this.paginationService.setPageSize(newPageSize, "autoCalculated");
            };
            if (!this.isBodyRendered) {
                update();
                this.isBodyRendered = true;
            } else $7b57b57eaf5a9648$export$cf7e39bfb94de6e(()=>update(), 50)();
        } else this.isBodyRendered = false;
    }
};
// community-modules/core/src/utils/focus.ts
function $7b57b57eaf5a9648$export$8865b8c867776648(comp, eGui, focusService) {
    comp.addManagedElementListeners(eGui, {
        keydown: (e)=>{
            if (!e.defaultPrevented && e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.TAB) {
                const backwards = e.shiftKey;
                if (!focusService.findNextFocusableElement(eGui, false, backwards)) {
                    if (focusService.focusNextGridCoreContainer(backwards)) e.preventDefault();
                }
            }
        }
    });
}
// community-modules/core/src/pagination/pageSizeSelector/pageSizeSelectorComp.ts
var $7b57b57eaf5a9648$var$PageSizeSelectorComp = class extends $7b57b57eaf5a9648$export$16fa2f45be04daa8 {
    constructor(){
        super(/* html */ `<span class="ag-paging-page-size"></span>`);
        this.hasEmptyOption = false;
        this.handlePageSizeItemSelected = ()=>{
            if (!this.selectPageSizeComp) return;
            const newValue = this.selectPageSizeComp.getValue();
            if (!newValue) return;
            const paginationPageSize = Number(newValue);
            if (isNaN(paginationPageSize) || paginationPageSize < 1 || paginationPageSize === this.paginationService.getPageSize()) return;
            this.paginationService.setPageSize(paginationPageSize, "pageSizeSelector");
            if (this.hasEmptyOption) this.toggleSelectDisplay(true);
            this.selectPageSizeComp.getFocusableElement().focus();
        };
    }
    wireBeans(beans) {
        this.paginationService = beans.paginationService;
    }
    postConstruct() {
        this.addManagedPropertyListener("paginationPageSizeSelector", ()=>{
            this.onPageSizeSelectorValuesChange();
        });
        this.addManagedEventListeners({
            paginationChanged: (event)=>this.handlePaginationChanged(event)
        });
    }
    handlePaginationChanged(paginationChangedEvent) {
        if (!this.selectPageSizeComp || !paginationChangedEvent?.newPageSize) return;
        const paginationPageSize = this.paginationService.getPageSize();
        if (this.getPageSizeSelectorValues().includes(paginationPageSize)) this.selectPageSizeComp.setValue(paginationPageSize.toString());
        else if (this.hasEmptyOption) this.selectPageSizeComp.setValue("");
        else this.toggleSelectDisplay(true);
    }
    toggleSelectDisplay(show) {
        if (this.selectPageSizeComp) this.reset();
        if (!show) return;
        this.reloadPageSizesSelector();
        if (!this.selectPageSizeComp) return;
        this.appendChild(this.selectPageSizeComp);
    }
    reset() {
        $7b57b57eaf5a9648$export$69e6e10709eabd91(this.getGui());
        if (!this.selectPageSizeComp) return;
        this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp);
    }
    onPageSizeSelectorValuesChange() {
        if (!this.selectPageSizeComp) return;
        if (this.shouldShowPageSizeSelector()) this.reloadPageSizesSelector();
    }
    shouldShowPageSizeSelector() {
        return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get("paginationPageSizeSelector") !== false;
    }
    reloadPageSizesSelector() {
        const pageSizeOptions = this.getPageSizeSelectorValues();
        const paginationPageSizeOption = this.paginationService.getPageSize();
        const shouldAddAndSelectEmptyOption = !paginationPageSizeOption || !pageSizeOptions.includes(paginationPageSizeOption);
        if (shouldAddAndSelectEmptyOption) {
            pageSizeOptions.unshift("");
            $7b57b57eaf5a9648$export$2cf41453020eef66(`The paginationPageSize grid option is set to a value that is not in the list of page size options.
                Please make sure that the paginationPageSize grid option is set to one of the values in the 
                paginationPageSizeSelector array, or set the paginationPageSizeSelector to false to hide the page size selector.`);
        }
        if (this.selectPageSizeComp) this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp);
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const localisedLabel = localeTextFunc("pageSizeSelectorLabel", "Page Size:");
        const options = pageSizeOptions.map((value)=>({
                value: String(value),
                text: String(value)
            }));
        const localisedAriaLabel = localeTextFunc("ariaPageSizeSelectorLabel", "Page Size");
        this.selectPageSizeComp = this.createManagedBean(new $7b57b57eaf5a9648$export$6f9c460854d56032()).addOptions(options).setValue(String(shouldAddAndSelectEmptyOption ? "" : paginationPageSizeOption)).setAriaLabel(localisedAriaLabel).setLabel(localisedLabel).onValueChange(()=>this.handlePageSizeItemSelected());
        this.hasEmptyOption = shouldAddAndSelectEmptyOption;
    }
    getPageSizeSelectorValues() {
        const defaultValues = [
            20,
            50,
            100
        ];
        const paginationPageSizeSelectorValues = this.gos.get("paginationPageSizeSelector");
        if (!Array.isArray(paginationPageSizeSelectorValues) || !this.validateValues(paginationPageSizeSelectorValues)) return defaultValues;
        return [
            ...paginationPageSizeSelectorValues
        ].sort((a, b)=>a - b);
    }
    validateValues(values) {
        if (!values.length) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`The paginationPageSizeSelector grid option is an empty array. This is most likely a mistake.
                If you want to hide the page size selector, please set the paginationPageSizeSelector to false.`);
            return false;
        }
        for(let i = 0; i < values.length; i++){
            const value = values[i];
            const isNumber = typeof value === "number";
            const isPositive = value > 0;
            if (!isNumber) {
                $7b57b57eaf5a9648$export$2cf41453020eef66(`The paginationPageSizeSelector grid option contains a non-numeric value.
                    Please make sure that all values in the paginationPageSizeSelector array are numbers.`);
                return false;
            }
            if (!isPositive) {
                $7b57b57eaf5a9648$export$2cf41453020eef66(`The paginationPageSizeSelector grid option contains a negative number or zero.
                    Please make sure that all values in the paginationPageSizeSelector array are positive.`);
                return false;
            }
        }
        return true;
    }
    destroy() {
        this.toggleSelectDisplay(false);
        super.destroy();
    }
};
var $7b57b57eaf5a9648$var$PageSizeSelectorSelector = {
    selector: "AG-PAGE-SIZE-SELECTOR",
    component: $7b57b57eaf5a9648$var$PageSizeSelectorComp
};
// community-modules/core/src/pagination/paginationComp.ts
var $7b57b57eaf5a9648$var$PaginationComp = class extends $7b57b57eaf5a9648$export$5a26e3abd1c845b6 {
    constructor(){
        super();
        this.btFirst = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.btPrevious = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.btNext = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.btLast = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.lbRecordCount = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.lbFirstRowOnPage = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.lbLastRowOnPage = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.lbCurrent = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.lbTotal = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.pageSizeComp = $7b57b57eaf5a9648$export$6c811454646ed8be;
        this.previousAndFirstButtonsDisabled = false;
        this.nextButtonDisabled = false;
        this.lastButtonDisabled = false;
        this.areListenersSetup = false;
        this.allowFocusInnerElement = false;
    }
    wireBeans(beans) {
        this.rowNodeBlockLoader = beans.rowNodeBlockLoader;
        this.rowModel = beans.rowModel;
        this.paginationService = beans.paginationService;
        this.focusService = beans.focusService;
    }
    postConstruct() {
        const isRtl = this.gos.get("enableRtl");
        this.setTemplate(this.getTemplate(), [
            $7b57b57eaf5a9648$var$PageSizeSelectorSelector
        ]);
        const { btFirst: btFirst , btPrevious: btPrevious , btNext: btNext , btLast: btLast  } = this;
        this.activateTabIndex([
            btFirst,
            btPrevious,
            btNext,
            btLast
        ]);
        btFirst.insertAdjacentElement("afterbegin", $7b57b57eaf5a9648$export$d8feba07bf373edb(isRtl ? "last" : "first", this.gos));
        btPrevious.insertAdjacentElement("afterbegin", $7b57b57eaf5a9648$export$d8feba07bf373edb(isRtl ? "next" : "previous", this.gos));
        btNext.insertAdjacentElement("afterbegin", $7b57b57eaf5a9648$export$d8feba07bf373edb(isRtl ? "previous" : "next", this.gos));
        btLast.insertAdjacentElement("afterbegin", $7b57b57eaf5a9648$export$d8feba07bf373edb(isRtl ? "first" : "last", this.gos));
        this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this));
        this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this));
        this.addManagedPropertyListeners([
            "paginationPageSizeSelector",
            "paginationAutoPageSize",
            "suppressPaginationPanel"
        ], ()=>this.onPageSizeRelatedOptionsChange());
        this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
        this.initialiseTabGuard({
            // prevent tab guard default logic
            onTabKeyDown: ()=>{},
            focusInnerElement: (fromBottom)=>{
                if (this.allowFocusInnerElement) this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(fromBottom);
                else this.focusService.focusGridInnerElement(fromBottom);
            },
            forceFocusOutWhenTabGuardsAreEmpty: true
        });
        this.onPaginationChanged();
    }
    setAllowFocus(allowFocus) {
        this.allowFocusInnerElement = allowFocus;
    }
    onPaginationChanged() {
        const isPaging = this.gos.get("pagination");
        const paginationPanelEnabled = isPaging && !this.gos.get("suppressPaginationPanel");
        this.setDisplayed(paginationPanelEnabled);
        if (!paginationPanelEnabled) return;
        this.setupListeners();
        this.enableOrDisableButtons();
        this.updateRowLabels();
        this.setCurrentPageLabel();
        this.setTotalLabels();
        this.onPageSizeRelatedOptionsChange();
    }
    onPageSizeRelatedOptionsChange() {
        this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
    }
    setupListeners() {
        if (!this.areListenersSetup) {
            this.addManagedEventListeners({
                paginationChanged: this.onPaginationChanged.bind(this)
            });
            [
                {
                    el: this.btFirst,
                    fn: this.onBtFirst.bind(this)
                },
                {
                    el: this.btPrevious,
                    fn: this.onBtPrevious.bind(this)
                },
                {
                    el: this.btNext,
                    fn: this.onBtNext.bind(this)
                },
                {
                    el: this.btLast,
                    fn: this.onBtLast.bind(this)
                }
            ].forEach((item)=>{
                const { el: el , fn: fn  } = item;
                this.addManagedListeners(el, {
                    click: fn,
                    keydown: (e)=>{
                        if (e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.ENTER || e.key === $7b57b57eaf5a9648$export$e9e0d96f49f57c33.SPACE) {
                            e.preventDefault();
                            fn();
                        }
                    }
                });
            });
            $7b57b57eaf5a9648$export$8865b8c867776648(this, this.getGui(), this.focusService);
            this.areListenersSetup = true;
        }
    }
    onBtFirst() {
        if (!this.previousAndFirstButtonsDisabled) this.paginationService.goToFirstPage();
    }
    setCurrentPageLabel() {
        const pagesExist = this.paginationService.getTotalPages() > 0;
        const currentPage = this.paginationService.getCurrentPage();
        const toDisplay = pagesExist ? currentPage + 1 : 0;
        this.lbCurrent.textContent = this.formatNumber(toDisplay);
    }
    formatNumber(value) {
        const userFunc = this.gos.getCallback("paginationNumberFormatter");
        if (userFunc) {
            const params = {
                value: value
            };
            return userFunc(params);
        }
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const thousandSeparator = localeTextFunc("thousandSeparator", ",");
        const decimalSeparator = localeTextFunc("decimalSeparator", ".");
        return $7b57b57eaf5a9648$export$c8980add4a69422e(value, thousandSeparator, decimalSeparator);
    }
    getTemplate() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const strPage = localeTextFunc("page", "Page");
        const strTo = localeTextFunc("to", "to");
        const strOf = localeTextFunc("of", "of");
        const strFirst = localeTextFunc("firstPage", "First Page");
        const strPrevious = localeTextFunc("previousPage", "Previous Page");
        const strNext = localeTextFunc("nextPage", "Next Page");
        const strLast = localeTextFunc("lastPage", "Last Page");
        const compId = this.getCompId();
        return /* html */ `<div class="ag-paging-panel ag-unselectable" id="ag-${compId}">
                <ag-page-size-selector data-ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-${compId}-first-row" data-ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${compId}-to">${strTo}</span>
                    <span id="ag-${compId}-last-row" data-ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${compId}-of">${strOf}</span>
                    <span id="ag-${compId}-row-count" data-ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div data-ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${strFirst}"></div>
                    <div data-ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${strPrevious}"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-${compId}-start-page">${strPage}</span>
                        <span id="ag-${compId}-start-page-number" data-ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${compId}-of-page">${strOf}</span>
                        <span id="ag-${compId}-of-page-number" data-ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div data-ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${strNext}"></div>
                    <div data-ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${strLast}"></div>
                </span>
            </div>`;
    }
    onBtNext() {
        if (!this.nextButtonDisabled) this.paginationService.goToNextPage();
    }
    onBtPrevious() {
        if (!this.previousAndFirstButtonsDisabled) this.paginationService.goToPreviousPage();
    }
    onBtLast() {
        if (!this.lastButtonDisabled) this.paginationService.goToLastPage();
    }
    enableOrDisableButtons() {
        const currentPage = this.paginationService.getCurrentPage();
        const maxRowFound = this.rowModel.isLastRowIndexKnown();
        const totalPages = this.paginationService.getTotalPages();
        this.previousAndFirstButtonsDisabled = currentPage === 0;
        this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled);
        this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
        const zeroPagesToDisplay = this.isZeroPagesToDisplay();
        const onLastPage = currentPage === totalPages - 1;
        this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
        this.lastButtonDisabled = !maxRowFound || zeroPagesToDisplay || currentPage === totalPages - 1;
        this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled);
        this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
    }
    toggleButtonDisabled(button, disabled) {
        $7b57b57eaf5a9648$export$7ed376f43c6f2bbd(button, disabled);
        button.classList.toggle("ag-disabled", disabled);
    }
    updateRowLabels() {
        const currentPage = this.paginationService.getCurrentPage();
        const pageSize = this.paginationService.getPageSize();
        const maxRowFound = this.rowModel.isLastRowIndexKnown();
        const rowCount = this.rowModel.isLastRowIndexKnown() ? this.paginationService.getMasterRowCount() : null;
        let startRow;
        let endRow;
        if (this.isZeroPagesToDisplay()) startRow = endRow = 0;
        else {
            startRow = pageSize * currentPage + 1;
            endRow = startRow + pageSize - 1;
            if (maxRowFound && endRow > rowCount) endRow = rowCount;
        }
        this.lbFirstRowOnPage.textContent = this.formatNumber(startRow);
        if (this.rowNodeBlockLoader?.isLoading()) {
            const translate = this.localeService.getLocaleTextFunc();
            this.lbLastRowOnPage.innerHTML = translate("pageLastRowUnknown", "?");
        } else this.lbLastRowOnPage.textContent = this.formatNumber(endRow);
    }
    isZeroPagesToDisplay() {
        const maxRowFound = this.rowModel.isLastRowIndexKnown();
        const totalPages = this.paginationService.getTotalPages();
        return maxRowFound && totalPages === 0;
    }
    setTotalLabels() {
        const lastPageFound = this.rowModel.isLastRowIndexKnown();
        const totalPages = this.paginationService.getTotalPages();
        const rowCount = lastPageFound ? this.paginationService.getMasterRowCount() : null;
        if (rowCount === 1) {
            const firstRow = this.rowModel.getRow(0);
            const hiddenGroupRow = firstRow && firstRow.group && !(firstRow.groupData || firstRow.aggData);
            if (hiddenGroupRow) {
                this.setTotalLabelsToZero();
                return;
            }
        }
        if (lastPageFound) {
            this.lbTotal.textContent = this.formatNumber(totalPages);
            this.lbRecordCount.textContent = this.formatNumber(rowCount);
        } else {
            const moreText = this.localeService.getLocaleTextFunc()("more", "more");
            this.lbTotal.innerHTML = moreText;
            this.lbRecordCount.innerHTML = moreText;
        }
    }
    setTotalLabelsToZero() {
        this.lbFirstRowOnPage.textContent = this.formatNumber(0);
        this.lbCurrent.textContent = this.formatNumber(0);
        this.lbLastRowOnPage.textContent = this.formatNumber(0);
        this.lbTotal.textContent = this.formatNumber(0);
        this.lbRecordCount.textContent = this.formatNumber(0);
    }
};
var $7b57b57eaf5a9648$var$PaginationSelector = {
    selector: "AG-PAGINATION",
    component: $7b57b57eaf5a9648$var$PaginationComp
};
// community-modules/core/src/pagination/paginationService.ts
var $7b57b57eaf5a9648$var$PaginationService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "paginationService";
        this.currentPage = 0;
        this.topDisplayedRowIndex = 0;
        this.bottomDisplayedRowIndex = 0;
        this.masterRowCount = 0;
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.pageBoundsService = beans.pageBoundsService;
    }
    postConstruct() {
        this.active = this.gos.get("pagination");
        this.pageSizeFromGridOptions = this.gos.get("paginationPageSize");
        this.paginateChildRows = this.isPaginateChildRows();
        this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this));
        this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
    }
    getPaginationSelector() {
        return $7b57b57eaf5a9648$var$PaginationSelector;
    }
    isPaginateChildRows() {
        const shouldPaginate = this.gos.get("groupRemoveSingleChildren") || this.gos.get("groupRemoveLowestSingleChildren");
        if (shouldPaginate) return true;
        return this.gos.get("paginateChildRows");
    }
    onPaginationGridOptionChanged() {
        this.active = this.gos.get("pagination");
        this.calculatePages();
        this.dispatchPaginationChangedEvent({
            keepRenderedRows: true
        });
    }
    onPageSizeGridOptionChanged() {
        this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
    }
    goToPage(page) {
        if (!this.active || this.currentPage === page || typeof this.currentPage !== "number") return;
        this.currentPage = page;
        this.calculatePages();
        this.dispatchPaginationChangedEvent({
            newPage: true
        });
    }
    isRowPresent(rowNode) {
        const nodeIsInPage = rowNode.rowIndex >= this.topDisplayedRowIndex && rowNode.rowIndex <= this.bottomDisplayedRowIndex;
        return nodeIsInPage;
    }
    getPageForIndex(index) {
        return Math.floor(index / this.pageSize);
    }
    goToPageWithIndex(index) {
        if (!this.active) return;
        const pageNumber = this.getPageForIndex(index);
        this.goToPage(pageNumber);
    }
    isRowInPage(row) {
        if (!this.active) return true;
        const rowPage = this.getPageForIndex(row.rowIndex);
        return rowPage === this.currentPage;
    }
    getCurrentPage() {
        return this.currentPage;
    }
    goToNextPage() {
        this.goToPage(this.currentPage + 1);
    }
    goToPreviousPage() {
        this.goToPage(this.currentPage - 1);
    }
    goToFirstPage() {
        this.goToPage(0);
    }
    goToLastPage() {
        const rowCount = this.rowModel.getRowCount();
        const lastPage = Math.floor(rowCount / this.pageSize);
        this.goToPage(lastPage);
    }
    getPageSize() {
        return this.pageSize;
    }
    getTotalPages() {
        return this.totalPages;
    }
    /** This is only for state setting before data has been loaded */ setPage(page) {
        this.currentPage = page;
    }
    get pageSize() {
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(this.pageSizeAutoCalculated)) return this.pageSizeAutoCalculated;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(this.pageSizeFromPageSizeSelector)) return this.pageSizeFromPageSizeSelector;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(this.pageSizeFromInitialState)) return this.pageSizeFromInitialState;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(this.pageSizeFromGridOptions)) return this.pageSizeFromGridOptions;
        return this.defaultPageSize;
    }
    calculatePages() {
        if (this.active) {
            if (this.paginateChildRows) this.calculatePagesAllRows();
            else this.calculatePagesMasterRowsOnly();
        } else this.calculatedPagesNotActive();
        this.pageBoundsService.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
    }
    unsetAutoCalculatedPageSize() {
        if (this.pageSizeAutoCalculated === void 0) return;
        const oldPageSize = this.pageSizeAutoCalculated;
        this.pageSizeAutoCalculated = void 0;
        if (this.pageSize === oldPageSize) return;
        this.calculatePages();
        this.dispatchPaginationChangedEvent({
            newPageSize: true
        });
    }
    setPageSize(size, source) {
        const currentSize = this.pageSize;
        switch(source){
            case "autoCalculated":
                this.pageSizeAutoCalculated = size;
                break;
            case "pageSizeSelector":
                this.pageSizeFromPageSizeSelector = size;
                if (this.currentPage !== 0) this.goToFirstPage();
                break;
            case "initialState":
                this.pageSizeFromInitialState = size;
                break;
            case "gridOptions":
                this.pageSizeFromGridOptions = size;
                this.pageSizeFromInitialState = void 0;
                this.pageSizeFromPageSizeSelector = void 0;
                if (this.currentPage !== 0) this.goToFirstPage();
                break;
        }
        if (currentSize !== this.pageSize) {
            this.calculatePages();
            this.dispatchPaginationChangedEvent({
                newPageSize: true,
                keepRenderedRows: true
            });
        }
    }
    setZeroRows() {
        this.masterRowCount = 0;
        this.topDisplayedRowIndex = 0;
        this.bottomDisplayedRowIndex = -1;
        this.currentPage = 0;
        this.totalPages = 0;
    }
    adjustCurrentPageIfInvalid() {
        if (this.currentPage >= this.totalPages) this.currentPage = this.totalPages - 1;
        if (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) this.currentPage = 0;
    }
    calculatePagesMasterRowsOnly() {
        this.masterRowCount = this.rowModel.getTopLevelRowCount();
        if (this.masterRowCount <= 0) {
            this.setZeroRows();
            return;
        }
        const masterLastRowIndex = this.masterRowCount - 1;
        this.totalPages = Math.floor(masterLastRowIndex / this.pageSize) + 1;
        this.adjustCurrentPageIfInvalid();
        const masterPageStartIndex = this.pageSize * this.currentPage;
        let masterPageEndIndex = this.pageSize * (this.currentPage + 1) - 1;
        if (masterPageEndIndex > masterLastRowIndex) masterPageEndIndex = masterLastRowIndex;
        this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(masterPageStartIndex);
        if (masterPageEndIndex === masterLastRowIndex) this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
        else {
            const firstIndexNotToShow = this.rowModel.getTopLevelRowDisplayedIndex(masterPageEndIndex + 1);
            this.bottomDisplayedRowIndex = firstIndexNotToShow - 1;
        }
    }
    getMasterRowCount() {
        return this.masterRowCount;
    }
    calculatePagesAllRows() {
        this.masterRowCount = this.rowModel.getRowCount();
        if (this.masterRowCount === 0) {
            this.setZeroRows();
            return;
        }
        const maxRowIndex = this.masterRowCount - 1;
        this.totalPages = Math.floor(maxRowIndex / this.pageSize) + 1;
        this.adjustCurrentPageIfInvalid();
        this.topDisplayedRowIndex = this.pageSize * this.currentPage;
        this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1;
        if (this.bottomDisplayedRowIndex > maxRowIndex) this.bottomDisplayedRowIndex = maxRowIndex;
    }
    calculatedPagesNotActive() {
        this.setPageSize(void 0, "autoCalculated");
        this.totalPages = 1;
        this.currentPage = 0;
        this.topDisplayedRowIndex = 0;
        this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    }
    dispatchPaginationChangedEvent(params) {
        const { keepRenderedRows: keepRenderedRows = false , newPage: newPage = false , newPageSize: newPageSize = false  } = params;
        const paginationChangedEvent = {
            type: "paginationChanged",
            animate: false,
            newData: false,
            newPage: newPage,
            newPageSize: newPageSize,
            keepRenderedRows: keepRenderedRows
        };
        this.eventService.dispatchEvent(paginationChangedEvent);
    }
};
// community-modules/core/src/pagination/paginationModule.ts
var $7b57b57eaf5a9648$var$PaginationCoreModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/pagination-core",
    beans: [
        $7b57b57eaf5a9648$var$PaginationService,
        $7b57b57eaf5a9648$var$PaginationAutoPageSizeService
    ]
};
var $7b57b57eaf5a9648$var$PaginationApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/pagination-api",
    dependantModules: [
        $7b57b57eaf5a9648$var$PaginationCoreModule
    ],
    apiFunctions: {
        paginationIsLastPageFound: $7b57b57eaf5a9648$var$paginationIsLastPageFound,
        paginationGetPageSize: $7b57b57eaf5a9648$var$paginationGetPageSize,
        paginationGetCurrentPage: $7b57b57eaf5a9648$var$paginationGetCurrentPage,
        paginationGetTotalPages: $7b57b57eaf5a9648$var$paginationGetTotalPages,
        paginationGetRowCount: $7b57b57eaf5a9648$var$paginationGetRowCount,
        paginationGoToNextPage: $7b57b57eaf5a9648$var$paginationGoToNextPage,
        paginationGoToPreviousPage: $7b57b57eaf5a9648$var$paginationGoToPreviousPage,
        paginationGoToFirstPage: $7b57b57eaf5a9648$var$paginationGoToFirstPage,
        paginationGoToLastPage: $7b57b57eaf5a9648$var$paginationGoToLastPage,
        paginationGoToPage: $7b57b57eaf5a9648$var$paginationGoToPage
    }
};
var $7b57b57eaf5a9648$var$PaginationModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/pagination",
    dependantModules: [
        $7b57b57eaf5a9648$var$PaginationCoreModule,
        $7b57b57eaf5a9648$var$PaginationApiModule
    ]
};
// community-modules/core/src/validation/apiFunctionValidator.ts
var $7b57b57eaf5a9648$var$coreModule = "@ag-grid-community/core" /* CommunityCoreModule */ ;
var $7b57b57eaf5a9648$var$clientSideRowModelModule = "@ag-grid-community/client-side-row-model" /* ClientSideRowModelModule */ ;
var $7b57b57eaf5a9648$var$csvExportModule = "@ag-grid-community/csv-export" /* CsvExportModule */ ;
var $7b57b57eaf5a9648$var$infiniteRowModelModule = "@ag-grid-community/infinite-row-model" /* InfiniteRowModelModule */ ;
var $7b57b57eaf5a9648$var$advancedFilterModule = "@ag-grid-enterprise/advanced-filter" /* AdvancedFilterModule */ ;
var $7b57b57eaf5a9648$var$gridChartsModule = "@ag-grid-enterprise/charts" /* GridChartsModule */ ;
var $7b57b57eaf5a9648$var$clipboardModule = "@ag-grid-enterprise/clipboard" /* ClipboardModule */ ;
var $7b57b57eaf5a9648$var$excelExportModule = "@ag-grid-enterprise/excel-export" /* ExcelExportModule */ ;
var $7b57b57eaf5a9648$var$masterDetailModule = "@ag-grid-enterprise/master-detail" /* MasterDetailModule */ ;
var $7b57b57eaf5a9648$var$menuModule = "@ag-grid-enterprise/menu" /* MenuModule */ ;
var $7b57b57eaf5a9648$var$rangeSelectionModule = "@ag-grid-enterprise/range-selection" /* RangeSelectionModule */ ;
var $7b57b57eaf5a9648$var$rowGroupingModule = "@ag-grid-enterprise/row-grouping" /* RowGroupingModule */ ;
var $7b57b57eaf5a9648$var$serverSideRowModelModule = "@ag-grid-enterprise/server-side-row-model" /* ServerSideRowModelModule */ ;
var $7b57b57eaf5a9648$var$sideBarModule = "@ag-grid-enterprise/side-bar" /* SideBarModule */ ;
var $7b57b57eaf5a9648$var$statusBarModule = "@ag-grid-enterprise/status-bar" /* StatusBarModule */ ;
var $7b57b57eaf5a9648$var$functionModules = {
    dispatchEvent: $7b57b57eaf5a9648$var$coreModule,
    getState: $7b57b57eaf5a9648$var$coreModule,
    getGridId: $7b57b57eaf5a9648$var$coreModule,
    destroy: $7b57b57eaf5a9648$var$coreModule,
    isDestroyed: $7b57b57eaf5a9648$var$coreModule,
    getGridOption: $7b57b57eaf5a9648$var$coreModule,
    setGridOption: $7b57b57eaf5a9648$var$coreModule,
    updateGridOptions: $7b57b57eaf5a9648$var$coreModule,
    setNodesSelected: $7b57b57eaf5a9648$var$coreModule,
    selectAll: $7b57b57eaf5a9648$var$coreModule,
    deselectAll: $7b57b57eaf5a9648$var$coreModule,
    selectAllFiltered: $7b57b57eaf5a9648$var$coreModule,
    deselectAllFiltered: $7b57b57eaf5a9648$var$coreModule,
    selectAllOnCurrentPage: $7b57b57eaf5a9648$var$coreModule,
    deselectAllOnCurrentPage: $7b57b57eaf5a9648$var$coreModule,
    getSelectedNodes: $7b57b57eaf5a9648$var$coreModule,
    getSelectedRows: $7b57b57eaf5a9648$var$coreModule,
    redrawRows: $7b57b57eaf5a9648$var$coreModule,
    setRowNodeExpanded: $7b57b57eaf5a9648$var$coreModule,
    getRowNode: $7b57b57eaf5a9648$var$coreModule,
    addRenderedRowListener: $7b57b57eaf5a9648$var$coreModule,
    getRenderedNodes: $7b57b57eaf5a9648$var$coreModule,
    forEachNode: $7b57b57eaf5a9648$var$coreModule,
    getFirstDisplayedRow: $7b57b57eaf5a9648$var$coreModule,
    getFirstDisplayedRowIndex: $7b57b57eaf5a9648$var$coreModule,
    getLastDisplayedRow: $7b57b57eaf5a9648$var$coreModule,
    getLastDisplayedRowIndex: $7b57b57eaf5a9648$var$coreModule,
    getDisplayedRowAtIndex: $7b57b57eaf5a9648$var$coreModule,
    getDisplayedRowCount: $7b57b57eaf5a9648$var$coreModule,
    getModel: $7b57b57eaf5a9648$var$coreModule,
    getVerticalPixelRange: $7b57b57eaf5a9648$var$coreModule,
    getHorizontalPixelRange: $7b57b57eaf5a9648$var$coreModule,
    ensureColumnVisible: $7b57b57eaf5a9648$var$coreModule,
    ensureIndexVisible: $7b57b57eaf5a9648$var$coreModule,
    ensureNodeVisible: $7b57b57eaf5a9648$var$coreModule,
    getFocusedCell: $7b57b57eaf5a9648$var$coreModule,
    clearFocusedCell: $7b57b57eaf5a9648$var$coreModule,
    setFocusedCell: $7b57b57eaf5a9648$var$coreModule,
    tabToNextCell: $7b57b57eaf5a9648$var$coreModule,
    tabToPreviousCell: $7b57b57eaf5a9648$var$coreModule,
    setFocusedHeader: $7b57b57eaf5a9648$var$coreModule,
    addEventListener: $7b57b57eaf5a9648$var$coreModule,
    addGlobalListener: $7b57b57eaf5a9648$var$coreModule,
    removeEventListener: $7b57b57eaf5a9648$var$coreModule,
    removeGlobalListener: $7b57b57eaf5a9648$var$coreModule,
    expireValueCache: $7b57b57eaf5a9648$var$coreModule,
    getValue: $7b57b57eaf5a9648$var$coreModule,
    getCellValue: $7b57b57eaf5a9648$var$coreModule,
    showColumnMenuAfterButtonClick: $7b57b57eaf5a9648$var$coreModule,
    showColumnMenuAfterMouseClick: $7b57b57eaf5a9648$var$coreModule,
    showColumnMenu: $7b57b57eaf5a9648$var$coreModule,
    hidePopupMenu: $7b57b57eaf5a9648$var$coreModule,
    onSortChanged: $7b57b57eaf5a9648$var$coreModule,
    getPinnedTopRowCount: $7b57b57eaf5a9648$var$coreModule,
    getPinnedBottomRowCount: $7b57b57eaf5a9648$var$coreModule,
    getPinnedTopRow: $7b57b57eaf5a9648$var$coreModule,
    getPinnedBottomRow: $7b57b57eaf5a9648$var$coreModule,
    showLoadingOverlay: $7b57b57eaf5a9648$var$coreModule,
    showNoRowsOverlay: $7b57b57eaf5a9648$var$coreModule,
    hideOverlay: $7b57b57eaf5a9648$var$coreModule,
    setGridAriaProperty: $7b57b57eaf5a9648$var$coreModule,
    refreshCells: $7b57b57eaf5a9648$var$coreModule,
    flashCells: $7b57b57eaf5a9648$var$coreModule,
    refreshHeader: $7b57b57eaf5a9648$var$coreModule,
    isAnimationFrameQueueEmpty: $7b57b57eaf5a9648$var$coreModule,
    flushAllAnimationFrames: $7b57b57eaf5a9648$var$coreModule,
    getSizesForCurrentTheme: $7b57b57eaf5a9648$var$coreModule,
    getCellRendererInstances: $7b57b57eaf5a9648$var$coreModule,
    addRowDropZone: $7b57b57eaf5a9648$var$coreModule,
    removeRowDropZone: $7b57b57eaf5a9648$var$coreModule,
    getRowDropZoneParams: $7b57b57eaf5a9648$var$coreModule,
    getColumnDef: $7b57b57eaf5a9648$var$coreModule,
    getColumnDefs: $7b57b57eaf5a9648$var$coreModule,
    sizeColumnsToFit: $7b57b57eaf5a9648$var$coreModule,
    setColumnGroupOpened: $7b57b57eaf5a9648$var$coreModule,
    getColumnGroup: $7b57b57eaf5a9648$var$coreModule,
    getProvidedColumnGroup: $7b57b57eaf5a9648$var$coreModule,
    getDisplayNameForColumn: $7b57b57eaf5a9648$var$coreModule,
    getDisplayNameForColumnGroup: $7b57b57eaf5a9648$var$coreModule,
    getColumn: $7b57b57eaf5a9648$var$coreModule,
    getColumns: $7b57b57eaf5a9648$var$coreModule,
    applyColumnState: $7b57b57eaf5a9648$var$coreModule,
    getColumnState: $7b57b57eaf5a9648$var$coreModule,
    resetColumnState: $7b57b57eaf5a9648$var$coreModule,
    getColumnGroupState: $7b57b57eaf5a9648$var$coreModule,
    setColumnGroupState: $7b57b57eaf5a9648$var$coreModule,
    resetColumnGroupState: $7b57b57eaf5a9648$var$coreModule,
    isPinning: $7b57b57eaf5a9648$var$coreModule,
    isPinningLeft: $7b57b57eaf5a9648$var$coreModule,
    isPinningRight: $7b57b57eaf5a9648$var$coreModule,
    getDisplayedColAfter: $7b57b57eaf5a9648$var$coreModule,
    getDisplayedColBefore: $7b57b57eaf5a9648$var$coreModule,
    setColumnVisible: $7b57b57eaf5a9648$var$coreModule,
    setColumnsVisible: $7b57b57eaf5a9648$var$coreModule,
    setColumnPinned: $7b57b57eaf5a9648$var$coreModule,
    setColumnsPinned: $7b57b57eaf5a9648$var$coreModule,
    getAllGridColumns: $7b57b57eaf5a9648$var$coreModule,
    getDisplayedLeftColumns: $7b57b57eaf5a9648$var$coreModule,
    getDisplayedCenterColumns: $7b57b57eaf5a9648$var$coreModule,
    getDisplayedRightColumns: $7b57b57eaf5a9648$var$coreModule,
    getAllDisplayedColumns: $7b57b57eaf5a9648$var$coreModule,
    getAllDisplayedVirtualColumns: $7b57b57eaf5a9648$var$coreModule,
    moveColumn: $7b57b57eaf5a9648$var$coreModule,
    moveColumnByIndex: $7b57b57eaf5a9648$var$coreModule,
    moveColumns: $7b57b57eaf5a9648$var$coreModule,
    setColumnWidth: $7b57b57eaf5a9648$var$coreModule,
    setColumnWidths: $7b57b57eaf5a9648$var$coreModule,
    getLeftDisplayedColumnGroups: $7b57b57eaf5a9648$var$coreModule,
    getCenterDisplayedColumnGroups: $7b57b57eaf5a9648$var$coreModule,
    getRightDisplayedColumnGroups: $7b57b57eaf5a9648$var$coreModule,
    getAllDisplayedColumnGroups: $7b57b57eaf5a9648$var$coreModule,
    autoSizeColumn: $7b57b57eaf5a9648$var$coreModule,
    autoSizeColumns: $7b57b57eaf5a9648$var$coreModule,
    autoSizeAllColumns: $7b57b57eaf5a9648$var$coreModule,
    undoCellEditing: $7b57b57eaf5a9648$var$coreModule,
    redoCellEditing: $7b57b57eaf5a9648$var$coreModule,
    getCellEditorInstances: $7b57b57eaf5a9648$var$coreModule,
    getEditingCells: $7b57b57eaf5a9648$var$coreModule,
    stopEditing: $7b57b57eaf5a9648$var$coreModule,
    startEditingCell: $7b57b57eaf5a9648$var$coreModule,
    getCurrentUndoSize: $7b57b57eaf5a9648$var$coreModule,
    getCurrentRedoSize: $7b57b57eaf5a9648$var$coreModule,
    isAnyFilterPresent: $7b57b57eaf5a9648$var$coreModule,
    onFilterChanged: $7b57b57eaf5a9648$var$coreModule,
    isColumnFilterPresent: $7b57b57eaf5a9648$var$coreModule,
    getFilterInstance: $7b57b57eaf5a9648$var$coreModule,
    getColumnFilterInstance: $7b57b57eaf5a9648$var$coreModule,
    destroyFilter: $7b57b57eaf5a9648$var$coreModule,
    setFilterModel: $7b57b57eaf5a9648$var$coreModule,
    getFilterModel: $7b57b57eaf5a9648$var$coreModule,
    getColumnFilterModel: $7b57b57eaf5a9648$var$coreModule,
    setColumnFilterModel: $7b57b57eaf5a9648$var$coreModule,
    showColumnFilter: $7b57b57eaf5a9648$var$coreModule,
    isQuickFilterPresent: $7b57b57eaf5a9648$var$coreModule,
    getQuickFilter: $7b57b57eaf5a9648$var$coreModule,
    resetQuickFilter: $7b57b57eaf5a9648$var$coreModule,
    paginationIsLastPageFound: $7b57b57eaf5a9648$var$coreModule,
    paginationGetPageSize: $7b57b57eaf5a9648$var$coreModule,
    paginationGetCurrentPage: $7b57b57eaf5a9648$var$coreModule,
    paginationGetTotalPages: $7b57b57eaf5a9648$var$coreModule,
    paginationGetRowCount: $7b57b57eaf5a9648$var$coreModule,
    paginationGoToNextPage: $7b57b57eaf5a9648$var$coreModule,
    paginationGoToPreviousPage: $7b57b57eaf5a9648$var$coreModule,
    paginationGoToFirstPage: $7b57b57eaf5a9648$var$coreModule,
    paginationGoToLastPage: $7b57b57eaf5a9648$var$coreModule,
    paginationGoToPage: $7b57b57eaf5a9648$var$coreModule,
    // These may need updating to say which of multiple possible modules they could be missing from.
    expandAll: $7b57b57eaf5a9648$var$coreModule,
    collapseAll: $7b57b57eaf5a9648$var$coreModule,
    onRowHeightChanged: $7b57b57eaf5a9648$var$coreModule,
    setRowCount: $7b57b57eaf5a9648$var$coreModule,
    getCacheBlockState: $7b57b57eaf5a9648$var$coreModule,
    onGroupExpandedOrCollapsed: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    refreshClientSideRowModel: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    forEachLeafNode: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    forEachNodeAfterFilter: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    forEachNodeAfterFilterAndSort: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    resetRowHeights: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    applyTransaction: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    applyTransactionAsync: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    flushAsyncTransactions: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    getBestCostNodeSelection: $7b57b57eaf5a9648$var$clientSideRowModelModule,
    getDataAsCsv: $7b57b57eaf5a9648$var$csvExportModule,
    exportDataAsCsv: $7b57b57eaf5a9648$var$csvExportModule,
    refreshInfiniteCache: $7b57b57eaf5a9648$var$infiniteRowModelModule,
    purgeInfiniteCache: $7b57b57eaf5a9648$var$infiniteRowModelModule,
    getInfiniteRowCount: $7b57b57eaf5a9648$var$infiniteRowModelModule,
    isLastRowIndexKnown: $7b57b57eaf5a9648$var$infiniteRowModelModule,
    getAdvancedFilterModel: $7b57b57eaf5a9648$var$advancedFilterModule,
    setAdvancedFilterModel: $7b57b57eaf5a9648$var$advancedFilterModule,
    showAdvancedFilterBuilder: $7b57b57eaf5a9648$var$advancedFilterModule,
    hideAdvancedFilterBuilder: $7b57b57eaf5a9648$var$advancedFilterModule,
    getChartModels: $7b57b57eaf5a9648$var$gridChartsModule,
    getChartRef: $7b57b57eaf5a9648$var$gridChartsModule,
    getChartImageDataURL: $7b57b57eaf5a9648$var$gridChartsModule,
    downloadChart: $7b57b57eaf5a9648$var$gridChartsModule,
    openChartToolPanel: $7b57b57eaf5a9648$var$gridChartsModule,
    closeChartToolPanel: $7b57b57eaf5a9648$var$gridChartsModule,
    createRangeChart: $7b57b57eaf5a9648$var$gridChartsModule,
    createPivotChart: $7b57b57eaf5a9648$var$gridChartsModule,
    createCrossFilterChart: $7b57b57eaf5a9648$var$gridChartsModule,
    updateChart: $7b57b57eaf5a9648$var$gridChartsModule,
    restoreChart: $7b57b57eaf5a9648$var$gridChartsModule,
    copyToClipboard: $7b57b57eaf5a9648$var$clipboardModule,
    cutToClipboard: $7b57b57eaf5a9648$var$clipboardModule,
    copySelectedRowsToClipboard: $7b57b57eaf5a9648$var$clipboardModule,
    copySelectedRangeToClipboard: $7b57b57eaf5a9648$var$clipboardModule,
    copySelectedRangeDown: $7b57b57eaf5a9648$var$clipboardModule,
    pasteFromClipboard: $7b57b57eaf5a9648$var$clipboardModule,
    getDataAsExcel: $7b57b57eaf5a9648$var$excelExportModule,
    exportDataAsExcel: $7b57b57eaf5a9648$var$excelExportModule,
    getSheetDataForExcel: $7b57b57eaf5a9648$var$excelExportModule,
    getMultipleSheetsAsExcel: $7b57b57eaf5a9648$var$excelExportModule,
    exportMultipleSheetsAsExcel: $7b57b57eaf5a9648$var$excelExportModule,
    addDetailGridInfo: $7b57b57eaf5a9648$var$masterDetailModule,
    removeDetailGridInfo: $7b57b57eaf5a9648$var$masterDetailModule,
    getDetailGridInfo: $7b57b57eaf5a9648$var$masterDetailModule,
    forEachDetailGridInfo: $7b57b57eaf5a9648$var$masterDetailModule,
    showContextMenu: $7b57b57eaf5a9648$var$menuModule,
    showColumnChooser: $7b57b57eaf5a9648$var$menuModule,
    hideColumnChooser: $7b57b57eaf5a9648$var$menuModule,
    getCellRanges: $7b57b57eaf5a9648$var$rangeSelectionModule,
    addCellRange: $7b57b57eaf5a9648$var$rangeSelectionModule,
    clearRangeSelection: $7b57b57eaf5a9648$var$rangeSelectionModule,
    addAggFunc: $7b57b57eaf5a9648$var$rowGroupingModule,
    addAggFuncs: $7b57b57eaf5a9648$var$rowGroupingModule,
    clearAggFuncs: $7b57b57eaf5a9648$var$rowGroupingModule,
    setColumnAggFunc: $7b57b57eaf5a9648$var$rowGroupingModule,
    isPivotMode: $7b57b57eaf5a9648$var$rowGroupingModule,
    getPivotResultColumn: $7b57b57eaf5a9648$var$rowGroupingModule,
    setValueColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    getValueColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    removeValueColumn: $7b57b57eaf5a9648$var$rowGroupingModule,
    removeValueColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    addValueColumn: $7b57b57eaf5a9648$var$rowGroupingModule,
    addValueColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    setRowGroupColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    removeRowGroupColumn: $7b57b57eaf5a9648$var$rowGroupingModule,
    removeRowGroupColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    addRowGroupColumn: $7b57b57eaf5a9648$var$rowGroupingModule,
    addRowGroupColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    getRowGroupColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    moveRowGroupColumn: $7b57b57eaf5a9648$var$rowGroupingModule,
    setPivotColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    removePivotColumn: $7b57b57eaf5a9648$var$rowGroupingModule,
    removePivotColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    addPivotColumn: $7b57b57eaf5a9648$var$rowGroupingModule,
    addPivotColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    getPivotColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    setPivotResultColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    getPivotResultColumns: $7b57b57eaf5a9648$var$rowGroupingModule,
    getServerSideSelectionState: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    setServerSideSelectionState: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    applyServerSideTransaction: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    applyServerSideTransactionAsync: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    applyServerSideRowData: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    retryServerSideLoads: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    flushServerSideAsyncTransactions: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    refreshServerSide: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    getServerSideGroupLevelState: $7b57b57eaf5a9648$var$serverSideRowModelModule,
    isSideBarVisible: $7b57b57eaf5a9648$var$sideBarModule,
    setSideBarVisible: $7b57b57eaf5a9648$var$sideBarModule,
    setSideBarPosition: $7b57b57eaf5a9648$var$sideBarModule,
    openToolPanel: $7b57b57eaf5a9648$var$sideBarModule,
    closeToolPanel: $7b57b57eaf5a9648$var$sideBarModule,
    getOpenedToolPanel: $7b57b57eaf5a9648$var$sideBarModule,
    refreshToolPanel: $7b57b57eaf5a9648$var$sideBarModule,
    isToolPanelShowing: $7b57b57eaf5a9648$var$sideBarModule,
    getToolPanelInstance: $7b57b57eaf5a9648$var$sideBarModule,
    getSideBar: $7b57b57eaf5a9648$var$sideBarModule,
    getStatusPanel: $7b57b57eaf5a9648$var$statusBarModule
};
var $7b57b57eaf5a9648$var$clientSide = "clientSide";
var $7b57b57eaf5a9648$var$serverSide = "serverSide";
var $7b57b57eaf5a9648$var$infinite = "infinite";
var $7b57b57eaf5a9648$var$functionRowModels = {
    onGroupExpandedOrCollapsed: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    refreshClientSideRowModel: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    forEachLeafNode: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    forEachNodeAfterFilter: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    forEachNodeAfterFilterAndSort: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    resetRowHeights: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    applyTransaction: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    applyTransactionAsync: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    flushAsyncTransactions: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    getBestCostNodeSelection: [
        $7b57b57eaf5a9648$var$clientSide
    ],
    getServerSideSelectionState: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    setServerSideSelectionState: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    applyServerSideTransaction: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    applyServerSideTransactionAsync: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    applyServerSideRowData: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    retryServerSideLoads: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    flushServerSideAsyncTransactions: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    refreshServerSide: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    getServerSideGroupLevelState: [
        $7b57b57eaf5a9648$var$serverSide
    ],
    refreshInfiniteCache: [
        $7b57b57eaf5a9648$var$infinite
    ],
    purgeInfiniteCache: [
        $7b57b57eaf5a9648$var$infinite
    ],
    getInfiniteRowCount: [
        $7b57b57eaf5a9648$var$infinite
    ],
    isLastRowIndexKnown: [
        $7b57b57eaf5a9648$var$infinite
    ],
    expandAll: [
        $7b57b57eaf5a9648$var$clientSide,
        $7b57b57eaf5a9648$var$serverSide
    ],
    collapseAll: [
        $7b57b57eaf5a9648$var$clientSide,
        $7b57b57eaf5a9648$var$serverSide
    ],
    onRowHeightChanged: [
        $7b57b57eaf5a9648$var$clientSide,
        $7b57b57eaf5a9648$var$serverSide
    ],
    setRowCount: [
        $7b57b57eaf5a9648$var$infinite,
        $7b57b57eaf5a9648$var$serverSide
    ],
    getCacheBlockState: [
        $7b57b57eaf5a9648$var$infinite,
        $7b57b57eaf5a9648$var$serverSide
    ]
};
var $7b57b57eaf5a9648$var$deprecatedFunctions = {
    getValue: {
        version: "v31.3",
        new: "getCellValue"
    },
    getFirstDisplayedRow: {
        version: "v31.1",
        new: "getFirstDisplayedRowIndex"
    },
    getLastDisplayedRow: {
        version: "v31.1",
        new: "getLastDisplayedRowIndex"
    },
    getModel: {
        version: "v31.1",
        message: "Please use the appropriate grid API methods instead."
    },
    setColumnVisible: {
        version: "v31.1",
        old: "setColumnVisible(key,visible)",
        new: "setColumnsVisible([key],visible)"
    },
    setColumnPinned: {
        version: "v31.1",
        old: "setColumnPinned(key,pinned)",
        new: "setColumnsPinned([key],pinned)"
    },
    moveColumn: {
        version: "v31.1",
        old: "moveColumn(key, toIndex)",
        new: "moveColumns([key], toIndex)"
    },
    setColumnWidth: {
        version: "v31.1",
        old: "setColumnWidth(col, width)",
        new: "setColumnWidths([{key: col, newWidth: width}])"
    },
    autoSizeColumn: {
        version: "v31.1",
        old: "autoSizeColumn(key, skipHeader)",
        new: "autoSizeColumns([key], skipHeader)"
    },
    addAggFunc: {
        version: "v31.1",
        old: "addAggFunc(key, func)",
        new: "addAggFuncs({ key: func })"
    },
    removeValueColumn: {
        version: "v31.1",
        old: "removeValueColumn(colKey)",
        new: "removeValueColumns([colKey])"
    },
    addValueColumn: {
        version: "v31.1",
        old: "addValueColumn(colKey)",
        new: "addValueColumns([colKey])"
    },
    removeRowGroupColumn: {
        version: "v31.1",
        old: "removeRowGroupColumn(colKey)",
        new: "removeRowGroupColumns([colKey])"
    },
    addRowGroupColumn: {
        version: "v31.1",
        old: "addRowGroupColumn(colKey)",
        new: "addRowGroupColumns([colKey])"
    },
    removePivotColumn: {
        version: "v31.1",
        old: "removePivotColumn(colKey)",
        new: "removePivotColumns([colKey])"
    },
    addPivotColumn: {
        version: "v31.1",
        old: "addPivotColumn(colKey)",
        new: "addPivotColumns([colKey])"
    },
    showColumnMenuAfterButtonClick: {
        version: "v31.1",
        message: `Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere.`
    },
    showColumnMenuAfterMouseClick: {
        version: "v31.1",
        message: `Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere.`
    },
    getFilterInstance: {
        version: "v31.1",
        message: `'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously.`
    },
    showLoadingOverlay: {
        version: "v32",
        message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).'
    }
};
function $7b57b57eaf5a9648$var$warnMissingApiFunction(functionName, gridId) {
    const module = $7b57b57eaf5a9648$var$functionModules[functionName];
    if (module) {
        if ($7b57b57eaf5a9648$export$dc053975cc7f6c11.__assertRegistered(module, `api.${functionName}`, gridId)) $7b57b57eaf5a9648$export$2cf41453020eef66(`API function '${functionName}' not registered to module '${module}'`);
    } else $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`Unknown API function: '${functionName}' on GridApi.`);
}
function $7b57b57eaf5a9648$var$validateApiFunction(functionName, apiFunction, beans) {
    const deprecation = $7b57b57eaf5a9648$var$deprecatedFunctions[functionName];
    if (deprecation) {
        const { version: version , new: replacement , old: old , message: message  } = deprecation;
        const apiMethod = old ?? functionName;
        return (...args)=>{
            const replacementMessage = replacement ? `Please use ${replacement} instead. ` : "";
            $7b57b57eaf5a9648$export$2cf41453020eef66(`Since ${version} api.${apiMethod} is deprecated. ${replacementMessage}${message ?? ""}`);
            return apiFunction.apply(apiFunction, args);
        };
    }
    const rowModels = $7b57b57eaf5a9648$var$functionRowModels[functionName];
    if (rowModels) return (...args)=>{
        const rowModel = beans.rowModel.getType();
        if (!rowModels.includes(rowModel)) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`api.${functionName} can only be called when gridOptions.rowModelType is ${rowModels.join(" or ")}`);
            return void 0;
        }
        return apiFunction.apply(apiFunction, args);
    };
    return apiFunction;
}
// community-modules/core/src/validation/rules/colDefValidations.ts
var $7b57b57eaf5a9648$var$COLUMN_DEFINITION_DEPRECATIONS = {
    columnsMenuParams: {
        version: "31.1",
        message: "Use `columnChooserParams` instead."
    },
    suppressMenu: {
        version: "31.1",
        message: "Use `suppressHeaderMenuButton` instead."
    },
    suppressCellFlash: {
        version: "31.2",
        message: "Use `enableCellChangeFlash={false}` in the ColDef"
    }
};
var $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE = (_options, gridOptions)=>{
    if ((gridOptions.rowModelType ?? "clientSide") === "clientSide") return {
        module: "@ag-grid-enterprise/row-grouping" /* RowGroupingModule */ 
    };
    return null;
};
var $7b57b57eaf5a9648$var$COLUMN_DEFINITION_VALIDATIONS = {
    // supported on all row models, but need module for client side.
    enableRowGroup: $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE,
    rowGroup: $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE,
    rowGroupIndex: $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE,
    enablePivot: $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE,
    enableValue: $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE,
    pivot: $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE,
    pivotIndex: $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE,
    aggFunc: $7b57b57eaf5a9648$var$CSRM_REQUIRES_ROW_GROUP_MODULE,
    cellEditor: (options)=>{
        if (options.cellEditor === "agRichSelect" || options.cellEditor === "agRichSelectCellEditor") return {
            module: "@ag-grid-enterprise/rich-select" /* RichSelectModule */ 
        };
        return null;
    },
    menuTabs: (options)=>{
        const enterpriseMenuTabs = [
            "columnsMenuTab",
            "generalMenuTab"
        ];
        if (options.menuTabs?.some((tab)=>enterpriseMenuTabs.includes(tab))) return {
            module: "@ag-grid-enterprise/menu" /* MenuModule */ 
        };
        return null;
    },
    columnsMenuParams: {
        module: [
            "@ag-grid-enterprise/menu" /* MenuModule */ ,
            "@ag-grid-enterprise/column-tool-panel" /* ColumnsToolPanelModule */ 
        ]
    },
    columnChooserParams: {
        module: [
            "@ag-grid-enterprise/menu" /* MenuModule */ ,
            "@ag-grid-enterprise/column-tool-panel" /* ColumnsToolPanelModule */ 
        ]
    },
    headerCheckboxSelection: {
        supportedRowModels: [
            "clientSide",
            "serverSide"
        ],
        dependencies: (_options, { rowSelection: rowSelection  })=>rowSelection === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
    },
    headerCheckboxSelectionFilteredOnly: {
        supportedRowModels: [
            "clientSide"
        ],
        dependencies: (_options, { rowSelection: rowSelection  })=>rowSelection === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
    },
    headerCheckboxSelectionCurrentPageOnly: {
        supportedRowModels: [
            "clientSide"
        ],
        dependencies: (_options, { rowSelection: rowSelection  })=>rowSelection === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
    },
    children: ()=>$7b57b57eaf5a9648$var$COL_DEF_VALIDATORS
};
var $7b57b57eaf5a9648$var$colDefPropertyMap = {
    headerName: void 0,
    columnGroupShow: void 0,
    headerClass: void 0,
    toolPanelClass: void 0,
    headerValueGetter: void 0,
    pivotKeys: void 0,
    groupId: void 0,
    colId: void 0,
    sort: void 0,
    initialSort: void 0,
    field: void 0,
    type: void 0,
    cellDataType: void 0,
    tooltipComponent: void 0,
    tooltipField: void 0,
    headerTooltip: void 0,
    cellClass: void 0,
    showRowGroup: void 0,
    filter: void 0,
    initialAggFunc: void 0,
    defaultAggFunc: void 0,
    aggFunc: void 0,
    pinned: void 0,
    initialPinned: void 0,
    chartDataType: void 0,
    cellAriaRole: void 0,
    cellEditorPopupPosition: void 0,
    headerGroupComponent: void 0,
    headerGroupComponentParams: void 0,
    cellStyle: void 0,
    cellRenderer: void 0,
    cellRendererParams: void 0,
    cellEditor: void 0,
    cellEditorParams: void 0,
    filterParams: void 0,
    pivotValueColumn: void 0,
    headerComponent: void 0,
    headerComponentParams: void 0,
    floatingFilterComponent: void 0,
    floatingFilterComponentParams: void 0,
    tooltipComponentParams: void 0,
    refData: void 0,
    columnsMenuParams: void 0,
    columnChooserParams: void 0,
    children: void 0,
    sortingOrder: void 0,
    allowedAggFuncs: void 0,
    menuTabs: void 0,
    pivotTotalColumnIds: void 0,
    cellClassRules: void 0,
    icons: void 0,
    sortIndex: void 0,
    initialSortIndex: void 0,
    flex: void 0,
    initialFlex: void 0,
    width: void 0,
    initialWidth: void 0,
    minWidth: void 0,
    maxWidth: void 0,
    rowGroupIndex: void 0,
    initialRowGroupIndex: void 0,
    pivotIndex: void 0,
    initialPivotIndex: void 0,
    suppressCellFlash: void 0,
    suppressColumnsToolPanel: void 0,
    suppressFiltersToolPanel: void 0,
    openByDefault: void 0,
    marryChildren: void 0,
    suppressStickyLabel: void 0,
    hide: void 0,
    initialHide: void 0,
    rowGroup: void 0,
    initialRowGroup: void 0,
    pivot: void 0,
    initialPivot: void 0,
    checkboxSelection: void 0,
    showDisabledCheckboxes: void 0,
    headerCheckboxSelection: void 0,
    headerCheckboxSelectionFilteredOnly: void 0,
    headerCheckboxSelectionCurrentPageOnly: void 0,
    suppressMenu: void 0,
    suppressHeaderMenuButton: void 0,
    suppressMovable: void 0,
    lockPosition: void 0,
    lockVisible: void 0,
    lockPinned: void 0,
    unSortIcon: void 0,
    suppressSizeToFit: void 0,
    suppressAutoSize: void 0,
    enableRowGroup: void 0,
    enablePivot: void 0,
    enableValue: void 0,
    editable: void 0,
    suppressPaste: void 0,
    suppressNavigable: void 0,
    enableCellChangeFlash: void 0,
    rowDrag: void 0,
    dndSource: void 0,
    autoHeight: void 0,
    wrapText: void 0,
    sortable: void 0,
    resizable: void 0,
    singleClickEdit: void 0,
    floatingFilter: void 0,
    cellEditorPopup: void 0,
    suppressFillHandle: void 0,
    wrapHeaderText: void 0,
    autoHeaderHeight: void 0,
    dndSourceOnRowDrag: void 0,
    valueGetter: void 0,
    valueSetter: void 0,
    filterValueGetter: void 0,
    keyCreator: void 0,
    valueFormatter: void 0,
    valueParser: void 0,
    comparator: void 0,
    equals: void 0,
    pivotComparator: void 0,
    suppressKeyboardEvent: void 0,
    suppressHeaderKeyboardEvent: void 0,
    colSpan: void 0,
    rowSpan: void 0,
    getQuickFilterText: void 0,
    onCellValueChanged: void 0,
    onCellClicked: void 0,
    onCellDoubleClicked: void 0,
    onCellContextMenu: void 0,
    rowDragText: void 0,
    tooltipValueGetter: void 0,
    cellRendererSelector: void 0,
    cellEditorSelector: void 0,
    suppressSpanHeaderHeight: void 0,
    useValueFormatterForExport: void 0,
    useValueParserForImport: void 0,
    mainMenuItems: void 0,
    contextMenuItems: void 0,
    suppressFloatingFilterButton: void 0,
    suppressHeaderFilterButton: void 0,
    suppressHeaderContextMenu: void 0,
    loadingCellRenderer: void 0,
    loadingCellRendererParams: void 0,
    loadingCellRendererSelector: void 0,
    context: void 0
};
var $7b57b57eaf5a9648$var$ALL_PROPERTIES = Object.keys($7b57b57eaf5a9648$var$colDefPropertyMap);
var $7b57b57eaf5a9648$var$COL_DEF_VALIDATORS = {
    objectName: "colDef",
    allProperties: $7b57b57eaf5a9648$var$ALL_PROPERTIES,
    docsUrl: "column-properties/",
    deprecations: $7b57b57eaf5a9648$var$COLUMN_DEFINITION_DEPRECATIONS,
    validations: $7b57b57eaf5a9648$var$COLUMN_DEFINITION_VALIDATIONS
};
// community-modules/core/src/validation/rules/gridOptionsValidations.ts
var $7b57b57eaf5a9648$var$GRID_OPTION_DEPRECATIONS = ()=>({
        advancedFilterModel: {
            version: "31",
            message: "Use `initialState.filter.advancedFilterModel` instead."
        },
        suppressAsyncEvents: {
            version: "31",
            message: "Events should be handled asynchronously."
        },
        cellFadeDelay: {
            version: "31.1",
            renamed: "cellFadeDuration"
        },
        cellFlashDelay: {
            version: "31.1",
            renamed: "cellFlashDuration"
        },
        suppressServerSideInfiniteScroll: {
            version: "31.1"
        },
        serverSideSortOnServer: {
            version: "31.1"
        },
        serverSideFilterOnServer: {
            version: "31.1"
        },
        enableCellChangeFlash: {
            version: "31.2",
            message: "Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns."
        },
        groupIncludeFooter: {
            version: "31.3",
            message: "Use `groupTotalRow` instead."
        },
        groupIncludeTotalFooter: {
            version: "31.3",
            message: "Use `grandTotalRow` instead."
        },
        suppressLoadingOverlay: {
            version: "32",
            message: "Use `loading`=false instead."
        }
    });
var $7b57b57eaf5a9648$var$GRID_OPTION_DEFAULTS = {
    suppressContextMenu: false,
    preventDefaultOnContextMenu: false,
    allowContextMenuWithControlKey: false,
    suppressMenuHide: true,
    enableBrowserTooltips: false,
    tooltipTrigger: "hover",
    tooltipShowDelay: 2e3,
    tooltipHideDelay: 1e4,
    tooltipMouseTrack: false,
    tooltipShowMode: "standard",
    tooltipInteraction: false,
    copyHeadersToClipboard: false,
    copyGroupHeadersToClipboard: false,
    clipboardDelimiter: "	",
    suppressCopyRowsToClipboard: false,
    suppressCopySingleCellRanges: false,
    suppressLastEmptyLineOnPaste: false,
    suppressClipboardPaste: false,
    suppressClipboardApi: false,
    suppressCutToClipboard: false,
    maintainColumnOrder: false,
    suppressFieldDotNotation: false,
    allowDragFromColumnsToolPanel: false,
    suppressMovableColumns: false,
    suppressColumnMoveAnimation: false,
    suppressDragLeaveHidesColumns: false,
    suppressRowGroupHidesColumns: false,
    suppressAutoSize: false,
    autoSizePadding: 20,
    skipHeaderOnAutoSize: false,
    singleClickEdit: false,
    suppressClickEdit: false,
    readOnlyEdit: false,
    stopEditingWhenCellsLoseFocus: false,
    enterNavigatesVertically: false,
    enterNavigatesVerticallyAfterEdit: false,
    enableCellEditingOnBackspace: false,
    undoRedoCellEditing: false,
    undoRedoCellEditingLimit: 10,
    suppressCsvExport: false,
    suppressExcelExport: false,
    cacheQuickFilter: false,
    includeHiddenColumnsInQuickFilter: false,
    excludeChildrenWhenTreeDataFiltering: false,
    enableAdvancedFilter: false,
    includeHiddenColumnsInAdvancedFilter: false,
    enableCharts: false,
    masterDetail: false,
    keepDetailRows: false,
    keepDetailRowsCount: 10,
    detailRowAutoHeight: false,
    tabIndex: 0,
    rowBuffer: 10,
    valueCache: false,
    valueCacheNeverExpires: false,
    enableCellExpressions: false,
    suppressTouch: false,
    suppressFocusAfterRefresh: false,
    suppressAsyncEvents: false,
    suppressBrowserResizeObserver: false,
    suppressPropertyNamesCheck: false,
    suppressChangeDetection: false,
    debug: false,
    suppressLoadingOverlay: false,
    suppressNoRowsOverlay: false,
    pagination: false,
    paginationPageSize: 100,
    paginationPageSizeSelector: true,
    paginationAutoPageSize: false,
    paginateChildRows: false,
    suppressPaginationPanel: false,
    pivotMode: false,
    pivotPanelShow: "never",
    pivotDefaultExpanded: 0,
    pivotSuppressAutoColumn: false,
    suppressExpandablePivotGroups: false,
    functionsReadOnly: false,
    suppressAggFuncInHeader: false,
    alwaysAggregateAtRootLevel: false,
    aggregateOnlyChangedColumns: false,
    suppressAggFilteredOnly: false,
    removePivotHeaderRowWhenSingleValueColumn: false,
    animateRows: true,
    enableCellChangeFlash: false,
    cellFlashDelay: 500,
    cellFlashDuration: 500,
    cellFadeDelay: 1e3,
    cellFadeDuration: 1e3,
    allowShowChangeAfterFilter: false,
    domLayout: "normal",
    ensureDomOrder: false,
    enableRtl: false,
    suppressColumnVirtualisation: false,
    suppressMaxRenderedRowRestriction: false,
    suppressRowVirtualisation: false,
    rowDragManaged: false,
    suppressRowDrag: false,
    suppressMoveWhenRowDragging: false,
    rowDragEntireRow: false,
    rowDragMultiRow: false,
    embedFullWidthRows: false,
    groupDisplayType: "singleColumn",
    groupDefaultExpanded: 0,
    groupMaintainOrder: false,
    groupSelectsChildren: false,
    groupIncludeTotalFooter: false,
    groupSuppressBlankHeader: false,
    groupSelectsFiltered: false,
    showOpenedGroup: false,
    groupRemoveSingleChildren: false,
    groupRemoveLowestSingleChildren: false,
    groupHideOpenParents: false,
    groupAllowUnbalanced: false,
    rowGroupPanelShow: "never",
    suppressMakeColumnVisibleAfterUnGroup: false,
    treeData: false,
    rowGroupPanelSuppressSort: false,
    suppressGroupRowsSticky: false,
    rowModelType: "clientSide",
    asyncTransactionWaitMillis: 50,
    suppressModelUpdateAfterUpdateTransaction: false,
    cacheOverflowSize: 1,
    infiniteInitialRowCount: 1,
    serverSideInitialRowCount: 1,
    suppressServerSideInfiniteScroll: false,
    cacheBlockSize: 100,
    maxBlocksInCache: -1,
    maxConcurrentDatasourceRequests: 2,
    blockLoadDebounceMillis: 0,
    purgeClosedRowNodes: false,
    serverSideSortAllLevels: false,
    serverSideOnlyRefreshFilteredGroups: false,
    serverSideSortOnServer: false,
    serverSideFilterOnServer: false,
    serverSidePivotResultFieldSeparator: "_",
    viewportRowModelPageSize: 5,
    viewportRowModelBufferSize: 5,
    alwaysShowHorizontalScroll: false,
    alwaysShowVerticalScroll: false,
    debounceVerticalScrollbar: false,
    suppressHorizontalScroll: false,
    suppressScrollOnNewData: false,
    suppressScrollWhenPopupsAreOpen: false,
    suppressAnimationFrame: false,
    suppressMiddleClickScrolls: false,
    suppressPreventDefaultOnMouseWheel: false,
    rowMultiSelectWithClick: false,
    suppressRowDeselection: false,
    suppressRowClickSelection: false,
    suppressCellFocus: false,
    suppressHeaderFocus: false,
    suppressMultiRangeSelection: false,
    enableCellTextSelection: false,
    enableRangeSelection: false,
    enableRangeHandle: false,
    enableFillHandle: false,
    fillHandleDirection: "xy",
    suppressClearOnFillReduction: false,
    accentedSort: false,
    unSortIcon: false,
    suppressMultiSort: false,
    alwaysMultiSort: false,
    suppressMaintainUnsortedOrder: false,
    suppressRowHoverHighlight: false,
    suppressRowTransform: false,
    columnHoverHighlight: false,
    deltaSort: false,
    enableGroupEdit: false,
    suppressGroupMaintainValueType: false,
    groupLockGroupColumns: 0,
    serverSideEnableClientSideSort: false,
    suppressServerSideFullWidthLoadingRow: false,
    pivotMaxGeneratedColumns: -1,
    columnMenu: "new",
    reactiveCustomComponents: true
};
var $7b57b57eaf5a9648$var$GRID_OPTION_VALIDATIONS = ()=>({
        sideBar: {
            module: "@ag-grid-enterprise/side-bar" /* SideBarModule */ 
        },
        statusBar: {
            module: "@ag-grid-enterprise/status-bar" /* StatusBarModule */ 
        },
        enableCharts: {
            module: "@ag-grid-enterprise/charts" /* GridChartsModule */ 
        },
        getMainMenuItems: {
            module: "@ag-grid-enterprise/menu" /* MenuModule */ 
        },
        getContextMenuItems: {
            module: "@ag-grid-enterprise/menu" /* MenuModule */ 
        },
        allowContextMenuWithControlKey: {
            module: "@ag-grid-enterprise/menu" /* MenuModule */ 
        },
        enableAdvancedFilter: {
            module: "@ag-grid-enterprise/advanced-filter" /* AdvancedFilterModule */ 
        },
        treeData: {
            supportedRowModels: [
                "clientSide",
                "serverSide"
            ],
            module: "@ag-grid-enterprise/row-grouping" /* RowGroupingModule */ ,
            dependencies: (options)=>{
                const rowModel = options.rowModelType ?? "clientSide";
                switch(rowModel){
                    case "clientSide":
                        {
                            const csrmWarning = `treeData requires 'getDataPath' in the ${rowModel} row model.`;
                            return options.getDataPath ? null : csrmWarning;
                        }
                    case "serverSide":
                        {
                            const ssrmWarning = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${rowModel} row model.`;
                            return options.isServerSideGroup && options.getServerSideGroupKey ? null : ssrmWarning;
                        }
                }
                return null;
            }
        },
        masterDetail: {
            module: "@ag-grid-enterprise/master-detail" /* MasterDetailModule */ 
        },
        enableRangeSelection: {
            module: "@ag-grid-enterprise/range-selection" /* RangeSelectionModule */ 
        },
        enableRangeHandle: {
            dependencies: {
                enableRangeSelection: [
                    true
                ]
            }
        },
        enableFillHandle: {
            dependencies: {
                enableRangeSelection: [
                    true
                ]
            }
        },
        groupDefaultExpanded: {
            supportedRowModels: [
                "clientSide"
            ]
        },
        groupIncludeFooter: {
            supportedRowModels: [
                "clientSide",
                "serverSide"
            ],
            dependencies: (options)=>{
                const rowModel = options.rowModelType ?? "clientSide";
                switch(rowModel){
                    case "clientSide":
                        return null;
                    case "serverSide":
                        {
                            const warning = "groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll";
                            return options.suppressServerSideInfiniteScroll ? warning : null;
                        }
                }
                return null;
            }
        },
        groupHideOpenParents: {
            supportedRowModels: [
                "clientSide"
            ],
            dependencies: {
                groupTotalRow: [
                    void 0,
                    "bottom"
                ]
            }
        },
        groupIncludeTotalFooter: {
            supportedRowModels: [
                "clientSide"
            ]
        },
        groupRemoveSingleChildren: {
            dependencies: {
                groupHideOpenParents: [
                    void 0,
                    false
                ],
                groupRemoveLowestSingleChildren: [
                    void 0,
                    false
                ]
            }
        },
        groupRemoveLowestSingleChildren: {
            dependencies: {
                groupHideOpenParents: [
                    void 0,
                    false
                ],
                groupRemoveSingleChildren: [
                    void 0,
                    false
                ]
            }
        },
        groupSelectsChildren: {
            dependencies: {
                rowSelection: [
                    "multiple"
                ]
            }
        },
        viewportDatasource: {
            supportedRowModels: [
                "viewport"
            ],
            module: "@ag-grid-enterprise/viewport-row-model" /* ViewportRowModelModule */ 
        },
        serverSideDatasource: {
            supportedRowModels: [
                "serverSide"
            ],
            module: "@ag-grid-enterprise/server-side-row-model" /* ServerSideRowModelModule */ 
        },
        cacheBlockSize: {
            supportedRowModels: [
                "serverSide",
                "infinite"
            ]
        },
        datasource: {
            supportedRowModels: [
                "infinite"
            ],
            module: "@ag-grid-community/infinite-row-model" /* InfiniteRowModelModule */ 
        },
        rowData: {
            supportedRowModels: [
                "clientSide"
            ],
            module: "@ag-grid-community/client-side-row-model" /* ClientSideRowModelModule */ 
        },
        columnDefs: ()=>$7b57b57eaf5a9648$var$COL_DEF_VALIDATORS,
        defaultColDef: ()=>$7b57b57eaf5a9648$var$COL_DEF_VALIDATORS,
        defaultColGroupDef: ()=>$7b57b57eaf5a9648$var$COL_DEF_VALIDATORS,
        autoGroupColumnDef: ()=>$7b57b57eaf5a9648$var$COL_DEF_VALIDATORS
    });
var $7b57b57eaf5a9648$var$GRID_OPTIONS_VALIDATORS = ()=>({
        objectName: "gridOptions",
        allProperties: [
            ...$7b57b57eaf5a9648$export$4d1a0127671c9c1f.ALL_PROPERTIES,
            ...$7b57b57eaf5a9648$export$1f1b72b628161f7c.EVENT_CALLBACKS
        ],
        propertyExceptions: [
            "api"
        ],
        docsUrl: "grid-options/",
        deprecations: $7b57b57eaf5a9648$var$GRID_OPTION_DEPRECATIONS(),
        validations: $7b57b57eaf5a9648$var$GRID_OPTION_VALIDATIONS()
    });
// community-modules/core/src/validation/validationService.ts
var $7b57b57eaf5a9648$var$ValidationService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "validationService";
    }
    wireBeans(beans) {
        this.beans = beans;
        this.gridOptions = beans.gridOptions;
    }
    postConstruct() {
        this.processGridOptions(this.gridOptions);
    }
    processGridOptions(options) {
        this.processOptions(options, $7b57b57eaf5a9648$var$GRID_OPTIONS_VALIDATORS());
    }
    processColumnDefs(options) {
        this.processOptions(options, $7b57b57eaf5a9648$var$COL_DEF_VALIDATORS);
    }
    warnMissingApiFunction(functionName) {
        $7b57b57eaf5a9648$var$warnMissingApiFunction(functionName, this.gridId);
    }
    validateApiFunction(functionName, apiFunction) {
        return $7b57b57eaf5a9648$var$validateApiFunction(functionName, apiFunction, this.beans);
    }
    processOptions(options, validator) {
        const { validations: validations , deprecations: deprecations , allProperties: allProperties , propertyExceptions: propertyExceptions , objectName: objectName , docsUrl: docsUrl  } = validator;
        if (allProperties && this.gridOptions.suppressPropertyNamesCheck !== true) this.checkProperties(options, [
            ...propertyExceptions ?? [],
            ...Object.keys(deprecations)
        ], allProperties, objectName, docsUrl);
        const warnings = /* @__PURE__ */ new Set();
        const optionKeys = Object.keys(options);
        optionKeys.forEach((key)=>{
            const deprecation = deprecations[key];
            if (deprecation) {
                if ("renamed" in deprecation) {
                    const { renamed: renamed , version: version  } = deprecation;
                    warnings.add(`As of v${version}, ${String(key)} is deprecated. Please use ${String(renamed)} instead.`);
                    options[renamed] = options[key];
                } else {
                    const { message: message , version: version  } = deprecation;
                    warnings.add(`As of v${version}, ${String(key)} is deprecated. ${message ?? ""}`);
                }
            }
            const value = options[key];
            if (value == null || value === false) return;
            const rulesOrGetter = validations[key];
            let rules;
            if (!rulesOrGetter) return;
            else if (typeof rulesOrGetter === "function") {
                const fromGetter = rulesOrGetter(options, this.gridOptions);
                if (!fromGetter) return;
                if ("objectName" in fromGetter) {
                    const value2 = options[key];
                    if (Array.isArray(value2)) {
                        value2.forEach((item)=>{
                            this.processOptions(item, fromGetter);
                        });
                        return;
                    }
                    this.processOptions(options[key], fromGetter);
                    return;
                }
                rules = fromGetter;
            } else rules = rulesOrGetter;
            const { module: module , dependencies: dependencies , supportedRowModels: supportedRowModels  } = rules;
            if (supportedRowModels) {
                const rowModel = this.gridOptions.rowModelType ?? "clientSide";
                if (!supportedRowModels.includes(rowModel)) {
                    warnings.add(`${String(key)} is not supported with the '${rowModel}' row model.`);
                    return;
                }
            }
            if (module) {
                const modules = Array.isArray(module) ? module : [
                    module
                ];
                let allRegistered = true;
                modules.forEach((m)=>{
                    if (!$7b57b57eaf5a9648$export$dc053975cc7f6c11.__assertRegistered(m, String(key), this.gridId)) {
                        allRegistered = false;
                        warnings.add(`${String(key)} is only available when ${m} is loaded.`);
                    }
                });
                if (!allRegistered) return;
            }
            if (dependencies) {
                const warning = this.checkForWarning(key, dependencies, options);
                if (warning) {
                    warnings.add(warning);
                    return;
                }
            }
        });
        if (warnings.size > 0) warnings.forEach((warning)=>{
            $7b57b57eaf5a9648$export$2cf41453020eef66(warning);
        });
    }
    checkForWarning(key, validator, options) {
        if (typeof validator === "function") return validator(options, this.gridOptions);
        const optionEntries = Object.entries(validator);
        const failed = optionEntries.find(([key2, value])=>{
            const gridOptionValue = options[key2];
            return !value.includes(gridOptionValue);
        });
        if (!failed) return null;
        const [failedKey, possibleOptions] = failed;
        if (possibleOptions.length > 1) return `'${String(key)}' requires '${failedKey}' to be one of [${possibleOptions.join(", ")}].`;
        return `'${String(key)}' requires '${failedKey}' to be ${possibleOptions[0]}.`;
    }
    checkProperties(object, exceptions, validProperties, containerName, docsUrl) {
        const VUE_FRAMEWORK_PROPS = [
            "__ob__",
            "__v_skip",
            "__metadata__"
        ];
        const invalidProperties = $7b57b57eaf5a9648$var$_fuzzyCheckStrings(Object.getOwnPropertyNames(object), [
            ...VUE_FRAMEWORK_PROPS,
            ...exceptions,
            ...validProperties
        ], validProperties);
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(invalidProperties, (key, value)=>{
            let message = `invalid ${containerName} property '${key}' did you mean any of these: ${value.slice(0, 8).join(", ")}.`;
            if (validProperties.includes("context")) message += `
If you are trying to annotate ${containerName} with application data, use the '${containerName}.context' property instead.`;
            $7b57b57eaf5a9648$export$2cf41453020eef66(message);
        });
        if (Object.keys(invalidProperties).length > 0 && docsUrl) {
            const url = this.getFrameworkOverrides().getDocLink(docsUrl);
            $7b57b57eaf5a9648$export$2cf41453020eef66(`to see all the valid ${containerName} properties please check: ${url}`);
        }
    }
};
// community-modules/core/src/gridCoreModule.ts
var $7b57b57eaf5a9648$export$41ec4de4c5adac92 = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/core" /* CommunityCoreModule */ 
};
var $7b57b57eaf5a9648$var$ValidationsModule = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/core-validations",
    beans: [
        $7b57b57eaf5a9648$var$ValidationService
    ]
};
var $7b57b57eaf5a9648$export$e7c66fbb2b880e54 = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/core-community-features",
    dependantModules: [
        $7b57b57eaf5a9648$export$41ec4de4c5adac92,
        $7b57b57eaf5a9648$var$ValidationsModule,
        $7b57b57eaf5a9648$var$EditModule,
        $7b57b57eaf5a9648$var$FilterModule,
        $7b57b57eaf5a9648$var$StateModule,
        $7b57b57eaf5a9648$var$DataTypeModule,
        $7b57b57eaf5a9648$var$AlignedGridsModule,
        $7b57b57eaf5a9648$var$PaginationModule,
        $7b57b57eaf5a9648$var$CommunityApiModule
    ]
};
// community-modules/core/src/gridDestroyService.ts
var $7b57b57eaf5a9648$var$GridDestroyService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "gridDestroyService";
        this.destroyCalled = false;
    }
    wireBeans(beans) {
        this.beans = beans;
    }
    destroy() {
        if (this.destroyCalled) return;
        const event = {
            type: "gridPreDestroyed",
            state: this.beans.stateService?.getState() ?? {}
        };
        this.eventService.dispatchEvent(event);
        this.destroyCalled = true;
        this.beans.ctrlsService.get("gridCtrl")?.destroyGridUi();
        this.beans.context.destroy();
        super.destroy();
    }
    isDestroyCalled() {
        return this.destroyCalled;
    }
};
// community-modules/core/src/events.ts
var $7b57b57eaf5a9648$export$12e4e9a3cbd0ec07 = /* @__PURE__ */ new Set([
    "gridPreDestroyed",
    "fillStart",
    "pasteStart"
]);
var $7b57b57eaf5a9648$export$16b052e8a337414c = (source)=>{
    return source === "checkboxSelected" || source === "rowClicked" || source === "spaceKey" || source === "uiSelectAll" || source === "uiSelectAllCurrentPage" || source === "uiSelectAllFiltered";
};
// community-modules/core/src/gridOptionsService.ts
var $7b57b57eaf5a9648$var$PROPERTY_COERCIONS = new Map([
    ...$7b57b57eaf5a9648$export$4d1a0127671c9c1f.BOOLEAN_PROPERTIES.map((key)=>[
            key,
            $7b57b57eaf5a9648$var$toBoolean
        ]),
    ...$7b57b57eaf5a9648$export$4d1a0127671c9c1f.NUMBER_PROPERTIES.map((key)=>[
            key,
            $7b57b57eaf5a9648$var$toNumber
        ]),
    [
        "groupAggFiltering",
        (val)=>typeof val === "function" ? val : $7b57b57eaf5a9648$var$toBoolean(val)
    ],
    [
        "pageSize",
        $7b57b57eaf5a9648$var$toConstrainedNum(1)
    ],
    [
        "autoSizePadding",
        $7b57b57eaf5a9648$var$toConstrainedNum(0)
    ],
    [
        "keepDetailRowsCount",
        $7b57b57eaf5a9648$var$toConstrainedNum(1)
    ],
    [
        "rowBuffer",
        $7b57b57eaf5a9648$var$toConstrainedNum(0)
    ],
    [
        "infiniteInitialRowCount",
        $7b57b57eaf5a9648$var$toConstrainedNum(1)
    ],
    [
        "cacheOverflowSize",
        $7b57b57eaf5a9648$var$toConstrainedNum(1)
    ],
    [
        "cacheBlockSize",
        $7b57b57eaf5a9648$var$toConstrainedNum(1)
    ],
    [
        "serverSideInitialRowCount",
        $7b57b57eaf5a9648$var$toConstrainedNum(1)
    ],
    [
        "viewportRowModelPageSize",
        $7b57b57eaf5a9648$var$toConstrainedNum(1)
    ],
    [
        "viewportRowModelBufferSize",
        $7b57b57eaf5a9648$var$toConstrainedNum(0)
    ]
]);
function $7b57b57eaf5a9648$var$getCoercedValue(key, value) {
    const coerceFunc = $7b57b57eaf5a9648$var$PROPERTY_COERCIONS.get(key);
    if (!coerceFunc) return value;
    return coerceFunc(value);
}
function $7b57b57eaf5a9648$var$getCoercedGridOptions(gridOptions) {
    const newGo = {};
    Object.entries(gridOptions).forEach(([key, value])=>{
        const coercedValue = $7b57b57eaf5a9648$var$getCoercedValue(key, value);
        newGo[key] = coercedValue;
    });
    return newGo;
}
var $7b57b57eaf5a9648$var$_GridOptionsService = class _GridOptionsService extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "gos";
        this.domDataKey = "__AG_" + Math.random().toString();
        this.propertyEventService = new $7b57b57eaf5a9648$export$820da7696a401cdc();
        // responsible for calling the onXXX functions on gridOptions
        // It forces events defined in GridOptionsService.alwaysSyncGlobalEvents to be fired synchronously.
        // This is required for events such as GridPreDestroyed.
        // Other events can be fired asynchronously or synchronously depending on config.
        this.globalEventHandlerFactory = (restrictToSyncOnly)=>{
            return (eventName, event)=>{
                if (!this.isAlive()) return;
                const alwaysSync = $7b57b57eaf5a9648$export$12e4e9a3cbd0ec07.has(eventName);
                if (alwaysSync && !restrictToSyncOnly || !alwaysSync && restrictToSyncOnly) return;
                const eventHandlerName = $7b57b57eaf5a9648$export$1f1b72b628161f7c.getCallbackForEvent(eventName);
                const eventHandler = this.gridOptions[eventHandlerName];
                if (typeof eventHandler === "function") this.frameworkOverrides.wrapOutgoing(()=>{
                    eventHandler(event);
                });
            };
        };
    }
    wireBeans(beans) {
        this.gridOptions = beans.gridOptions;
        this.eGridDiv = beans.eGridDiv;
        this.validationService = beans.validationService;
        this.environment = beans.environment;
        this.api = beans.gridApi;
    }
    // This is quicker then having code call gridOptionsService.get('context')
    get gridOptionsContext() {
        return this.gridOptions["context"];
    }
    postConstruct() {
        const async = !this.get("suppressAsyncEvents");
        this.eventService.addGlobalListener(this.globalEventHandlerFactory().bind(this), async);
        this.eventService.addGlobalListener(this.globalEventHandlerFactory(true).bind(this), false);
        this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides);
        this.getScrollbarWidth();
        this.addManagedEventListeners({
            gridOptionsChanged: ({ options: options  })=>{
                this.updateGridOptions({
                    options: options,
                    force: true,
                    source: "gridOptionsUpdated"
                });
            }
        });
    }
    /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */ get(property) {
        return this.gridOptions[property] ?? $7b57b57eaf5a9648$var$GRID_OPTION_DEFAULTS[property];
    }
    /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */ getCallback(property) {
        return this.mergeGridCommonParams(this.gridOptions[property]);
    }
    /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */ exists(property) {
        return $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.gridOptions[property]);
    }
    /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */ mergeGridCommonParams(callback) {
        if (callback) {
            const wrapped = (callbackParams)=>{
                const mergedParams = callbackParams;
                mergedParams.api = this.api;
                mergedParams.context = this.gridOptionsContext;
                return callback(mergedParams);
            };
            return wrapped;
        }
        return callback;
    }
    updateGridOptions({ options: options , force: force , source: source = "api"  }) {
        const changeSet = {
            id: _GridOptionsService.changeSetId++,
            properties: []
        };
        const events = [];
        Object.entries(options).forEach(([key, value])=>{
            if (source === "api" && $7b57b57eaf5a9648$var$INITIAL_GRID_OPTION_KEYS[key]) $7b57b57eaf5a9648$export$2cf41453020eef66(`${key} is an initial property and cannot be updated.`);
            const coercedValue = $7b57b57eaf5a9648$var$getCoercedValue(key, value);
            const shouldForce = force || typeof coercedValue === "object" && source === "api";
            const previousValue = this.gridOptions[key];
            if (shouldForce || previousValue !== coercedValue) {
                this.gridOptions[key] = coercedValue;
                const event = {
                    type: key,
                    currentValue: coercedValue,
                    previousValue: previousValue,
                    changeSet: changeSet,
                    source: source
                };
                events.push(event);
            }
        });
        this.validationService?.processGridOptions(this.gridOptions);
        changeSet.properties = events.map((event)=>event.type);
        events.forEach((event)=>{
            if (this.gridOptions.debug) $7b57b57eaf5a9648$export$1ce471ee7a8b4d23(`Updated property ${event.type} from`, event.previousValue, ` to `, event.currentValue);
            this.propertyEventService.dispatchEvent(event);
        });
    }
    addPropertyEventListener(key, listener) {
        this.propertyEventService.addEventListener(key, listener);
    }
    removePropertyEventListener(key, listener) {
        this.propertyEventService.removeEventListener(key, listener);
    }
    // *************** Helper methods ************************** //
    // Methods to share common GridOptions related logic that goes above accessing a single property
    // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
    // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
    // allow the user to provide the scroll width before we work it out.
    getScrollbarWidth() {
        if (this.scrollbarWidth == null) {
            const useGridOptions = typeof this.gridOptions.scrollbarWidth === "number" && this.gridOptions.scrollbarWidth >= 0;
            const scrollbarWidth = useGridOptions ? this.gridOptions.scrollbarWidth : $7b57b57eaf5a9648$var$_getScrollbarWidth();
            if (scrollbarWidth != null) {
                this.scrollbarWidth = scrollbarWidth;
                this.eventService.dispatchEvent({
                    type: "scrollbarWidthChanged"
                });
            }
        }
        return this.scrollbarWidth;
    }
    isRowModelType(rowModelType) {
        return this.gridOptions.rowModelType === rowModelType || rowModelType === "clientSide" && $7b57b57eaf5a9648$export$672d9e47bc342bac(this.gridOptions.rowModelType);
    }
    isDomLayout(domLayout) {
        const gridLayout = this.gridOptions.domLayout ?? "normal";
        return gridLayout === domLayout;
    }
    isRowSelection() {
        return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
    }
    useAsyncEvents() {
        return !this.get("suppressAsyncEvents");
    }
    isGetRowHeightFunction() {
        return typeof this.gridOptions.getRowHeight === "function";
    }
    getRowHeightForNode(rowNode, allowEstimate = false, defaultRowHeight) {
        if (defaultRowHeight == null) defaultRowHeight = this.environment.getDefaultRowHeight();
        if (this.isGetRowHeightFunction()) {
            if (allowEstimate) return {
                height: defaultRowHeight,
                estimated: true
            };
            const params = {
                node: rowNode,
                data: rowNode.data
            };
            const height = this.getCallback("getRowHeight")(params);
            if (this.isNumeric(height)) {
                if (height === 0) $7b57b57eaf5a9648$export$2cf41453020eef66("The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.");
                return {
                    height: Math.max(1, height),
                    estimated: false
                };
            }
        }
        if (rowNode.detail && this.get("masterDetail")) return this.getMasterDetailRowHeight();
        const rowHeight = this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : defaultRowHeight;
        return {
            height: rowHeight,
            estimated: false
        };
    }
    getMasterDetailRowHeight() {
        if (this.get("detailRowAutoHeight")) return {
            height: 1,
            estimated: false
        };
        if (this.isNumeric(this.gridOptions.detailRowHeight)) return {
            height: this.gridOptions.detailRowHeight,
            estimated: false
        };
        return {
            height: 300,
            estimated: false
        };
    }
    // we don't allow dynamic row height for virtual paging
    getRowHeightAsNumber() {
        if (!this.gridOptions.rowHeight || $7b57b57eaf5a9648$export$672d9e47bc342bac(this.gridOptions.rowHeight)) return this.environment.getDefaultRowHeight();
        const rowHeight = this.environment.refreshRowHeightVariable();
        if (rowHeight !== -1) return rowHeight;
        $7b57b57eaf5a9648$export$2cf41453020eef66("row height must be a number if not using standard row model");
        return this.environment.getDefaultRowHeight();
    }
    isNumeric(value) {
        return !isNaN(value) && typeof value === "number" && isFinite(value);
    }
    getDomDataKey() {
        return this.domDataKey;
    }
    // returns the dom data, or undefined if not found
    getDomData(element, key) {
        const domData = element[this.getDomDataKey()];
        return domData ? domData[key] : void 0;
    }
    setDomData(element, key, value) {
        const domDataKey = this.getDomDataKey();
        let domData = element[domDataKey];
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(domData)) {
            domData = {};
            element[domDataKey] = domData;
        }
        domData[key] = value;
    }
    getDocument() {
        let result = null;
        if (this.gridOptions.getDocument && $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.gridOptions.getDocument)) result = this.gridOptions.getDocument();
        else if (this.eGridDiv) result = this.eGridDiv.ownerDocument;
        if (result && $7b57b57eaf5a9648$export$25d27f17d3af40f7(result)) return result;
        return document;
    }
    getWindow() {
        const eDocument = this.getDocument();
        return eDocument.defaultView || window;
    }
    getRootNode() {
        return this.eGridDiv.getRootNode();
    }
    getActiveDomElement() {
        return this.getRootNode().activeElement;
    }
    getAsyncTransactionWaitMillis() {
        return $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : 50;
    }
    isAnimateRows() {
        if (this.get("ensureDomOrder")) return false;
        return this.get("animateRows");
    }
    isGroupRowsSticky() {
        if (this.get("paginateChildRows") || this.get("groupHideOpenParents") || this.isDomLayout("print")) return false;
        return true;
    }
    isColumnsSortingCoupledToGroup() {
        const autoGroupColumnDef = this.gridOptions.autoGroupColumnDef;
        return !autoGroupColumnDef?.comparator && !this.get("treeData");
    }
    getGroupAggFiltering() {
        const userValue = this.gridOptions.groupAggFiltering;
        if (typeof userValue === "function") return this.getCallback("groupAggFiltering");
        if (userValue === true) return ()=>true;
        return void 0;
    }
    getGrandTotalRow() {
        const userValue = this.gridOptions.grandTotalRow;
        if (userValue) return userValue;
        const legacyValue = this.gridOptions.groupIncludeTotalFooter;
        if (legacyValue) return "bottom";
        return void 0;
    }
    getGroupTotalRowCallback() {
        const userValue = this.get("groupTotalRow");
        if (typeof userValue === "function") return this.getCallback("groupTotalRow");
        if (userValue) return ()=>userValue;
        const legacyValue = this.get("groupIncludeFooter");
        if (typeof legacyValue === "function") {
            const legacyCallback = this.getCallback("groupIncludeFooter");
            return (p)=>{
                return legacyCallback(p) ? "bottom" : void 0;
            };
        }
        return ()=>legacyValue ? "bottom" : void 0;
    }
    isGroupMultiAutoColumn() {
        if (this.gridOptions.groupDisplayType) return this.gridOptions.groupDisplayType === "multipleColumns";
        return this.get("groupHideOpenParents");
    }
    isGroupUseEntireRow(pivotMode) {
        if (pivotMode) return false;
        return this.gridOptions.groupDisplayType === "groupRows";
    }
    getGridCommonParams() {
        return {
            api: this.api,
            context: this.gridOptionsContext
        };
    }
    addGridCommonParams(params) {
        const updatedParams = params;
        updatedParams.api = this.api;
        updatedParams.context = this.gridOptionsContext;
        return updatedParams;
    }
    // AG-9259 Can't use `WrappedCallback<'getRowId', ...>` here because of a strange typescript bug
    getRowIdCallback() {
        const getRowId = this.getCallback("getRowId");
        if (getRowId === void 0) return getRowId;
        return (params)=>{
            let id = getRowId(params);
            if (typeof id !== "string") {
                $7b57b57eaf5a9648$export$2cf41453020eef66(`The getRowId callback must return a string. The ID `, id, ` is being cast to a string.`);
                id = String(id);
            }
            return id;
        };
    }
};
$7b57b57eaf5a9648$var$_GridOptionsService.changeSetId = 0;
var $7b57b57eaf5a9648$export$4e35ad424d98ee6 = $7b57b57eaf5a9648$var$_GridOptionsService;
// community-modules/core/src/headerRendering/common/headerPosition.ts
var $7b57b57eaf5a9648$export$4dfb519ecc588412 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "headerPositionUtils";
    }
    wireBeans(beans) {
        this.visibleColsService = beans.visibleColsService;
        this.ctrlsService = beans.ctrlsService;
    }
    findHeader(focusedHeader, direction) {
        let nextColumn;
        let getColMethod;
        if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(focusedHeader.column)) nextColumn = this.visibleColsService.getGroupAtDirection(focusedHeader.column, direction);
        else {
            getColMethod = `getCol${direction}`;
            nextColumn = this.visibleColsService[getColMethod](focusedHeader.column);
        }
        if (!nextColumn) return;
        const { headerRowIndex: headerRowIndex  } = focusedHeader;
        if (this.getHeaderRowType(headerRowIndex) !== "filter" /* FLOATING_FILTER */ ) {
            const columnsInPath = [
                nextColumn
            ];
            while(nextColumn.getParent()){
                nextColumn = nextColumn.getParent();
                columnsInPath.push(nextColumn);
            }
            nextColumn = columnsInPath[columnsInPath.length - 1 - headerRowIndex];
        }
        const { column: column , headerRowIndex: indexToFocus  } = this.getHeaderIndexToFocus(nextColumn, headerRowIndex);
        return {
            column: column,
            headerRowIndex: indexToFocus
        };
    }
    getHeaderIndexToFocus(column, currentIndex) {
        let nextColumn;
        if ($7b57b57eaf5a9648$export$1f44a60fc23f9028(column) && this.isAnyChildSpanningHeaderHeight(column) && column.isPadding()) {
            const targetColumn = column;
            nextColumn = targetColumn.getLeafColumns()[0];
            let col = nextColumn;
            while(col !== targetColumn){
                currentIndex++;
                col = col.getParent();
            }
        }
        return {
            column: nextColumn || column,
            headerRowIndex: currentIndex
        };
    }
    isAnyChildSpanningHeaderHeight(columnGroup) {
        if (!columnGroup) return false;
        return columnGroup.getLeafColumns().some((col)=>col.isSpanHeaderHeight());
    }
    getColumnVisibleParent(currentColumn, currentIndex) {
        const currentRowType = this.getHeaderRowType(currentIndex);
        const isFloatingFilter = currentRowType === "filter" /* FLOATING_FILTER */ ;
        const isColumn2 = currentRowType === "column" /* COLUMN */ ;
        let nextFocusColumn = isFloatingFilter ? currentColumn : currentColumn.getParent();
        let nextRow = currentIndex - 1;
        let headerRowIndexWithoutSpan = nextRow;
        if (isColumn2 && this.isAnyChildSpanningHeaderHeight(currentColumn.getParent())) {
            while(nextFocusColumn && nextFocusColumn.isPadding()){
                nextFocusColumn = nextFocusColumn.getParent();
                nextRow--;
            }
            headerRowIndexWithoutSpan = nextRow;
            if (nextRow < 0) {
                nextFocusColumn = currentColumn;
                nextRow = currentIndex;
                headerRowIndexWithoutSpan = void 0;
            }
        }
        return {
            column: nextFocusColumn,
            headerRowIndex: nextRow,
            headerRowIndexWithoutSpan: headerRowIndexWithoutSpan
        };
    }
    getColumnVisibleChild(column, currentIndex, direction = "After") {
        const currentRowType = this.getHeaderRowType(currentIndex);
        let nextFocusColumn = column;
        let nextRow = currentIndex + 1;
        const headerRowIndexWithoutSpan = nextRow;
        if (currentRowType === "group" /* COLUMN_GROUP */ ) {
            const leafColumns = column.getDisplayedLeafColumns();
            const leafColumn = direction === "After" ? leafColumns[0] : $7b57b57eaf5a9648$export$236389741107357f(leafColumns);
            const columnsInTheWay = [];
            let currentColumn = leafColumn;
            while(currentColumn.getParent() !== column){
                currentColumn = currentColumn.getParent();
                columnsInTheWay.push(currentColumn);
            }
            nextFocusColumn = leafColumn;
            if (leafColumn.isSpanHeaderHeight()) for(let i = columnsInTheWay.length - 1; i >= 0; i--){
                const colToFocus = columnsInTheWay[i];
                if (!colToFocus.isPadding()) {
                    nextFocusColumn = colToFocus;
                    break;
                }
                nextRow++;
            }
            else {
                nextFocusColumn = $7b57b57eaf5a9648$export$236389741107357f(columnsInTheWay);
                if (!nextFocusColumn) nextFocusColumn = leafColumn;
            }
        }
        return {
            column: nextFocusColumn,
            headerRowIndex: nextRow,
            headerRowIndexWithoutSpan: headerRowIndexWithoutSpan
        };
    }
    getHeaderRowType(rowIndex) {
        const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();
        if (centerHeaderContainer) return centerHeaderContainer.getRowType(rowIndex);
    }
    findColAtEdgeForHeaderRow(level, position) {
        const displayedColumns = this.visibleColsService.getAllCols();
        const column = displayedColumns[position === "start" ? 0 : displayedColumns.length - 1];
        if (!column) return;
        const childContainer = this.ctrlsService.getHeaderRowContainerCtrl(column.getPinned());
        const type = childContainer.getRowType(level);
        if (type == "group" /* COLUMN_GROUP */ ) {
            const columnGroup = this.visibleColsService.getColGroupAtLevel(column, level);
            return {
                headerRowIndex: level,
                column: columnGroup
            };
        }
        return {
            // if type==null, means the header level didn't exist
            headerRowIndex: type == null ? -1 : level,
            column: column
        };
    }
};
// community-modules/core/src/localeService.ts
var $7b57b57eaf5a9648$export$f325e19d05d9c36d = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "localeService";
    }
    getLocaleTextFunc() {
        const getLocaleText = this.gos.getCallback("getLocaleText");
        if (getLocaleText) return (key, defaultValue, variableValues)=>{
            const params = {
                key: key,
                defaultValue: defaultValue,
                variableValues: variableValues
            };
            return getLocaleText(params);
        };
        const localeText = this.gos.get("localeText");
        return (key, defaultValue, variableValues)=>{
            let localisedText = localeText && localeText[key];
            if (localisedText && variableValues && variableValues.length) {
                let found = 0;
                while(true){
                    if (found >= variableValues.length) break;
                    const idx = localisedText.indexOf("${variable}");
                    if (idx === -1) break;
                    localisedText = localisedText.replace("${variable}", variableValues[found++]);
                }
            }
            return localisedText ?? defaultValue;
        };
    }
};
// community-modules/core/src/misc/apiEventService.ts
var $7b57b57eaf5a9648$var$ApiEventService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "apiEventService";
        this.syncEventListeners = /* @__PURE__ */ new Map();
        this.asyncEventListeners = /* @__PURE__ */ new Map();
        this.syncGlobalEventListeners = /* @__PURE__ */ new Set();
        this.globalEventListenerPairs = /* @__PURE__ */ new Map();
    }
    postConstruct() {
        this.frameworkEventWrappingService = new $7b57b57eaf5a9648$var$FrameworkEventListenerService(this.getFrameworkOverrides());
    }
    addEventListener(eventType, userListener) {
        const listener = this.frameworkEventWrappingService.wrap(userListener);
        const async = this.gos.useAsyncEvents() && !$7b57b57eaf5a9648$export$12e4e9a3cbd0ec07.has(eventType);
        const listeners = async ? this.asyncEventListeners : this.syncEventListeners;
        if (!listeners.has(eventType)) listeners.set(eventType, /* @__PURE__ */ new Set());
        listeners.get(eventType).add(listener);
        this.eventService.addEventListener(eventType, listener, async);
    }
    removeEventListener(eventType, userListener) {
        const listener = this.frameworkEventWrappingService.unwrap(userListener);
        const asyncListeners = this.asyncEventListeners.get(eventType);
        const hasAsync = !!asyncListeners?.delete(listener);
        if (!hasAsync) this.syncEventListeners.get(eventType)?.delete(listener);
        this.eventService.removeEventListener(eventType, listener, hasAsync);
    }
    addGlobalListener(userListener) {
        const listener = this.frameworkEventWrappingService.wrapGlobal(userListener);
        const async = this.gos.useAsyncEvents();
        if (async) {
            const syncListener = (eventType, event)=>{
                if ($7b57b57eaf5a9648$export$12e4e9a3cbd0ec07.has(eventType)) listener(eventType, event);
            };
            const asyncListener = (eventType, event)=>{
                if (!$7b57b57eaf5a9648$export$12e4e9a3cbd0ec07.has(eventType)) listener(eventType, event);
            };
            this.globalEventListenerPairs.set(userListener, {
                syncListener: syncListener,
                asyncListener: asyncListener
            });
            this.eventService.addGlobalListener(syncListener, false);
            this.eventService.addGlobalListener(asyncListener, true);
        } else {
            this.syncGlobalEventListeners.add(listener);
            this.eventService.addGlobalListener(listener, false);
        }
    }
    removeGlobalListener(userListener) {
        const listener = this.frameworkEventWrappingService.unwrapGlobal(userListener);
        const hasAsync = this.globalEventListenerPairs.has(listener);
        if (hasAsync) {
            const { syncListener: syncListener , asyncListener: asyncListener  } = this.globalEventListenerPairs.get(listener);
            this.eventService.removeGlobalListener(syncListener, false);
            this.eventService.removeGlobalListener(asyncListener, true);
            this.globalEventListenerPairs.delete(userListener);
        } else {
            this.syncGlobalEventListeners.delete(listener);
            this.eventService.removeGlobalListener(listener, false);
        }
    }
    destroyEventListeners(map, async) {
        map.forEach((listeners, eventType)=>{
            listeners.forEach((listener)=>this.eventService.removeEventListener(eventType, listener, async));
            listeners.clear();
        });
        map.clear();
    }
    destroyGlobalListeners(set, async) {
        set.forEach((listener)=>this.eventService.removeGlobalListener(listener, async));
        set.clear();
    }
    destroy() {
        super.destroy();
        this.destroyEventListeners(this.syncEventListeners, false);
        this.destroyEventListeners(this.asyncEventListeners, true);
        this.destroyGlobalListeners(this.syncGlobalEventListeners, false);
        this.globalEventListenerPairs.forEach(({ syncListener: syncListener , asyncListener: asyncListener  })=>{
            this.eventService.removeGlobalListener(syncListener, false);
            this.eventService.removeGlobalListener(asyncListener, true);
        });
        this.globalEventListenerPairs.clear();
    }
};
// community-modules/core/src/pagination/pageBoundsListener.ts
var $7b57b57eaf5a9648$var$PageBoundsListener = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "pageBoundsListener";
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.paginationService = beans.paginationService;
        this.pageBoundsService = beans.pageBoundsService;
    }
    postConstruct() {
        this.addManagedEventListeners({
            modelUpdated: this.onModelUpdated.bind(this),
            recalculateRowBounds: this.calculatePages.bind(this)
        });
        this.onModelUpdated();
    }
    onModelUpdated(modelUpdatedEvent) {
        this.calculatePages();
        const paginationChangedEvent = {
            type: "paginationChanged",
            animate: modelUpdatedEvent ? modelUpdatedEvent.animate : false,
            newData: modelUpdatedEvent ? modelUpdatedEvent.newData : false,
            newPage: modelUpdatedEvent ? modelUpdatedEvent.newPage : false,
            newPageSize: modelUpdatedEvent ? modelUpdatedEvent.newPageSize : false,
            keepRenderedRows: modelUpdatedEvent ? modelUpdatedEvent.keepRenderedRows : false
        };
        this.eventService.dispatchEvent(paginationChangedEvent);
    }
    calculatePages() {
        if (this.paginationService) this.paginationService.calculatePages();
        else this.pageBoundsService.calculateBounds(0, this.rowModel.getRowCount() - 1);
    }
};
// community-modules/core/src/pagination/pageBoundsService.ts
var $7b57b57eaf5a9648$var$PageBoundsService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "pageBoundsService";
        this.pixelOffset = 0;
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
    }
    getFirstRow() {
        return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
    }
    getLastRow() {
        return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
    }
    getCurrentPageHeight() {
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(this.topRowBounds) || $7b57b57eaf5a9648$export$672d9e47bc342bac(this.bottomRowBounds)) return 0;
        return Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
    }
    getCurrentPagePixelRange() {
        const pageFirstPixel = this.topRowBounds ? this.topRowBounds.rowTop : 0;
        const pageLastPixel = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
        return {
            pageFirstPixel: pageFirstPixel,
            pageLastPixel: pageLastPixel
        };
    }
    calculateBounds(topDisplayedRowIndex, bottomDisplayedRowIndex) {
        this.topRowBounds = this.rowModel.getRowBounds(topDisplayedRowIndex);
        if (this.topRowBounds) this.topRowBounds.rowIndex = topDisplayedRowIndex;
        this.bottomRowBounds = this.rowModel.getRowBounds(bottomDisplayedRowIndex);
        if (this.bottomRowBounds) this.bottomRowBounds.rowIndex = bottomDisplayedRowIndex;
        this.calculatePixelOffset();
    }
    getPixelOffset() {
        return this.pixelOffset;
    }
    calculatePixelOffset() {
        const value = $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.topRowBounds) ? this.topRowBounds.rowTop : 0;
        if (this.pixelOffset === value) return;
        this.pixelOffset = value;
        this.eventService.dispatchEvent({
            type: "paginationPixelOffsetChanged"
        });
    }
};
// community-modules/core/src/rendering/ariaAnnouncementService.ts
var $7b57b57eaf5a9648$export$cdc69977f394dec1 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super();
        this.beanName = "ariaAnnouncementService";
        this.descriptionContainer = null;
        this.announceValue = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.announceValue.bind(this), 200);
    }
    wireBeans(beans) {
        this.eGridDiv = beans.eGridDiv;
    }
    postConstruct() {
        const eDocument = this.gos.getDocument();
        const div = this.descriptionContainer = eDocument.createElement("div");
        div.classList.add("ag-aria-description-container");
        $7b57b57eaf5a9648$var$_setAriaLive(div, "polite");
        $7b57b57eaf5a9648$var$_setAriaRelevant(div, "additions text");
        $7b57b57eaf5a9648$var$_setAriaAtomic(div, true);
        this.eGridDiv.appendChild(div);
    }
    announceValue(value) {
        if (!this.descriptionContainer) return;
        this.descriptionContainer.textContent = "";
        setTimeout(()=>{
            if (this.isAlive() && this.descriptionContainer) this.descriptionContainer.textContent = value;
        }, 50);
    }
    destroy() {
        super.destroy();
        const { descriptionContainer: descriptionContainer  } = this;
        if (descriptionContainer) {
            $7b57b57eaf5a9648$export$69e6e10709eabd91(descriptionContainer);
            if (descriptionContainer.parentElement) descriptionContainer.parentElement.removeChild(descriptionContainer);
        }
        this.descriptionContainer = null;
        this.eGridDiv = null;
    }
};
// community-modules/core/src/rendering/columnAnimationService.ts
var $7b57b57eaf5a9648$var$ColumnAnimationService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnAnimationService";
        this.executeNextFuncs = [];
        this.executeLaterFuncs = [];
        this.active = false;
        this.suppressAnimation = false;
        this.animationThreadCount = 0;
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
    }
    postConstruct() {
        this.ctrlsService.whenReady((p)=>this.gridBodyCtrl = p.gridBodyCtrl);
    }
    isActive() {
        return this.active && !this.suppressAnimation;
    }
    setSuppressAnimation(suppress) {
        this.suppressAnimation = suppress;
    }
    start() {
        if (this.active) return;
        if (this.gos.get("suppressColumnMoveAnimation")) return;
        if (this.gos.get("enableRtl")) return;
        this.ensureAnimationCssClassPresent();
        this.active = true;
    }
    finish() {
        if (!this.active) return;
        this.flush(()=>{
            this.active = false;
        });
    }
    executeNextVMTurn(func) {
        if (this.active) this.executeNextFuncs.push(func);
        else func();
    }
    executeLaterVMTurn(func) {
        if (this.active) this.executeLaterFuncs.push(func);
        else func();
    }
    ensureAnimationCssClassPresent() {
        this.animationThreadCount++;
        const animationThreadCountCopy = this.animationThreadCount;
        this.gridBodyCtrl.setColumnMovingCss(true);
        this.executeLaterFuncs.push(()=>{
            if (this.animationThreadCount === animationThreadCountCopy) this.gridBodyCtrl.setColumnMovingCss(false);
        });
    }
    flush(callback) {
        if (this.executeNextFuncs.length === 0 && this.executeLaterFuncs.length === 0) {
            callback();
            return;
        }
        const runFuncs = (queue)=>{
            while(queue.length){
                const func = queue.pop();
                if (func) func();
            }
        };
        this.getFrameworkOverrides().wrapIncoming(()=>{
            window.setTimeout(()=>runFuncs(this.executeNextFuncs), 0);
            window.setTimeout(()=>{
                callback();
                runFuncs(this.executeLaterFuncs);
            }, 200);
        });
    }
};
// community-modules/core/src/rendering/columnHoverService.ts
var $7b57b57eaf5a9648$var$ColumnHoverService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "columnHoverService";
    }
    setMouseOver(columns) {
        this.selectedColumns = columns;
        const event = {
            type: "columnHoverChanged"
        };
        this.eventService.dispatchEvent(event);
    }
    clearMouseOver() {
        this.selectedColumns = null;
        const event = {
            type: "columnHoverChanged"
        };
        this.eventService.dispatchEvent(event);
    }
    isHovered(column) {
        return !!this.selectedColumns && this.selectedColumns.indexOf(column) >= 0;
    }
};
// community-modules/core/src/rendering/overlays/overlayService.ts
var $7b57b57eaf5a9648$var$OverlayService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "overlayService";
        this.state = 0 /* Hidden */ ;
        this.showInitialOverlay = true;
    }
    wireBeans(beans) {
        this.userComponentFactory = beans.userComponentFactory;
        this.rowModel = beans.rowModel;
        this.columnModel = beans.columnModel;
    }
    postConstruct() {
        const updateOverlayVisibility = ()=>this.updateOverlayVisibility();
        this.addManagedEventListeners({
            newColumnsLoaded: updateOverlayVisibility,
            rowDataUpdated: updateOverlayVisibility
        });
        this.addManagedPropertyListener("loading", updateOverlayVisibility);
    }
    registerOverlayWrapperComp(overlayWrapperComp) {
        this.overlayWrapperComp = overlayWrapperComp;
        this.updateOverlayVisibility();
    }
    showLoadingOverlay() {
        this.showInitialOverlay = false;
        const loading = this.gos.get("loading");
        if (!loading && (loading !== void 0 || this.gos.get("suppressLoadingOverlay"))) return;
        this.doShowLoadingOverlay();
    }
    showNoRowsOverlay() {
        this.showInitialOverlay = false;
        if (this.gos.get("loading") || this.gos.get("suppressNoRowsOverlay")) return;
        this.doShowNoRowsOverlay();
    }
    hideOverlay() {
        this.showInitialOverlay = false;
        if (this.gos.get("loading")) return;
        this.doHideOverlay();
    }
    updateOverlayVisibility() {
        let loading = this.gos.get("loading");
        if (this.showInitialOverlay && loading === void 0 && !this.gos.get("suppressLoadingOverlay")) loading = !this.gos.get("columnDefs") || !this.columnModel.isReady() || !this.gos.get("rowData") && this.gos.isRowModelType("clientSide");
        if (loading) {
            if (this.state !== 1 /* Loading */ ) this.doShowLoadingOverlay();
        } else {
            this.showInitialOverlay = false;
            if (this.rowModel.isEmpty() && !this.gos.get("suppressNoRowsOverlay") && this.gos.isRowModelType("clientSide")) {
                if (this.state !== 2 /* NoRows */ ) this.doShowNoRowsOverlay();
            } else if (this.state !== 0 /* Hidden */ ) this.doHideOverlay();
        }
    }
    doShowLoadingOverlay() {
        this.state = 1 /* Loading */ ;
        this.showOverlay(this.userComponentFactory.getLoadingOverlayCompDetails({}), "ag-overlay-loading-wrapper", "loadingOverlayComponentParams");
    }
    doShowNoRowsOverlay() {
        this.state = 2 /* NoRows */ ;
        this.showOverlay(this.userComponentFactory.getNoRowsOverlayCompDetails({}), "ag-overlay-no-rows-wrapper", "noRowsOverlayComponentParams");
    }
    doHideOverlay() {
        this.state = 0 /* Hidden */ ;
        this.overlayWrapperComp.hideOverlay();
    }
    showOverlay(compDetails, wrapperCssClass, gridOption) {
        const promise = compDetails.newAgStackInstance();
        this.overlayWrapperComp.showOverlay(promise, wrapperCssClass, gridOption);
    }
};
// community-modules/core/src/rendering/row/rowCssClassCalculator.ts
var $7b57b57eaf5a9648$var$RowCssClassCalculator = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowCssClassCalculator";
    }
    wireBeans(beans) {
        this.stylingService = beans.stylingService;
    }
    getInitialRowClasses(params) {
        const classes = [];
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(params.extraCssClass)) classes.push(params.extraCssClass);
        classes.push("ag-row");
        classes.push(params.rowFocused ? "ag-row-focus" : "ag-row-no-focus");
        if (params.fadeRowIn) classes.push("ag-opacity-zero");
        classes.push(params.rowIsEven ? "ag-row-even" : "ag-row-odd");
        if (params.rowNode.isRowPinned()) classes.push("ag-row-pinned");
        if (params.rowNode.isSelected()) classes.push("ag-row-selected");
        if (params.rowNode.footer) classes.push("ag-row-footer");
        classes.push("ag-row-level-" + params.rowLevel);
        if (params.rowNode.stub) classes.push("ag-row-loading");
        if (params.fullWidthRow) classes.push("ag-full-width-row");
        if (params.expandable) {
            classes.push("ag-row-group");
            classes.push(params.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted");
        }
        if (params.rowNode.dragging) classes.push("ag-row-dragging");
        $7b57b57eaf5a9648$var$_pushAll(classes, this.processClassesFromGridOptions(params.rowNode));
        $7b57b57eaf5a9648$var$_pushAll(classes, this.preProcessRowClassRules(params.rowNode));
        classes.push(params.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute");
        if (params.firstRowOnPage) classes.push("ag-row-first");
        if (params.lastRowOnPage) classes.push("ag-row-last");
        if (params.fullWidthRow) {
            if (params.pinned === "left") classes.push("ag-cell-last-left-pinned");
            if (params.pinned === "right") classes.push("ag-cell-first-right-pinned");
        }
        return classes;
    }
    processClassesFromGridOptions(rowNode) {
        const res = [];
        const process = (rowCls)=>{
            if (typeof rowCls === "string") res.push(rowCls);
            else if (Array.isArray(rowCls)) rowCls.forEach((e)=>res.push(e));
        };
        const rowClass = this.gos.get("rowClass");
        if (rowClass) {
            if (typeof rowClass === "function") {
                $7b57b57eaf5a9648$export$2cf41453020eef66("rowClass should not be a function, please use getRowClass instead");
                return [];
            }
            process(rowClass);
        }
        const rowClassFunc = this.gos.getCallback("getRowClass");
        if (rowClassFunc) {
            const params = {
                data: rowNode.data,
                node: rowNode,
                rowIndex: rowNode.rowIndex
            };
            const rowClassFuncResult = rowClassFunc(params);
            process(rowClassFuncResult);
        }
        return res;
    }
    preProcessRowClassRules(rowNode) {
        const res = [];
        this.processRowClassRules(rowNode, (className)=>{
            res.push(className);
        }, ()=>{});
        return res;
    }
    processRowClassRules(rowNode, onApplicableClass, onNotApplicableClass) {
        const rowClassParams = this.gos.addGridCommonParams({
            data: rowNode.data,
            node: rowNode,
            rowIndex: rowNode.rowIndex
        });
        this.stylingService.processClassRules(void 0, this.gos.get("rowClassRules"), rowClassParams, onApplicableClass, onNotApplicableClass);
    }
    calculateRowLevel(rowNode) {
        if (rowNode.group) return rowNode.level;
        return rowNode.parent ? rowNode.parent.level + 1 : 0;
    }
};
// community-modules/core/src/rendering/rowContainerHeightService.ts
var $7b57b57eaf5a9648$var$RowContainerHeightService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowContainerHeightService";
        // the scrollY position
        this.scrollY = 0;
        // how tall the body is
        this.uiBodyHeight = 0;
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
    }
    postConstruct() {
        this.addManagedEventListeners({
            bodyHeightChanged: this.updateOffset.bind(this)
        });
        this.maxDivHeight = $7b57b57eaf5a9648$var$_getMaxDivHeight();
        if (this.gos.get("debug")) $7b57b57eaf5a9648$export$1ce471ee7a8b4d23("RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
    }
    isStretching() {
        return this.stretching;
    }
    getDivStretchOffset() {
        return this.divStretchOffset;
    }
    updateOffset() {
        if (!this.stretching) return;
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        const newScrollY = gridBodyCon.getScrollFeature().getVScrollPosition().top;
        const newBodyHeight = this.getUiBodyHeight();
        const atLeastOneChanged = newScrollY !== this.scrollY || newBodyHeight !== this.uiBodyHeight;
        if (atLeastOneChanged) {
            this.scrollY = newScrollY;
            this.uiBodyHeight = newBodyHeight;
            this.calculateOffset();
        }
    }
    calculateOffset() {
        this.setUiContainerHeight(this.maxDivHeight);
        this.pixelsToShave = this.modelHeight - this.uiContainerHeight;
        this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
        const scrollPercent = this.scrollY / this.maxScrollY;
        const divStretchOffset = scrollPercent * this.pixelsToShave;
        if (this.gos.get("debug")) $7b57b57eaf5a9648$export$1ce471ee7a8b4d23(`RowContainerHeightService - Div Stretch Offset = ${divStretchOffset} (${this.pixelsToShave} * ${scrollPercent})`);
        this.setDivStretchOffset(divStretchOffset);
    }
    setUiContainerHeight(height) {
        if (height !== this.uiContainerHeight) {
            this.uiContainerHeight = height;
            this.eventService.dispatchEvent({
                type: "rowContainerHeightChanged"
            });
        }
    }
    clearOffset() {
        this.setUiContainerHeight(this.modelHeight);
        this.pixelsToShave = 0;
        this.setDivStretchOffset(0);
    }
    setDivStretchOffset(newOffset) {
        const newOffsetFloor = typeof newOffset === "number" ? Math.floor(newOffset) : null;
        if (this.divStretchOffset === newOffsetFloor) return;
        this.divStretchOffset = newOffsetFloor;
        this.eventService.dispatchEvent({
            type: "heightScaleChanged"
        });
    }
    setModelHeight(modelHeight) {
        this.modelHeight = modelHeight;
        this.stretching = modelHeight != null && // null happens when in print layout
        this.maxDivHeight > 0 && modelHeight > this.maxDivHeight;
        if (this.stretching) this.calculateOffset();
        else this.clearOffset();
    }
    getUiContainerHeight() {
        return this.uiContainerHeight;
    }
    getRealPixelPosition(modelPixel) {
        return modelPixel - this.divStretchOffset;
    }
    getUiBodyHeight() {
        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();
        const pos = gridBodyCon.getScrollFeature().getVScrollPosition();
        return pos.bottom - pos.top;
    }
    getScrollPositionForPixel(rowTop) {
        if (this.pixelsToShave <= 0) return rowTop;
        const modelMaxScroll = this.modelHeight - this.getUiBodyHeight();
        const scrollPercent = rowTop / modelMaxScroll;
        const scrollPixel = this.maxScrollY * scrollPercent;
        return scrollPixel;
    }
};
// community-modules/core/src/rowNodes/rowNodeSorter.ts
var $7b57b57eaf5a9648$export$5cc6416c85df0cc5 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowNodeSorter";
    }
    wireBeans(beans) {
        this.valueService = beans.valueService;
        this.columnModel = beans.columnModel;
        this.showRowGroupColsService = beans.showRowGroupColsService;
    }
    postConstruct() {
        this.isAccentedSort = this.gos.get("accentedSort");
        this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup();
        this.addManagedPropertyListener("accentedSort", (propChange)=>this.isAccentedSort = propChange.currentValue);
        this.addManagedPropertyListener("autoGroupColumnDef", ()=>this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup());
    }
    doFullSort(rowNodes, sortOptions) {
        const mapper = (rowNode, pos)=>({
                currentPos: pos,
                rowNode: rowNode
            });
        const sortedRowNodes = rowNodes.map(mapper);
        sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));
        return sortedRowNodes.map((item)=>item.rowNode);
    }
    compareRowNodes(sortOptions, sortedNodeA, sortedNodeB) {
        const nodeA = sortedNodeA.rowNode;
        const nodeB = sortedNodeB.rowNode;
        for(let i = 0, len = sortOptions.length; i < len; i++){
            const sortOption = sortOptions[i];
            const isDescending = sortOption.sort === "desc";
            const valueA = this.getValue(nodeA, sortOption.column);
            const valueB = this.getValue(nodeB, sortOption.column);
            let comparatorResult;
            const providedComparator = this.getComparator(sortOption, nodeA);
            if (providedComparator) comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isDescending);
            else comparatorResult = $7b57b57eaf5a9648$export$b0cca9f3c87c8df8(valueA, valueB, this.isAccentedSort);
            const validResult = !isNaN(comparatorResult);
            if (validResult && comparatorResult !== 0) return sortOption.sort === "asc" ? comparatorResult : comparatorResult * -1;
        }
        return sortedNodeA.currentPos - sortedNodeB.currentPos;
    }
    getComparator(sortOption, rowNode) {
        const column = sortOption.column;
        const comparatorOnCol = column.getColDef().comparator;
        if (comparatorOnCol != null) return comparatorOnCol;
        if (!column.getColDef().showRowGroup) return;
        const groupLeafField = !rowNode.group && column.getColDef().field;
        if (!groupLeafField) return;
        const primaryColumn = this.columnModel.getColDefCol(groupLeafField);
        if (!primaryColumn) return;
        return primaryColumn.getColDef().comparator;
    }
    getValue(node, column) {
        if (!this.primaryColumnsSortGroups) return this.valueService.getValue(column, node, false, false);
        const isNodeGroupedAtLevel = node.rowGroupColumn === column;
        if (isNodeGroupedAtLevel) {
            const isGroupRows = this.gos.isGroupUseEntireRow(this.columnModel.isPivotActive());
            if (isGroupRows) {
                const leafChild = node.allLeafChildren?.[0];
                if (leafChild) return this.valueService.getValue(column, leafChild, false, false);
                return void 0;
            }
            const displayCol = this.showRowGroupColsService?.getShowRowGroupCol(column.getId());
            if (!displayCol) return void 0;
            return node.groupData?.[displayCol.getId()];
        }
        if (node.group && column.getColDef().showRowGroup) return void 0;
        return this.valueService.getValue(column, node, false, false);
    }
};
// community-modules/core/src/utils/changedPath.ts
var $7b57b57eaf5a9648$export$cb4d9114a9732e85 = class {
    constructor(keepingColumns, rootNode){
        // whether changed path is active of not. it is active when a) doing
        // a transaction update or b) doing change detection. if we are doing
        // a CSRM refresh for other reasons (after sort or filter, or user calling
        // setRowData() without delta mode) then we are not active. we are also
        // marked as not active if secondary columns change in pivot (as this impacts
        // aggregations)
        this.active = true;
        // for each node in the change path, we also store which columns need
        // to be re-aggregated.
        this.nodeIdsToColumns = {};
        // for quick lookup, all items in the change path are mapped by nodeId
        this.mapToItems = {};
        this.keepingColumns = keepingColumns;
        this.pathRoot = {
            rowNode: rootNode,
            children: null
        };
        this.mapToItems[rootNode.id] = this.pathRoot;
    }
    // can be set inactive by:
    // a) ClientSideRowModel, if no transactions or
    // b) PivotService, if secondary columns changed
    setInactive() {
        this.active = false;
    }
    isActive() {
        return this.active;
    }
    depthFirstSearchChangedPath(pathItem, callback) {
        if (pathItem.children) for(let i = 0; i < pathItem.children.length; i++)this.depthFirstSearchChangedPath(pathItem.children[i], callback);
        callback(pathItem.rowNode);
    }
    depthFirstSearchEverything(rowNode, callback, traverseEverything) {
        if (rowNode.childrenAfterGroup) for(let i = 0; i < rowNode.childrenAfterGroup.length; i++){
            const childNode = rowNode.childrenAfterGroup[i];
            if (childNode.childrenAfterGroup) this.depthFirstSearchEverything(rowNode.childrenAfterGroup[i], callback, traverseEverything);
            else if (traverseEverything) callback(childNode);
        }
        callback(rowNode);
    }
    // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
    // will be called for child nodes in addition to parent nodes.
    forEachChangedNodeDepthFirst(callback, traverseLeafNodes = false, includeUnchangedNodes = false) {
        if (this.active && !includeUnchangedNodes) this.depthFirstSearchChangedPath(this.pathRoot, callback);
        else this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);
    }
    executeFromRootNode(callback) {
        callback(this.pathRoot.rowNode);
    }
    createPathItems(rowNode) {
        let pointer = rowNode;
        let newEntryCount = 0;
        while(!this.mapToItems[pointer.id]){
            const newEntry = {
                rowNode: pointer,
                children: null
            };
            this.mapToItems[pointer.id] = newEntry;
            newEntryCount++;
            pointer = pointer.parent;
        }
        return newEntryCount;
    }
    populateColumnsMap(rowNode, columns) {
        if (!this.keepingColumns || !columns) return;
        let pointer = rowNode;
        while(pointer){
            if (!this.nodeIdsToColumns[pointer.id]) this.nodeIdsToColumns[pointer.id] = {};
            columns.forEach((col)=>this.nodeIdsToColumns[pointer.id][col.getId()] = true);
            pointer = pointer.parent;
        }
    }
    linkPathItems(rowNode, newEntryCount) {
        let pointer = rowNode;
        for(let i = 0; i < newEntryCount; i++){
            const thisItem = this.mapToItems[pointer.id];
            const parentItem = this.mapToItems[pointer.parent.id];
            if (!parentItem.children) parentItem.children = [];
            parentItem.children.push(thisItem);
            pointer = pointer.parent;
        }
    }
    // called by
    // 1) change detection (provides cols) and
    // 2) groupStage if doing transaction update (doesn't provide cols)
    addParentNode(rowNode, columns) {
        if (!rowNode || rowNode.isRowPinned()) return;
        const newEntryCount = this.createPathItems(rowNode);
        this.linkPathItems(rowNode, newEntryCount);
        this.populateColumnsMap(rowNode, columns);
    }
    canSkip(rowNode) {
        return this.active && !this.mapToItems[rowNode.id];
    }
    getValueColumnsForNode(rowNode, valueColumns) {
        if (!this.keepingColumns) return valueColumns;
        const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
        const result = valueColumns.filter((col)=>colsForThisNode[col.getId()]);
        return result;
    }
    getNotValueColumnsForNode(rowNode, valueColumns) {
        if (!this.keepingColumns) return null;
        const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
        const result = valueColumns.filter((col)=>!colsForThisNode[col.getId()]);
        return result;
    }
};
// community-modules/core/src/selection/selectionService.ts
var $7b57b57eaf5a9648$var$SelectionService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "selectionService";
        this.selectedNodes = /* @__PURE__ */ new Map();
        this.selectionCtx = new $7b57b57eaf5a9648$var$RowRangeSelectionContext();
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.pageBoundsService = beans.pageBoundsService;
    }
    postConstruct() {
        this.selectionCtx.init(this.rowModel);
        this.rowSelection = this.gos.get("rowSelection");
        this.groupSelectsChildren = this.gos.get("groupSelectsChildren");
        this.addManagedPropertyListeners([
            "groupSelectsChildren",
            "rowSelection"
        ], ()=>{
            this.groupSelectsChildren = this.gos.get("groupSelectsChildren");
            this.rowSelection = this.gos.get("rowSelection");
            this.deselectAllRowNodes({
                source: "api"
            });
        });
        this.addManagedEventListeners({
            rowSelected: this.onRowSelected.bind(this)
        });
    }
    destroy() {
        super.destroy();
        this.resetNodes();
        this.selectionCtx.reset();
    }
    isMultiselect() {
        return this.rowSelection === "multiple";
    }
    /**
   * We override the selection value for UI-triggered events because it's the
   * current selection state that should determine the next selection state. This
   * is a stepping stone towards removing selection logic from event listeners and
   * other code external to the selection service(s).
   */ overrideSelectionValue(newValue, source) {
        if (!$7b57b57eaf5a9648$export$16b052e8a337414c(source)) return newValue;
        const root = this.selectionCtx.getRoot();
        return root ? root.isSelected() ?? false : true;
    }
    setNodesSelected(params) {
        const { newValue: newValue , clearSelection: clearSelection , suppressFinishActions: suppressFinishActions , rangeSelect: rangeSelect , nodes: nodes , event: event , source: source  } = params;
        if (nodes.length === 0) return 0;
        if (nodes.length > 1 && !this.isMultiselect()) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`cannot multi select while rowSelection='single'`);
            return 0;
        }
        const groupSelectsFiltered = this.groupSelectsChildren && params.groupSelectsFiltered === true;
        const filteredNodes = nodes.map((node)=>node.footer ? node.sibling : node);
        if (rangeSelect) {
            if (filteredNodes.length > 1) {
                $7b57b57eaf5a9648$export$2cf41453020eef66("cannot range select while selecting multiple rows");
                return 0;
            }
            const node = filteredNodes[0];
            const newSelectionValue = this.overrideSelectionValue(newValue, source);
            if (!this.isMultiselect()) ;
            else if (this.selectionCtx.isInRange(node)) {
                const partition = this.selectionCtx.truncate(node);
                if (newSelectionValue) this.selectRange(partition.discard, false, source);
                return this.selectRange(partition.keep, newSelectionValue, source);
            } else {
                const fromNode = this.selectionCtx.getRoot();
                const toNode = node;
                if (fromNode !== toNode) {
                    const partition = this.selectionCtx.extend(node, this.groupSelectsChildren);
                    if (newSelectionValue) this.selectRange(partition.discard, false, source);
                    return this.selectRange(partition.keep, newSelectionValue, source);
                }
            }
        }
        if (!suppressFinishActions) this.selectionCtx.setRoot(filteredNodes[0]);
        let updatedCount = 0;
        for(let i = 0; i < filteredNodes.length; i++){
            const node = filteredNodes[i];
            const skipThisNode = groupSelectsFiltered && node.group;
            if (!skipThisNode) {
                const thisNodeWasSelected = node.selectThisNode(newValue, event, source);
                if (thisNodeWasSelected) updatedCount++;
            }
            if (this.groupSelectsChildren && node.childrenAfterGroup?.length) updatedCount += this.selectChildren(node, newValue, groupSelectsFiltered, source);
        }
        if (!suppressFinishActions) {
            const clearOtherNodes = newValue && (clearSelection || !this.isMultiselect());
            if (clearOtherNodes) updatedCount += this.clearOtherNodes(filteredNodes[0], source);
            if (updatedCount > 0) {
                this.updateGroupsFromChildrenSelections(source);
                this.dispatchSelectionChanged(source);
            }
        }
        return updatedCount;
    }
    // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
    // holding down 'shift'.
    selectRange(nodesToSelect, value, source) {
        let updatedCount = 0;
        nodesToSelect.forEach((rowNode)=>{
            if (rowNode.group && this.groupSelectsChildren) return;
            const nodeWasSelected = rowNode.selectThisNode(value, void 0, source);
            if (nodeWasSelected) updatedCount++;
        });
        if (updatedCount > 0) {
            this.updateGroupsFromChildrenSelections(source);
            this.dispatchSelectionChanged(source);
        }
        return updatedCount;
    }
    selectChildren(node, newValue, groupSelectsFiltered, source) {
        const children = groupSelectsFiltered ? node.childrenAfterAggFilter : node.childrenAfterGroup;
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(children)) return 0;
        return this.setNodesSelected({
            newValue: newValue,
            clearSelection: false,
            suppressFinishActions: true,
            groupSelectsFiltered: groupSelectsFiltered,
            source: source,
            nodes: children
        });
    }
    getSelectedNodes() {
        const selectedNodes = [];
        this.selectedNodes.forEach((rowNode)=>{
            if (rowNode) selectedNodes.push(rowNode);
        });
        return selectedNodes;
    }
    getSelectedRows() {
        const selectedRows = [];
        this.selectedNodes.forEach((rowNode)=>{
            if (rowNode && rowNode.data) selectedRows.push(rowNode.data);
        });
        return selectedRows;
    }
    getSelectionCount() {
        return this.selectedNodes.size;
    }
    /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */ filterFromSelection(predicate) {
        const newSelectedNodes = /* @__PURE__ */ new Map();
        this.selectedNodes.forEach((rowNode, key)=>{
            const passesPredicate = rowNode && predicate(rowNode);
            if (passesPredicate) newSelectedNodes.set(key, rowNode);
        });
        this.selectedNodes = newSelectedNodes;
    }
    // should only be called if groupSelectsChildren=true
    updateGroupsFromChildrenSelections(source, changedPath) {
        if (!this.groupSelectsChildren) return false;
        if (this.rowModel.getType() !== "clientSide") return false;
        const clientSideRowModel = this.rowModel;
        const rootNode = clientSideRowModel.getRootNode();
        if (!changedPath) {
            changedPath = new $7b57b57eaf5a9648$export$cb4d9114a9732e85(true, rootNode);
            changedPath.setInactive();
        }
        let selectionChanged = false;
        changedPath.forEachChangedNodeDepthFirst((rowNode)=>{
            if (rowNode !== rootNode) {
                const selected = rowNode.calculateSelectedFromChildren();
                selectionChanged = rowNode.selectThisNode(selected === null ? false : selected, void 0, source) || selectionChanged;
            }
        });
        return selectionChanged;
    }
    clearOtherNodes(rowNodeToKeepSelected, source) {
        const groupsToRefresh = /* @__PURE__ */ new Map();
        let updatedCount = 0;
        this.selectedNodes.forEach((otherRowNode)=>{
            if (otherRowNode && otherRowNode.id !== rowNodeToKeepSelected.id) {
                const rowNode = this.selectedNodes.get(otherRowNode.id);
                updatedCount += rowNode.setSelectedParams({
                    newValue: false,
                    clearSelection: false,
                    suppressFinishActions: true,
                    source: source
                });
                if (this.groupSelectsChildren && otherRowNode.parent) groupsToRefresh.set(otherRowNode.parent.id, otherRowNode.parent);
            }
        });
        groupsToRefresh.forEach((group)=>{
            const selected = group.calculateSelectedFromChildren();
            group.selectThisNode(selected === null ? false : selected, void 0, source);
        });
        return updatedCount;
    }
    onRowSelected(event) {
        const rowNode = event.node;
        if (this.groupSelectsChildren && rowNode.group) return;
        if (rowNode.isSelected()) this.selectedNodes.set(rowNode.id, rowNode);
        else this.selectedNodes.delete(rowNode.id);
    }
    syncInRowNode(rowNode, oldNode) {
        this.syncInOldRowNode(rowNode, oldNode);
        this.syncInNewRowNode(rowNode);
    }
    // if the id has changed for the node, then this means the rowNode
    // is getting used for a different data item, which breaks
    // our selectedNodes, as the node now is mapped by the old id
    // which is inconsistent. so to keep the old node as selected,
    // we swap in the clone (with the old id and old data). this means
    // the oldNode is effectively a daemon we keep a reference to,
    // so if client calls api.getSelectedNodes(), it gets the daemon
    // in the result. when the client un-selects, the reference to the
    // daemon is removed. the daemon, because it's an oldNode, is not
    // used by the grid for rendering, it's a copy of what the node used
    // to be like before the id was changed.
    syncInOldRowNode(rowNode, oldNode) {
        const oldNodeHasDifferentId = $7b57b57eaf5a9648$export$25d27f17d3af40f7(oldNode) && rowNode.id !== oldNode.id;
        if (oldNodeHasDifferentId && oldNode) {
            const id = oldNode.id;
            const oldNodeSelected = this.selectedNodes.get(id) == rowNode;
            if (oldNodeSelected) this.selectedNodes.set(oldNode.id, oldNode);
        }
    }
    syncInNewRowNode(rowNode) {
        if (this.selectedNodes.has(rowNode.id)) {
            rowNode.setSelectedInitialValue(true);
            this.selectedNodes.set(rowNode.id, rowNode);
        } else rowNode.setSelectedInitialValue(false);
    }
    reset(source) {
        const selectionCount = this.getSelectionCount();
        this.resetNodes();
        if (selectionCount) this.dispatchSelectionChanged(source);
    }
    resetNodes() {
        this.selectedNodes?.clear();
    }
    // returns a list of all nodes at 'best cost' - a feature to be used
    // with groups / trees. if a group has all it's children selected,
    // then the group appears in the result, but not the children.
    // Designed for use with 'children' as the group selection type,
    // where groups don't actually appear in the selection normally.
    getBestCostNodeSelection() {
        if (this.rowModel.getType() !== "clientSide") return;
        const clientSideRowModel = this.rowModel;
        const topLevelNodes = clientSideRowModel.getTopLevelNodes();
        if (topLevelNodes === null) return;
        const result = [];
        function traverse(nodes) {
            for(let i = 0, l = nodes.length; i < l; i++){
                const node = nodes[i];
                if (node.isSelected()) result.push(node);
                else {
                    const maybeGroup = node;
                    if (maybeGroup.group && maybeGroup.children) traverse(maybeGroup.children);
                }
            }
        }
        traverse(topLevelNodes);
        return result;
    }
    isEmpty() {
        let count = 0;
        this.selectedNodes.forEach((rowNode)=>{
            if (rowNode) count++;
        });
        return count === 0;
    }
    deselectAllRowNodes(params) {
        const callback = (rowNode)=>rowNode.selectThisNode(false, void 0, source);
        const rowModelClientSide = this.rowModel.getType() === "clientSide";
        const { source: source , justFiltered: justFiltered , justCurrentPage: justCurrentPage  } = params;
        if (justCurrentPage || justFiltered) {
            if (!rowModelClientSide) {
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("selecting just filtered only works when gridOptions.rowModelType='clientSide'");
                return;
            }
            this.getNodesToSelect(justFiltered, justCurrentPage).forEach(callback);
        } else {
            this.selectedNodes.forEach((rowNode)=>{
                if (rowNode) callback(rowNode);
            });
            this.reset(source);
        }
        this.selectionCtx.reset();
        if (rowModelClientSide && this.groupSelectsChildren) this.updateGroupsFromChildrenSelections(source);
        this.dispatchSelectionChanged(source);
    }
    getSelectedCounts(justFiltered, justCurrentPage) {
        let selectedCount = 0;
        let notSelectedCount = 0;
        const callback = (node)=>{
            if (this.groupSelectsChildren && node.group) return;
            if (node.isSelected()) selectedCount++;
            else if (!node.selectable) ;
            else notSelectedCount++;
        };
        this.getNodesToSelect(justFiltered, justCurrentPage).forEach(callback);
        return {
            selectedCount: selectedCount,
            notSelectedCount: notSelectedCount
        };
    }
    getSelectAllState(justFiltered, justCurrentPage) {
        const { selectedCount: selectedCount , notSelectedCount: notSelectedCount  } = this.getSelectedCounts(justFiltered, justCurrentPage);
        if (selectedCount === 0 && notSelectedCount === 0) return false;
        if (selectedCount > 0 && notSelectedCount > 0) return null;
        return selectedCount > 0;
    }
    hasNodesToSelect(justFiltered = false, justCurrentPage = false) {
        return this.getNodesToSelect(justFiltered, justCurrentPage).filter((node)=>node.selectable).length > 0;
    }
    /**
   * @param justFiltered whether to just include nodes which have passed the filter
   * @param justCurrentPage whether to just include nodes on the current page
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */ getNodesToSelect(justFiltered = false, justCurrentPage = false) {
        if (this.rowModel.getType() !== "clientSide") throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
        const nodes = [];
        if (justCurrentPage) {
            this.forEachNodeOnPage((node)=>{
                if (!node.group) {
                    nodes.push(node);
                    return;
                }
                if (!node.expanded) {
                    const recursivelyAddChildren = (child)=>{
                        nodes.push(child);
                        if (child.childrenAfterFilter?.length) child.childrenAfterFilter.forEach(recursivelyAddChildren);
                    };
                    recursivelyAddChildren(node);
                    return;
                }
                if (!this.groupSelectsChildren) nodes.push(node);
            });
            return nodes;
        }
        const clientSideRowModel = this.rowModel;
        if (justFiltered) {
            clientSideRowModel.forEachNodeAfterFilter((node)=>{
                nodes.push(node);
            });
            return nodes;
        }
        clientSideRowModel.forEachNode((node)=>{
            nodes.push(node);
        });
        return nodes;
    }
    forEachNodeOnPage(callback) {
        const firstRow = this.pageBoundsService.getFirstRow();
        const lastRow = this.pageBoundsService.getLastRow();
        for(let i = firstRow; i <= lastRow; i++){
            const node = this.rowModel.getRow(i);
            if (node) callback(node);
        }
    }
    selectAllRowNodes(params) {
        if (this.rowModel.getType() !== "clientSide") throw new Error(`selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`);
        const { source: source , justFiltered: justFiltered , justCurrentPage: justCurrentPage  } = params;
        const nodes = this.getNodesToSelect(justFiltered, justCurrentPage);
        nodes.forEach((rowNode)=>rowNode.selectThisNode(true, void 0, source));
        this.selectionCtx.setRoot(nodes[0] ?? null);
        this.selectionCtx.setEndRange($7b57b57eaf5a9648$export$236389741107357f(nodes) ?? null);
        if (this.rowModel.getType() === "clientSide" && this.groupSelectsChildren) this.updateGroupsFromChildrenSelections(source);
        this.dispatchSelectionChanged(source);
    }
    getSelectionState() {
        const selectedIds = [];
        this.selectedNodes.forEach((node)=>{
            if (node?.id) selectedIds.push(node.id);
        });
        return selectedIds.length ? selectedIds : null;
    }
    setSelectionState(state, source) {
        if (!Array.isArray(state)) return;
        const rowIds = new Set(state);
        const nodes = [];
        this.rowModel.forEachNode((node)=>{
            if (rowIds.has(node.id)) nodes.push(node);
        });
        this.setNodesSelected({
            newValue: true,
            nodes: nodes,
            source: source
        });
    }
    dispatchSelectionChanged(source) {
        const event = {
            type: "selectionChanged",
            source: source
        };
        this.eventService.dispatchEvent(event);
    }
};
// community-modules/core/src/rowNodes/selectableService.ts
var $7b57b57eaf5a9648$export$75ae26c229338c6b = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "selectableService";
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.selectionService = beans.selectionService;
    }
    postConstruct() {
        this.addManagedPropertyListener("isRowSelectable", ()=>this.updateSelectable());
    }
    /**
   * Used by CSRM only, to update selectable state after group state changes.
   */ updateSelectableAfterGrouping() {
        this.updateSelectable(true);
    }
    updateSelectable(skipLeafNodes = false) {
        const isRowSelecting = !!this.gos.get("rowSelection");
        const isRowSelectable = this.gos.get("isRowSelectable");
        if (!isRowSelecting || !isRowSelectable) return;
        const isGroupSelectsChildren = this.gos.get("groupSelectsChildren");
        const isCsrmGroupSelectsChildren = this.rowModel.getType() === "clientSide" && isGroupSelectsChildren;
        const nodesToDeselect = [];
        const nodeCallback = (node)=>{
            if (skipLeafNodes && !node.group) return;
            if (isCsrmGroupSelectsChildren && node.group) {
                const hasSelectableChild = node.childrenAfterGroup.some((rowNode)=>rowNode.selectable === true);
                node.setRowSelectable(hasSelectableChild, true);
                return;
            }
            const rowSelectable = isRowSelectable ? isRowSelectable(node) : true;
            node.setRowSelectable(rowSelectable, true);
            if (!rowSelectable && node.isSelected()) nodesToDeselect.push(node);
        };
        if (isCsrmGroupSelectsChildren) {
            const csrm = this.rowModel;
            const changedPath = new $7b57b57eaf5a9648$export$cb4d9114a9732e85(false, csrm.getRootNode());
            changedPath.forEachChangedNodeDepthFirst(nodeCallback, true, true);
        } else this.rowModel.forEachNode(nodeCallback);
        if (nodesToDeselect.length) this.selectionService.setNodesSelected({
            nodes: nodesToDeselect,
            newValue: false,
            source: "selectableChanged"
        });
        if (isCsrmGroupSelectsChildren && this.selectionService instanceof $7b57b57eaf5a9648$var$SelectionService) this.selectionService.updateGroupsFromChildrenSelections("selectableChanged");
    }
};
// community-modules/core/src/sortController.ts
var $7b57b57eaf5a9648$var$DEFAULT_SORTING_ORDER = [
    "asc",
    "desc",
    null
];
var $7b57b57eaf5a9648$export$765594e5be71a851 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "sortController";
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.funcColsService = beans.funcColsService;
        this.showRowGroupColsService = beans.showRowGroupColsService;
    }
    progressSort(column, multiSort, source) {
        const nextDirection = this.getNextSortDirection(column);
        this.setSortForColumn(column, nextDirection, multiSort, source);
    }
    setSortForColumn(column, sort, multiSort, source) {
        if (sort !== "asc" && sort !== "desc") sort = null;
        const isColumnsSortingCoupledToGroup = this.gos.isColumnsSortingCoupledToGroup();
        let columnsToUpdate = [
            column
        ];
        if (isColumnsSortingCoupledToGroup) {
            if (column.getColDef().showRowGroup) {
                const rowGroupColumns = this.funcColsService.getSourceColumnsForGroupColumn(column);
                const sortableRowGroupColumns = rowGroupColumns?.filter((col)=>col.isSortable());
                if (sortableRowGroupColumns) columnsToUpdate = [
                    column,
                    ...sortableRowGroupColumns
                ];
            }
        }
        columnsToUpdate.forEach((col)=>col.setSort(sort, source));
        const doingMultiSort = (multiSort || this.gos.get("alwaysMultiSort")) && !this.gos.get("suppressMultiSort");
        const updatedColumns = [];
        if (!doingMultiSort) {
            const clearedColumns = this.clearSortBarTheseColumns(columnsToUpdate, source);
            updatedColumns.push(...clearedColumns);
        }
        this.updateSortIndex(column);
        updatedColumns.push(...columnsToUpdate);
        this.dispatchSortChangedEvents(source, updatedColumns);
    }
    updateSortIndex(lastColToChange) {
        const isCoupled = this.gos.isColumnsSortingCoupledToGroup();
        const groupParent = this.showRowGroupColsService?.getShowRowGroupCol(lastColToChange.getId());
        const lastSortIndexCol = isCoupled ? groupParent || lastColToChange : lastColToChange;
        const allSortedCols = this.getColumnsWithSortingOrdered();
        this.columnModel.getAllCols().forEach((col)=>col.setSortIndex(null));
        const allSortedColsWithoutChangesOrGroups = allSortedCols.filter((col)=>{
            if (isCoupled && col.getColDef().showRowGroup) return false;
            return col !== lastSortIndexCol;
        });
        const sortedColsWithIndices = lastSortIndexCol.getSort() ? [
            ...allSortedColsWithoutChangesOrGroups,
            lastSortIndexCol
        ] : allSortedColsWithoutChangesOrGroups;
        sortedColsWithIndices.forEach((col, idx)=>{
            col.setSortIndex(idx);
        });
    }
    // gets called by API, so if data changes, use can call this, which will end up
    // working out the sort order again of the rows.
    onSortChanged(source, columns) {
        this.dispatchSortChangedEvents(source, columns);
    }
    isSortActive() {
        const allCols = this.columnModel.getAllCols();
        const sortedCols = allCols.filter((column)=>!!column.getSort());
        return sortedCols && sortedCols.length > 0;
    }
    dispatchSortChangedEvents(source, columns) {
        const event = {
            type: "sortChanged",
            source: source
        };
        if (columns) event.columns = columns;
        this.eventService.dispatchEvent(event);
    }
    clearSortBarTheseColumns(columnsToSkip, source) {
        const clearedColumns = [];
        this.columnModel.getAllCols().forEach((columnToClear)=>{
            if (!columnsToSkip.includes(columnToClear)) {
                if (columnToClear.getSort()) clearedColumns.push(columnToClear);
                columnToClear.setSort(void 0, source);
            }
        });
        return clearedColumns;
    }
    getNextSortDirection(column) {
        let sortingOrder;
        if (column.getColDef().sortingOrder) sortingOrder = column.getColDef().sortingOrder;
        else if (this.gos.get("sortingOrder")) sortingOrder = this.gos.get("sortingOrder");
        else sortingOrder = $7b57b57eaf5a9648$var$DEFAULT_SORTING_ORDER;
        if (!Array.isArray(sortingOrder) || sortingOrder.length <= 0) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`sortingOrder must be an array with at least one element, currently it's ${sortingOrder}`);
            return null;
        }
        const currentIndex = sortingOrder.indexOf(column.getSort());
        const notInArray = currentIndex < 0;
        const lastItemInArray = currentIndex == sortingOrder.length - 1;
        let result;
        if (notInArray || lastItemInArray) result = sortingOrder[0];
        else result = sortingOrder[currentIndex + 1];
        if ($7b57b57eaf5a9648$var$DEFAULT_SORTING_ORDER.indexOf(result) < 0) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("invalid sort type ", result);
            return null;
        }
        return result;
    }
    /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */ getIndexedSortMap() {
        let allSortedCols = this.columnModel.getAllCols().filter((col)=>!!col.getSort());
        if (this.columnModel.isPivotMode()) {
            const isSortingLinked = this.gos.isColumnsSortingCoupledToGroup();
            allSortedCols = allSortedCols.filter((col)=>{
                const isAggregated = !!col.getAggFunc();
                const isSecondary = !col.isPrimary();
                const isGroup = isSortingLinked ? this.showRowGroupColsService?.getShowRowGroupCol(col.getId()) : col.getColDef().showRowGroup;
                return isAggregated || isSecondary || isGroup;
            });
        }
        const sortedRowGroupCols = this.funcColsService.getRowGroupColumns().filter((col)=>!!col.getSort());
        const allColsIndexes = {};
        allSortedCols.forEach((col, index)=>allColsIndexes[col.getId()] = index);
        allSortedCols.sort((a, b)=>{
            const iA = a.getSortIndex();
            const iB = b.getSortIndex();
            if (iA != null && iB != null) return iA - iB;
            else if (iA == null && iB == null) {
                const posA = allColsIndexes[a.getId()];
                const posB = allColsIndexes[b.getId()];
                return posA > posB ? 1 : -1;
            } else if (iB == null) return -1;
            else return 1;
        });
        const isSortLinked = this.gos.isColumnsSortingCoupledToGroup() && !!sortedRowGroupCols.length;
        if (isSortLinked) allSortedCols = [
            ...new Set(// if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
            allSortedCols.map((col)=>this.showRowGroupColsService?.getShowRowGroupCol(col.getId()) ?? col))
        ];
        const indexMap = /* @__PURE__ */ new Map();
        allSortedCols.forEach((col, idx)=>indexMap.set(col, idx));
        if (isSortLinked) sortedRowGroupCols.forEach((col)=>{
            const groupDisplayCol = this.showRowGroupColsService.getShowRowGroupCol(col.getId());
            indexMap.set(col, indexMap.get(groupDisplayCol));
        });
        return indexMap;
    }
    getColumnsWithSortingOrdered() {
        return [
            ...this.getIndexedSortMap().entries()
        ].sort(([col1, idx1], [col2, idx2])=>idx1 - idx2).map(([col])=>col);
    }
    // used by server side row models, to sent sort to server
    getSortModel() {
        return this.getColumnsWithSortingOrdered().filter((column)=>column.getSort()).map((column)=>({
                sort: column.getSort(),
                colId: column.getId()
            }));
    }
    getSortOptions() {
        return this.getColumnsWithSortingOrdered().filter((column)=>column.getSort()).map((column)=>({
                sort: column.getSort(),
                column: column
            }));
    }
    canColumnDisplayMixedSort(column) {
        const isColumnSortCouplingActive = this.gos.isColumnsSortingCoupledToGroup();
        const isGroupDisplayColumn = !!column.getColDef().showRowGroup;
        return isColumnSortCouplingActive && isGroupDisplayColumn;
    }
    getDisplaySortForColumn(column) {
        const linkedColumns = this.funcColsService.getSourceColumnsForGroupColumn(column);
        if (!this.canColumnDisplayMixedSort(column) || !linkedColumns?.length) return column.getSort();
        const columnHasUniqueData = column.getColDef().field != null || !!column.getColDef().valueGetter;
        const sortableColumns = columnHasUniqueData ? [
            column,
            ...linkedColumns
        ] : linkedColumns;
        const firstSort = sortableColumns[0].getSort();
        const allMatch = sortableColumns.every((col)=>col.getSort() == firstSort);
        if (!allMatch) return "mixed";
        return firstSort;
    }
    getDisplaySortIndexForColumn(column) {
        return this.getIndexedSortMap().get(column);
    }
};
// community-modules/core/src/syncService.ts
var $7b57b57eaf5a9648$var$SyncService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "syncService";
        this.waitingForColumns = false;
    }
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
        this.columnModel = beans.columnModel;
        this.rowModel = beans.rowModel;
    }
    postConstruct() {
        this.addManagedPropertyListener("columnDefs", (event)=>this.setColumnDefs(event));
    }
    start() {
        this.ctrlsService.whenReady(()=>{
            const columnDefs = this.gos.get("columnDefs");
            if (columnDefs) this.setColumnsAndData(columnDefs);
            else this.waitingForColumns = true;
            this.gridReady();
        });
    }
    setColumnsAndData(columnDefs) {
        this.columnModel.setColumnDefs(columnDefs ?? [], "gridInitializing");
        this.rowModel.start();
    }
    gridReady() {
        this.dispatchGridReadyEvent();
        const isEnterprise = $7b57b57eaf5a9648$export$dc053975cc7f6c11.__isRegistered("@ag-grid-enterprise/core" /* EnterpriseCoreModule */ , this.gridId);
        if (this.gos.get("debug")) $7b57b57eaf5a9648$export$1ce471ee7a8b4d23(`initialised successfully, enterprise = ${isEnterprise}`);
    }
    dispatchGridReadyEvent() {
        const readyEvent = {
            type: "gridReady"
        };
        this.eventService.dispatchEvent(readyEvent);
    }
    setColumnDefs(event) {
        const columnDefs = this.gos.get("columnDefs");
        if (!columnDefs) return;
        if (this.waitingForColumns) {
            this.waitingForColumns = false;
            this.setColumnsAndData(columnDefs);
            return;
        }
        this.columnModel.setColumnDefs(columnDefs, $7b57b57eaf5a9648$var$convertSourceType(event.source));
    }
};
// community-modules/core/src/valueService/changeDetectionService.ts
var $7b57b57eaf5a9648$var$SOURCE_PASTE = "paste";
var $7b57b57eaf5a9648$var$ChangeDetectionService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "changeDetectionService";
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.rowRenderer = beans.rowRenderer;
    }
    postConstruct() {
        if (this.rowModel.getType() === "clientSide") this.clientSideRowModel = this.rowModel;
        this.addManagedEventListeners({
            cellValueChanged: this.onCellValueChanged.bind(this)
        });
    }
    onCellValueChanged(event) {
        if (event.source === $7b57b57eaf5a9648$var$SOURCE_PASTE) return;
        this.doChangeDetection(event.node, event.column);
    }
    doChangeDetection(rowNode, column) {
        if (this.gos.get("suppressChangeDetection")) return;
        const nodesToRefresh = [
            rowNode
        ];
        if (this.clientSideRowModel && !rowNode.isRowPinned()) {
            const onlyChangedColumns = this.gos.get("aggregateOnlyChangedColumns");
            const changedPath = new $7b57b57eaf5a9648$export$cb4d9114a9732e85(onlyChangedColumns, this.clientSideRowModel.getRootNode());
            changedPath.addParentNode(rowNode.parent, [
                column
            ]);
            this.clientSideRowModel.doAggregate(changedPath);
            changedPath.forEachChangedNodeDepthFirst((rowNode2)=>{
                nodesToRefresh.push(rowNode2);
            });
        }
        this.rowRenderer.refreshCells({
            rowNodes: nodesToRefresh
        });
    }
};
// community-modules/core/src/valueService/expressionService.ts
var $7b57b57eaf5a9648$export$4ce5344b7d88a0e2 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "expressionService";
        this.expressionToFunctionCache = {};
    }
    evaluate(expression, params) {
        if (typeof expression === "string") return this.evaluateExpression(expression, params);
        else $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("value should be either a string or a function", expression);
    }
    evaluateExpression(expression, params) {
        try {
            const javaScriptFunction = this.createExpressionFunction(expression);
            const result = javaScriptFunction(params.value, params.context, params.oldValue, params.newValue, params.value, params.node, params.data, params.colDef, params.rowIndex, params.api, params.getValue, params.column, params.columnGroup);
            return result;
        } catch (e) {
            $7b57b57eaf5a9648$export$1ce471ee7a8b4d23("Processing of the expression failed");
            $7b57b57eaf5a9648$export$1ce471ee7a8b4d23("Expression = ", expression);
            $7b57b57eaf5a9648$export$1ce471ee7a8b4d23("Params = ", params);
            $7b57b57eaf5a9648$export$1ce471ee7a8b4d23("Exception = ", e);
            return null;
        }
    }
    createExpressionFunction(expression) {
        if (this.expressionToFunctionCache[expression]) return this.expressionToFunctionCache[expression];
        const functionBody = this.createFunctionBody(expression);
        const theFunction = new Function("x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup", functionBody);
        this.expressionToFunctionCache[expression] = theFunction;
        return theFunction;
    }
    createFunctionBody(expression) {
        if (expression.indexOf("return") >= 0) return expression;
        else return "return " + expression + ";";
    }
};
// community-modules/core/src/valueService/valueCache.ts
var $7b57b57eaf5a9648$export$8bb85f19590498f6 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "valueCache";
        this.cacheVersion = 0;
    }
    postConstruct() {
        this.active = this.gos.get("valueCache");
        this.neverExpires = this.gos.get("valueCacheNeverExpires");
    }
    onDataChanged() {
        if (this.neverExpires) return;
        this.expire();
    }
    expire() {
        this.cacheVersion++;
    }
    setValue(rowNode, colId, value) {
        if (this.active) {
            if (rowNode.__cacheVersion !== this.cacheVersion) {
                rowNode.__cacheVersion = this.cacheVersion;
                rowNode.__cacheData = {};
            }
            rowNode.__cacheData[colId] = value;
        }
    }
    getValue(rowNode, colId) {
        if (!this.active || rowNode.__cacheVersion !== this.cacheVersion) return void 0;
        return rowNode.__cacheData[colId];
    }
};
// community-modules/core/src/valueService/valueService.ts
var $7b57b57eaf5a9648$export$c52638093d9fc6a3 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "valueService";
        this.initialised = false;
        this.isSsrm = false;
    }
    wireBeans(beans) {
        this.expressionService = beans.expressionService;
        this.columnModel = beans.columnModel;
        this.valueCache = beans.valueCache;
        this.dataTypeService = beans.dataTypeService;
    }
    postConstruct() {
        if (!this.initialised) this.init();
    }
    init() {
        this.isSsrm = this.gos.isRowModelType("serverSide");
        this.cellExpressions = this.gos.get("enableCellExpressions");
        this.isTreeData = this.gos.get("treeData");
        this.initialised = true;
        const listener = (event)=>this.callColumnCellValueChangedHandler(event);
        const async = this.gos.useAsyncEvents();
        this.eventService.addEventListener("cellValueChanged", listener, async);
        this.addDestroyFunc(()=>this.eventService.removeEventListener("cellValueChanged", listener, async));
        this.addManagedPropertyListener("treeData", (propChange)=>this.isTreeData = propChange.currentValue);
    }
    getValue(column, rowNode, forFilter = false, ignoreAggData = false) {
        if (!this.initialised) this.init();
        if (!rowNode) return;
        const colDef = column.getColDef();
        const field = colDef.field;
        const colId = column.getColId();
        const data = rowNode.data;
        let result;
        const groupDataExists = rowNode.groupData && rowNode.groupData[colId] !== void 0;
        const aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== void 0;
        const ignoreSsrmAggData = this.isSsrm && ignoreAggData && !!column.getColDef().aggFunc;
        const ssrmFooterGroupCol = this.isSsrm && rowNode.footer && rowNode.field && (column.getColDef().showRowGroup === true || column.getColDef().showRowGroup === rowNode.field);
        if (forFilter && colDef.filterValueGetter) result = this.executeFilterValueGetter(colDef.filterValueGetter, data, column, rowNode);
        else if (this.isTreeData && aggDataExists) result = rowNode.aggData[colId];
        else if (this.isTreeData && colDef.valueGetter) result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
        else if (this.isTreeData && field && data) result = $7b57b57eaf5a9648$var$_getValueUsingField(data, field, column.isFieldContainsDots());
        else if (groupDataExists) result = rowNode.groupData[colId];
        else if (aggDataExists) result = rowNode.aggData[colId];
        else if (colDef.valueGetter) result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
        else if (ssrmFooterGroupCol) result = $7b57b57eaf5a9648$var$_getValueUsingField(data, rowNode.field, column.isFieldContainsDots());
        else if (field && data && !ignoreSsrmAggData) result = $7b57b57eaf5a9648$var$_getValueUsingField(data, field, column.isFieldContainsDots());
        if (this.cellExpressions && typeof result === "string" && result.indexOf("=") === 0) {
            const cellValueGetter = result.substring(1);
            result = this.executeValueGetter(cellValueGetter, data, column, rowNode);
        }
        if (result == null) {
            const openedGroup = this.getOpenedGroup(rowNode, column);
            if (openedGroup != null) return openedGroup;
        }
        return result;
    }
    parseValue(column, rowNode, newValue, oldValue) {
        const colDef = column.getColDef();
        const params = this.gos.addGridCommonParams({
            node: rowNode,
            data: rowNode?.data,
            oldValue: oldValue,
            newValue: newValue,
            colDef: colDef,
            column: column
        });
        const valueParser = colDef.valueParser;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(valueParser)) {
            if (typeof valueParser === "function") return valueParser(params);
            return this.expressionService.evaluate(valueParser, params);
        }
        return newValue;
    }
    formatValue(column, node, value, suppliedFormatter, useFormatterFromColumn = true) {
        let result = null;
        let formatter;
        const colDef = column.getColDef();
        if (suppliedFormatter) formatter = suppliedFormatter;
        else if (useFormatterFromColumn) formatter = colDef.valueFormatter;
        if (formatter) {
            const params = this.gos.addGridCommonParams({
                value: value,
                node: node,
                data: node ? node.data : null,
                colDef: colDef,
                column: column
            });
            if (typeof formatter === "function") result = formatter(params);
            else result = this.expressionService.evaluate(formatter, params);
        } else if (colDef.refData) return colDef.refData[value] || "";
        if (result == null && Array.isArray(value)) result = value.join(", ");
        return result;
    }
    getOpenedGroup(rowNode, column) {
        if (!this.gos.get("showOpenedGroup")) return;
        const colDef = column.getColDef();
        if (!colDef.showRowGroup) return;
        const showRowGroup = column.getColDef().showRowGroup;
        let pointer = rowNode.parent;
        while(pointer != null){
            if (pointer.rowGroupColumn && (showRowGroup === true || showRowGroup === pointer.rowGroupColumn.getColId())) return pointer.key;
            pointer = pointer.parent;
        }
        return void 0;
    }
    /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */ setValue(rowNode, colKey, newValue, eventSource) {
        const column = this.columnModel.getColDefCol(colKey);
        if (!rowNode || !column) return false;
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(rowNode.data)) rowNode.data = {};
        const { field: field , valueSetter: valueSetter  } = column.getColDef();
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(field) && $7b57b57eaf5a9648$export$672d9e47bc342bac(valueSetter)) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`you need either field or valueSetter set on colDef for editing to work`);
            return false;
        }
        if (this.dataTypeService && !this.dataTypeService.checkType(column, newValue)) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`Data type of the new value does not match the cell data type of the column`);
            return false;
        }
        const params = this.gos.addGridCommonParams({
            node: rowNode,
            data: rowNode.data,
            oldValue: this.getValue(column, rowNode),
            newValue: newValue,
            colDef: column.getColDef(),
            column: column
        });
        params.newValue = newValue;
        let valueWasDifferent;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(valueSetter)) {
            if (typeof valueSetter === "function") valueWasDifferent = valueSetter(params);
            else valueWasDifferent = this.expressionService.evaluate(valueSetter, params);
        } else valueWasDifferent = this.setValueUsingField(rowNode.data, field, newValue, column.isFieldContainsDots());
        if (valueWasDifferent === void 0) valueWasDifferent = true;
        if (!valueWasDifferent) return false;
        rowNode.resetQuickFilterAggregateText();
        this.valueCache.onDataChanged();
        params.newValue = this.getValue(column, rowNode);
        const event = {
            type: "cellValueChanged",
            event: null,
            rowIndex: rowNode.rowIndex,
            rowPinned: rowNode.rowPinned,
            column: params.column,
            api: params.api,
            colDef: params.colDef,
            context: params.context,
            data: rowNode.data,
            node: rowNode,
            oldValue: params.oldValue,
            newValue: params.newValue,
            value: params.newValue,
            source: eventSource
        };
        this.eventService.dispatchEvent(event);
        return true;
    }
    callColumnCellValueChangedHandler(event) {
        const onCellValueChanged = event.colDef.onCellValueChanged;
        if (typeof onCellValueChanged === "function") this.getFrameworkOverrides().wrapOutgoing(()=>{
            onCellValueChanged({
                node: event.node,
                data: event.data,
                oldValue: event.oldValue,
                newValue: event.newValue,
                colDef: event.colDef,
                column: event.column,
                api: event.api,
                context: event.context
            });
        });
    }
    setValueUsingField(data, field, newValue, isFieldContainsDots) {
        if (!field) return false;
        let valuesAreSame = false;
        if (!isFieldContainsDots) {
            valuesAreSame = data[field] === newValue;
            if (!valuesAreSame) data[field] = newValue;
        } else {
            const fieldPieces = field.split(".");
            let currentObject = data;
            while(fieldPieces.length > 0 && currentObject){
                const fieldPiece = fieldPieces.shift();
                if (fieldPieces.length === 0) {
                    valuesAreSame = currentObject[fieldPiece] === newValue;
                    if (!valuesAreSame) currentObject[fieldPiece] = newValue;
                } else currentObject = currentObject[fieldPiece];
            }
        }
        return !valuesAreSame;
    }
    executeFilterValueGetter(valueGetter, data, column, rowNode) {
        const params = this.gos.addGridCommonParams({
            data: data,
            node: rowNode,
            column: column,
            colDef: column.getColDef(),
            getValue: this.getValueCallback.bind(this, rowNode)
        });
        if (typeof valueGetter === "function") return valueGetter(params);
        return this.expressionService.evaluate(valueGetter, params);
    }
    executeValueGetter(valueGetter, data, column, rowNode) {
        const colId = column.getColId();
        const valueFromCache = this.valueCache.getValue(rowNode, colId);
        if (valueFromCache !== void 0) return valueFromCache;
        const params = this.gos.addGridCommonParams({
            data: data,
            node: rowNode,
            column: column,
            colDef: column.getColDef(),
            getValue: this.getValueCallback.bind(this, rowNode)
        });
        let result;
        if (typeof valueGetter === "function") result = valueGetter(params);
        else result = this.expressionService.evaluate(valueGetter, params);
        this.valueCache.setValue(rowNode, colId, result);
        return result;
    }
    getValueCallback(node, field) {
        const otherColumn = this.columnModel.getColDefCol(field);
        if (otherColumn) return this.getValue(otherColumn, node);
        return null;
    }
    // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
    getKeyForNode(col, rowNode) {
        const value = this.getValue(col, rowNode);
        const keyCreator = col.getColDef().keyCreator;
        let result = value;
        if (keyCreator) {
            const keyParams = this.gos.addGridCommonParams({
                value: value,
                colDef: col.getColDef(),
                column: col,
                node: rowNode,
                data: rowNode.data
            });
            result = keyCreator(keyParams);
        }
        if (typeof result === "string" || result == null) return result;
        result = String(result);
        if (result === "[object Object]") $7b57b57eaf5a9648$export$2cf41453020eef66("a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key");
        return result;
    }
};
// community-modules/core/src/grid.ts
var $7b57b57eaf5a9648$var$GlobalGridOptions = class {
};
$7b57b57eaf5a9648$var$GlobalGridOptions.gridOptions = void 0;
function $7b57b57eaf5a9648$export$9def8154c643bfd1(gridOptions) {
    $7b57b57eaf5a9648$var$GlobalGridOptions.gridOptions = gridOptions;
}
function $7b57b57eaf5a9648$export$fce123c48a7b4eae(eGridDiv, gridOptions, params) {
    if (!gridOptions) {
        $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("No gridOptions provided to createGrid");
        return {};
    }
    const api = new $7b57b57eaf5a9648$export$7759b93c6200a2f9().create(eGridDiv, gridOptions, (context)=>{
        const gridComp = new $7b57b57eaf5a9648$export$f29859a2c0c53119(eGridDiv);
        context.createBean(gridComp);
    }, void 0, params);
    if (!Object.isFrozen(gridOptions) && !params?.frameworkOverrides) {
        const apiUrl = "https://ag-grid.com/javascript-data-grid/grid-interface/#grid-api";
        Object.defineProperty(gridOptions, "api", {
            get: ()=>{
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`gridOptions.api is no longer supported. See ${apiUrl}.`);
                return void 0;
            },
            configurable: true
        });
    }
    return api;
}
var $7b57b57eaf5a9648$export$ef2184bd89960b14 = class {
    // Not typed to enable setting api for backwards compatibility
    constructor(eGridDiv, gridOptions, params){
        $7b57b57eaf5a9648$export$2cf41453020eef66("Since v31 new Grid(...) is deprecated. Use createGrid instead: `const gridApi = createGrid(...)`. The grid api is returned from createGrid and will not be available on gridOptions.");
        if (!gridOptions) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("No gridOptions provided to the grid");
            return;
        }
        this.gridOptions = gridOptions;
        const api = new $7b57b57eaf5a9648$export$7759b93c6200a2f9().create(eGridDiv, gridOptions, (context)=>{
            const gridComp = new $7b57b57eaf5a9648$export$f29859a2c0c53119(eGridDiv);
            const bean = context.createBean(gridComp);
            bean.addDestroyFunc(()=>{
                this.destroy();
            });
        }, void 0, params);
        this.gridOptions.api = api;
    }
    destroy() {
        if (this.gridOptions) {
            this.gridOptions.api?.destroy();
            delete this.gridOptions.api;
        }
    }
};
var $7b57b57eaf5a9648$var$nextGridId = 1;
var $7b57b57eaf5a9648$export$7759b93c6200a2f9 = class {
    create(eGridDiv, providedOptions, createUi, acceptChanges, params) {
        let mergedGridOps = {};
        if ($7b57b57eaf5a9648$var$GlobalGridOptions.gridOptions) {
            $7b57b57eaf5a9648$export$8ade6bd474fcde42(mergedGridOps, $7b57b57eaf5a9648$var$GlobalGridOptions.gridOptions, true, true);
            mergedGridOps = {
                ...mergedGridOps,
                ...providedOptions
            };
        } else mergedGridOps = providedOptions;
        const gridOptions = $7b57b57eaf5a9648$var$getCoercedGridOptions(mergedGridOps);
        const gridId = gridOptions.gridId ?? String($7b57b57eaf5a9648$var$nextGridId++);
        const registeredModules = this.getRegisteredModules(params, gridId);
        const beanClasses = this.createBeansList(gridOptions.rowModelType, registeredModules, gridId);
        const providedBeanInstances = this.createProvidedBeans(eGridDiv, gridOptions, params);
        if (!beanClasses) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("Failed to create grid.");
            return void 0;
        }
        const contextParams = {
            providedBeanInstances: providedBeanInstances,
            beanClasses: beanClasses,
            gridId: gridId,
            beanInitComparator: $7b57b57eaf5a9648$var$gridBeanInitComparator,
            beanDestroyComparator: $7b57b57eaf5a9648$var$gridBeanDestroyComparator,
            derivedBeans: [
                $7b57b57eaf5a9648$var$createApiProxy
            ]
        };
        const context = new $7b57b57eaf5a9648$export$841858b892ce1f4c(contextParams);
        this.registerModuleUserComponents(context, registeredModules);
        this.registerControllers(context, registeredModules);
        this.registerModuleApiFunctions(context, registeredModules);
        createUi(context);
        context.getBean("syncService").start();
        if (acceptChanges) acceptChanges(context);
        return context.getBean("gridApi");
    }
    registerControllers(context, registeredModules) {
        const factory = context.getBean("ctrlsFactory");
        registeredModules.forEach((module)=>{
            if (module.controllers) module.controllers.forEach((meta)=>factory.register(meta));
        });
    }
    getRegisteredModules(params, gridId) {
        const passedViaConstructor = params ? params.modules : null;
        const registered = $7b57b57eaf5a9648$export$dc053975cc7f6c11.__getRegisteredModules(gridId);
        const allModules = [];
        const mapNames = {};
        const addModule = (moduleBased, mod, gridId2)=>{
            const addIndividualModule = (currentModule)=>{
                if (!mapNames[currentModule.moduleName]) {
                    mapNames[currentModule.moduleName] = true;
                    allModules.push(currentModule);
                    $7b57b57eaf5a9648$export$dc053975cc7f6c11.__register(currentModule, moduleBased, gridId2);
                }
            };
            addIndividualModule(mod);
            if (mod.dependantModules) mod.dependantModules.forEach((m)=>addModule(moduleBased, m, gridId2));
        };
        addModule(!!passedViaConstructor?.length || !$7b57b57eaf5a9648$export$dc053975cc7f6c11.__isPackageBased(), $7b57b57eaf5a9648$export$e7c66fbb2b880e54, void 0);
        if (passedViaConstructor) passedViaConstructor.forEach((m)=>addModule(true, m, gridId));
        if (registered) registered.forEach((m)=>addModule(!$7b57b57eaf5a9648$export$dc053975cc7f6c11.__isPackageBased(), m, void 0));
        return allModules;
    }
    registerModuleUserComponents(context, registeredModules) {
        const moduleUserComps = this.extractModuleEntity(registeredModules, (module)=>module.userComponents ? module.userComponents : []);
        const registry = context.getBean("userComponentRegistry");
        moduleUserComps.forEach((compMeta)=>{
            registry.registerDefaultComponent(compMeta.name, compMeta.classImp);
        });
    }
    registerModuleApiFunctions(context, registeredModules) {
        const apiFunctionService = context.getBean("apiFunctionService");
        registeredModules.forEach((module)=>{
            const apiFunctions = module.apiFunctions ?? {};
            const names = Object.keys(apiFunctions);
            names.forEach((name)=>{
                apiFunctionService?.addFunction(name, apiFunctions[name]);
            });
        });
    }
    createProvidedBeans(eGridDiv, gridOptions, params) {
        let frameworkOverrides = params ? params.frameworkOverrides : null;
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(frameworkOverrides)) frameworkOverrides = new $7b57b57eaf5a9648$export$8174ad74937c6482();
        const seed = {
            gridOptions: gridOptions,
            eGridDiv: eGridDiv,
            globalEventListener: params ? params.globalEventListener : null,
            globalSyncEventListener: params ? params.globalSyncEventListener : null,
            frameworkOverrides: frameworkOverrides
        };
        if (params && params.providedBeanInstances) Object.assign(seed, params.providedBeanInstances);
        return seed;
    }
    createBeansList(rowModelType = "clientSide", registeredModules, gridId) {
        const rowModelModules = registeredModules.filter((module)=>!module.rowModel || module.rowModel === rowModelType);
        const rowModelModuleNames = {
            clientSide: "@ag-grid-community/client-side-row-model" /* ClientSideRowModelModule */ ,
            infinite: "@ag-grid-community/infinite-row-model" /* InfiniteRowModelModule */ ,
            serverSide: "@ag-grid-enterprise/server-side-row-model" /* ServerSideRowModelModule */ ,
            viewport: "@ag-grid-enterprise/viewport-row-model" /* ViewportRowModelModule */ 
        };
        if (!rowModelModuleNames[rowModelType]) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("Could not find row model for rowModelType = ", rowModelType);
            return;
        }
        if (!$7b57b57eaf5a9648$export$dc053975cc7f6c11.__assertRegistered(rowModelModuleNames[rowModelType], `rowModelType = '${rowModelType}'`, gridId)) return;
        const beans = [
            $7b57b57eaf5a9648$export$27e6ff2feb462d0f,
            $7b57b57eaf5a9648$export$d4b97c43369f9635,
            $7b57b57eaf5a9648$export$4dfb519ecc588412,
            $7b57b57eaf5a9648$var$GridDestroyService,
            $7b57b57eaf5a9648$var$ApiFunctionService,
            $7b57b57eaf5a9648$export$84607ca0a5de10d3,
            $7b57b57eaf5a9648$var$AgComponentUtils,
            $7b57b57eaf5a9648$var$ComponentMetadataProvider,
            $7b57b57eaf5a9648$export$c3ae9ac02599b50f,
            $7b57b57eaf5a9648$export$b32ef18681c5348a,
            $7b57b57eaf5a9648$var$RowContainerHeightService,
            $7b57b57eaf5a9648$export$8c88ee8741066b8b,
            $7b57b57eaf5a9648$export$f325e19d05d9c36d,
            $7b57b57eaf5a9648$export$d44126a5f53c99d9,
            $7b57b57eaf5a9648$export$590729638d17528a,
            $7b57b57eaf5a9648$export$c550a8370fd215d9,
            $7b57b57eaf5a9648$export$895d7dc49f082ca1,
            $7b57b57eaf5a9648$export$4e35ad424d98ee6,
            $7b57b57eaf5a9648$export$27497a369f7303c1,
            $7b57b57eaf5a9648$var$SelectionService,
            $7b57b57eaf5a9648$export$c9dec256e4c9f340,
            $7b57b57eaf5a9648$export$ee63d8b4f36fee20,
            $7b57b57eaf5a9648$var$PageBoundsService,
            $7b57b57eaf5a9648$var$PageBoundsListener,
            $7b57b57eaf5a9648$export$a41edaea3b7c09c8,
            $7b57b57eaf5a9648$export$4ce5344b7d88a0e2,
            $7b57b57eaf5a9648$export$a988f568cf9d5725,
            $7b57b57eaf5a9648$export$2a4aa3d46d9c7613,
            $7b57b57eaf5a9648$export$8bb85f19590498f6,
            $7b57b57eaf5a9648$export$c52638093d9fc6a3,
            $7b57b57eaf5a9648$export$cc129c761c9af6b5,
            $7b57b57eaf5a9648$export$ddca88023f936464,
            $7b57b57eaf5a9648$export$3529111922becfa6,
            $7b57b57eaf5a9648$export$a48e931b7fcc2862,
            $7b57b57eaf5a9648$export$2e403e146bc377e1,
            $7b57b57eaf5a9648$export$7dc6752a22ab011a,
            $7b57b57eaf5a9648$export$672e779a12850b13,
            $7b57b57eaf5a9648$export$cf53ce5e31dacc9f,
            $7b57b57eaf5a9648$export$eca0fad328f0291c,
            $7b57b57eaf5a9648$export$765594e5be71a851,
            $7b57b57eaf5a9648$var$ColumnHoverService,
            $7b57b57eaf5a9648$var$ColumnAnimationService,
            $7b57b57eaf5a9648$export$75ae26c229338c6b,
            $7b57b57eaf5a9648$var$ChangeDetectionService,
            $7b57b57eaf5a9648$export$2963e6121f7c3146,
            $7b57b57eaf5a9648$var$ColumnDefFactory,
            $7b57b57eaf5a9648$var$RowCssClassCalculator,
            $7b57b57eaf5a9648$export$5cc6416c85df0cc5,
            $7b57b57eaf5a9648$export$1ec35376f0ed6145,
            $7b57b57eaf5a9648$var$PinnedWidthService,
            $7b57b57eaf5a9648$var$RowNodeEventThrottle,
            $7b57b57eaf5a9648$var$CtrlsFactory,
            $7b57b57eaf5a9648$var$SyncService,
            $7b57b57eaf5a9648$var$OverlayService,
            $7b57b57eaf5a9648$export$609b78da5e2f116c,
            $7b57b57eaf5a9648$var$ApiEventService,
            $7b57b57eaf5a9648$export$cdc69977f394dec1,
            $7b57b57eaf5a9648$export$ec78627b94a587e2,
            $7b57b57eaf5a9648$export$1e2d44020d94a6d1,
            $7b57b57eaf5a9648$var$ColumnEventDispatcher,
            $7b57b57eaf5a9648$export$2690662948863ae3,
            $7b57b57eaf5a9648$export$2c779e47c90a0605,
            $7b57b57eaf5a9648$var$ColumnGetStateService,
            $7b57b57eaf5a9648$var$ColumnGroupStateService,
            $7b57b57eaf5a9648$export$7ca43c2c3fd3ccb4,
            $7b57b57eaf5a9648$export$5d8918e6b11a0531,
            $7b57b57eaf5a9648$export$a71857df571f7d7d,
            $7b57b57eaf5a9648$var$ColumnViewportService,
            $7b57b57eaf5a9648$export$2ac7359cc75159ed
        ];
        const moduleBeans = this.extractModuleEntity(rowModelModules, (module)=>module.beans ? module.beans : []);
        beans.push(...moduleBeans);
        const beansNoDuplicates = [];
        beans.forEach((bean)=>{
            if (beansNoDuplicates.indexOf(bean) < 0) beansNoDuplicates.push(bean);
        });
        return beansNoDuplicates;
    }
    extractModuleEntity(moduleEntities, extractor) {
        return [].concat(...moduleEntities.map(extractor));
    }
};
// community-modules/core/src/api/rowModelHelperService.ts
var $7b57b57eaf5a9648$export$d00661386d616044 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowModelHelperService";
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
    }
    postConstruct() {
        const rowModel = this.rowModel;
        switch(rowModel.getType()){
            case "clientSide":
                this.clientSideRowModel = rowModel;
                break;
            case "infinite":
                this.infiniteRowModel = rowModel;
                break;
            case "serverSide":
                this.serverSideRowModel = rowModel;
                break;
        }
    }
    getClientSideRowModel() {
        return this.clientSideRowModel;
    }
    getInfiniteRowModel() {
        return this.infiniteRowModel;
    }
    getServerSideRowModel() {
        return this.serverSideRowModel;
    }
};
// community-modules/core/src/api/csrmSsrmSharedApi.ts
function $7b57b57eaf5a9648$var$expandAll(beans) {
    beans.expansionService.expandAll(true);
}
function $7b57b57eaf5a9648$var$collapseAll(beans) {
    beans.expansionService.expandAll(false);
}
function $7b57b57eaf5a9648$var$onRowHeightChanged(beans) {
    const clientSideRowModel = beans.rowModelHelperService?.getClientSideRowModel();
    const serverSideRowModel = beans.rowModelHelperService?.getServerSideRowModel();
    if (clientSideRowModel) clientSideRowModel.onRowHeightChanged();
    else if (serverSideRowModel) serverSideRowModel.onRowHeightChanged();
}
// community-modules/core/src/api/ssrmInfiniteSharedApi.ts
function $7b57b57eaf5a9648$var$setRowCount(beans, rowCount, maxRowFound) {
    const serverSideRowModel = beans.rowModelHelperService?.getServerSideRowModel();
    if (serverSideRowModel) {
        if (beans.funcColsService.isRowGroupEmpty()) {
            serverSideRowModel.setRowCount(rowCount, maxRowFound);
            return;
        }
        $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("setRowCount cannot be used while using row grouping.");
        return;
    }
    const infiniteRowModel = beans.rowModelHelperService?.getInfiniteRowModel();
    if (infiniteRowModel) {
        infiniteRowModel.setRowCount(rowCount, maxRowFound);
        return;
    }
}
function $7b57b57eaf5a9648$var$getCacheBlockState(beans) {
    return beans.rowNodeBlockLoader?.getBlockState() ?? {};
}
// community-modules/core/src/api/sharedApiModule.ts
var $7b57b57eaf5a9648$export$76fb120d9e251426 = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/csrm-ssrm-shared-api",
    apiFunctions: {
        expandAll: $7b57b57eaf5a9648$var$expandAll,
        collapseAll: $7b57b57eaf5a9648$var$collapseAll,
        onRowHeightChanged: $7b57b57eaf5a9648$var$onRowHeightChanged
    }
};
var $7b57b57eaf5a9648$export$2f6740e35dedc261 = {
    version: $7b57b57eaf5a9648$var$VERSION,
    moduleName: "@ag-grid-community/ssrm-infinite-shared-api",
    apiFunctions: {
        setRowCount: $7b57b57eaf5a9648$var$setRowCount,
        getCacheBlockState: $7b57b57eaf5a9648$var$getCacheBlockState
    }
};
// community-modules/core/src/components/framework/frameworkComponentWrapper.ts
var $7b57b57eaf5a9648$export$157f014d661b6f19 = class {
    wrap(OriginalConstructor, mandatoryMethodList, optionalMethodList = [], componentType) {
        const wrapper = this.createWrapper(OriginalConstructor, componentType);
        mandatoryMethodList.forEach((methodName)=>{
            this.createMethod(wrapper, methodName, true);
        });
        optionalMethodList.forEach((methodName)=>{
            this.createMethod(wrapper, methodName, false);
        });
        return wrapper;
    }
    unwrap(comp) {
        return comp;
    }
    createMethod(wrapper, methodName, mandatory) {
        wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));
    }
    createMethodProxy(wrapper, methodName, mandatory) {
        return function() {
            if (wrapper.hasMethod(methodName)) return wrapper.callMethod(methodName, arguments);
            if (mandatory) $7b57b57eaf5a9648$export$2cf41453020eef66("Framework component is missing the method " + methodName + "()");
            return null;
        };
    }
};
// community-modules/core/src/utils/rowNode.ts
function $7b57b57eaf5a9648$export$3c29aeb06dfacfc(rowNodes, rowNodeOrder) {
    if (!rowNodes) return false;
    const comparator = (nodeA, nodeB)=>{
        const positionA = rowNodeOrder[nodeA.id];
        const positionB = rowNodeOrder[nodeB.id];
        const aHasIndex = positionA !== void 0;
        const bHasIndex = positionB !== void 0;
        const bothNodesAreUserNodes = aHasIndex && bHasIndex;
        const bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;
        if (bothNodesAreUserNodes) return positionA - positionB;
        if (bothNodesAreFillerNodes) return nodeA.__objectId - nodeB.__objectId;
        if (aHasIndex) return 1;
        return -1;
    };
    let rowNodeA;
    let rowNodeB;
    let atLeastOneOutOfOrder = false;
    for(let i = 0; i < rowNodes.length - 1; i++){
        rowNodeA = rowNodes[i];
        rowNodeB = rowNodes[i + 1];
        if (comparator(rowNodeA, rowNodeB) > 0) {
            atLeastOneOutOfOrder = true;
            break;
        }
    }
    if (atLeastOneOutOfOrder) {
        rowNodes.sort(comparator);
        return true;
    }
    return false;
}
// community-modules/core/src/interfaces/iChartOptions.ts
var $7b57b57eaf5a9648$export$95ec81232b2e8791 = class {
};
$7b57b57eaf5a9648$export$95ec81232b2e8791.CHART_TYPE_TO_SERIES_TYPE = {
    column: "bar",
    groupedColumn: "bar",
    stackedColumn: "bar",
    normalizedColumn: "bar",
    bar: "bar",
    groupedBar: "bar",
    stackedBar: "bar",
    normalizedBar: "bar",
    line: "line",
    scatter: "scatter",
    bubble: "bubble",
    pie: "pie",
    donut: "donut",
    doughnut: "donut",
    area: "area",
    stackedArea: "area",
    normalizedArea: "area",
    histogram: "histogram",
    radarLine: "radar-line",
    radarArea: "radar-area",
    nightingale: "nightingale",
    radialColumn: "radial-column",
    radialBar: "radial-bar",
    sunburst: "sunburst",
    rangeBar: "range-bar",
    rangeArea: "range-area",
    boxPlot: "box-plot",
    treemap: "treemap",
    heatmap: "heatmap",
    waterfall: "waterfall"
};
$7b57b57eaf5a9648$export$95ec81232b2e8791.COMBO_CHART_TYPES = [
    "columnLineCombo",
    "areaColumnCombo",
    "customCombo"
];
$7b57b57eaf5a9648$export$95ec81232b2e8791.SERIES_GROUP_TYPES = [
    "grouped",
    "stacked",
    "normalized"
];
// community-modules/core/src/interfaces/iSparklineCellRendererParams.ts
var $7b57b57eaf5a9648$export$c8e24a0d0ec865d3 = /* @__PURE__ */ ((BarColumnLabelPlacement2)=>{
    BarColumnLabelPlacement2["InsideBase"] = "insideBase";
    BarColumnLabelPlacement2["InsideEnd"] = "insideEnd";
    BarColumnLabelPlacement2["Center"] = "center";
    BarColumnLabelPlacement2["OutsideEnd"] = "outsideEnd";
    return BarColumnLabelPlacement2;
})($7b57b57eaf5a9648$export$c8e24a0d0ec865d3 || {});
// community-modules/core/src/main.ts
var $7b57b57eaf5a9648$var$globalObj = typeof $parcel$global === "undefined" ? {} : $parcel$global;
$7b57b57eaf5a9648$var$globalObj.HTMLElement = typeof HTMLElement === "undefined" ? {} : HTMLElement;
$7b57b57eaf5a9648$var$globalObj.HTMLButtonElement = typeof HTMLButtonElement === "undefined" ? {} : HTMLButtonElement;
$7b57b57eaf5a9648$var$globalObj.HTMLSelectElement = typeof HTMLSelectElement === "undefined" ? {} : HTMLSelectElement;
$7b57b57eaf5a9648$var$globalObj.HTMLInputElement = typeof HTMLInputElement === "undefined" ? {} : HTMLInputElement;
$7b57b57eaf5a9648$var$globalObj.Node = typeof Node === "undefined" ? {} : Node;
$7b57b57eaf5a9648$var$globalObj.MouseEvent = typeof MouseEvent === "undefined" ? {} : MouseEvent;
// community-modules/client-side-row-model/src/clientSideRowModel/clientSideNodeManager.ts
var $7b57b57eaf5a9648$var$ROOT_NODE_ID = "ROOT_NODE_ID";
var $7b57b57eaf5a9648$var$TOP_LEVEL = 0;
var $7b57b57eaf5a9648$var$ClientSideNodeManager = class {
    constructor(rootNode, gos, eventService, funcColsService, selectionService, beans){
        this.nextId = 0;
        // has row data actually been set
        this.rowCountReady = false;
        // when user is provide the id's, we also keep a map of ids to row nodes for convenience
        this.allNodesMap = {};
        this.rootNode = rootNode;
        this.gos = gos;
        this.eventService = eventService;
        this.funcColsService = funcColsService;
        this.beans = beans;
        this.selectionService = selectionService;
        this.rootNode.group = true;
        this.rootNode.level = -1;
        this.rootNode.id = $7b57b57eaf5a9648$var$ROOT_NODE_ID;
        this.rootNode.allLeafChildren = [];
        this.rootNode.childrenAfterGroup = [];
        this.rootNode.childrenAfterSort = [];
        this.rootNode.childrenAfterAggFilter = [];
        this.rootNode.childrenAfterFilter = [];
    }
    getCopyOfNodesMap() {
        return $7b57b57eaf5a9648$export$b0cc93169835e7eb(this.allNodesMap);
    }
    getRowNode(id) {
        return this.allNodesMap[id];
    }
    setRowData(rowData) {
        if (typeof rowData === "string") {
            $7b57b57eaf5a9648$export$2cf41453020eef66("rowData must be an array.");
            return;
        }
        this.rowCountReady = true;
        this.dispatchRowDataUpdateStartedEvent(rowData);
        const rootNode = this.rootNode;
        const sibling = this.rootNode.sibling;
        rootNode.childrenAfterFilter = null;
        rootNode.childrenAfterGroup = null;
        rootNode.childrenAfterAggFilter = null;
        rootNode.childrenAfterSort = null;
        rootNode.childrenMapped = null;
        rootNode.updateHasChildren();
        this.nextId = 0;
        this.allNodesMap = {};
        if (rowData) rootNode.allLeafChildren = rowData.map((dataItem)=>this.createNode(dataItem, this.rootNode, $7b57b57eaf5a9648$var$TOP_LEVEL));
        else {
            rootNode.allLeafChildren = [];
            rootNode.childrenAfterGroup = [];
        }
        if (sibling) {
            sibling.childrenAfterFilter = rootNode.childrenAfterFilter;
            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
            sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;
            sibling.childrenAfterSort = rootNode.childrenAfterSort;
            sibling.childrenMapped = rootNode.childrenMapped;
            sibling.allLeafChildren = rootNode.allLeafChildren;
        }
    }
    updateRowData(rowDataTran, rowNodeOrder) {
        this.rowCountReady = true;
        this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);
        const rowNodeTransaction = {
            remove: [],
            update: [],
            add: []
        };
        const nodesToUnselect = [];
        this.executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect);
        this.executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect);
        this.executeAdd(rowDataTran, rowNodeTransaction);
        this.updateSelection(nodesToUnselect, "rowDataChanged");
        if (rowNodeOrder) $7b57b57eaf5a9648$export$3c29aeb06dfacfc(this.rootNode.allLeafChildren, rowNodeOrder);
        return rowNodeTransaction;
    }
    isRowCountReady() {
        return this.rowCountReady;
    }
    dispatchRowDataUpdateStartedEvent(rowData) {
        const event = {
            type: "rowDataUpdateStarted",
            firstRowData: rowData?.length ? rowData[0] : null
        };
        this.eventService.dispatchEvent(event);
    }
    updateSelection(nodesToUnselect, source) {
        const selectionChanged = nodesToUnselect.length > 0;
        if (selectionChanged) this.selectionService.setNodesSelected({
            newValue: false,
            nodes: nodesToUnselect,
            suppressFinishActions: true,
            source: source
        });
        this.selectionService.updateGroupsFromChildrenSelections(source);
        if (selectionChanged) {
            const event = {
                type: "selectionChanged",
                source: source
            };
            this.eventService.dispatchEvent(event);
        }
    }
    executeAdd(rowDataTran, rowNodeTransaction) {
        const { add: add , addIndex: addIndex  } = rowDataTran;
        if ($7b57b57eaf5a9648$export$c15f339f10321853(add)) return;
        const newNodes = add.map((item)=>this.createNode(item, this.rootNode, $7b57b57eaf5a9648$var$TOP_LEVEL));
        const allLeafChildren = this.rootNode.allLeafChildren;
        if (typeof addIndex === "number" && addIndex >= 0) {
            const len = allLeafChildren.length;
            let normalisedAddIndex = addIndex;
            const isTreeData = this.gos.get("treeData");
            if (isTreeData && addIndex > 0 && len > 0) {
                for(let i = 0; i < len; i++)if (allLeafChildren[i]?.rowIndex == addIndex - 1) {
                    normalisedAddIndex = i + 1;
                    break;
                }
            }
            const nodesBeforeIndex = allLeafChildren.slice(0, normalisedAddIndex);
            const nodesAfterIndex = allLeafChildren.slice(normalisedAddIndex, allLeafChildren.length);
            this.rootNode.allLeafChildren = [
                ...nodesBeforeIndex,
                ...newNodes,
                ...nodesAfterIndex
            ];
        } else this.rootNode.allLeafChildren = [
            ...allLeafChildren,
            ...newNodes
        ];
        if (this.rootNode.sibling) this.rootNode.sibling.allLeafChildren = allLeafChildren;
        rowNodeTransaction.add = newNodes;
    }
    executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect) {
        const { remove: remove  } = rowDataTran;
        if ($7b57b57eaf5a9648$export$c15f339f10321853(remove)) return;
        const rowIdsRemoved = {};
        remove.forEach((item)=>{
            const rowNode = this.lookupRowNode(item);
            if (!rowNode) return;
            if (rowNode.isSelected()) nodesToUnselect.push(rowNode);
            rowNode.clearRowTopAndRowIndex();
            rowIdsRemoved[rowNode.id] = true;
            delete this.allNodesMap[rowNode.id];
            rowNodeTransaction.remove.push(rowNode);
        });
        this.rootNode.allLeafChildren = this.rootNode.allLeafChildren?.filter((rowNode)=>!rowIdsRemoved[rowNode.id]) ?? null;
        if (this.rootNode.sibling) this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;
    }
    executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect) {
        const { update: update  } = rowDataTran;
        if ($7b57b57eaf5a9648$export$c15f339f10321853(update)) return;
        update.forEach((item)=>{
            const rowNode = this.lookupRowNode(item);
            if (!rowNode) return;
            rowNode.updateData(item);
            if (!rowNode.selectable && rowNode.isSelected()) nodesToUnselect.push(rowNode);
            this.setMasterForRow(rowNode, item, $7b57b57eaf5a9648$var$TOP_LEVEL, false);
            rowNodeTransaction.update.push(rowNode);
        });
    }
    lookupRowNode(data) {
        const getRowIdFunc = this.gos.getRowIdCallback();
        let rowNode;
        if (getRowIdFunc) {
            const id = getRowIdFunc({
                data: data,
                level: 0
            });
            rowNode = this.allNodesMap[id];
            if (!rowNode) {
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`could not find row id=${id}, data item was not found for this id`);
                return null;
            }
        } else {
            rowNode = this.rootNode.allLeafChildren?.find((node)=>node.data === data);
            if (!rowNode) {
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`could not find data item as object was not found`, data);
                $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`Consider using getRowId to help the Grid find matching row data`);
                return null;
            }
        }
        return rowNode || null;
    }
    createNode(dataItem, parent, level) {
        const node = new $7b57b57eaf5a9648$export$6af91cd58ec2edf9(this.beans);
        node.group = false;
        this.setMasterForRow(node, dataItem, level, true);
        if (parent) node.parent = parent;
        node.level = level;
        node.setDataAndId(dataItem, this.nextId.toString());
        if (this.allNodesMap[node.id]) $7b57b57eaf5a9648$export$2cf41453020eef66(`duplicate node id '${node.id}' detected from getRowId callback, this could cause issues in your grid.`);
        this.allNodesMap[node.id] = node;
        this.nextId++;
        return node;
    }
    setMasterForRow(rowNode, data, level, setExpanded) {
        const isTreeData = this.gos.get("treeData");
        if (isTreeData) {
            rowNode.setMaster(false);
            if (setExpanded) rowNode.expanded = false;
        } else {
            const masterDetail = this.gos.get("masterDetail");
            if (masterDetail) {
                const isRowMasterFunc = this.gos.get("isRowMaster");
                if (isRowMasterFunc) rowNode.setMaster(isRowMasterFunc(data));
                else rowNode.setMaster(true);
            } else rowNode.setMaster(false);
            if (setExpanded) {
                const rowGroupColumns = this.funcColsService.getRowGroupColumns();
                const numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;
                const masterRowLevel = level + numRowGroupColumns;
                rowNode.expanded = rowNode.master ? this.isExpanded(masterRowLevel) : false;
            }
        }
    }
    isExpanded(level) {
        const expandByDefault = this.gos.get("groupDefaultExpanded");
        if (expandByDefault === -1) return true;
        return level < expandByDefault;
    }
};
// community-modules/client-side-row-model/src/clientSideRowModel/clientSideRowModel.ts
var $7b57b57eaf5a9648$var$ClientSideRowModel = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowModel";
        this.onRowHeightChanged_debounced = $7b57b57eaf5a9648$export$cf7e39bfb94de6e(this.onRowHeightChanged.bind(this), 100);
        this.rowsToDisplay = [];
        /** Has the start method been called */ this.hasStarted = false;
        /** E.g. data has been set into the node manager already */ this.shouldSkipSettingDataOnStart = false;
        /**
     * This is to prevent refresh model being called when it's already being called.
     * E.g. the group stage can trigger initial state filter model to be applied. This fires onFilterChanged,
     * which then triggers the listener here that calls refresh model again but at the filter stage
     * (which is about to be run by the original call).
     */ this.isRefreshingModel = false;
        this.rowCountReady = false;
    }
    wireBeans(beans) {
        this.beans = beans;
        this.columnModel = beans.columnModel;
        this.funcColsService = beans.funcColsService;
        this.selectionService = beans.selectionService;
        this.valueCache = beans.valueCache;
        this.environment = beans.environment;
        this.filterStage = beans.filterStage;
        this.sortStage = beans.sortStage;
        this.flattenStage = beans.flattenStage;
        this.groupStage = beans.groupStage;
        this.aggregationStage = beans.aggregationStage;
        this.pivotStage = beans.pivotStage;
        this.filterAggregatesStage = beans.filterAggregatesStage;
    }
    postConstruct() {
        const refreshEverythingFunc = this.refreshModel.bind(this, {
            step: "group" /* EVERYTHING */ 
        });
        const animate = !this.gos.get("suppressAnimationFrame");
        const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {
            step: "group" /* EVERYTHING */ ,
            // after cols change, row grouping (the first stage) could of changed
            afterColumnsChanged: true,
            keepRenderedRows: true,
            animate: // we want animations cos sorting or filtering could be applied
            animate
        });
        this.addManagedEventListeners({
            newColumnsLoaded: refreshEverythingAfterColsChangedFunc,
            columnRowGroupChanged: refreshEverythingFunc,
            columnValueChanged: this.onValueChanged.bind(this),
            columnPivotChanged: this.refreshModel.bind(this, {
                step: "pivot" /* PIVOT */ 
            }),
            filterChanged: this.onFilterChanged.bind(this),
            sortChanged: this.onSortChanged.bind(this),
            columnPivotModeChanged: refreshEverythingFunc,
            gridStylesChanged: this.onGridStylesChanges.bind(this),
            gridReady: this.onGridReady.bind(this)
        });
        this.addPropertyListeners();
        this.rootNode = new $7b57b57eaf5a9648$export$6af91cd58ec2edf9(this.beans);
        this.nodeManager = new $7b57b57eaf5a9648$var$ClientSideNodeManager(this.rootNode, this.gos, this.eventService, this.funcColsService, this.selectionService, this.beans);
    }
    addPropertyListeners() {
        const resetProps = /* @__PURE__ */ new Set([
            "treeData",
            "masterDetail"
        ]);
        const groupStageRefreshProps = /* @__PURE__ */ new Set([
            "groupDefaultExpanded",
            "groupAllowUnbalanced",
            "initialGroupOrderComparator",
            "groupHideOpenParents",
            "groupDisplayType"
        ]);
        const filterStageRefreshProps = /* @__PURE__ */ new Set([
            "excludeChildrenWhenTreeDataFiltering"
        ]);
        const pivotStageRefreshProps = /* @__PURE__ */ new Set([
            "removePivotHeaderRowWhenSingleValueColumn",
            "pivotRowTotals",
            "pivotColumnGroupTotals",
            "suppressExpandablePivotGroups"
        ]);
        const aggregateStageRefreshProps = /* @__PURE__ */ new Set([
            "getGroupRowAgg",
            "alwaysAggregateAtRootLevel",
            "groupIncludeTotalFooter",
            "suppressAggFilteredOnly",
            "grandTotalRow"
        ]);
        const sortStageRefreshProps = /* @__PURE__ */ new Set([
            "postSortRows",
            "groupDisplayType",
            "accentedSort"
        ]);
        const filterAggStageRefreshProps = /* @__PURE__ */ new Set([]);
        const flattenStageRefreshProps = /* @__PURE__ */ new Set([
            "groupRemoveSingleChildren",
            "groupRemoveLowestSingleChildren",
            "groupIncludeFooter",
            "groupTotalRow"
        ]);
        const allProps = [
            ...resetProps,
            ...groupStageRefreshProps,
            ...filterStageRefreshProps,
            ...pivotStageRefreshProps,
            ...pivotStageRefreshProps,
            ...aggregateStageRefreshProps,
            ...sortStageRefreshProps,
            ...filterAggStageRefreshProps,
            ...flattenStageRefreshProps
        ];
        this.addManagedPropertyListeners(allProps, (params)=>{
            const properties = params.changeSet?.properties;
            if (!properties) return;
            const arePropertiesImpacted = (propSet)=>properties.some((prop)=>propSet.has(prop));
            if (arePropertiesImpacted(resetProps)) {
                this.setRowData(this.rootNode.allLeafChildren.map((child)=>child.data));
                return;
            }
            if (arePropertiesImpacted(groupStageRefreshProps)) {
                this.refreshModel({
                    step: "group" /* EVERYTHING */ 
                });
                return;
            }
            if (arePropertiesImpacted(filterStageRefreshProps)) {
                this.refreshModel({
                    step: "filter" /* FILTER */ 
                });
                return;
            }
            if (arePropertiesImpacted(pivotStageRefreshProps)) {
                this.refreshModel({
                    step: "pivot" /* PIVOT */ 
                });
                return;
            }
            if (arePropertiesImpacted(aggregateStageRefreshProps)) {
                this.refreshModel({
                    step: "aggregate" /* AGGREGATE */ 
                });
                return;
            }
            if (arePropertiesImpacted(sortStageRefreshProps)) {
                this.refreshModel({
                    step: "sort" /* SORT */ 
                });
                return;
            }
            if (arePropertiesImpacted(filterAggStageRefreshProps)) {
                this.refreshModel({
                    step: "filter_aggregates" /* FILTER_AGGREGATES */ 
                });
                return;
            }
            if (arePropertiesImpacted(flattenStageRefreshProps)) this.refreshModel({
                step: "map" /* MAP */ 
            });
        });
        this.addManagedPropertyListener("rowHeight", ()=>this.resetRowHeights());
    }
    start() {
        this.hasStarted = true;
        if (this.shouldSkipSettingDataOnStart) this.dispatchUpdateEventsAndRefresh();
        else this.setInitialData();
    }
    setInitialData() {
        const rowData = this.gos.get("rowData");
        if (rowData) {
            this.shouldSkipSettingDataOnStart = true;
            this.setRowData(rowData);
        }
    }
    ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) {
        let atLeastOneChange;
        let res = false;
        do {
            atLeastOneChange = false;
            const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);
            const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);
            const firstRow = Math.max(rowAtStartPixel, startLimitIndex);
            const lastRow = Math.min(rowAtEndPixel, endLimitIndex);
            for(let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++){
                const rowNode = this.getRow(rowIndex);
                if (rowNode.rowHeightEstimated) {
                    const rowHeight = this.gos.getRowHeightForNode(rowNode);
                    rowNode.setRowHeight(rowHeight.height);
                    atLeastOneChange = true;
                    res = true;
                }
            }
            if (atLeastOneChange) this.setRowTopAndRowIndex();
        }while (atLeastOneChange);
        return res;
    }
    setRowTopAndRowIndex() {
        const defaultRowHeight = this.environment.getDefaultRowHeight();
        let nextRowTop = 0;
        const displayedRowsMapped = /* @__PURE__ */ new Set();
        const allowEstimate = this.gos.isDomLayout("normal");
        for(let i = 0; i < this.rowsToDisplay.length; i++){
            const rowNode = this.rowsToDisplay[i];
            if (rowNode.id != null) displayedRowsMapped.add(rowNode.id);
            if (rowNode.rowHeight == null) {
                const rowHeight = this.gos.getRowHeightForNode(rowNode, allowEstimate, defaultRowHeight);
                rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);
            }
            rowNode.setRowTop(nextRowTop);
            rowNode.setRowIndex(i);
            nextRowTop += rowNode.rowHeight;
        }
        return displayedRowsMapped;
    }
    clearRowTopAndRowIndex(changedPath, displayedRowsMapped) {
        const changedPathActive = changedPath.isActive();
        const clearIfNotDisplayed = (rowNode)=>{
            if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) rowNode.clearRowTopAndRowIndex();
        };
        const recurse = (rowNode)=>{
            clearIfNotDisplayed(rowNode);
            clearIfNotDisplayed(rowNode.detailNode);
            clearIfNotDisplayed(rowNode.sibling);
            if (rowNode.hasChildren()) {
                if (rowNode.childrenAfterGroup) {
                    const isRootNode = rowNode.level == -1;
                    const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;
                    if (!skipChildren) rowNode.childrenAfterGroup.forEach(recurse);
                }
            }
        };
        recurse(this.rootNode);
    }
    // returns false if row was moved, otherwise true
    ensureRowsAtPixel(rowNodes, pixel, increment = 0) {
        const indexAtPixelNow = this.getRowIndexAtPixel(pixel);
        const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);
        const animate = !this.gos.get("suppressAnimationFrame");
        if (rowNodeAtPixelNow === rowNodes[0]) return false;
        rowNodes.forEach((rowNode)=>{
            $7b57b57eaf5a9648$export$83a881c8b5120679(this.rootNode.allLeafChildren, rowNode);
        });
        rowNodes.forEach((rowNode, idx)=>{
            $7b57b57eaf5a9648$export$820a25988ad46b8d(this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);
        });
        this.refreshModel({
            step: "group" /* EVERYTHING */ ,
            keepRenderedRows: true,
            keepEditingRows: true,
            animate: animate
        });
        return true;
    }
    highlightRowAtPixel(rowNode, pixel) {
        const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;
        const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;
        if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {
            if (this.lastHighlightedRow) {
                this.lastHighlightedRow.setHighlighted(null);
                this.lastHighlightedRow = null;
            }
            return;
        }
        const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);
        if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {
            this.lastHighlightedRow.setHighlighted(null);
            this.lastHighlightedRow = null;
        }
        rowNodeAtPixelNow.setHighlighted(highlight);
        this.lastHighlightedRow = rowNodeAtPixelNow;
    }
    getHighlightPosition(pixel, rowNode) {
        if (!rowNode) {
            const index = this.getRowIndexAtPixel(pixel);
            rowNode = this.getRow(index || 0);
            if (!rowNode) return 1 /* Below */ ;
        }
        const { rowTop: rowTop , rowHeight: rowHeight  } = rowNode;
        return pixel - rowTop < rowHeight / 2 ? 0 /* Above */  : 1 /* Below */ ;
    }
    getLastHighlightedRowNode() {
        return this.lastHighlightedRow;
    }
    isLastRowIndexKnown() {
        return true;
    }
    getRowCount() {
        if (this.rowsToDisplay) return this.rowsToDisplay.length;
        return 0;
    }
    getTopLevelRowCount() {
        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;
        if (showingRootNode) return 1;
        const totalFooterInc = this.rootNode.sibling ? 1 : 0;
        const filteredChildren = this.rootNode.childrenAfterAggFilter;
        return (filteredChildren ? filteredChildren.length : 0) + totalFooterInc;
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;
        if (showingRootNode) return topLevelIndex;
        let adjustedIndex = topLevelIndex;
        if (this.rowsToDisplay[0].footer) {
            if (topLevelIndex === 0) return 0;
            adjustedIndex -= 1;
        }
        let rowNode = this.rootNode.childrenAfterSort[adjustedIndex];
        if (this.gos.get("groupHideOpenParents")) while(rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0)rowNode = rowNode.childrenAfterSort[0];
        return rowNode.rowIndex;
    }
    getRowBounds(index) {
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(this.rowsToDisplay)) return null;
        const rowNode = this.rowsToDisplay[index];
        if (rowNode) return {
            rowTop: rowNode.rowTop,
            rowHeight: rowNode.rowHeight
        };
        return null;
    }
    onRowGroupOpened() {
        const animate = this.gos.isAnimateRows();
        this.refreshModel({
            step: "map" /* MAP */ ,
            keepRenderedRows: true,
            animate: animate
        });
    }
    onFilterChanged(event) {
        if (event.afterDataChange) return;
        const animate = this.gos.isAnimateRows();
        const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some((col)=>col.isPrimary());
        const step = primaryOrQuickFilterChanged ? "filter" /* FILTER */  : "filter_aggregates" /* FILTER_AGGREGATES */ ;
        this.refreshModel({
            step: step,
            keepRenderedRows: true,
            animate: animate
        });
    }
    onSortChanged() {
        const animate = this.gos.isAnimateRows();
        this.refreshModel({
            step: "sort" /* SORT */ ,
            keepRenderedRows: true,
            animate: animate,
            keepEditingRows: true
        });
    }
    getType() {
        return "clientSide";
    }
    onValueChanged() {
        if (this.columnModel.isPivotActive()) this.refreshModel({
            step: "pivot" /* PIVOT */ 
        });
        else this.refreshModel({
            step: "aggregate" /* AGGREGATE */ 
        });
    }
    createChangePath(rowNodeTransactions) {
        const noTransactions = $7b57b57eaf5a9648$export$c15f339f10321853(rowNodeTransactions);
        const changedPath = new $7b57b57eaf5a9648$export$cb4d9114a9732e85(false, this.rootNode);
        if (noTransactions || this.gos.get("treeData")) changedPath.setInactive();
        return changedPath;
    }
    isSuppressModelUpdateAfterUpdateTransaction(params) {
        if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction")) return false;
        if (params.rowNodeTransactions == null) return false;
        const transWithAddsOrDeletes = params.rowNodeTransactions.filter((tx)=>tx.add != null && tx.add.length > 0 || tx.remove != null && tx.remove.length > 0);
        const transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;
        return transactionsContainUpdatesOnly;
    }
    buildRefreshModelParams(step) {
        let paramsStep = "group" /* EVERYTHING */ ;
        const stepsMapped = {
            everything: "group" /* EVERYTHING */ ,
            group: "group" /* EVERYTHING */ ,
            filter: "filter" /* FILTER */ ,
            map: "map" /* MAP */ ,
            aggregate: "aggregate" /* AGGREGATE */ ,
            sort: "sort" /* SORT */ ,
            pivot: "pivot" /* PIVOT */ 
        };
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(step)) paramsStep = stepsMapped[step];
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(paramsStep)) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49(`invalid step ${step}, available steps are ${Object.keys(stepsMapped).join(", ")}`);
            return void 0;
        }
        const animate = !this.gos.get("suppressAnimationFrame");
        const modelParams = {
            step: paramsStep,
            keepRenderedRows: true,
            keepEditingRows: true,
            animate: animate
        };
        return modelParams;
    }
    refreshModel(paramsOrStep) {
        if (!this.hasStarted || this.isRefreshingModel || this.columnModel.isChangeEventsDispatching()) return;
        const params = typeof paramsOrStep === "object" && "step" in paramsOrStep ? paramsOrStep : this.buildRefreshModelParams(paramsOrStep);
        if (!params) return;
        if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) return;
        const changedPath = this.createChangePath(params.rowNodeTransactions);
        this.isRefreshingModel = true;
        switch(params.step){
            case "group" /* EVERYTHING */ :
                this.doRowGrouping(params.rowNodeTransactions, params.rowNodeOrder, changedPath, !!params.afterColumnsChanged);
            case "filter" /* FILTER */ :
                this.doFilter(changedPath);
            case "pivot" /* PIVOT */ :
                this.doPivot(changedPath);
            case "aggregate" /* AGGREGATE */ :
                this.doAggregate(changedPath);
            case "filter_aggregates" /* FILTER_AGGREGATES */ :
                this.doFilterAggregates(changedPath);
            case "sort" /* SORT */ :
                this.doSort(params.rowNodeTransactions, changedPath);
            case "map" /* MAP */ :
                this.doRowsToDisplay();
        }
        const displayedNodesMapped = this.setRowTopAndRowIndex();
        this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);
        this.isRefreshingModel = false;
        const event = {
            type: "modelUpdated",
            animate: params.animate,
            keepRenderedRows: params.keepRenderedRows,
            newData: params.newData,
            newPage: false,
            keepUndoRedoStack: params.keepUndoRedoStack
        };
        this.eventService.dispatchEvent(event);
    }
    isEmpty() {
        const rowsMissing = $7b57b57eaf5a9648$export$672d9e47bc342bac(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
        return $7b57b57eaf5a9648$export$672d9e47bc342bac(this.rootNode) || rowsMissing || !this.columnModel.isReady();
    }
    isRowsToRender() {
        return $7b57b57eaf5a9648$export$25d27f17d3af40f7(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
        let started = false;
        let finished = false;
        const result = [];
        const groupsSelectChildren = this.gos.get("groupSelectsChildren");
        this.forEachNodeAfterFilterAndSort((rowNode)=>{
            if (finished) return;
            if (started) {
                if (rowNode === lastInRange || rowNode === firstInRange) {
                    finished = true;
                    if (rowNode.group && groupsSelectChildren) {
                        result.push(...rowNode.allLeafChildren);
                        return;
                    }
                }
            }
            if (!started) {
                if (rowNode !== lastInRange && rowNode !== firstInRange) return;
                started = true;
            }
            const includeThisNode = !rowNode.group || !groupsSelectChildren;
            if (includeThisNode) {
                result.push(rowNode);
                return;
            }
        });
        return result;
    }
    // eslint-disable-next-line
    setDatasource(datasource) {
        $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("should never call setDatasource on clientSideRowController");
    }
    getTopLevelNodes() {
        return this.rootNode ? this.rootNode.childrenAfterGroup : null;
    }
    getRootNode() {
        return this.rootNode;
    }
    getRow(index) {
        return this.rowsToDisplay[index];
    }
    isRowPresent(rowNode) {
        return this.rowsToDisplay.indexOf(rowNode) >= 0;
    }
    getRowIndexAtPixel(pixelToMatch) {
        if (this.isEmpty() || this.rowsToDisplay.length === 0) return -1;
        let bottomPointer = 0;
        let topPointer = this.rowsToDisplay.length - 1;
        if (pixelToMatch <= 0) return 0;
        const lastNode = $7b57b57eaf5a9648$export$236389741107357f(this.rowsToDisplay);
        if (lastNode.rowTop <= pixelToMatch) return this.rowsToDisplay.length - 1;
        let oldBottomPointer = -1;
        let oldTopPointer = -1;
        while(true){
            const midPointer = Math.floor((bottomPointer + topPointer) / 2);
            const currentRowNode = this.rowsToDisplay[midPointer];
            if (this.isRowInPixel(currentRowNode, pixelToMatch)) return midPointer;
            if (currentRowNode.rowTop < pixelToMatch) bottomPointer = midPointer + 1;
            else if (currentRowNode.rowTop > pixelToMatch) topPointer = midPointer - 1;
            const caughtInInfiniteLoop = oldBottomPointer === bottomPointer && oldTopPointer === topPointer;
            if (caughtInInfiniteLoop) return midPointer;
            oldBottomPointer = bottomPointer;
            oldTopPointer = topPointer;
        }
    }
    isRowInPixel(rowNode, pixelToMatch) {
        const topPixel = rowNode.rowTop;
        const bottomPixel = rowNode.rowTop + rowNode.rowHeight;
        const pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;
        return pixelInRow;
    }
    forEachLeafNode(callback) {
        if (this.rootNode.allLeafChildren) this.rootNode.allLeafChildren.forEach((rowNode, index)=>callback(rowNode, index));
    }
    forEachNode(callback, includeFooterNodes = false) {
        this.recursivelyWalkNodesAndCallback({
            nodes: [
                ...this.rootNode.childrenAfterGroup || []
            ],
            callback: callback,
            recursionType: 0 /* Normal */ ,
            index: 0,
            includeFooterNodes: includeFooterNodes
        });
    }
    forEachNodeAfterFilter(callback, includeFooterNodes = false) {
        this.recursivelyWalkNodesAndCallback({
            nodes: [
                ...this.rootNode.childrenAfterAggFilter || []
            ],
            callback: callback,
            recursionType: 1 /* AfterFilter */ ,
            index: 0,
            includeFooterNodes: includeFooterNodes
        });
    }
    forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {
        this.recursivelyWalkNodesAndCallback({
            nodes: [
                ...this.rootNode.childrenAfterSort || []
            ],
            callback: callback,
            recursionType: 2 /* AfterFilterAndSort */ ,
            index: 0,
            includeFooterNodes: includeFooterNodes
        });
    }
    forEachPivotNode(callback, includeFooterNodes = false) {
        this.recursivelyWalkNodesAndCallback({
            nodes: [
                this.rootNode
            ],
            callback: callback,
            recursionType: 3 /* PivotNodes */ ,
            index: 0,
            includeFooterNodes: includeFooterNodes
        });
    }
    // iterates through each item in memory, and calls the callback function
    // nodes - the rowNodes to traverse
    // callback - the user provided callback
    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
    // index - works similar to the index in forEach in javascript's array function
    recursivelyWalkNodesAndCallback(params) {
        const { nodes: nodes , callback: callback , recursionType: recursionType , includeFooterNodes: includeFooterNodes  } = params;
        let { index: index  } = params;
        const addFooters = (position)=>{
            const parentNode = nodes[0]?.parent;
            if (!parentNode) return;
            const grandTotal = includeFooterNodes && this.gos.getGrandTotalRow();
            const isGroupIncludeFooter = this.gos.getGroupTotalRowCallback();
            const groupTotal = includeFooterNodes && isGroupIncludeFooter({
                node: parentNode
            });
            const isRootNode = parentNode === this.rootNode;
            if (isRootNode) {
                if (grandTotal === position) {
                    parentNode.createFooter();
                    callback(parentNode.sibling, index++);
                }
                return;
            }
            if (groupTotal === position) {
                parentNode.createFooter();
                callback(parentNode.sibling, index++);
            }
        };
        addFooters("top");
        for(let i = 0; i < nodes.length; i++){
            const node = nodes[i];
            callback(node, index++);
            if (node.hasChildren() && !node.footer) {
                let nodeChildren = null;
                switch(recursionType){
                    case 0 /* Normal */ :
                        nodeChildren = node.childrenAfterGroup;
                        break;
                    case 1 /* AfterFilter */ :
                        nodeChildren = node.childrenAfterAggFilter;
                        break;
                    case 2 /* AfterFilterAndSort */ :
                        nodeChildren = node.childrenAfterSort;
                        break;
                    case 3 /* PivotNodes */ :
                        nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;
                        break;
                }
                if (nodeChildren) index = this.recursivelyWalkNodesAndCallback({
                    nodes: [
                        ...nodeChildren
                    ],
                    callback: callback,
                    recursionType: recursionType,
                    index: index,
                    includeFooterNodes: includeFooterNodes
                });
            }
        }
        addFooters("bottom");
        return index;
    }
    // it's possible to recompute the aggregate without doing the other parts
    // + api.refreshClientSideRowModel('aggregate')
    doAggregate(changedPath) {
        this.aggregationStage?.execute({
            rowNode: this.rootNode,
            changedPath: changedPath
        });
    }
    doFilterAggregates(changedPath) {
        if (this.filterAggregatesStage) this.filterAggregatesStage.execute({
            rowNode: this.rootNode,
            changedPath: changedPath
        });
        else this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
    }
    // + gridApi.expandAll()
    // + gridApi.collapseAll()
    expandOrCollapseAll(expand) {
        const usingTreeData = this.gos.get("treeData");
        const usingPivotMode = this.columnModel.isPivotActive();
        const recursiveExpandOrCollapse = (rowNodes)=>{
            if (!rowNodes) return;
            rowNodes.forEach((rowNode)=>{
                const actionRow = ()=>{
                    rowNode.expanded = expand;
                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);
                };
                if (usingTreeData) {
                    const hasChildren = $7b57b57eaf5a9648$export$25d27f17d3af40f7(rowNode.childrenAfterGroup);
                    if (hasChildren) actionRow();
                    return;
                }
                if (usingPivotMode) {
                    const notLeafGroup = !rowNode.leafGroup;
                    if (notLeafGroup) actionRow();
                    return;
                }
                const isRowGroup = rowNode.group;
                if (isRowGroup) actionRow();
            });
        };
        if (this.rootNode) recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);
        this.refreshModel({
            step: "map" /* MAP */ 
        });
        const eventSource = expand ? "expandAll" : "collapseAll";
        const event = {
            type: "expandOrCollapseAll",
            source: eventSource
        };
        this.eventService.dispatchEvent(event);
    }
    doSort(rowNodeTransactions, changedPath) {
        this.sortStage.execute({
            rowNode: this.rootNode,
            rowNodeTransactions: rowNodeTransactions,
            changedPath: changedPath
        });
    }
    doRowGrouping(rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {
        if (this.groupStage) {
            if (rowNodeTransactions) this.groupStage.execute({
                rowNode: this.rootNode,
                rowNodeTransactions: rowNodeTransactions,
                rowNodeOrder: rowNodeOrder,
                changedPath: changedPath
            });
            else this.groupStage.execute({
                rowNode: this.rootNode,
                changedPath: changedPath,
                afterColumnsChanged: afterColumnsChanged
            });
            if (this.gos.get("groupSelectsChildren")) {
                const selectionChanged = this.selectionService.updateGroupsFromChildrenSelections("rowGroupChanged", changedPath);
                if (selectionChanged) {
                    const event = {
                        type: "selectionChanged",
                        source: "rowGroupChanged"
                    };
                    this.eventService.dispatchEvent(event);
                }
            }
        } else {
            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;
            if (this.rootNode.sibling) this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup;
            this.rootNode.updateHasChildren();
        }
        if (this.nodeManager.isRowCountReady()) {
            this.rowCountReady = true;
            this.eventService.dispatchEventOnce({
                type: "rowCountReady"
            });
        }
    }
    doFilter(changedPath) {
        this.filterStage.execute({
            rowNode: this.rootNode,
            changedPath: changedPath
        });
    }
    doPivot(changedPath) {
        this.pivotStage?.execute({
            rowNode: this.rootNode,
            changedPath: changedPath
        });
    }
    getCopyOfNodesMap() {
        return this.nodeManager.getCopyOfNodesMap();
    }
    getRowNode(id) {
        const idIsGroup = typeof id == "string" && id.indexOf($7b57b57eaf5a9648$export$6af91cd58ec2edf9.ID_PREFIX_ROW_GROUP) == 0;
        if (idIsGroup) {
            let res = void 0;
            this.forEachNode((node)=>{
                if (node.id === id) res = node;
            });
            return res;
        }
        return this.nodeManager.getRowNode(id);
    }
    // rows: the rows to put into the model
    setRowData(rowData) {
        this.selectionService.reset("rowDataChanged");
        this.nodeManager.setRowData(rowData);
        if (this.hasStarted) this.dispatchUpdateEventsAndRefresh();
    }
    dispatchUpdateEventsAndRefresh() {
        const rowDataUpdatedEvent = {
            type: "rowDataUpdated"
        };
        this.eventService.dispatchEvent(rowDataUpdatedEvent);
        this.refreshModel({
            step: "group" /* EVERYTHING */ ,
            newData: true
        });
    }
    batchUpdateRowData(rowDataTransaction, callback) {
        if (this.applyAsyncTransactionsTimeout == null) {
            this.rowDataTransactionBatch = [];
            const waitMillis = this.gos.getAsyncTransactionWaitMillis();
            this.applyAsyncTransactionsTimeout = window.setTimeout(()=>{
                this.executeBatchUpdateRowData();
            }, waitMillis);
        }
        this.rowDataTransactionBatch.push({
            rowDataTransaction: rowDataTransaction,
            callback: callback
        });
    }
    flushAsyncTransactions() {
        if (this.applyAsyncTransactionsTimeout != null) {
            clearTimeout(this.applyAsyncTransactionsTimeout);
            this.executeBatchUpdateRowData();
        }
    }
    executeBatchUpdateRowData() {
        this.valueCache.onDataChanged();
        const callbackFuncsBound = [];
        const rowNodeTrans = [];
        let forceRowNodeOrder = false;
        if (this.rowDataTransactionBatch) this.rowDataTransactionBatch.forEach((tranItem)=>{
            const rowNodeTran = this.nodeManager.updateRowData(tranItem.rowDataTransaction, void 0);
            rowNodeTrans.push(rowNodeTran);
            if (tranItem.callback) callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));
            if (typeof tranItem.rowDataTransaction.addIndex === "number") forceRowNodeOrder = true;
        });
        this.commonUpdateRowData(rowNodeTrans, void 0, forceRowNodeOrder);
        if (callbackFuncsBound.length > 0) window.setTimeout(()=>{
            callbackFuncsBound.forEach((func)=>func());
        }, 0);
        if (rowNodeTrans.length > 0) {
            const event = {
                type: "asyncTransactionsFlushed",
                results: rowNodeTrans
            };
            this.eventService.dispatchEvent(event);
        }
        this.rowDataTransactionBatch = null;
        this.applyAsyncTransactionsTimeout = void 0;
    }
    updateRowData(rowDataTran, rowNodeOrder) {
        this.valueCache.onDataChanged();
        const rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);
        const forceRowNodeOrder = typeof rowDataTran.addIndex === "number";
        this.commonUpdateRowData([
            rowNodeTran
        ], rowNodeOrder, forceRowNodeOrder);
        return rowNodeTran;
    }
    createRowNodeOrder() {
        const suppressSortOrder = this.gos.get("suppressMaintainUnsortedOrder");
        if (suppressSortOrder) return;
        const orderMap = {};
        if (this.rootNode && this.rootNode.allLeafChildren) for(let index = 0; index < this.rootNode.allLeafChildren.length; index++){
            const node = this.rootNode.allLeafChildren[index];
            orderMap[node.id] = index;
        }
        return orderMap;
    }
    // common to updateRowData and batchUpdateRowData
    commonUpdateRowData(rowNodeTrans, rowNodeOrder, forceRowNodeOrder) {
        if (!this.hasStarted) return;
        const animate = !this.gos.get("suppressAnimationFrame");
        if (forceRowNodeOrder) rowNodeOrder = this.createRowNodeOrder();
        const event = {
            type: "rowDataUpdated"
        };
        this.eventService.dispatchEvent(event);
        this.refreshModel({
            step: "group" /* EVERYTHING */ ,
            rowNodeTransactions: rowNodeTrans,
            rowNodeOrder: rowNodeOrder,
            keepRenderedRows: true,
            keepEditingRows: true,
            animate: animate
        });
    }
    doRowsToDisplay() {
        this.rowsToDisplay = this.flattenStage.execute({
            rowNode: this.rootNode
        });
    }
    onRowHeightChanged() {
        this.refreshModel({
            step: "map" /* MAP */ ,
            keepRenderedRows: true,
            keepEditingRows: true,
            keepUndoRedoStack: true
        });
    }
    /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */ onRowHeightChangedDebounced() {
        this.onRowHeightChanged_debounced();
    }
    resetRowHeights() {
        const atLeastOne = this.resetRowHeightsForAllRowNodes();
        this.rootNode.setRowHeight(this.rootNode.rowHeight, true);
        if (this.rootNode.sibling) this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, true);
        if (atLeastOne) this.onRowHeightChanged();
    }
    resetRowHeightsForAllRowNodes() {
        let atLeastOne = false;
        this.forEachNode((rowNode)=>{
            rowNode.setRowHeight(rowNode.rowHeight, true);
            const detailNode = rowNode.detailNode;
            if (detailNode) detailNode.setRowHeight(detailNode.rowHeight, true);
            if (rowNode.sibling) rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);
            atLeastOne = true;
        });
        return atLeastOne;
    }
    onGridStylesChanges(e) {
        if (e.rowHeightChanged) {
            if (this.columnModel.isAutoRowHeightActive()) return;
            this.resetRowHeights();
        }
    }
    onGridReady() {
        if (this.hasStarted) return;
        this.setInitialData();
    }
    isRowDataLoaded() {
        return this.rowCountReady;
    }
};
// community-modules/client-side-row-model/src/clientSideRowModel/clientSideRowModelApi.ts
function $7b57b57eaf5a9648$var$onGroupExpandedOrCollapsed(beans) {
    beans.expansionService.onGroupExpandedOrCollapsed();
}
function $7b57b57eaf5a9648$var$refreshClientSideRowModel(beans, step) {
    beans.rowModelHelperService?.getClientSideRowModel()?.refreshModel(step);
}
function $7b57b57eaf5a9648$var$forEachLeafNode(beans, callback) {
    beans.rowModelHelperService?.getClientSideRowModel()?.forEachLeafNode(callback);
}
function $7b57b57eaf5a9648$var$forEachNodeAfterFilter(beans, callback) {
    beans.rowModelHelperService?.getClientSideRowModel()?.forEachNodeAfterFilter(callback);
}
function $7b57b57eaf5a9648$var$forEachNodeAfterFilterAndSort(beans, callback) {
    beans.rowModelHelperService?.getClientSideRowModel()?.forEachNodeAfterFilterAndSort(callback);
}
function $7b57b57eaf5a9648$var$resetRowHeights(beans) {
    if (beans.columnModel.isAutoRowHeightActive()) {
        $7b57b57eaf5a9648$export$2cf41453020eef66("calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
        return;
    }
    beans.rowModelHelperService?.getClientSideRowModel()?.resetRowHeights();
}
function $7b57b57eaf5a9648$var$applyTransaction(beans, rowDataTransaction) {
    return beans.frameworkOverrides.wrapIncoming(()=>beans.rowModelHelperService?.getClientSideRowModel()?.updateRowData(rowDataTransaction));
}
function $7b57b57eaf5a9648$var$applyTransactionAsync(beans, rowDataTransaction, callback) {
    beans.frameworkOverrides.wrapIncoming(()=>beans.rowModelHelperService?.getClientSideRowModel()?.batchUpdateRowData(rowDataTransaction, callback));
}
function $7b57b57eaf5a9648$var$flushAsyncTransactions(beans) {
    beans.frameworkOverrides.wrapIncoming(()=>beans.rowModelHelperService?.getClientSideRowModel()?.flushAsyncTransactions());
}
function $7b57b57eaf5a9648$var$getBestCostNodeSelection(beans) {
    return beans.selectionService.getBestCostNodeSelection();
}
// community-modules/client-side-row-model/src/clientSideRowModel/filterStage.ts
var $7b57b57eaf5a9648$var$FilterStage = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "filterStage";
    }
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
    }
    execute(params) {
        const { changedPath: changedPath  } = params;
        this.filter(changedPath);
    }
    filter(changedPath) {
        const filterActive = !!this.filterManager?.isChildFilterPresent();
        this.filterNodes(filterActive, changedPath);
    }
    filterNodes(filterActive, changedPath) {
        const filterCallback = (rowNode, includeChildNodes)=>{
            if (rowNode.hasChildren()) {
                if (filterActive && !includeChildNodes) rowNode.childrenAfterFilter = rowNode.childrenAfterGroup.filter((childNode)=>{
                    const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;
                    const passBecauseDataPasses = childNode.data && this.filterManager.doesRowPassFilter({
                        rowNode: childNode
                    });
                    return passBecauseChildren || passBecauseDataPasses;
                });
                else rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
            } else rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;
            if (rowNode.sibling) rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;
        };
        if (this.doingTreeDataFiltering()) {
            const treeDataDepthFirstFilter = (rowNode, alreadyFoundInParent)=>{
                if (rowNode.childrenAfterGroup) for(let i = 0; i < rowNode.childrenAfterGroup.length; i++){
                    const childNode = rowNode.childrenAfterGroup[i];
                    const foundInParent = alreadyFoundInParent || this.filterManager.doesRowPassFilter({
                        rowNode: childNode
                    });
                    if (childNode.childrenAfterGroup) treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);
                    else filterCallback(childNode, foundInParent);
                }
                filterCallback(rowNode, alreadyFoundInParent);
            };
            const treeDataFilterCallback = (rowNode)=>treeDataDepthFirstFilter(rowNode, false);
            changedPath.executeFromRootNode(treeDataFilterCallback);
        } else {
            const defaultFilterCallback = (rowNode)=>filterCallback(rowNode, false);
            changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);
        }
    }
    doingTreeDataFiltering() {
        return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
    }
};
// community-modules/client-side-row-model/src/clientSideRowModel/flattenStage.ts
var $7b57b57eaf5a9648$var$FlattenStage = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "flattenStage";
    }
    wireBeans(beans) {
        this.beans = beans;
        this.columnModel = beans.columnModel;
    }
    execute(params) {
        const rootNode = params.rowNode;
        const result = [];
        const skipLeafNodes = this.columnModel.isPivotMode();
        const showRootNode = skipLeafNodes && rootNode.leafGroup;
        const topList = showRootNode ? [
            rootNode
        ] : rootNode.childrenAfterSort;
        const details = this.getFlattenDetails();
        this.recursivelyAddToRowsToDisplay(details, topList, result, skipLeafNodes, 0);
        const atLeastOneRowPresent = result.length > 0;
        const includeGrandTotalRow = !showRootNode && // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)
        atLeastOneRowPresent && details.grandTotalRow;
        if (includeGrandTotalRow) {
            rootNode.createFooter();
            const addToTop = details.grandTotalRow === "top";
            this.addRowNodeToRowsToDisplay(details, rootNode.sibling, result, 0, addToTop);
        }
        return result;
    }
    getFlattenDetails() {
        const groupRemoveSingleChildren = this.gos.get("groupRemoveSingleChildren");
        const groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gos.get("groupRemoveLowestSingleChildren");
        return {
            groupRemoveLowestSingleChildren: groupRemoveLowestSingleChildren,
            groupRemoveSingleChildren: groupRemoveSingleChildren,
            isGroupMultiAutoColumn: this.gos.isGroupMultiAutoColumn(),
            hideOpenParents: this.gos.get("groupHideOpenParents"),
            grandTotalRow: this.gos.getGrandTotalRow(),
            groupTotalRow: this.gos.getGroupTotalRowCallback()
        };
    }
    recursivelyAddToRowsToDisplay(details, rowsToFlatten, result, skipLeafNodes, uiLevel) {
        if ($7b57b57eaf5a9648$export$c15f339f10321853(rowsToFlatten)) return;
        for(let i = 0; i < rowsToFlatten.length; i++){
            const rowNode = rowsToFlatten[i];
            const isParent = rowNode.hasChildren();
            const isSkippedLeafNode = skipLeafNodes && !isParent;
            const isRemovedSingleChildrenGroup = details.groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;
            const isRemovedLowestSingleChildrenGroup = details.groupRemoveLowestSingleChildren && isParent && rowNode.leafGroup && rowNode.childrenAfterGroup.length === 1;
            const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;
            const isHiddenOpenParent = details.hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;
            const thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent && !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;
            if (thisRowShouldBeRendered) this.addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel);
            if (skipLeafNodes && rowNode.leafGroup) continue;
            if (isParent) {
                const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;
                if (rowNode.expanded || excludedParent) {
                    const doesRowShowFooter = details.groupTotalRow({
                        node: rowNode
                    });
                    if (!doesRowShowFooter) rowNode.destroyFooter();
                    const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;
                    if (doesRowShowFooter === "top") {
                        rowNode.createFooter();
                        this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);
                    }
                    this.recursivelyAddToRowsToDisplay(details, rowNode.childrenAfterSort, result, skipLeafNodes, uiLevelForChildren);
                    if (doesRowShowFooter === "bottom") {
                        rowNode.createFooter();
                        this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);
                    }
                }
            } else if (rowNode.master && rowNode.expanded) {
                const detailNode = this.createDetailNode(rowNode);
                this.addRowNodeToRowsToDisplay(details, detailNode, result, uiLevel);
            }
        }
    }
    // duplicated method, it's also in floatingRowModel
    addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel, addToTop) {
        if (addToTop) result.unshift(rowNode);
        else result.push(rowNode);
        rowNode.setUiLevel(details.isGroupMultiAutoColumn ? 0 : uiLevel);
    }
    createDetailNode(masterNode) {
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(masterNode.detailNode)) return masterNode.detailNode;
        const detailNode = new $7b57b57eaf5a9648$export$6af91cd58ec2edf9(this.beans);
        detailNode.detail = true;
        detailNode.selectable = false;
        detailNode.parent = masterNode;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(masterNode.id)) detailNode.id = "detail_" + masterNode.id;
        detailNode.data = masterNode.data;
        detailNode.level = masterNode.level + 1;
        masterNode.detailNode = detailNode;
        return detailNode;
    }
};
// community-modules/client-side-row-model/src/clientSideRowModel/immutableService.ts
var $7b57b57eaf5a9648$var$ImmutableService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "immutableService";
    }
    wireBeans(beans) {
        this.rowModel = beans.rowModel;
        this.selectionService = beans.selectionService;
    }
    postConstruct() {
        if (this.rowModel.getType() === "clientSide") {
            this.clientSideRowModel = this.rowModel;
            this.addManagedPropertyListener("rowData", ()=>this.onRowDataUpdated());
        }
    }
    isActive() {
        const getRowIdProvided = this.gos.exists("getRowId");
        const resetRowDataOnUpdate = this.gos.get("resetRowDataOnUpdate");
        if (resetRowDataOnUpdate) return false;
        return getRowIdProvided;
    }
    setRowData(rowData) {
        const transactionAndMap = this.createTransactionForRowData(rowData);
        if (!transactionAndMap) return;
        const [transaction, orderIdMap] = transactionAndMap;
        this.clientSideRowModel.updateRowData(transaction, orderIdMap);
    }
    // converts the setRowData() command to a transaction
    createTransactionForRowData(rowData) {
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(this.clientSideRowModel)) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("ImmutableService only works with ClientSideRowModel");
            return;
        }
        const getRowIdFunc = this.gos.getRowIdCallback();
        if (getRowIdFunc == null) {
            $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");
            return;
        }
        const transaction = {
            remove: [],
            update: [],
            add: []
        };
        const existingNodesMap = this.clientSideRowModel.getCopyOfNodesMap();
        const suppressSortOrder = this.gos.get("suppressMaintainUnsortedOrder");
        const orderMap = suppressSortOrder ? void 0 : {};
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(rowData)) rowData.forEach((data, index)=>{
            const id = getRowIdFunc({
                data: data,
                level: 0
            });
            const existingNode = existingNodesMap[id];
            if (orderMap) orderMap[id] = index;
            if (existingNode) {
                const dataHasChanged = existingNode.data !== data;
                if (dataHasChanged) transaction.update.push(data);
                existingNodesMap[id] = void 0;
            } else transaction.add.push(data);
        });
        $7b57b57eaf5a9648$export$9ecc2f8c52ebeeb8(existingNodesMap, (id, rowNode)=>{
            if (rowNode) transaction.remove.push(rowNode.data);
        });
        return [
            transaction,
            orderMap
        ];
    }
    onRowDataUpdated() {
        const rowData = this.gos.get("rowData");
        if (!rowData) return;
        if (this.isActive()) this.setRowData(rowData);
        else {
            this.selectionService.reset("rowDataChanged");
            this.clientSideRowModel.setRowData(rowData);
        }
    }
};
// community-modules/client-side-row-model/src/clientSideRowModel/sortService.ts
var $7b57b57eaf5a9648$var$SortService = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "sortService";
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.funcColsService = beans.funcColsService;
        this.rowNodeSorter = beans.rowNodeSorter;
        this.showRowGroupColsService = beans.showRowGroupColsService;
    }
    sort(sortOptions, sortActive, useDeltaSort, rowNodeTransactions, changedPath, sortContainsGroupColumns) {
        const groupMaintainOrder = this.gos.get("groupMaintainOrder");
        const groupColumnsPresent = this.columnModel.getCols().some((c)=>c.isRowGroupActive());
        let allDirtyNodes = {};
        if (useDeltaSort && rowNodeTransactions) allDirtyNodes = this.calculateDirtyNodes(rowNodeTransactions);
        const isPivotMode = this.columnModel.isPivotMode();
        const postSortFunc = this.gos.getCallback("postSortRows");
        const callback = (rowNode)=>{
            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);
            const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;
            const skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;
            if (skipSortingGroups) {
                const nextGroup = this.funcColsService.getRowGroupColumns()?.[rowNode.level + 1];
                const wasSortExplicitlyRemoved = nextGroup?.getSort() === null;
                const childrenToBeSorted = rowNode.childrenAfterAggFilter.slice(0);
                if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {
                    const indexedOrders = {};
                    rowNode.childrenAfterSort.forEach((node, idx)=>{
                        indexedOrders[node.id] = idx;
                    });
                    childrenToBeSorted.sort((row1, row2)=>(indexedOrders[row1.id] ?? 0) - (indexedOrders[row2.id] ?? 0));
                }
                rowNode.childrenAfterSort = childrenToBeSorted;
            } else if (!sortActive || skipSortingPivotLeafs) rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter.slice(0);
            else if (useDeltaSort) rowNode.childrenAfterSort = this.doDeltaSort(rowNode, allDirtyNodes, changedPath, sortOptions);
            else rowNode.childrenAfterSort = this.rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter, sortOptions);
            if (rowNode.sibling) rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;
            this.updateChildIndexes(rowNode);
            if (postSortFunc) {
                const params = {
                    nodes: rowNode.childrenAfterSort
                };
                postSortFunc(params);
            }
        };
        if (changedPath) changedPath.forEachChangedNodeDepthFirst(callback);
        this.updateGroupDataForHideOpenParents(changedPath);
    }
    calculateDirtyNodes(rowNodeTransactions) {
        const dirtyNodes = {};
        const addNodesFunc = (rowNodes)=>{
            if (rowNodes) rowNodes.forEach((rowNode)=>dirtyNodes[rowNode.id] = true);
        };
        if (rowNodeTransactions) rowNodeTransactions.forEach((tran)=>{
            addNodesFunc(tran.add);
            addNodesFunc(tran.update);
            addNodesFunc(tran.remove);
        });
        return dirtyNodes;
    }
    doDeltaSort(rowNode, allTouchedNodes, changedPath, sortOptions) {
        const unsortedRows = rowNode.childrenAfterAggFilter;
        const oldSortedRows = rowNode.childrenAfterSort;
        if (!oldSortedRows) return this.rowNodeSorter.doFullSort(unsortedRows, sortOptions);
        const untouchedRowsMap = {};
        const touchedRows = [];
        unsortedRows.forEach((row)=>{
            if (allTouchedNodes[row.id] || !changedPath.canSkip(row)) touchedRows.push(row);
            else untouchedRowsMap[row.id] = true;
        });
        const sortedUntouchedRows = oldSortedRows.filter((child)=>untouchedRowsMap[child.id]);
        const mapNodeToSortedNode = (rowNode2, pos)=>({
                currentPos: pos,
                rowNode: rowNode2
            });
        const sortedChangedRows = touchedRows.map(mapNodeToSortedNode).sort((a, b)=>this.rowNodeSorter.compareRowNodes(sortOptions, a, b));
        return this.mergeSortedArrays(sortOptions, sortedChangedRows, sortedUntouchedRows.map(mapNodeToSortedNode)).map(({ rowNode: rowNode2  })=>rowNode2);
    }
    // Merge two sorted arrays into each other
    mergeSortedArrays(sortOptions, arr1, arr2) {
        const res = [];
        let i = 0;
        let j = 0;
        while(i < arr1.length && j < arr2.length){
            const compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);
            if (compareResult < 0) res.push(arr1[i++]);
            else res.push(arr2[j++]);
        }
        while(i < arr1.length)res.push(arr1[i++]);
        while(j < arr2.length)res.push(arr2[j++]);
        return res;
    }
    updateChildIndexes(rowNode) {
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(rowNode.childrenAfterSort)) return;
        const listToSort = rowNode.childrenAfterSort;
        for(let i = 0; i < listToSort.length; i++){
            const child = listToSort[i];
            const firstChild = i === 0;
            const lastChild = i === rowNode.childrenAfterSort.length - 1;
            child.setFirstChild(firstChild);
            child.setLastChild(lastChild);
            child.setChildIndex(i);
        }
    }
    updateGroupDataForHideOpenParents(changedPath) {
        if (!this.gos.get("groupHideOpenParents")) return;
        if (this.gos.get("treeData")) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them.`);
            return false;
        }
        const callback = (rowNode)=>{
            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);
            rowNode.childrenAfterSort.forEach((child)=>{
                if (child.hasChildren()) callback(child);
            });
        };
        if (changedPath) changedPath.executeFromRootNode((rowNode)=>callback(rowNode));
    }
    pullDownGroupDataForHideOpenParents(rowNodes, clearOperation) {
        if (!this.gos.get("groupHideOpenParents") || $7b57b57eaf5a9648$export$672d9e47bc342bac(rowNodes)) return;
        rowNodes.forEach((childRowNode)=>{
            const groupDisplayCols = this.showRowGroupColsService?.getShowRowGroupCols() ?? [];
            groupDisplayCols.forEach((groupDisplayCol)=>{
                const showRowGroup = groupDisplayCol.getColDef().showRowGroup;
                if (typeof showRowGroup !== "string") {
                    $7b57b57eaf5a9648$export$ab3c32f4f4a12b49("groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup");
                    return;
                }
                const displayingGroupKey = showRowGroup;
                const rowGroupColumn = this.columnModel.getColDefCol(displayingGroupKey);
                const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;
                if (thisRowNodeMatches) return;
                if (clearOperation) childRowNode.setGroupValue(groupDisplayCol.getId(), void 0);
                else {
                    const parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);
                    if (parentToStealFrom) childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);
                }
            });
        });
    }
};
// community-modules/client-side-row-model/src/clientSideRowModel/sortStage.ts
var $7b57b57eaf5a9648$var$SortStage = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "sortStage";
    }
    wireBeans(beans) {
        this.sortService = beans.sortService;
        this.sortController = beans.sortController;
    }
    execute(params) {
        const sortOptions = this.sortController.getSortOptions();
        const sortActive = $7b57b57eaf5a9648$export$25d27f17d3af40f7(sortOptions) && sortOptions.length > 0;
        const deltaSort = sortActive && $7b57b57eaf5a9648$export$25d27f17d3af40f7(params.rowNodeTransactions) && // in time we can remove this check, so that delta sort is always
        // on if transactions are present. it's off for now so that we can
        // selectively turn it on and test it with some select users before
        // rolling out to everyone.
        this.gos.get("deltaSort");
        const sortContainsGroupColumns = sortOptions.some((opt)=>{
            const isSortingCoupled = this.gos.isColumnsSortingCoupledToGroup();
            if (isSortingCoupled) return opt.column.isPrimary() && opt.column.isRowGroupActive();
            return !!opt.column.getColDef().showRowGroup;
        });
        this.sortService.sort(sortOptions, sortActive, deltaSort, params.rowNodeTransactions, params.changedPath, sortContainsGroupColumns);
    }
};
// community-modules/client-side-row-model/src/version.ts
var $7b57b57eaf5a9648$var$VERSION2 = "32.0.1";
// community-modules/client-side-row-model/src/clientSideRowModelModule.ts
var $7b57b57eaf5a9648$var$ClientSideRowModelCoreModule = {
    version: $7b57b57eaf5a9648$var$VERSION2,
    moduleName: `${"@ag-grid-community/client-side-row-model" /* ClientSideRowModelModule */ }-core`,
    rowModel: "clientSide",
    beans: [
        $7b57b57eaf5a9648$var$ClientSideRowModel,
        $7b57b57eaf5a9648$var$FilterStage,
        $7b57b57eaf5a9648$var$SortStage,
        $7b57b57eaf5a9648$var$FlattenStage,
        $7b57b57eaf5a9648$var$SortService,
        $7b57b57eaf5a9648$var$ImmutableService
    ]
};
var $7b57b57eaf5a9648$var$ClientSideRowModelApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION2,
    moduleName: `${"@ag-grid-community/client-side-row-model" /* ClientSideRowModelModule */ }-api`,
    beans: [
        $7b57b57eaf5a9648$export$d00661386d616044
    ],
    apiFunctions: {
        onGroupExpandedOrCollapsed: $7b57b57eaf5a9648$var$onGroupExpandedOrCollapsed,
        refreshClientSideRowModel: $7b57b57eaf5a9648$var$refreshClientSideRowModel,
        forEachLeafNode: $7b57b57eaf5a9648$var$forEachLeafNode,
        forEachNodeAfterFilter: $7b57b57eaf5a9648$var$forEachNodeAfterFilter,
        forEachNodeAfterFilterAndSort: $7b57b57eaf5a9648$var$forEachNodeAfterFilterAndSort,
        resetRowHeights: $7b57b57eaf5a9648$var$resetRowHeights,
        applyTransaction: $7b57b57eaf5a9648$var$applyTransaction,
        applyTransactionAsync: $7b57b57eaf5a9648$var$applyTransactionAsync,
        flushAsyncTransactions: $7b57b57eaf5a9648$var$flushAsyncTransactions,
        getBestCostNodeSelection: $7b57b57eaf5a9648$var$getBestCostNodeSelection
    },
    dependantModules: [
        $7b57b57eaf5a9648$var$ClientSideRowModelCoreModule,
        $7b57b57eaf5a9648$export$76fb120d9e251426
    ]
};
var $7b57b57eaf5a9648$export$4c74201d5a94c8e5 = {
    version: $7b57b57eaf5a9648$var$VERSION2,
    moduleName: "@ag-grid-community/client-side-row-model" /* ClientSideRowModelModule */ ,
    dependantModules: [
        $7b57b57eaf5a9648$var$ClientSideRowModelCoreModule,
        $7b57b57eaf5a9648$var$ClientSideRowModelApiModule
    ]
};
// community-modules/csv-export/dist/package/main.esm.mjs
var $7b57b57eaf5a9648$export$b335f23c5aead909 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    setBeans(beans) {
        this.beans = beans;
    }
    getFileName(fileName) {
        const extension = this.getDefaultFileExtension();
        if (fileName == null || !fileName.length) fileName = this.getDefaultFileName();
        return fileName.indexOf(".") === -1 ? `${fileName}.${extension}` : fileName;
    }
    getData(params) {
        const serializingSession = this.createSerializingSession(params);
        return this.beans.gridSerializer.serialize(serializingSession, params);
    }
    getDefaultFileName() {
        return `export.${this.getDefaultFileExtension()}`;
    }
};
var $7b57b57eaf5a9648$export$5018ab277b833b61 = class {
    constructor(config){
        this.groupColumns = [];
        const { columnModel: columnModel , funcColsService: funcColsService , columnNameService: columnNameService , valueService: valueService , gos: gos , processCellCallback: processCellCallback , processHeaderCallback: processHeaderCallback , processGroupHeaderCallback: processGroupHeaderCallback , processRowGroupCallback: processRowGroupCallback  } = config;
        this.columnModel = columnModel;
        this.funcColsService = funcColsService;
        this.columnNameService = columnNameService;
        this.valueService = valueService;
        this.gos = gos;
        this.processCellCallback = processCellCallback;
        this.processHeaderCallback = processHeaderCallback;
        this.processGroupHeaderCallback = processGroupHeaderCallback;
        this.processRowGroupCallback = processRowGroupCallback;
    }
    prepare(columnsToExport) {
        this.groupColumns = columnsToExport.filter((col)=>!!col.getColDef().showRowGroup);
    }
    extractHeaderValue(column) {
        const value = this.getHeaderName(this.processHeaderCallback, column);
        return value ?? "";
    }
    extractRowCellValue(column, index, accumulatedRowIndex, type, node) {
        const hideOpenParents = this.gos.get("groupHideOpenParents");
        const value = (!hideOpenParents || node.footer) && this.shouldRenderGroupSummaryCell(node, column, index) ? this.createValueForGroupNode(column, node) : this.valueService.getValue(column, node);
        const processedValue = this.processCell({
            accumulatedRowIndex: accumulatedRowIndex,
            rowNode: node,
            column: column,
            value: value,
            processCellCallback: this.processCellCallback,
            type: type
        });
        return processedValue;
    }
    shouldRenderGroupSummaryCell(node, column, currentColumnIndex) {
        const isGroupNode = node && node.group;
        if (!isGroupNode) return false;
        const currentColumnGroupIndex = this.groupColumns.indexOf(column);
        if (currentColumnGroupIndex !== -1) {
            if (node.groupData?.[column.getId()] != null) return true;
            if (this.gos.isRowModelType("serverSide") && node.group) return true;
            if (node.footer && node.level === -1) {
                const colDef = column.getColDef();
                const isFullWidth = colDef == null || colDef.showRowGroup === true;
                return isFullWidth || colDef.showRowGroup === this.funcColsService.getRowGroupColumns()[0].getId();
            }
        }
        const isGroupUseEntireRow = this.gos.isGroupUseEntireRow(this.columnModel.isPivotMode());
        return currentColumnIndex === 0 && isGroupUseEntireRow;
    }
    getHeaderName(callback, column) {
        if (callback) return callback(this.gos.addGridCommonParams({
            column: column
        }));
        return this.columnNameService.getDisplayNameForColumn(column, "csv", true);
    }
    createValueForGroupNode(column, node) {
        if (this.processRowGroupCallback) return this.processRowGroupCallback(this.gos.addGridCommonParams({
            column: column,
            node: node
        }));
        const isTreeData = this.gos.get("treeData");
        const isSuppressGroupMaintainValueType = this.gos.get("suppressGroupMaintainValueType");
        const getValueFromNode = (node2)=>{
            if (isTreeData || isSuppressGroupMaintainValueType) return node2.key;
            const value = node2.groupData?.[column.getId()];
            if (!value || !node2.rowGroupColumn || node2.rowGroupColumn.getColDef().useValueFormatterForExport === false) return value;
            return this.valueService.formatValue(node2.rowGroupColumn, node2, value) ?? value;
        };
        const isFooter = node.footer;
        const keys = [
            getValueFromNode(node)
        ];
        if (!this.gos.isGroupMultiAutoColumn()) while(node.parent){
            node = node.parent;
            keys.push(getValueFromNode(node));
        }
        const groupValue = keys.reverse().join(" -> ");
        return isFooter ? `Total ${groupValue}` : groupValue;
    }
    processCell(params) {
        const { accumulatedRowIndex: accumulatedRowIndex , rowNode: rowNode , column: column , value: value , processCellCallback: processCellCallback , type: type  } = params;
        if (processCellCallback) return {
            value: processCellCallback(this.gos.addGridCommonParams({
                accumulatedRowIndex: accumulatedRowIndex,
                column: column,
                node: rowNode,
                value: value,
                type: type,
                parseValue: (valueToParse)=>this.valueService.parseValue(column, rowNode, valueToParse, this.valueService.getValue(column, rowNode)),
                formatValue: (valueToFormat)=>this.valueService.formatValue(column, rowNode, valueToFormat) ?? valueToFormat
            })) ?? ""
        };
        if (column.getColDef().useValueFormatterForExport !== false) return {
            value: value ?? "",
            valueFormatted: this.valueService.formatValue(column, rowNode, value)
        };
        return {
            value: value ?? ""
        };
    }
};
var $7b57b57eaf5a9648$export$ef06e7620d37c296 = class {
    static download(fileName, content) {
        const win = document.defaultView || window;
        if (!win) {
            $7b57b57eaf5a9648$export$2cf41453020eef66("There is no `window` associated with the current `document`");
            return;
        }
        const element = document.createElement("a");
        const url = win.URL.createObjectURL(content);
        element.setAttribute("href", url);
        element.setAttribute("download", fileName);
        element.style.display = "none";
        document.body.appendChild(element);
        element.dispatchEvent(new MouseEvent("click", {
            bubbles: false,
            cancelable: true,
            view: win
        }));
        document.body.removeChild(element);
        win.setTimeout(()=>{
            win.URL.revokeObjectURL(url);
        }, 0);
    }
};
var $7b57b57eaf5a9648$var$LINE_SEPARATOR = "\r\n";
var $7b57b57eaf5a9648$var$CsvSerializingSession = class extends $7b57b57eaf5a9648$export$5018ab277b833b61 {
    constructor(config){
        super(config);
        this.isFirstLine = true;
        this.result = "";
        const { suppressQuotes: suppressQuotes , columnSeparator: columnSeparator  } = config;
        this.suppressQuotes = suppressQuotes;
        this.columnSeparator = columnSeparator;
    }
    addCustomContent(content) {
        if (!content) return;
        if (typeof content === "string") {
            if (!/^\s*\n/.test(content)) this.beginNewLine();
            content = content.replace(/\r?\n/g, $7b57b57eaf5a9648$var$LINE_SEPARATOR);
            this.result += content;
        } else content.forEach((row)=>{
            this.beginNewLine();
            row.forEach((cell, index)=>{
                if (index !== 0) this.result += this.columnSeparator;
                this.result += this.putInQuotes(cell.data.value || "");
                if (cell.mergeAcross) this.appendEmptyCells(cell.mergeAcross);
            });
        });
    }
    onNewHeaderGroupingRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
        };
    }
    onNewHeaderGroupingRowColumn(columnGroup, header, index, span) {
        if (index != 0) this.result += this.columnSeparator;
        this.result += this.putInQuotes(header);
        this.appendEmptyCells(span);
    }
    appendEmptyCells(count) {
        for(let i = 1; i <= count; i++)this.result += this.columnSeparator + this.putInQuotes("");
    }
    onNewHeaderRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewHeaderRowColumn.bind(this)
        };
    }
    onNewHeaderRowColumn(column, index) {
        if (index != 0) this.result += this.columnSeparator;
        this.result += this.putInQuotes(this.extractHeaderValue(column));
    }
    onNewBodyRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewBodyRowColumn.bind(this)
        };
    }
    onNewBodyRowColumn(column, index, node) {
        if (index != 0) this.result += this.columnSeparator;
        const rowCellValue = this.extractRowCellValue(column, index, index, "csv", node);
        this.result += this.putInQuotes(rowCellValue.valueFormatted ?? rowCellValue.value);
    }
    putInQuotes(value) {
        if (this.suppressQuotes) return value;
        if (value === null || value === void 0) return '""';
        let stringValue;
        if (typeof value === "string") stringValue = value;
        else if (typeof value.toString === "function") stringValue = value.toString();
        else {
            $7b57b57eaf5a9648$export$2cf41453020eef66("unknown value type during csv conversion");
            stringValue = "";
        }
        const valueEscaped = stringValue.replace(/"/g, '""');
        return '"' + valueEscaped + '"';
    }
    parse() {
        return this.result;
    }
    beginNewLine() {
        if (!this.isFirstLine) this.result += $7b57b57eaf5a9648$var$LINE_SEPARATOR;
        this.isFirstLine = false;
    }
};
var $7b57b57eaf5a9648$export$8ff7d5e0eafc769c = class extends $7b57b57eaf5a9648$export$b335f23c5aead909 {
    constructor(){
        super(...arguments);
        this.beanName = "csvCreator";
    }
    wireBeans(beans) {
        this.columnModel = beans.columnModel;
        this.columnNameService = beans.columnNameService;
        this.funcColsService = beans.funcColsService;
        this.valueService = beans.valueService;
        this.gridSerializer = beans.gridSerializer;
    }
    postConstruct() {
        this.setBeans({
            gridSerializer: this.gridSerializer,
            gos: this.gos
        });
    }
    getMergedParams(params) {
        const baseParams = this.gos.get("defaultCsvExportParams");
        return Object.assign({}, baseParams, params);
    }
    export(userParams) {
        if (this.isExportSuppressed()) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`Export cancelled. Export is not allowed as per your configuration.`);
            return;
        }
        const mergedParams = this.getMergedParams(userParams);
        const data = this.getData(mergedParams);
        const packagedFile = new Blob([
            "\uFEFF",
            data
        ], {
            type: "text/plain"
        });
        const fileName = typeof mergedParams.fileName === "function" ? mergedParams.fileName(this.gos.getGridCommonParams()) : mergedParams.fileName;
        $7b57b57eaf5a9648$export$ef06e7620d37c296.download(this.getFileName(fileName), packagedFile);
    }
    exportDataAsCsv(params) {
        this.export(params);
    }
    getDataAsCsv(params, skipDefaultParams = false) {
        const mergedParams = skipDefaultParams ? Object.assign({}, params) : this.getMergedParams(params);
        return this.getData(mergedParams);
    }
    getDefaultFileExtension() {
        return "csv";
    }
    createSerializingSession(params) {
        const { columnModel: columnModel , columnNameService: columnNameService , funcColsService: funcColsService , valueService: valueService , gos: gos  } = this;
        const { processCellCallback: processCellCallback , processHeaderCallback: processHeaderCallback , processGroupHeaderCallback: processGroupHeaderCallback , processRowGroupCallback: processRowGroupCallback , suppressQuotes: suppressQuotes , columnSeparator: columnSeparator  } = params;
        return new $7b57b57eaf5a9648$var$CsvSerializingSession({
            columnModel: columnModel,
            columnNameService: columnNameService,
            funcColsService: funcColsService,
            valueService: valueService,
            gos: gos,
            processCellCallback: processCellCallback || void 0,
            processHeaderCallback: processHeaderCallback || void 0,
            processGroupHeaderCallback: processGroupHeaderCallback || void 0,
            processRowGroupCallback: processRowGroupCallback || void 0,
            suppressQuotes: suppressQuotes || false,
            columnSeparator: columnSeparator || ","
        });
    }
    isExportSuppressed() {
        return this.gos.get("suppressCsvExport");
    }
};
function $7b57b57eaf5a9648$var$getDataAsCsv(beans, params) {
    return beans.csvCreator?.getDataAsCsv(params);
}
function $7b57b57eaf5a9648$var$exportDataAsCsv(beans, params) {
    beans.csvCreator?.exportDataAsCsv(params);
}
var $7b57b57eaf5a9648$export$6c09164be112ad33 = /* @__PURE__ */ ((RowType2)=>{
    RowType2[RowType2["HEADER_GROUPING"] = 0] = "HEADER_GROUPING";
    RowType2[RowType2["HEADER"] = 1] = "HEADER";
    RowType2[RowType2["BODY"] = 2] = "BODY";
    return RowType2;
})($7b57b57eaf5a9648$export$6c09164be112ad33 || {});
var $7b57b57eaf5a9648$export$6ec40cbcb0344850 = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "gridSerializer";
    }
    wireBeans(beans) {
        this.visibleColsService = beans.visibleColsService;
        this.columnModel = beans.columnModel;
        this.columnNameService = beans.columnNameService;
        this.rowModel = beans.rowModel;
        this.pinnedRowModel = beans.pinnedRowModel;
        this.selectionService = beans.selectionService;
        this.rowNodeSorter = beans.rowNodeSorter;
        this.sortController = beans.sortController;
    }
    serialize(gridSerializingSession, params = {}) {
        const { allColumns: allColumns , columnKeys: columnKeys , skipRowGroups: skipRowGroups  } = params;
        const columnsToExport = this.getColumnsToExport(allColumns, skipRowGroups, columnKeys);
        const serializeChain = $7b57b57eaf5a9648$export$142f8ba6f38315ec(// first pass, put in the header names of the cols
        this.prepareSession(columnsToExport), this.prependContent(params), this.exportColumnGroups(params, columnsToExport), this.exportHeaders(params, columnsToExport), this.processPinnedTopRows(params, columnsToExport), this.processRows(params, columnsToExport), this.processPinnedBottomRows(params, columnsToExport), this.appendContent(params));
        return serializeChain(gridSerializingSession).parse();
    }
    processRow(gridSerializingSession, params, columnsToExport, node) {
        const rowSkipper = params.shouldRowBeSkipped || (()=>false);
        const skipSingleChildrenGroup = this.gos.get("groupRemoveSingleChildren");
        const skipLowestSingleChildrenGroup = this.gos.get("groupRemoveLowestSingleChildren");
        const isClipboardExport = params.rowPositions != null;
        const isExplicitExportSelection = isClipboardExport || !!params.onlySelected;
        const hideOpenParents = this.gos.get("groupHideOpenParents") && !isExplicitExportSelection;
        const isLeafNode = this.columnModel.isPivotMode() ? node.leafGroup : !node.group;
        const isFooter = !!node.footer;
        const shouldSkipLowestGroup = skipLowestSingleChildrenGroup && node.leafGroup;
        const shouldSkipCurrentGroup = node.allChildrenCount === 1 && node.childrenAfterGroup?.length === 1 && (skipSingleChildrenGroup || shouldSkipLowestGroup);
        if (!isLeafNode && !isFooter && (params.skipRowGroups || shouldSkipCurrentGroup || hideOpenParents) || params.onlySelected && !node.isSelected() || params.skipPinnedTop && node.rowPinned === "top" || params.skipPinnedBottom && node.rowPinned === "bottom") return;
        const nodeIsRootNode = node.level === -1;
        if (nodeIsRootNode && !isLeafNode && !isFooter) return;
        const shouldRowBeSkipped = rowSkipper(this.gos.addGridCommonParams({
            node: node
        }));
        if (shouldRowBeSkipped) return;
        const rowAccumulator = gridSerializingSession.onNewBodyRow(node);
        columnsToExport.forEach((column, index)=>{
            rowAccumulator.onColumn(column, index, node);
        });
        if (params.getCustomContentBelowRow) {
            const content = params.getCustomContentBelowRow(this.gos.addGridCommonParams({
                node: node
            }));
            if (content) gridSerializingSession.addCustomContent(content);
        }
    }
    appendContent(params) {
        return (gridSerializingSession)=>{
            const appendContent = params.appendContent;
            if (appendContent) gridSerializingSession.addCustomContent(appendContent);
            return gridSerializingSession;
        };
    }
    prependContent(params) {
        return (gridSerializingSession)=>{
            const prependContent = params.prependContent;
            if (prependContent) gridSerializingSession.addCustomContent(prependContent);
            return gridSerializingSession;
        };
    }
    prepareSession(columnsToExport) {
        return (gridSerializingSession)=>{
            gridSerializingSession.prepare(columnsToExport);
            return gridSerializingSession;
        };
    }
    exportColumnGroups(params, columnsToExport) {
        return (gridSerializingSession)=>{
            if (!params.skipColumnGroupHeaders) {
                const idCreator = new $7b57b57eaf5a9648$export$b3b24737a74261fb();
                const displayedGroups = this.visibleColsService.createGroups({
                    columns: columnsToExport,
                    idCreator: idCreator,
                    pinned: null,
                    isStandaloneStructure: true
                });
                this.recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, params.processGroupHeaderCallback);
            }
            return gridSerializingSession;
        };
    }
    exportHeaders(params, columnsToExport) {
        return (gridSerializingSession)=>{
            if (!params.skipColumnHeaders) {
                const gridRowIterator = gridSerializingSession.onNewHeaderRow();
                columnsToExport.forEach((column, index)=>{
                    gridRowIterator.onColumn(column, index, void 0);
                });
            }
            return gridSerializingSession;
        };
    }
    processPinnedTopRows(params, columnsToExport) {
        return (gridSerializingSession)=>{
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            if (params.rowPositions) params.rowPositions.filter((position)=>position.rowPinned === "top").sort((a, b)=>a.rowIndex - b.rowIndex).map((position)=>this.pinnedRowModel.getPinnedTopRow(position.rowIndex)).forEach(processRow);
            else this.pinnedRowModel.forEachPinnedTopRow(processRow);
            return gridSerializingSession;
        };
    }
    processRows(params, columnsToExport) {
        return (gridSerializingSession)=>{
            const rowModel = this.rowModel;
            const rowModelType = rowModel.getType();
            const usingCsrm = rowModelType === "clientSide";
            const usingSsrm = rowModelType === "serverSide";
            const onlySelectedNonStandardModel = !usingCsrm && params.onlySelected;
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            const { exportedRows: exportedRows = "filteredAndSorted"  } = params;
            if (params.rowPositions) params.rowPositions.filter((position)=>position.rowPinned == null).sort((a, b)=>a.rowIndex - b.rowIndex).map((position)=>rowModel.getRow(position.rowIndex)).forEach(processRow);
            else if (this.columnModel.isPivotMode()) {
                if (usingCsrm) rowModel.forEachPivotNode(processRow, true);
                else if (usingSsrm) rowModel.forEachNodeAfterFilterAndSort(processRow, true);
                else rowModel.forEachNode(processRow);
            } else if (params.onlySelectedAllPages || onlySelectedNonStandardModel) {
                const selectedNodes = this.selectionService.getSelectedNodes();
                this.replicateSortedOrder(selectedNodes);
                selectedNodes.forEach(processRow);
            } else {
                if (exportedRows === "all") rowModel.forEachNode(processRow);
                else if (usingCsrm) rowModel.forEachNodeAfterFilterAndSort(processRow, true);
                else if (usingSsrm) rowModel.forEachNodeAfterFilterAndSort(processRow, true);
                else rowModel.forEachNode(processRow);
            }
            return gridSerializingSession;
        };
    }
    replicateSortedOrder(rows) {
        const sortOptions = this.sortController.getSortOptions();
        const compareNodes = (rowA, rowB)=>{
            if (rowA.rowIndex != null && rowB.rowIndex != null) return rowA.rowIndex - rowB.rowIndex;
            if (rowA.level === rowB.level) {
                if (rowA.parent?.id === rowB.parent?.id) return this.rowNodeSorter.compareRowNodes(sortOptions, {
                    rowNode: rowA,
                    currentPos: rowA.rowIndex ?? -1
                }, {
                    rowNode: rowB,
                    currentPos: rowB.rowIndex ?? -1
                });
                return compareNodes(rowA.parent, rowB.parent);
            }
            if (rowA.level > rowB.level) return compareNodes(rowA.parent, rowB);
            return compareNodes(rowA, rowB.parent);
        };
        rows.sort(compareNodes);
    }
    processPinnedBottomRows(params, columnsToExport) {
        return (gridSerializingSession)=>{
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            if (params.rowPositions) params.rowPositions.filter((position)=>position.rowPinned === "bottom").sort((a, b)=>a.rowIndex - b.rowIndex).map((position)=>this.pinnedRowModel.getPinnedBottomRow(position.rowIndex)).forEach(processRow);
            else this.pinnedRowModel.forEachPinnedBottomRow(processRow);
            return gridSerializingSession;
        };
    }
    getColumnsToExport(allColumns = false, skipRowGroups = false, columnKeys) {
        const isPivotMode = this.columnModel.isPivotMode();
        if (columnKeys && columnKeys.length) return this.columnModel.getColsForKeys(columnKeys);
        const isTreeData = this.gos.get("treeData");
        let columnsToExport = [];
        if (allColumns && !isPivotMode) columnsToExport = this.columnModel.getCols();
        else columnsToExport = this.visibleColsService.getAllCols();
        if (skipRowGroups && !isTreeData) columnsToExport = columnsToExport.filter((column)=>column.getColId() !== $7b57b57eaf5a9648$export$a7016588c430dba6);
        return columnsToExport;
    }
    recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, processGroupHeaderCallback) {
        const directChildrenHeaderGroups = [];
        displayedGroups.forEach((columnGroupChild)=>{
            const columnGroup = columnGroupChild;
            if (!columnGroup.getChildren) return;
            columnGroup.getChildren().forEach((it)=>directChildrenHeaderGroups.push(it));
        });
        if (displayedGroups.length > 0 && $7b57b57eaf5a9648$export$1f44a60fc23f9028(displayedGroups[0])) this.doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback);
        if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) this.recursivelyAddHeaderGroups(directChildrenHeaderGroups, gridSerializingSession, processGroupHeaderCallback);
    }
    doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback) {
        const gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();
        let columnIndex = 0;
        displayedGroups.forEach((columnGroupChild)=>{
            const columnGroup = columnGroupChild;
            let name;
            if (processGroupHeaderCallback) name = processGroupHeaderCallback(this.gos.addGridCommonParams({
                columnGroup: columnGroup
            }));
            else name = this.columnNameService.getDisplayNameForColumnGroup(columnGroup, "header");
            const collapsibleGroupRanges = columnGroup.getLeafColumns().reduce((collapsibleGroups, currentColumn, currentIdx, arr)=>{
                let lastGroup = $7b57b57eaf5a9648$export$236389741107357f(collapsibleGroups);
                const groupShow = currentColumn.getColumnGroupShow() === "open";
                if (!groupShow) {
                    if (lastGroup && lastGroup[1] == null) lastGroup[1] = currentIdx - 1;
                } else if (!lastGroup || lastGroup[1] != null) {
                    lastGroup = [
                        currentIdx
                    ];
                    collapsibleGroups.push(lastGroup);
                }
                if (currentIdx === arr.length - 1 && lastGroup && lastGroup[1] == null) lastGroup[1] = currentIdx;
                return collapsibleGroups;
            }, []);
            gridRowIterator.onColumn(columnGroup, name || "", columnIndex++, columnGroup.getLeafColumns().length - 1, collapsibleGroupRanges);
        });
    }
};
var $7b57b57eaf5a9648$var$VERSION3 = "32.0.1";
var $7b57b57eaf5a9648$export$334a8abd8351f1fb = {
    version: $7b57b57eaf5a9648$var$VERSION3,
    moduleName: `${"@ag-grid-community/csv-export" /* CsvExportModule */ }-core`,
    beans: [
        $7b57b57eaf5a9648$export$8ff7d5e0eafc769c,
        $7b57b57eaf5a9648$export$6ec40cbcb0344850
    ]
};
var $7b57b57eaf5a9648$var$CsvExportApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION3,
    moduleName: `${"@ag-grid-community/csv-export" /* CsvExportModule */ }-api`,
    apiFunctions: {
        getDataAsCsv: $7b57b57eaf5a9648$var$getDataAsCsv,
        exportDataAsCsv: $7b57b57eaf5a9648$var$exportDataAsCsv
    },
    dependantModules: [
        $7b57b57eaf5a9648$export$334a8abd8351f1fb
    ]
};
var $7b57b57eaf5a9648$export$f744275d8b795fc2 = {
    version: $7b57b57eaf5a9648$var$VERSION3,
    moduleName: "@ag-grid-community/csv-export" /* CsvExportModule */ ,
    dependantModules: [
        $7b57b57eaf5a9648$export$334a8abd8351f1fb,
        $7b57b57eaf5a9648$var$CsvExportApiModule
    ]
};
var $7b57b57eaf5a9648$var$LINE_SEPARATOR2 = "\r\n";
function $7b57b57eaf5a9648$var$returnAttributeIfPopulated(key, value, booleanTransformer) {
    if (!value && value !== "" && value !== 0) return "";
    let xmlValue = value;
    if (typeof value === "boolean") {
        if (booleanTransformer) xmlValue = booleanTransformer(value);
    }
    return ` ${key}="${xmlValue}"`;
}
var $7b57b57eaf5a9648$export$1abb521838b54ff = class {
    static createHeader(headerElement = {}) {
        const headerStart = "<?";
        const headerEnd = "?>";
        const keys = [
            "version"
        ];
        if (!headerElement.version) headerElement.version = "1.0";
        if (headerElement.encoding) keys.push("encoding");
        if (headerElement.standalone) keys.push("standalone");
        const att = keys.map((key)=>`${key}="${headerElement[key]}"`).join(" ");
        return `${headerStart}xml ${att} ${headerEnd}`;
    }
    static createXml(xmlElement, booleanTransformer) {
        let props = "";
        if (xmlElement.properties) {
            if (xmlElement.properties.prefixedAttributes) xmlElement.properties.prefixedAttributes.forEach((prefixedSet)=>{
                Object.keys(prefixedSet.map).forEach((key)=>{
                    props += $7b57b57eaf5a9648$var$returnAttributeIfPopulated(prefixedSet.prefix + key, prefixedSet.map[key], booleanTransformer);
                });
            });
            if (xmlElement.properties.rawMap) Object.keys(xmlElement.properties.rawMap).forEach((key)=>{
                props += $7b57b57eaf5a9648$var$returnAttributeIfPopulated(key, xmlElement.properties.rawMap[key], booleanTransformer);
            });
        }
        let result = "<" + xmlElement.name + props;
        if (!xmlElement.children && xmlElement.textNode == null) return result + "/>" + $7b57b57eaf5a9648$var$LINE_SEPARATOR2;
        if (xmlElement.textNode != null) return result + ">" + xmlElement.textNode + "</" + xmlElement.name + ">" + $7b57b57eaf5a9648$var$LINE_SEPARATOR2;
        result += ">" + $7b57b57eaf5a9648$var$LINE_SEPARATOR2;
        if (xmlElement.children) xmlElement.children.forEach((it)=>{
            result += this.createXml(it, booleanTransformer);
        });
        return result + "</" + xmlElement.name + ">" + $7b57b57eaf5a9648$var$LINE_SEPARATOR2;
    }
};
var $7b57b57eaf5a9648$var$compressBlob = async (data)=>{
    let chunksSize = 0;
    const chunks = [];
    const writeCompressedData = new WritableStream({
        write: (chunk)=>{
            chunks.push(chunk);
            chunksSize += chunk.length;
        }
    });
    const readable = new ReadableStream({
        start: (controller)=>{
            const reader = new FileReader();
            reader.onload = (e)=>{
                if (e.target?.result) controller.enqueue(e.target.result);
                controller.close();
            };
            reader.readAsArrayBuffer(data);
        }
    });
    const compressStream = new window.CompressionStream("deflate-raw");
    await readable.pipeThrough(compressStream).pipeTo(writeCompressedData);
    return {
        size: chunksSize,
        content: new Blob(chunks)
    };
};
var $7b57b57eaf5a9648$var$deflateLocalFile = async (rawContent)=>{
    const contentAsBlob = new Blob([
        rawContent
    ]);
    const { size: compressedSize , content: compressedContent  } = await $7b57b57eaf5a9648$var$compressBlob(contentAsBlob);
    const compressedContentAsUint8Array = new Uint8Array(await compressedContent.arrayBuffer());
    return {
        size: compressedSize,
        content: compressedContentAsUint8Array
    };
};
var $7b57b57eaf5a9648$var$convertTime = (date)=>{
    let time = date.getHours();
    time <<= 6;
    time = time | date.getMinutes();
    time <<= 5;
    time = time | date.getSeconds() / 2;
    return time;
};
var $7b57b57eaf5a9648$var$convertDate = (date)=>{
    let dt = date.getFullYear() - 1980;
    dt <<= 4;
    dt = dt | date.getMonth() + 1;
    dt <<= 5;
    dt = dt | date.getDate();
    return dt;
};
function $7b57b57eaf5a9648$var$convertDecToHex(number, bytes) {
    let hex = "";
    for(let i = 0; i < bytes; i++){
        hex += String.fromCharCode(number & 255);
        number >>>= 8;
    }
    return hex;
}
var $7b57b57eaf5a9648$var$getCrcFromCrc32TableAndByteArray = (content)=>{
    if (!content.length) return 0;
    let crc = -1;
    let j = 0;
    let k = 0;
    let l = 0;
    for(let i = 0; i < content.length; i++){
        j = content[i];
        k = (crc ^ j) & 255;
        l = $7b57b57eaf5a9648$var$crcTable[k];
        crc = crc >>> 8 ^ l;
    }
    return crc ^ -1;
};
var $7b57b57eaf5a9648$var$getCrcFromCrc32Table = (content)=>{
    if (!content.length) return 0;
    if (typeof content === "string") return $7b57b57eaf5a9648$var$getCrcFromCrc32TableAndByteArray(new TextEncoder().encode(content));
    return $7b57b57eaf5a9648$var$getCrcFromCrc32TableAndByteArray(content);
};
var $7b57b57eaf5a9648$var$crcTable = new Uint32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
]);
var $7b57b57eaf5a9648$var$getHeaders = (currentFile, isCompressed, offset, rawSize, rawContent, deflatedSize)=>{
    const { content: content , path: path , created: creationDate  } = currentFile;
    const time = $7b57b57eaf5a9648$var$convertTime(creationDate);
    const dt = $7b57b57eaf5a9648$var$convertDate(creationDate);
    const crcFlag = $7b57b57eaf5a9648$var$getCrcFromCrc32Table(rawContent);
    const zipSize = deflatedSize !== void 0 ? deflatedSize : rawSize;
    const utfPath = $7b57b57eaf5a9648$export$3e99ec8a83701984(path);
    const isUTF8 = utfPath !== path;
    let extraFields = "";
    if (isUTF8) {
        const uExtraFieldPath = $7b57b57eaf5a9648$var$convertDecToHex(1, 1) + $7b57b57eaf5a9648$var$convertDecToHex($7b57b57eaf5a9648$var$getCrcFromCrc32Table(utfPath), 4) + utfPath;
        extraFields = "up" + $7b57b57eaf5a9648$var$convertDecToHex(uExtraFieldPath.length, 2) + uExtraFieldPath;
    }
    const commonHeader = "\x14\0" + // version needed to extract
    (isUTF8 ? "\0\b" : "\0\0") + // Language encoding flag (EFS) (12th bit turned on)
    $7b57b57eaf5a9648$var$convertDecToHex(isCompressed ? 8 : 0, 2) + // As per ECMA-376 Part 2 specs
    $7b57b57eaf5a9648$var$convertDecToHex(time, 2) + // last modified time
    $7b57b57eaf5a9648$var$convertDecToHex(dt, 2) + // last modified date
    $7b57b57eaf5a9648$var$convertDecToHex(zipSize ? crcFlag : 0, 4) + $7b57b57eaf5a9648$var$convertDecToHex(deflatedSize ?? rawSize, 4) + // compressed size
    $7b57b57eaf5a9648$var$convertDecToHex(rawSize, 4) + // uncompressed size
    $7b57b57eaf5a9648$var$convertDecToHex(utfPath.length, 2) + // file name length
    $7b57b57eaf5a9648$var$convertDecToHex(extraFields.length, 2);
    const localFileHeader = "PK\x03\x04" + commonHeader + utfPath + extraFields;
    const centralDirectoryHeader = "PK\x01\x02\x14\0" + commonHeader + // file header
    "\0\0\0\0\0\0" + (content ? "\0\0\0\0" : "\x10\0\0\0") + // external file attributes
    $7b57b57eaf5a9648$var$convertDecToHex(offset, 4) + // relative offset of local header
    utfPath + // file name
    extraFields;
    return {
        localFileHeader: Uint8Array.from(localFileHeader, (c)=>c.charCodeAt(0)),
        centralDirectoryHeader: Uint8Array.from(centralDirectoryHeader, (c)=>c.charCodeAt(0))
    };
};
var $7b57b57eaf5a9648$var$getDecodedContent = (content)=>{
    let contentToUse;
    if (typeof content === "string") {
        const base64String = atob(content.split(";base64,")[1]);
        contentToUse = Uint8Array.from(base64String, (c)=>c.charCodeAt(0));
    } else contentToUse = content;
    return {
        size: contentToUse.length,
        content: contentToUse
    };
};
var $7b57b57eaf5a9648$var$getDeflatedHeaderAndContent = async (currentFile, offset)=>{
    const { content: content  } = currentFile;
    const { size: size , content: rawContent  } = !content ? {
        size: 0,
        content: Uint8Array.from([])
    } : $7b57b57eaf5a9648$var$getDecodedContent(content);
    let deflatedContent = void 0;
    let deflatedSize = void 0;
    let deflationPerformed = false;
    const shouldDeflate = currentFile.type === "file" && rawContent && size > 0;
    if (shouldDeflate) {
        const result = await $7b57b57eaf5a9648$var$deflateLocalFile(rawContent);
        deflatedContent = result.content;
        deflatedSize = result.size;
        deflationPerformed = true;
    }
    const headers = $7b57b57eaf5a9648$var$getHeaders(currentFile, deflationPerformed, offset, size, rawContent, deflatedSize);
    return {
        ...headers,
        content: deflatedContent || rawContent,
        isCompressed: deflationPerformed
    };
};
var $7b57b57eaf5a9648$var$getHeaderAndContent = (currentFile, offset)=>{
    const { content: content  } = currentFile;
    const { content: rawContent  } = !content ? {
        content: Uint8Array.from([])
    } : $7b57b57eaf5a9648$var$getDecodedContent(content);
    const headers = $7b57b57eaf5a9648$var$getHeaders(currentFile, false, offset, rawContent.length, rawContent, void 0);
    return {
        ...headers,
        content: rawContent,
        isCompressed: false
    };
};
var $7b57b57eaf5a9648$var$buildCentralDirectoryEnd = (tLen, cLen, lLen)=>{
    const str = "PK\x05\x06\0\0\0\0" + $7b57b57eaf5a9648$var$convertDecToHex(tLen, 2) + // total number of entries in the central folder
    $7b57b57eaf5a9648$var$convertDecToHex(tLen, 2) + // total number of entries in the central folder
    $7b57b57eaf5a9648$var$convertDecToHex(cLen, 4) + // size of the central folder
    $7b57b57eaf5a9648$var$convertDecToHex(lLen, 4) + // central folder start offset
    "\0\0";
    return Uint8Array.from(str, (c)=>c.charCodeAt(0));
};
var $7b57b57eaf5a9648$export$35dc58f6886fc963 = class {
    static addFolders(paths) {
        paths.forEach(this.addFolder.bind(this));
    }
    static addFolder(path) {
        this.folders.push({
            path: path,
            created: /* @__PURE__ */ new Date(),
            isBase64: false,
            type: "folder"
        });
    }
    static addFile(path, content, isBase64 = false) {
        this.files.push({
            path: path,
            created: /* @__PURE__ */ new Date(),
            content: isBase64 ? content : new TextEncoder().encode(content),
            isBase64: isBase64,
            type: "file"
        });
    }
    static async getZipFile(mimeType = "application/zip") {
        const textOutput = await this.buildCompressedFileStream();
        this.clearStream();
        return new Blob([
            textOutput
        ], {
            type: mimeType
        });
    }
    static getUncompressedZipFile(mimeType = "application/zip") {
        const textOutput = this.buildFileStream();
        this.clearStream();
        return new Blob([
            textOutput
        ], {
            type: mimeType
        });
    }
    static clearStream() {
        this.folders = [];
        this.files = [];
    }
    static packageFiles(files) {
        let fileLen = 0;
        let folderLen = 0;
        for (const currentFile of files){
            const { localFileHeader: localFileHeader , centralDirectoryHeader: centralDirectoryHeader , content: content  } = currentFile;
            fileLen += localFileHeader.length + content.length;
            folderLen += centralDirectoryHeader.length;
        }
        const fileData = new Uint8Array(fileLen);
        const folderData = new Uint8Array(folderLen);
        let fileOffset = 0;
        let folderOffset = 0;
        for (const currentFile of files){
            const { localFileHeader: localFileHeader , centralDirectoryHeader: centralDirectoryHeader , content: content  } = currentFile;
            fileData.set(localFileHeader, fileOffset);
            fileOffset += localFileHeader.length;
            fileData.set(content, fileOffset);
            fileOffset += content.length;
            folderData.set(centralDirectoryHeader, folderOffset);
            folderOffset += centralDirectoryHeader.length;
        }
        const folderEnd = $7b57b57eaf5a9648$var$buildCentralDirectoryEnd(files.length, folderLen, fileLen);
        const result = new Uint8Array(fileData.length + folderData.length + folderEnd.length);
        result.set(fileData);
        result.set(folderData, fileData.length);
        result.set(folderEnd, fileData.length + folderData.length);
        return result;
    }
    static async buildCompressedFileStream() {
        const totalFiles = [
            ...this.folders,
            ...this.files
        ];
        const readyFiles = [];
        let lL = 0;
        for (const currentFile of totalFiles){
            const output = await $7b57b57eaf5a9648$var$getDeflatedHeaderAndContent(currentFile, lL);
            const { localFileHeader: localFileHeader , content: content  } = output;
            readyFiles.push(output);
            lL += localFileHeader.length + content.length;
        }
        return this.packageFiles(readyFiles);
    }
    static buildFileStream() {
        const totalFiles = [
            ...this.folders,
            ...this.files
        ];
        const readyFiles = [];
        let lL = 0;
        for (const currentFile of totalFiles){
            const readyFile = $7b57b57eaf5a9648$var$getHeaderAndContent(currentFile, lL);
            const { localFileHeader: localFileHeader , content: content  } = readyFile;
            readyFiles.push(readyFile);
            lL += localFileHeader.length + content.length;
        }
        return this.packageFiles(readyFiles);
    }
};
$7b57b57eaf5a9648$export$35dc58f6886fc963.folders = [];
$7b57b57eaf5a9648$export$35dc58f6886fc963.files = [];
// community-modules/infinite-row-model/dist/package/main.esm.mjs
var $7b57b57eaf5a9648$var$InfiniteBlock = class extends $7b57b57eaf5a9648$export$eb7378abb0bca09e {
    wireBeans(beans) {
        this.beans = beans;
    }
    constructor(id, parentCache, params){
        super(id);
        this.parentCache = parentCache;
        this.params = params;
        this.startRow = id * params.blockSize;
        this.endRow = this.startRow + params.blockSize;
    }
    postConstruct() {
        this.createRowNodes();
    }
    getBlockStateJson() {
        return {
            id: "" + this.getId(),
            state: {
                blockNumber: this.getId(),
                startRow: this.getStartRow(),
                endRow: this.getEndRow(),
                pageStatus: this.getState()
            }
        };
    }
    setDataAndId(rowNode, data, index) {
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(data)) rowNode.setDataAndId(data, index.toString());
        else rowNode.setDataAndId(void 0, void 0);
    }
    loadFromDatasource() {
        const params = this.createLoadParams();
        if ($7b57b57eaf5a9648$export$672d9e47bc342bac(this.params.datasource.getRows)) {
            $7b57b57eaf5a9648$export$2cf41453020eef66(`datasource is missing getRows method`);
            return;
        }
        window.setTimeout(()=>{
            this.params.datasource.getRows(params);
        }, 0);
    }
    processServerFail() {}
    createLoadParams() {
        const params = {
            startRow: this.getStartRow(),
            endRow: this.getEndRow(),
            successCallback: this.pageLoaded.bind(this, this.getVersion()),
            failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
            sortModel: this.params.sortModel,
            filterModel: this.params.filterModel,
            context: this.gos.getGridCommonParams().context
        };
        return params;
    }
    forEachNode(callback, sequence, rowCount) {
        this.rowNodes.forEach((rowNode, index)=>{
            const rowIndex = this.startRow + index;
            if (rowIndex < rowCount) callback(rowNode, sequence.next());
        });
    }
    getLastAccessed() {
        return this.lastAccessed;
    }
    getRow(rowIndex, dontTouchLastAccessed = false) {
        if (!dontTouchLastAccessed) this.lastAccessed = this.params.lastAccessedSequence.next();
        const localIndex = rowIndex - this.startRow;
        return this.rowNodes[localIndex];
    }
    getStartRow() {
        return this.startRow;
    }
    getEndRow() {
        return this.endRow;
    }
    // creates empty row nodes, data is missing as not loaded yet
    createRowNodes() {
        this.rowNodes = [];
        for(let i = 0; i < this.params.blockSize; i++){
            const rowIndex = this.startRow + i;
            const rowNode = new $7b57b57eaf5a9648$export$6af91cd58ec2edf9(this.beans);
            rowNode.setRowHeight(this.params.rowHeight);
            rowNode.uiLevel = 0;
            rowNode.setRowIndex(rowIndex);
            rowNode.setRowTop(this.params.rowHeight * rowIndex);
            this.rowNodes.push(rowNode);
        }
    }
    processServerResult(params) {
        this.rowNodes.forEach((rowNode, index)=>{
            const data = params.rowData ? params.rowData[index] : void 0;
            if (!rowNode.id && rowNode.alreadyRendered && data) {
                this.rowNodes[index] = new $7b57b57eaf5a9648$export$6af91cd58ec2edf9(this.beans);
                this.rowNodes[index].setRowIndex(rowNode.rowIndex);
                this.rowNodes[index].setRowTop(rowNode.rowTop);
                this.rowNodes[index].setRowHeight(rowNode.rowHeight);
                rowNode.clearRowTopAndRowIndex();
            }
            this.setDataAndId(this.rowNodes[index], data, this.startRow + index);
        });
        const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : void 0;
        this.parentCache.pageLoaded(this, finalRowCount);
    }
    destroy() {
        this.rowNodes.forEach((rowNode)=>{
            rowNode.clearRowTopAndRowIndex();
        });
        super.destroy();
    }
};
var $7b57b57eaf5a9648$var$MAX_EMPTY_BLOCKS_TO_KEEP = 2;
var $7b57b57eaf5a9648$var$InfiniteCache = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(params){
        super();
        this.lastRowIndexKnown = false;
        this.blocks = {};
        this.blockCount = 0;
        this.rowCount = params.initialRowCount;
        this.params = params;
    }
    wireBeans(beans) {
        this.rowRenderer = beans.rowRenderer;
        this.focusService = beans.focusService;
    }
    // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
    // it will want new pages in the cache as it asks for rows. only when we are inserting /
    // removing rows via the api is dontCreatePage set, where we move rows between the pages.
    getRow(rowIndex, dontCreatePage = false) {
        const blockId = Math.floor(rowIndex / this.params.blockSize);
        let block = this.blocks[blockId];
        if (!block) {
            if (dontCreatePage) return void 0;
            block = this.createBlock(blockId);
        }
        return block.getRow(rowIndex);
    }
    createBlock(blockNumber) {
        const newBlock = this.createBean(new $7b57b57eaf5a9648$var$InfiniteBlock(blockNumber, this, this.params));
        this.blocks[newBlock.getId()] = newBlock;
        this.blockCount++;
        this.purgeBlocksIfNeeded(newBlock);
        this.params.rowNodeBlockLoader.addBlock(newBlock);
        return newBlock;
    }
    // we have this on infinite row model only, not server side row model,
    // because for server side, it would leave the children in inconsistent
    // state - eg if a node had children, but after the refresh it had data
    // for a different row, then the children would be with the wrong row node.
    refreshCache() {
        const nothingToRefresh = this.blockCount == 0;
        if (nothingToRefresh) {
            this.purgeCache();
            return;
        }
        this.getBlocksInOrder().forEach((block)=>block.setStateWaitingToLoad());
        this.params.rowNodeBlockLoader.checkBlockToLoad();
    }
    destroy() {
        this.getBlocksInOrder().forEach((block)=>this.destroyBlock(block));
        super.destroy();
    }
    getRowCount() {
        return this.rowCount;
    }
    isLastRowIndexKnown() {
        return this.lastRowIndexKnown;
    }
    // block calls this, when page loaded
    pageLoaded(block, lastRow) {
        if (!this.isAlive()) return;
        if (this.gos.get("debug")) $7b57b57eaf5a9648$export$1ce471ee7a8b4d23(`InfiniteCache - onPageLoaded: page = ${block.getId()}, lastRow = ${lastRow}`);
        this.checkRowCount(block, lastRow);
        this.onCacheUpdated();
    }
    purgeBlocksIfNeeded(blockToExclude) {
        const blocksForPurging = this.getBlocksInOrder().filter((b)=>b != blockToExclude);
        const lastAccessedComparator = (a, b)=>b.getLastAccessed() - a.getLastAccessed();
        blocksForPurging.sort(lastAccessedComparator);
        const maxBlocksProvided = this.params.maxBlocksInCache > 0;
        const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache - 1 : null;
        const emptyBlocksToKeep = $7b57b57eaf5a9648$var$MAX_EMPTY_BLOCKS_TO_KEEP - 1;
        blocksForPurging.forEach((block, index)=>{
            const purgeBecauseBlockEmpty = block.getState() === "needsLoading" && index >= emptyBlocksToKeep;
            const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;
            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {
                if (this.isBlockCurrentlyDisplayed(block)) return;
                if (this.isBlockFocused(block)) return;
                this.removeBlockFromCache(block);
            }
        });
    }
    isBlockFocused(block) {
        const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();
        if (!focusedCell) return false;
        if (focusedCell.rowPinned != null) return false;
        const blockIndexStart = block.getStartRow();
        const blockIndexEnd = block.getEndRow();
        const hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;
        return hasFocus;
    }
    isBlockCurrentlyDisplayed(block) {
        const startIndex = block.getStartRow();
        const endIndex = block.getEndRow() - 1;
        return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);
    }
    removeBlockFromCache(blockToRemove) {
        if (!blockToRemove) return;
        this.destroyBlock(blockToRemove);
    }
    checkRowCount(block, lastRow) {
        if (typeof lastRow === "number" && lastRow >= 0) {
            this.rowCount = lastRow;
            this.lastRowIndexKnown = true;
        } else if (!this.lastRowIndexKnown) {
            const lastRowIndex = (block.getId() + 1) * this.params.blockSize;
            const lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;
            if (this.rowCount < lastRowIndexPlusOverflow) this.rowCount = lastRowIndexPlusOverflow;
        }
    }
    setRowCount(rowCount, lastRowIndexKnown) {
        this.rowCount = rowCount;
        if ($7b57b57eaf5a9648$export$25d27f17d3af40f7(lastRowIndexKnown)) this.lastRowIndexKnown = lastRowIndexKnown;
        if (!this.lastRowIndexKnown) {
            if (this.rowCount % this.params.blockSize === 0) this.rowCount++;
        }
        this.onCacheUpdated();
    }
    forEachNodeDeep(callback) {
        const sequence = new $7b57b57eaf5a9648$export$9bbf3cc62ef6fcad();
        this.getBlocksInOrder().forEach((block)=>block.forEachNode(callback, sequence, this.rowCount));
    }
    getBlocksInOrder() {
        const blockComparator = (a, b)=>a.getId() - b.getId();
        const blocks = $7b57b57eaf5a9648$export$2f52ef471f042094(this.blocks).sort(blockComparator);
        return blocks;
    }
    destroyBlock(block) {
        delete this.blocks[block.getId()];
        this.destroyBean(block);
        this.blockCount--;
        this.params.rowNodeBlockLoader.removeBlock(block);
    }
    // gets called 1) row count changed 2) cache purged 3) items inserted
    onCacheUpdated() {
        if (this.isAlive()) {
            this.destroyAllBlocksPastVirtualRowCount();
            const event = {
                type: "storeUpdated"
            };
            this.eventService.dispatchEvent(event);
        }
    }
    destroyAllBlocksPastVirtualRowCount() {
        const blocksToDestroy = [];
        this.getBlocksInOrder().forEach((block)=>{
            const startRow = block.getId() * this.params.blockSize;
            if (startRow >= this.rowCount) blocksToDestroy.push(block);
        });
        if (blocksToDestroy.length > 0) blocksToDestroy.forEach((block)=>this.destroyBlock(block));
    }
    purgeCache() {
        this.getBlocksInOrder().forEach((block)=>this.removeBlockFromCache(block));
        this.lastRowIndexKnown = false;
        if (this.rowCount === 0) this.rowCount = this.params.initialRowCount;
        this.onCacheUpdated();
    }
    getRowNodesInRange(firstInRange, lastInRange) {
        const result = [];
        let lastBlockId = -1;
        let inActiveRange = false;
        const numberSequence = new $7b57b57eaf5a9648$export$9bbf3cc62ef6fcad();
        let foundGapInSelection = false;
        this.getBlocksInOrder().forEach((block)=>{
            if (foundGapInSelection) return;
            if (inActiveRange && lastBlockId + 1 !== block.getId()) {
                foundGapInSelection = true;
                return;
            }
            lastBlockId = block.getId();
            block.forEachNode((rowNode)=>{
                const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;
                if (inActiveRange || hitFirstOrLast) result.push(rowNode);
                if (hitFirstOrLast) inActiveRange = !inActiveRange;
            }, numberSequence, this.rowCount);
        });
        const invalidRange = foundGapInSelection || inActiveRange;
        return invalidRange ? [] : result;
    }
};
var $7b57b57eaf5a9648$var$InfiniteRowModel = class extends $7b57b57eaf5a9648$export$2032c8ef3788dfbd {
    constructor(){
        super(...arguments);
        this.beanName = "rowModel";
    }
    wireBeans(beans) {
        this.filterManager = beans.filterManager;
        this.sortController = beans.sortController;
        this.selectionService = beans.selectionService;
        this.rowRenderer = beans.rowRenderer;
        this.rowNodeBlockLoader = beans.rowNodeBlockLoader;
    }
    getRowBounds(index) {
        return {
            rowHeight: this.rowHeight,
            rowTop: this.rowHeight * index
        };
    }
    // we don't implement as lazy row heights is not supported in this row model
    ensureRowHeightsValid() {
        return false;
    }
    postConstruct() {
        if (!this.gos.isRowModelType("infinite")) return;
        this.rowHeight = this.gos.getRowHeightAsNumber();
        this.addEventListeners();
        this.addDestroyFunc(()=>this.destroyCache());
        this.verifyProps();
    }
    verifyProps() {
        if (this.gos.exists("initialGroupOrderComparator")) $7b57b57eaf5a9648$export$2cf41453020eef66("initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side");
    }
    start() {
        this.setDatasource(this.gos.get("datasource"));
    }
    destroy() {
        this.destroyDatasource();
        super.destroy();
    }
    destroyDatasource() {
        if (this.datasource) {
            this.destroyBean(this.datasource);
            this.rowRenderer.datasourceChanged();
            this.datasource = null;
        }
    }
    addEventListeners() {
        this.addManagedEventListeners({
            filterChanged: this.onFilterChanged.bind(this),
            sortChanged: this.onSortChanged.bind(this),
            newColumnsLoaded: this.onColumnEverything.bind(this),
            storeUpdated: this.onCacheUpdated.bind(this)
        });
        this.addManagedPropertyListener("datasource", ()=>this.setDatasource(this.gos.get("datasource")));
        this.addManagedPropertyListener("cacheBlockSize", ()=>this.resetCache());
        this.addManagedPropertyListener("rowHeight", ()=>{
            this.rowHeight = this.gos.getRowHeightAsNumber();
            this.cacheParams.rowHeight = this.rowHeight;
            this.updateRowHeights();
        });
    }
    onFilterChanged() {
        this.reset();
    }
    onSortChanged() {
        this.reset();
    }
    onColumnEverything() {
        let resetRequired;
        if (this.cacheParams) resetRequired = this.isSortModelDifferent();
        else resetRequired = true;
        if (resetRequired) this.reset();
    }
    isSortModelDifferent() {
        return !$7b57b57eaf5a9648$export$dbc2068cc90f5875(this.cacheParams.sortModel, this.sortController.getSortModel());
    }
    getType() {
        return "infinite";
    }
    setDatasource(datasource) {
        this.destroyDatasource();
        this.datasource = datasource;
        if (datasource) this.reset();
    }
    isEmpty() {
        return !this.infiniteCache;
    }
    isRowsToRender() {
        return !!this.infiniteCache;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
        return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange) : [];
    }
    reset() {
        if (!this.datasource) return;
        const getRowIdFunc = this.gos.getRowIdCallback();
        const userGeneratingIds = getRowIdFunc != null;
        if (!userGeneratingIds) this.selectionService.reset("rowDataChanged");
        this.resetCache();
    }
    createModelUpdatedEvent() {
        return {
            type: "modelUpdated",
            // not sure if these should all be false - noticed if after implementing,
            // maybe they should be true?
            newPage: false,
            newPageSize: false,
            newData: false,
            keepRenderedRows: true,
            animate: false
        };
    }
    resetCache() {
        this.destroyCache();
        this.cacheParams = {
            // the user provided datasource
            datasource: this.datasource,
            // sort and filter model
            filterModel: this.filterManager?.getFilterModel() ?? {},
            sortModel: this.sortController.getSortModel(),
            rowNodeBlockLoader: this.rowNodeBlockLoader,
            // properties - this way we take a snapshot of them, so if user changes any, they will be
            // used next time we create a new cache, which is generally after a filter or sort change,
            // or a new datasource is set
            initialRowCount: this.gos.get("infiniteInitialRowCount"),
            maxBlocksInCache: this.gos.get("maxBlocksInCache"),
            rowHeight: this.gos.getRowHeightAsNumber(),
            // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
            // the current page and request first row of next page
            overflowSize: this.gos.get("cacheOverflowSize"),
            // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
            // server for one page at a time. so the default if not specified is 100.
            blockSize: this.gos.get("cacheBlockSize"),
            // the cache could create this, however it is also used by the pages, so handy to create it
            // here as the settings are also passed to the pages
            lastAccessedSequence: new $7b57b57eaf5a9648$export$9bbf3cc62ef6fcad()
        };
        this.infiniteCache = this.createBean(new $7b57b57eaf5a9648$var$InfiniteCache(this.cacheParams));
        this.eventService.dispatchEventOnce({
            type: "rowCountReady"
        });
        const event = this.createModelUpdatedEvent();
        this.eventService.dispatchEvent(event);
    }
    updateRowHeights() {
        this.forEachNode((node)=>{
            node.setRowHeight(this.rowHeight);
            node.setRowTop(this.rowHeight * node.rowIndex);
        });
        const event = this.createModelUpdatedEvent();
        this.eventService.dispatchEvent(event);
    }
    destroyCache() {
        if (this.infiniteCache) this.infiniteCache = this.destroyBean(this.infiniteCache);
    }
    onCacheUpdated() {
        const event = this.createModelUpdatedEvent();
        this.eventService.dispatchEvent(event);
    }
    getRow(rowIndex) {
        if (!this.infiniteCache) return void 0;
        if (rowIndex >= this.infiniteCache.getRowCount()) return void 0;
        return this.infiniteCache.getRow(rowIndex);
    }
    getRowNode(id) {
        let result;
        this.forEachNode((rowNode)=>{
            if (rowNode.id === id) result = rowNode;
        });
        return result;
    }
    forEachNode(callback) {
        if (this.infiniteCache) this.infiniteCache.forEachNodeDeep(callback);
    }
    getTopLevelRowCount() {
        return this.getRowCount();
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        return topLevelIndex;
    }
    getRowIndexAtPixel(pixel) {
        if (this.rowHeight !== 0) {
            const rowIndexForPixel = Math.floor(pixel / this.rowHeight);
            const lastRowIndex = this.getRowCount() - 1;
            if (rowIndexForPixel > lastRowIndex) return lastRowIndex;
            return rowIndexForPixel;
        }
        return 0;
    }
    getRowCount() {
        return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
    }
    isRowPresent(rowNode) {
        const foundRowNode = this.getRowNode(rowNode.id);
        return !!foundRowNode;
    }
    refreshCache() {
        if (this.infiniteCache) this.infiniteCache.refreshCache();
    }
    purgeCache() {
        if (this.infiniteCache) this.infiniteCache.purgeCache();
    }
    // for iRowModel
    isLastRowIndexKnown() {
        if (this.infiniteCache) return this.infiniteCache.isLastRowIndexKnown();
        return false;
    }
    setRowCount(rowCount, lastRowIndexKnown) {
        if (this.infiniteCache) this.infiniteCache.setRowCount(rowCount, lastRowIndexKnown);
    }
};
function $7b57b57eaf5a9648$var$refreshInfiniteCache(beans) {
    beans.rowModelHelperService?.getInfiniteRowModel()?.refreshCache();
}
function $7b57b57eaf5a9648$var$purgeInfiniteCache(beans) {
    beans.rowModelHelperService?.getInfiniteRowModel()?.purgeCache();
}
function $7b57b57eaf5a9648$var$getInfiniteRowCount(beans) {
    return beans.rowModelHelperService?.getInfiniteRowModel()?.getRowCount();
}
function $7b57b57eaf5a9648$var$isLastRowIndexKnown(beans) {
    return beans.rowModelHelperService?.getInfiniteRowModel()?.isLastRowIndexKnown();
}
var $7b57b57eaf5a9648$var$VERSION4 = "32.0.1";
var $7b57b57eaf5a9648$var$InfiniteRowModelCoreModule = {
    version: $7b57b57eaf5a9648$var$VERSION4,
    moduleName: `${"@ag-grid-community/infinite-row-model" /* InfiniteRowModelModule */ }-core`,
    rowModel: "infinite",
    beans: [
        $7b57b57eaf5a9648$var$InfiniteRowModel
    ],
    dependantModules: [
        $7b57b57eaf5a9648$export$452a5acb3d5a3102
    ]
};
var $7b57b57eaf5a9648$var$InfiniteRowModelApiModule = {
    version: $7b57b57eaf5a9648$var$VERSION4,
    moduleName: `${"@ag-grid-community/infinite-row-model" /* InfiniteRowModelModule */ }-api`,
    beans: [
        $7b57b57eaf5a9648$export$d00661386d616044
    ],
    apiFunctions: {
        refreshInfiniteCache: $7b57b57eaf5a9648$var$refreshInfiniteCache,
        purgeInfiniteCache: $7b57b57eaf5a9648$var$purgeInfiniteCache,
        getInfiniteRowCount: $7b57b57eaf5a9648$var$getInfiniteRowCount,
        isLastRowIndexKnown: $7b57b57eaf5a9648$var$isLastRowIndexKnown
    },
    dependantModules: [
        $7b57b57eaf5a9648$var$InfiniteRowModelCoreModule,
        $7b57b57eaf5a9648$export$2f6740e35dedc261
    ]
};
var $7b57b57eaf5a9648$export$ca8341149bdd39bc = {
    version: $7b57b57eaf5a9648$var$VERSION4,
    moduleName: "@ag-grid-community/infinite-row-model" /* InfiniteRowModelModule */ ,
    dependantModules: [
        $7b57b57eaf5a9648$var$InfiniteRowModelCoreModule,
        $7b57b57eaf5a9648$var$InfiniteRowModelApiModule
    ]
};
// packages/ag-grid-community/src/main.ts
$7b57b57eaf5a9648$export$dc053975cc7f6c11.__registerModules([
    $7b57b57eaf5a9648$export$e7c66fbb2b880e54,
    $7b57b57eaf5a9648$export$4c74201d5a94c8e5,
    $7b57b57eaf5a9648$export$ca8341149bdd39bc,
    $7b57b57eaf5a9648$export$f744275d8b795fc2
], false, void 0);



var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");

var $aaLBe = parcelRequire("aaLBe");



var $aaLBe = parcelRequire("aaLBe");

var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");





var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");

var $aaLBe = parcelRequire("aaLBe");

var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");

var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");


var $aaLBe = parcelRequire("aaLBe");
var $89799df32d2d843b$var$BeansContext = (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createContext({});
// packages/ag-grid-react/src/reactUi/jsComp.tsx
var $89799df32d2d843b$var$showJsComp = (compDetails, context, eParent, ref)=>{
    const doNothing = !compDetails || compDetails.componentFromFramework || context.isDestroyed();
    if (doNothing) return;
    const promise = compDetails.newAgStackInstance();
    if (promise == null) return;
    let comp;
    let compGui;
    let destroyed = false;
    promise.then((c)=>{
        if (destroyed) {
            context.destroyBean(c);
            return;
        }
        comp = c;
        compGui = comp.getGui();
        eParent.appendChild(compGui);
        $89799df32d2d843b$var$setRef(ref, comp);
    });
    return ()=>{
        destroyed = true;
        if (!comp) return;
        if (compGui && compGui.parentElement) compGui.parentElement.removeChild(compGui);
        context.destroyBean(comp);
        if (ref) $89799df32d2d843b$var$setRef(ref, void 0);
    };
};
var $89799df32d2d843b$var$setRef = (ref, value)=>{
    if (!ref) return;
    if (ref instanceof Function) {
        const refCallback = ref;
        refCallback(value);
    } else {
        const refObj = ref;
        refObj.current = value;
    }
};
var $89799df32d2d843b$var$classesList = (...list)=>{
    const filtered = list.filter((s)=>s != null && s !== "");
    return filtered.join(" ");
};
var $89799df32d2d843b$var$CssClasses = class _CssClasses {
    constructor(...initialClasses){
        this.classesMap = {};
        initialClasses.forEach((className)=>{
            this.classesMap[className] = true;
        });
    }
    setClass(className, on) {
        const nothingHasChanged = !!this.classesMap[className] == on;
        if (nothingHasChanged) return this;
        const res = new _CssClasses();
        res.classesMap = {
            ...this.classesMap
        };
        res.classesMap[className] = on;
        return res;
    }
    toString() {
        const res = Object.keys(this.classesMap).filter((key)=>this.classesMap[key]).join(" ");
        return res;
    }
};
var $89799df32d2d843b$var$isComponentStateless = (Component2)=>{
    const hasSymbol = ()=>typeof Symbol === "function" && Symbol.for;
    const getMemoType = ()=>hasSymbol() ? Symbol.for("react.memo") : 60115;
    return typeof Component2 === "function" && !(Component2.prototype && Component2.prototype.isReactComponent) || typeof Component2 === "object" && Component2.$$typeof === getMemoType();
};
var $89799df32d2d843b$var$createRootAndFlushSyncAvailable = (0, (/*@__PURE__*/$parcel$interopDefault($ba021dca0cbd5bec$exports))).createRoot != null && (0, (/*@__PURE__*/$parcel$interopDefault($ba021dca0cbd5bec$exports))).flushSync != null;
function $89799df32d2d843b$var$isReact17Minus() {
    return !$89799df32d2d843b$var$createRootAndFlushSyncAvailable;
}
var $89799df32d2d843b$var$disableFlushSync = false;
function $89799df32d2d843b$var$runWithoutFlushSync(func) {
    if (!$89799df32d2d843b$var$disableFlushSync) setTimeout(()=>$89799df32d2d843b$var$disableFlushSync = false, 0);
    $89799df32d2d843b$var$disableFlushSync = true;
    return func();
}
var $89799df32d2d843b$var$agFlushSync = (useFlushSync, fn)=>{
    if ($89799df32d2d843b$var$createRootAndFlushSyncAvailable && useFlushSync && !$89799df32d2d843b$var$disableFlushSync) (0, (/*@__PURE__*/$parcel$interopDefault($ba021dca0cbd5bec$exports))).flushSync(fn);
    else fn();
};
function $89799df32d2d843b$var$getNextValueIfDifferent(prev, next, maintainOrder) {
    if (next == null || prev == null) return next;
    if (prev === next || next.length === 0 && prev.length === 0) return prev;
    if (maintainOrder || prev.length === 0 && next.length > 0 || prev.length > 0 && next.length === 0) return next;
    const oldValues = [];
    const newValues = [];
    const prevMap = /* @__PURE__ */ new Map();
    const nextMap = /* @__PURE__ */ new Map();
    for(let i = 0; i < next.length; i++){
        const c = next[i];
        nextMap.set(c.getInstanceId(), c);
    }
    for(let i = 0; i < prev.length; i++){
        const c = prev[i];
        prevMap.set(c.getInstanceId(), c);
        if (nextMap.has(c.getInstanceId())) oldValues.push(c);
    }
    for(let i = 0; i < next.length; i++){
        const c = next[i];
        const instanceId = c.getInstanceId();
        if (!prevMap.has(instanceId)) newValues.push(c);
    }
    if (oldValues.length === prev.length && newValues.length === 0) return prev;
    if (oldValues.length === 0 && newValues.length === next.length) return next;
    if (oldValues.length === 0) return newValues;
    if (newValues.length === 0) return oldValues;
    return [
        ...oldValues,
        ...newValues
    ];
}
// packages/ag-grid-react/src/reactUi/cellRenderer/groupCellRenderer.tsx
var $89799df32d2d843b$var$GroupCellRenderer = (0, $aaLBe.forwardRef)((props, ref)=>{
    const { ctrlsFactory: ctrlsFactory , context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const eGui = (0, $aaLBe.useRef)(null);
    const eValueRef = (0, $aaLBe.useRef)(null);
    const eCheckboxRef = (0, $aaLBe.useRef)(null);
    const eExpandedRef = (0, $aaLBe.useRef)(null);
    const eContractedRef = (0, $aaLBe.useRef)(null);
    const ctrlRef = (0, $aaLBe.useRef)();
    const [innerCompDetails, setInnerCompDetails] = (0, $aaLBe.useState)();
    const [childCount, setChildCount] = (0, $aaLBe.useState)();
    const [value, setValue] = (0, $aaLBe.useState)();
    const [cssClasses, setCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses());
    const [expandedCssClasses, setExpandedCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses("ag-hidden"));
    const [contractedCssClasses, setContractedCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses("ag-hidden"));
    const [checkboxCssClasses, setCheckboxCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses("ag-invisible"));
    (0, $aaLBe.useImperativeHandle)(ref, ()=>{
        return {
            // force new instance when grid tries to refresh
            refresh () {
                return false;
            }
        };
    });
    (0, $aaLBe.useLayoutEffect)(()=>{
        return $89799df32d2d843b$var$showJsComp(innerCompDetails, context, eValueRef.current);
    }, [
        innerCompDetails
    ]);
    const setRef2 = (0, $aaLBe.useCallback)((ref2)=>{
        eGui.current = ref2;
        if (!eGui.current) {
            context.destroyBean(ctrlRef.current);
            ctrlRef.current = null;
            return;
        }
        const compProxy = {
            setInnerRenderer: (details, valueToDisplay)=>{
                setInnerCompDetails(details);
                setValue(valueToDisplay);
            },
            setChildCount: (count)=>setChildCount(count),
            addOrRemoveCssClass: (name, on)=>setCssClasses((prev)=>prev.setClass(name, on)),
            setContractedDisplayed: (displayed)=>setContractedCssClasses((prev)=>prev.setClass("ag-hidden", !displayed)),
            setExpandedDisplayed: (displayed)=>setExpandedCssClasses((prev)=>prev.setClass("ag-hidden", !displayed)),
            setCheckboxVisible: (visible)=>setCheckboxCssClasses((prev)=>prev.setClass("ag-invisible", !visible))
        };
        const groupCellRendererCtrl = ctrlsFactory.getInstance("groupCellRendererCtrl");
        if (groupCellRendererCtrl) {
            ctrlRef.current = context.createBean(groupCellRendererCtrl);
            ctrlRef.current.init(compProxy, eGui.current, eCheckboxRef.current, eExpandedRef.current, eContractedRef.current, $89799df32d2d843b$var$GroupCellRenderer, props);
        }
    }, []);
    const className = (0, $aaLBe.useMemo)(()=>`ag-cell-wrapper ${cssClasses.toString()}`, [
        cssClasses
    ]);
    const expandedClassName = (0, $aaLBe.useMemo)(()=>`ag-group-expanded ${expandedCssClasses.toString()}`, [
        expandedCssClasses
    ]);
    const contractedClassName = (0, $aaLBe.useMemo)(()=>`ag-group-contracted ${contractedCssClasses.toString()}`, [
        contractedCssClasses
    ]);
    const checkboxClassName = (0, $aaLBe.useMemo)(()=>`ag-group-checkbox ${checkboxCssClasses.toString()}`, [
        checkboxCssClasses
    ]);
    const useFwRenderer = innerCompDetails && innerCompDetails.componentFromFramework;
    const FwRenderer = useFwRenderer ? innerCompDetails.componentClass : void 0;
    const useValue = innerCompDetails == null && value != null;
    const escapedValue = (0, $7b57b57eaf5a9648$export$3df06b741968da82)(value, true);
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("span", {
        className: className,
        ref: setRef2,
        ...!props.colDef ? {
            role: ctrlRef.current?.getCellAriaRole()
        } : {}
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("span", {
        className: expandedClassName,
        ref: eExpandedRef
    }), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("span", {
        className: contractedClassName,
        ref: eContractedRef
    }), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("span", {
        className: checkboxClassName,
        ref: eCheckboxRef
    }), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("span", {
        className: "ag-group-value",
        ref: eValueRef
    }, useValue && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, escapedValue), useFwRenderer && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(FwRenderer, {
        ...innerCompDetails.params
    })), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("span", {
        className: "ag-group-child-count"
    }, childCount));
});
var $89799df32d2d843b$var$groupCellRenderer_default = $89799df32d2d843b$var$GroupCellRenderer;
var $89799df32d2d843b$export$9f6317c67b47ac67 = (0, $aaLBe.createContext)({
    setMethods: ()=>{}
});
// packages/ag-grid-react/src/reactUi/customComp/customWrapperComp.tsx
var $89799df32d2d843b$var$CustomWrapperComp = (params)=>{
    const { initialProps: initialProps , addUpdateCallback: addUpdateCallback , CustomComponentClass: CustomComponentClass , setMethods: setMethods  } = params;
    const [props, setProps] = (0, $aaLBe.useState)(initialProps);
    (0, $aaLBe.useEffect)(()=>{
        addUpdateCallback((newProps)=>setProps(newProps));
    }, []);
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$export$9f6317c67b47ac67.Provider, {
        value: {
            setMethods: setMethods
        }
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(CustomComponentClass, {
        ...props
    }));
};
var $89799df32d2d843b$var$customWrapperComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$CustomWrapperComp);
// packages/ag-grid-react/src/shared/keyGenerator.ts
var $89799df32d2d843b$var$counter = 0;
function $89799df32d2d843b$var$generateNewKey() {
    return `agPortalKey_${++$89799df32d2d843b$var$counter}`;
}
// packages/ag-grid-react/src/shared/reactComponent.ts
var $89799df32d2d843b$var$ReactComponent = class {
    constructor(reactComponent, portalManager, componentType, suppressFallbackMethods){
        this.portal = null;
        this.oldPortal = null;
        this.reactComponent = reactComponent;
        this.portalManager = portalManager;
        this.componentType = componentType;
        this.suppressFallbackMethods = !!suppressFallbackMethods;
        this.statelessComponent = this.isStateless(this.reactComponent);
        this.key = $89799df32d2d843b$var$generateNewKey();
        this.portalKey = $89799df32d2d843b$var$generateNewKey();
        this.instanceCreated = this.isStatelessComponent() ? (0, $7b57b57eaf5a9648$export$30ec7836a4847721).resolve(false) : new (0, $7b57b57eaf5a9648$export$30ec7836a4847721)((resolve)=>{
            this.resolveInstanceCreated = resolve;
        });
    }
    getGui() {
        return this.eParentElement;
    }
    /** `getGui()` returns the parent element. This returns the actual root element. */ getRootElement() {
        const firstChild = this.eParentElement.firstChild;
        return firstChild;
    }
    destroy() {
        if (this.componentInstance && typeof this.componentInstance.destroy == "function") this.componentInstance.destroy();
        const portal = this.portal;
        if (portal) this.portalManager.destroyPortal(portal);
    }
    createParentElement(params) {
        const componentWrappingElement = this.portalManager.getComponentWrappingElement();
        const eParentElement = document.createElement(componentWrappingElement || "div");
        eParentElement.classList.add("ag-react-container");
        params.reactContainer = eParentElement;
        return eParentElement;
    }
    addParentContainerStyleAndClasses() {
        if (!this.componentInstance) return;
        if (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle()) {
            (0, $7b57b57eaf5a9648$export$2cf41453020eef66)('Since v31.1 "getReactContainerStyle" is deprecated. Apply styling directly to ".ag-react-container" if needed.');
            Object.assign(this.eParentElement.style, this.componentInstance.getReactContainerStyle());
        }
        if (this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses()) {
            (0, $7b57b57eaf5a9648$export$2cf41453020eef66)('Since v31.1 "getReactContainerClasses" is deprecated. Apply styling directly to ".ag-react-container" if needed.');
            const parentContainerClasses = this.componentInstance.getReactContainerClasses();
            parentContainerClasses.forEach((className)=>this.eParentElement.classList.add(className));
        }
    }
    statelessComponentRendered() {
        return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
    }
    getFrameworkComponentInstance() {
        return this.componentInstance;
    }
    isStatelessComponent() {
        return this.statelessComponent;
    }
    getReactComponentName() {
        return this.reactComponent.name;
    }
    getMemoType() {
        return this.hasSymbol() ? Symbol.for("react.memo") : 60115;
    }
    hasSymbol() {
        return typeof Symbol === "function" && Symbol.for;
    }
    isStateless(Component2) {
        return typeof Component2 === "function" && !(Component2.prototype && Component2.prototype.isReactComponent) || typeof Component2 === "object" && Component2.$$typeof === this.getMemoType();
    }
    hasMethod(name) {
        const frameworkComponentInstance = this.getFrameworkComponentInstance();
        return !!frameworkComponentInstance && frameworkComponentInstance[name] != null || this.fallbackMethodAvailable(name);
    }
    callMethod(name, args) {
        const frameworkComponentInstance = this.getFrameworkComponentInstance();
        if (this.isStatelessComponent()) return this.fallbackMethod(name, !!args && args[0] ? args[0] : {});
        else if (!frameworkComponentInstance) {
            setTimeout(()=>this.callMethod(name, args));
            return;
        }
        const method = frameworkComponentInstance[name];
        if (method) return method.apply(frameworkComponentInstance, args);
        if (this.fallbackMethodAvailable(name)) return this.fallbackMethod(name, !!args && args[0] ? args[0] : {});
    }
    addMethod(name, callback) {
        this[name] = callback;
    }
    init(params) {
        this.eParentElement = this.createParentElement(params);
        this.params = params;
        this.createOrUpdatePortal(params);
        return new (0, $7b57b57eaf5a9648$export$30ec7836a4847721)((resolve)=>this.createReactComponent(resolve));
    }
    createOrUpdatePortal(params) {
        if (!this.isStatelessComponent()) {
            this.ref = (element)=>{
                this.componentInstance = element;
                this.addParentContainerStyleAndClasses();
                this.resolveInstanceCreated?.(true);
                this.resolveInstanceCreated = void 0;
            };
            params.ref = this.ref;
        }
        this.reactElement = this.createElement(this.reactComponent, {
            ...params,
            key: this.key
        });
        this.portal = (0, $ba021dca0cbd5bec$exports.createPortal)(this.reactElement, this.eParentElement, this.portalKey);
    }
    createElement(reactComponent, props) {
        return (0, $aaLBe.createElement)(reactComponent, props);
    }
    createReactComponent(resolve) {
        this.portalManager.mountReactPortal(this.portal, this, resolve);
    }
    rendered() {
        return this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
    }
    /*
   * fallback methods - these will be invoked if a corresponding instance method is not present
   * for example if refresh is called and is not available on the component instance, then refreshComponent on this
   * class will be invoked instead
   *
   * Currently only refresh is supported
   */ refreshComponent(args) {
        this.oldPortal = this.portal;
        this.createOrUpdatePortal(args);
        this.portalManager.updateReactPortal(this.oldPortal, this.portal);
    }
    fallbackMethod(name, params) {
        const method = this[`${name}Component`];
        if (!this.suppressFallbackMethods && !!method) return method.bind(this)(params);
    }
    fallbackMethodAvailable(name) {
        if (this.suppressFallbackMethods) return false;
        const method = this[`${name}Component`];
        return !!method;
    }
};
// packages/ag-grid-react/src/shared/customComp/customComponentWrapper.ts
function $89799df32d2d843b$var$addOptionalMethods(optionalMethodNames, providedMethods, component) {
    optionalMethodNames.forEach((methodName)=>{
        const providedMethod = providedMethods[methodName];
        if (providedMethod) component[methodName] = providedMethod;
    });
}
var $89799df32d2d843b$var$CustomComponentWrapper = class extends $89799df32d2d843b$var$ReactComponent {
    constructor(){
        super(...arguments);
        this.awaitUpdateCallback = new (0, $7b57b57eaf5a9648$export$30ec7836a4847721)((resolve)=>{
            this.resolveUpdateCallback = resolve;
        });
        this.wrapperComponent = $89799df32d2d843b$var$customWrapperComp_default;
    }
    init(params) {
        this.sourceParams = params;
        return super.init(this.getProps());
    }
    addMethod() {}
    getInstance() {
        return this.instanceCreated.then(()=>this.componentInstance);
    }
    getFrameworkComponentInstance() {
        return this;
    }
    createElement(reactComponent, props) {
        return super.createElement(this.wrapperComponent, {
            initialProps: props,
            CustomComponentClass: reactComponent,
            setMethods: (methods)=>this.setMethods(methods),
            addUpdateCallback: (callback)=>{
                this.updateCallback = ()=>{
                    callback(this.getProps());
                    return new (0, $7b57b57eaf5a9648$export$30ec7836a4847721)((resolve)=>{
                        setTimeout(()=>{
                            resolve();
                        });
                    });
                };
                this.resolveUpdateCallback();
            }
        });
    }
    setMethods(methods) {
        this.providedMethods = methods;
        $89799df32d2d843b$var$addOptionalMethods(this.getOptionalMethods(), this.providedMethods, this);
    }
    getOptionalMethods() {
        return [];
    }
    getProps() {
        return {
            ...this.sourceParams,
            key: this.key,
            ref: this.ref
        };
    }
    refreshProps() {
        if (this.updateCallback) return this.updateCallback();
        return new (0, $7b57b57eaf5a9648$export$30ec7836a4847721)((resolve)=>this.awaitUpdateCallback.then(()=>{
                this.updateCallback().then(()=>resolve());
            }));
    }
};
// packages/ag-grid-react/src/shared/customComp/cellRendererComponentWrapper.ts
var $89799df32d2d843b$var$CellRendererComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    refresh(params) {
        this.sourceParams = params;
        this.refreshProps();
        return true;
    }
};
// packages/ag-grid-react/src/shared/customComp/dateComponentWrapper.ts
var $89799df32d2d843b$var$DateComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    constructor(){
        super(...arguments);
        this.date = null;
        this.onDateChange = (date)=>this.updateDate(date);
    }
    getDate() {
        return this.date;
    }
    setDate(date) {
        this.date = date;
        this.refreshProps();
    }
    refresh(params) {
        this.sourceParams = params;
        this.refreshProps();
    }
    getOptionalMethods() {
        return [
            "afterGuiAttached",
            "setInputPlaceholder",
            "setInputAriaLabel",
            "setDisabled"
        ];
    }
    updateDate(date) {
        this.setDate(date);
        this.sourceParams.onDateChanged();
    }
    getProps() {
        const props = super.getProps();
        props.date = this.date;
        props.onDateChange = this.onDateChange;
        delete props.onDateChanged;
        return props;
    }
};
// packages/ag-grid-react/src/shared/customComp/filterComponentWrapper.ts
var $89799df32d2d843b$var$FilterComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    constructor(){
        super(...arguments);
        this.model = null;
        this.onModelChange = (model)=>this.updateModel(model);
        this.onUiChange = ()=>this.sourceParams.filterChangedCallback();
        this.expectingNewMethods = true;
    }
    isFilterActive() {
        return this.model != null;
    }
    doesFilterPass(params) {
        return this.providedMethods.doesFilterPass(params);
    }
    getModel() {
        return this.model;
    }
    setModel(model) {
        this.expectingNewMethods = true;
        this.model = model;
        return this.refreshProps();
    }
    refresh(newParams) {
        this.sourceParams = newParams;
        this.refreshProps();
        return true;
    }
    getOptionalMethods() {
        return [
            "afterGuiAttached",
            "afterGuiDetached",
            "onNewRowsLoaded",
            "getModelAsString",
            "onAnyFilterChanged"
        ];
    }
    setMethods(methods) {
        if (this.expectingNewMethods === false && this.providedMethods?.doesFilterPass !== methods?.doesFilterPass) setTimeout(()=>{
            this.sourceParams.filterChangedCallback();
        });
        this.expectingNewMethods = false;
        super.setMethods(methods);
    }
    updateModel(model) {
        this.setModel(model).then(()=>this.sourceParams.filterChangedCallback());
    }
    getProps() {
        const props = super.getProps();
        props.model = this.model;
        props.onModelChange = this.onModelChange;
        props.onUiChange = this.onUiChange;
        delete props.filterChangedCallback;
        delete props.filterModifiedCallback;
        delete props.valueGetter;
        return props;
    }
};
function $89799df32d2d843b$var$updateFloatingFilterParent(params, model) {
    params.parentFilterInstance((instance)=>{
        (instance.setModel(model) || (0, $7b57b57eaf5a9648$export$30ec7836a4847721).resolve()).then(()=>{
            params.filterParams.filterChangedCallback();
        });
    });
}
var $89799df32d2d843b$var$FloatingFilterComponentProxy = class {
    constructor(floatingFilterParams, refreshProps){
        this.floatingFilterParams = floatingFilterParams;
        this.refreshProps = refreshProps;
        this.model = null;
        this.onModelChange = (model)=>this.updateModel(model);
    }
    getProps() {
        return {
            ...this.floatingFilterParams,
            model: this.model,
            onModelChange: this.onModelChange
        };
    }
    onParentModelChanged(parentModel) {
        this.model = parentModel;
        this.refreshProps();
    }
    refresh(params) {
        this.floatingFilterParams = params;
        this.refreshProps();
    }
    setMethods(methods) {
        $89799df32d2d843b$var$addOptionalMethods(this.getOptionalMethods(), methods, this);
    }
    getOptionalMethods() {
        return [
            "afterGuiAttached"
        ];
    }
    updateModel(model) {
        this.model = model;
        this.refreshProps();
        $89799df32d2d843b$var$updateFloatingFilterParent(this.floatingFilterParams, model);
    }
};
// packages/ag-grid-react/src/shared/customComp/floatingFilterComponentWrapper.ts
var $89799df32d2d843b$var$FloatingFilterComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    constructor(){
        super(...arguments);
        this.model = null;
        this.onModelChange = (model)=>this.updateModel(model);
    }
    onParentModelChanged(parentModel) {
        this.model = parentModel;
        this.refreshProps();
    }
    refresh(newParams) {
        this.sourceParams = newParams;
        this.refreshProps();
    }
    getOptionalMethods() {
        return [
            "afterGuiAttached"
        ];
    }
    updateModel(model) {
        this.model = model;
        this.refreshProps();
        $89799df32d2d843b$var$updateFloatingFilterParent(this.sourceParams, model);
    }
    getProps() {
        const props = super.getProps();
        props.model = this.model;
        props.onModelChange = this.onModelChange;
        return props;
    }
};
// packages/ag-grid-react/src/shared/customComp/loadingOverlayComponentWrapper.ts
var $89799df32d2d843b$var$LoadingOverlayComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    refresh(params) {
        this.sourceParams = params;
        this.refreshProps();
    }
};
// packages/ag-grid-react/src/shared/customComp/menuItemComponentWrapper.ts
var $89799df32d2d843b$var$MenuItemComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    constructor(){
        super(...arguments);
        this.active = false;
        this.expanded = false;
        this.onActiveChange = (active)=>this.updateActive(active);
    }
    setActive(active) {
        this.awaitSetActive(active);
    }
    setExpanded(expanded) {
        this.expanded = expanded;
        this.refreshProps();
    }
    getOptionalMethods() {
        return [
            "select",
            "configureDefaults"
        ];
    }
    awaitSetActive(active) {
        this.active = active;
        return this.refreshProps();
    }
    updateActive(active) {
        const result = this.awaitSetActive(active);
        if (active) result.then(()=>this.sourceParams.onItemActivated());
    }
    getProps() {
        const props = super.getProps();
        props.active = this.active;
        props.expanded = this.expanded;
        props.onActiveChange = this.onActiveChange;
        delete props.onItemActivated;
        return props;
    }
};
// packages/ag-grid-react/src/shared/customComp/noRowsOverlayComponentWrapper.ts
var $89799df32d2d843b$var$NoRowsOverlayComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    refresh(params) {
        this.sourceParams = params;
        this.refreshProps();
    }
};
// packages/ag-grid-react/src/shared/customComp/statusPanelComponentWrapper.ts
var $89799df32d2d843b$var$StatusPanelComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    refresh(params) {
        this.sourceParams = params;
        this.refreshProps();
        return true;
    }
};
// packages/ag-grid-react/src/shared/customComp/toolPanelComponentWrapper.ts
var $89799df32d2d843b$var$ToolPanelComponentWrapper = class extends $89799df32d2d843b$var$CustomComponentWrapper {
    constructor(){
        super(...arguments);
        this.onStateChange = (state)=>this.updateState(state);
    }
    refresh(params) {
        this.sourceParams = params;
        this.refreshProps();
        return true;
    }
    getState() {
        return this.state;
    }
    updateState(state) {
        this.state = state;
        this.refreshProps();
        this.sourceParams.onStateUpdated();
    }
    getProps() {
        const props = super.getProps();
        props.state = this.state;
        props.onStateChange = this.onStateChange;
        return props;
    }
};
function $89799df32d2d843b$export$8bedcca5bbd73999(wrapperComponent, callback) {
    const promise = wrapperComponent?.getInstance?.() ?? (0, $7b57b57eaf5a9648$export$30ec7836a4847721).resolve(void 0);
    promise.then((comp)=>callback(comp));
}
function $89799df32d2d843b$export$e83e01bcf62967be() {
    (0, $7b57b57eaf5a9648$export$2cf41453020eef66)("As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.");
}
// packages/ag-grid-react/src/shared/portalManager.ts
var $89799df32d2d843b$var$MAX_COMPONENT_CREATION_TIME_IN_MS = 1e3;
var $89799df32d2d843b$var$PortalManager = class {
    constructor(refresher, wrappingElement, maxComponentCreationTimeMs){
        this.destroyed = false;
        this.portals = [];
        this.hasPendingPortalUpdate = false;
        this.wrappingElement = wrappingElement ? wrappingElement : "div";
        this.refresher = refresher;
        this.maxComponentCreationTimeMs = maxComponentCreationTimeMs ? maxComponentCreationTimeMs : $89799df32d2d843b$var$MAX_COMPONENT_CREATION_TIME_IN_MS;
    }
    getPortals() {
        return this.portals;
    }
    destroy() {
        this.destroyed = true;
    }
    destroyPortal(portal) {
        this.portals = this.portals.filter((curPortal)=>curPortal !== portal);
        this.batchUpdate();
    }
    getComponentWrappingElement() {
        return this.wrappingElement;
    }
    mountReactPortal(portal, reactComponent, resolve) {
        this.portals = [
            ...this.portals,
            portal
        ];
        this.waitForInstance(reactComponent, resolve);
        this.batchUpdate();
    }
    updateReactPortal(oldPortal, newPortal) {
        this.portals[this.portals.indexOf(oldPortal)] = newPortal;
        this.batchUpdate();
    }
    batchUpdate() {
        if (this.hasPendingPortalUpdate) return;
        setTimeout(()=>{
            if (!this.destroyed) {
                this.refresher();
                this.hasPendingPortalUpdate = false;
            }
        });
        this.hasPendingPortalUpdate = true;
    }
    waitForInstance(reactComponent, resolve, startTime = Date.now()) {
        if (this.destroyed) {
            resolve(null);
            return;
        }
        if (reactComponent.rendered()) resolve(reactComponent);
        else {
            if (Date.now() - startTime >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate) return;
            window.setTimeout(()=>{
                this.waitForInstance(reactComponent, resolve, startTime);
            });
        }
    }
};
var $89799df32d2d843b$var$HeaderCellComp = (props)=>{
    const { ctrl: ctrl  } = props;
    const isAlive = ctrl.isAlive();
    const { context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const colId = isAlive ? ctrl.getColId() : void 0;
    const [userCompDetails, setUserCompDetails] = (0, $aaLBe.useState)();
    const eGui = (0, $aaLBe.useRef)(null);
    const eResize = (0, $aaLBe.useRef)(null);
    const eHeaderCompWrapper = (0, $aaLBe.useRef)(null);
    const userCompRef = (0, $aaLBe.useRef)();
    const cssClassManager = (0, $aaLBe.useRef)();
    if (isAlive && !cssClassManager.current) cssClassManager.current = new (0, $7b57b57eaf5a9648$export$a7053cb7eb605bd2)(()=>eGui.current);
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGui.current = e;
        if (!eGui.current || !isAlive) return;
        const compProxy = {
            setWidth: (width)=>{
                if (eGui.current) eGui.current.style.width = width;
            },
            addOrRemoveCssClass: (name, on)=>cssClassManager.current.addOrRemoveCssClass(name, on),
            setAriaSort: (sort)=>{
                if (eGui.current) sort ? (0, $7b57b57eaf5a9648$export$c8dd030b968c6fd2)(eGui.current, sort) : (0, $7b57b57eaf5a9648$export$26c7aa61eda05134)(eGui.current);
            },
            setUserCompDetails: (compDetails)=>setUserCompDetails(compDetails),
            getUserCompInstance: ()=>userCompRef.current || void 0
        };
        ctrl.setComp(compProxy, eGui.current, eResize.current, eHeaderCompWrapper.current);
        const selectAllGui = ctrl.getSelectAllGui();
        eResize.current?.insertAdjacentElement("afterend", selectAllGui);
    }, []);
    (0, $aaLBe.useLayoutEffect)(()=>$89799df32d2d843b$var$showJsComp(userCompDetails, context, eHeaderCompWrapper.current, userCompRef), [
        userCompDetails
    ]);
    (0, $aaLBe.useEffect)(()=>{
        ctrl.setDragSource(eGui.current);
    }, [
        userCompDetails
    ]);
    const userCompStateless = (0, $aaLBe.useMemo)(()=>{
        const res = userCompDetails?.componentFromFramework && $89799df32d2d843b$var$isComponentStateless(userCompDetails.componentClass);
        return !!res;
    }, [
        userCompDetails
    ]);
    const reactUserComp = userCompDetails && userCompDetails.componentFromFramework;
    const UserCompClass = userCompDetails && userCompDetails.componentClass;
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: "ag-header-cell",
        "col-id": colId,
        role: "columnheader"
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: eResize,
        className: "ag-header-cell-resize",
        role: "presentation"
    }), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: eHeaderCompWrapper,
        className: "ag-header-cell-comp-wrapper",
        role: "presentation"
    }, reactUserComp && userCompStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(UserCompClass, {
        ...userCompDetails.params
    }), reactUserComp && !userCompStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(UserCompClass, {
        ...userCompDetails.params,
        ref: userCompRef
    })));
};
var $89799df32d2d843b$var$headerCellComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$HeaderCellComp);
var $89799df32d2d843b$var$HeaderFilterCellComp = (props)=>{
    const { context: context , gos: gos  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const [cssClasses, setCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses("ag-header-cell", "ag-floating-filter"));
    const [cssBodyClasses, setBodyCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses());
    const [cssButtonWrapperClasses, setButtonWrapperCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses("ag-floating-filter-button", "ag-hidden"));
    const [buttonWrapperAriaHidden, setButtonWrapperAriaHidden] = (0, $aaLBe.useState)("false");
    const [userCompDetails, setUserCompDetails] = (0, $aaLBe.useState)();
    const [, setRenderKey] = (0, $aaLBe.useState)(1);
    const eGui = (0, $aaLBe.useRef)(null);
    const eFloatingFilterBody = (0, $aaLBe.useRef)(null);
    const eButtonWrapper = (0, $aaLBe.useRef)(null);
    const eButtonShowMainFilter = (0, $aaLBe.useRef)(null);
    const userCompResolve = (0, $aaLBe.useRef)();
    const userCompPromise = (0, $aaLBe.useRef)();
    const userCompRef = (value)=>{
        if (value == null) return;
        userCompResolve.current && userCompResolve.current(value);
    };
    const { ctrl: ctrl  } = props;
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGui.current = e;
        if (!eGui.current) return;
        userCompPromise.current = new (0, $7b57b57eaf5a9648$export$30ec7836a4847721)((resolve)=>{
            userCompResolve.current = resolve;
        });
        const compProxy = {
            addOrRemoveCssClass: (name, on)=>setCssClasses((prev)=>prev.setClass(name, on)),
            addOrRemoveBodyCssClass: (name, on)=>setBodyCssClasses((prev)=>prev.setClass(name, on)),
            setButtonWrapperDisplayed: (displayed)=>{
                setButtonWrapperCssClasses((prev)=>prev.setClass("ag-hidden", !displayed));
                setButtonWrapperAriaHidden(!displayed ? "true" : "false");
            },
            setWidth: (width)=>{
                if (eGui.current) eGui.current.style.width = width;
            },
            setCompDetails: (compDetails)=>setUserCompDetails(compDetails),
            getFloatingFilterComp: ()=>userCompPromise.current ? userCompPromise.current : null,
            setMenuIcon: (eIcon)=>eButtonShowMainFilter.current?.appendChild(eIcon)
        };
        ctrl.setComp(compProxy, eGui.current, eButtonShowMainFilter.current, eFloatingFilterBody.current);
    }, []);
    (0, $aaLBe.useLayoutEffect)(()=>$89799df32d2d843b$var$showJsComp(userCompDetails, context, eFloatingFilterBody.current, userCompRef), [
        userCompDetails
    ]);
    const className = (0, $aaLBe.useMemo)(()=>cssClasses.toString(), [
        cssClasses
    ]);
    const bodyClassName = (0, $aaLBe.useMemo)(()=>cssBodyClasses.toString(), [
        cssBodyClasses
    ]);
    const buttonWrapperClassName = (0, $aaLBe.useMemo)(()=>cssButtonWrapperClasses.toString(), [
        cssButtonWrapperClasses
    ]);
    const userCompStateless = (0, $aaLBe.useMemo)(()=>{
        const res = userCompDetails && userCompDetails.componentFromFramework && $89799df32d2d843b$var$isComponentStateless(userCompDetails.componentClass);
        return !!res;
    }, [
        userCompDetails
    ]);
    const reactiveCustomComponents = (0, $aaLBe.useMemo)(()=>gos.get("reactiveCustomComponents"), []);
    const floatingFilterCompProxy = (0, $aaLBe.useMemo)(()=>{
        if (userCompDetails) {
            if (reactiveCustomComponents) {
                const compProxy = new $89799df32d2d843b$var$FloatingFilterComponentProxy(userCompDetails.params, ()=>setRenderKey((prev)=>prev + 1));
                userCompRef(compProxy);
                return compProxy;
            } else if (userCompDetails.componentFromFramework) $89799df32d2d843b$export$e83e01bcf62967be();
        }
        return void 0;
    }, [
        userCompDetails
    ]);
    const floatingFilterProps = floatingFilterCompProxy?.getProps();
    const reactUserComp = userCompDetails && userCompDetails.componentFromFramework;
    const UserCompClass = userCompDetails && userCompDetails.componentClass;
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: className,
        role: "gridcell"
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: eFloatingFilterBody,
        className: bodyClassName,
        role: "presentation"
    }, reactUserComp && !reactiveCustomComponents && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(UserCompClass, {
        ...userCompDetails.params,
        ref: userCompStateless ? ()=>{} : userCompRef
    }), reactUserComp && reactiveCustomComponents && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$export$9f6317c67b47ac67.Provider, {
        value: {
            setMethods: (methods)=>floatingFilterCompProxy.setMethods(methods)
        }
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(UserCompClass, {
        ...floatingFilterProps
    }))), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: eButtonWrapper,
        "aria-hidden": buttonWrapperAriaHidden,
        className: buttonWrapperClassName,
        role: "presentation"
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("button", {
        ref: eButtonShowMainFilter,
        type: "button",
        className: "ag-button ag-floating-filter-button-button",
        tabIndex: -1
    })));
};
var $89799df32d2d843b$var$headerFilterCellComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$HeaderFilterCellComp);
var $89799df32d2d843b$var$HeaderGroupCellComp = (props)=>{
    const { context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const { ctrl: ctrl  } = props;
    const [cssClasses, setCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses());
    const [cssResizableClasses, setResizableCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses());
    const [resizableAriaHidden, setResizableAriaHidden] = (0, $aaLBe.useState)("false");
    const [ariaExpanded, setAriaExpanded] = (0, $aaLBe.useState)();
    const [userCompDetails, setUserCompDetails] = (0, $aaLBe.useState)();
    const colId = (0, $aaLBe.useMemo)(()=>ctrl.getColId(), []);
    const eGui = (0, $aaLBe.useRef)(null);
    const eResize = (0, $aaLBe.useRef)(null);
    const userCompRef = (0, $aaLBe.useRef)();
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGui.current = e;
        if (!eGui.current) return;
        const compProxy = {
            setWidth: (width)=>{
                if (eGui.current) eGui.current.style.width = width;
            },
            addOrRemoveCssClass: (name, on)=>setCssClasses((prev)=>prev.setClass(name, on)),
            setUserCompDetails: (compDetails)=>setUserCompDetails(compDetails),
            setResizableDisplayed: (displayed)=>{
                setResizableCssClasses((prev)=>prev.setClass("ag-hidden", !displayed));
                setResizableAriaHidden(!displayed ? "true" : "false");
            },
            setAriaExpanded: (expanded)=>setAriaExpanded(expanded),
            getUserCompInstance: ()=>userCompRef.current || void 0
        };
        ctrl.setComp(compProxy, eGui.current, eResize.current);
    }, []);
    (0, $aaLBe.useLayoutEffect)(()=>$89799df32d2d843b$var$showJsComp(userCompDetails, context, eGui.current), [
        userCompDetails
    ]);
    (0, $aaLBe.useEffect)(()=>{
        if (eGui.current) ctrl.setDragSource(eGui.current);
    }, [
        userCompDetails
    ]);
    const userCompStateless = (0, $aaLBe.useMemo)(()=>{
        const res = userCompDetails?.componentFromFramework && $89799df32d2d843b$var$isComponentStateless(userCompDetails.componentClass);
        return !!res;
    }, [
        userCompDetails
    ]);
    const className = (0, $aaLBe.useMemo)(()=>"ag-header-group-cell " + cssClasses.toString(), [
        cssClasses
    ]);
    const resizableClassName = (0, $aaLBe.useMemo)(()=>"ag-header-cell-resize " + cssResizableClasses.toString(), [
        cssResizableClasses
    ]);
    const reactUserComp = userCompDetails && userCompDetails.componentFromFramework;
    const UserCompClass = userCompDetails && userCompDetails.componentClass;
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: className,
        "col-id": colId,
        role: "columnheader",
        "aria-expanded": ariaExpanded
    }, reactUserComp && userCompStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(UserCompClass, {
        ...userCompDetails.params
    }), reactUserComp && !userCompStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(UserCompClass, {
        ...userCompDetails.params,
        ref: userCompRef
    }), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: eResize,
        "aria-hidden": resizableAriaHidden,
        className: resizableClassName
    }));
};
var $89799df32d2d843b$var$headerGroupCellComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$HeaderGroupCellComp);
// packages/ag-grid-react/src/reactUi/header/headerRowComp.tsx
var $89799df32d2d843b$var$HeaderRowComp = (props)=>{
    const { ctrl: ctrl  } = props;
    const { topOffset: topOffset , rowHeight: rowHeight  } = (0, $aaLBe.useMemo)(()=>ctrl.getTopAndHeight(), []);
    const ariaRowIndex = ctrl.getAriaRowIndex();
    const className = ctrl.getHeaderRowClass();
    const [height, setHeight] = (0, $aaLBe.useState)(()=>rowHeight + "px");
    const [top, setTop] = (0, $aaLBe.useState)(()=>topOffset + "px");
    const cellCtrlsRef = (0, $aaLBe.useRef)(null);
    const prevCellCtrlsRef = (0, $aaLBe.useRef)(null);
    const [cellCtrls, setCellCtrls] = (0, $aaLBe.useState)(()=>ctrl.getHeaderCtrls());
    const eGui = (0, $aaLBe.useRef)(null);
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGui.current = e;
        if (!e) return;
        const compProxy = {
            setHeight: (height2)=>setHeight(height2),
            setTop: (top2)=>setTop(top2),
            setHeaderCtrls: (ctrls, forceOrder, afterScroll)=>{
                prevCellCtrlsRef.current = cellCtrlsRef.current;
                cellCtrlsRef.current = ctrls;
                const next = $89799df32d2d843b$var$getNextValueIfDifferent(prevCellCtrlsRef.current, ctrls, forceOrder);
                if (next !== prevCellCtrlsRef.current) $89799df32d2d843b$var$agFlushSync(afterScroll, ()=>setCellCtrls(next));
            },
            setWidth: (width)=>{
                if (eGui.current) eGui.current.style.width = width;
            }
        };
        ctrl.setComp(compProxy, false);
    }, []);
    const style = (0, $aaLBe.useMemo)(()=>({
            height: height,
            top: top
        }), [
        height,
        top
    ]);
    const createCellJsx = (0, $aaLBe.useCallback)((cellCtrl)=>{
        switch(ctrl.getType()){
            case (0, $7b57b57eaf5a9648$export$e37505288cf627d).COLUMN_GROUP:
                return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$headerGroupCellComp_default, {
                    ctrl: cellCtrl,
                    key: cellCtrl.getInstanceId()
                });
            case (0, $7b57b57eaf5a9648$export$e37505288cf627d).FLOATING_FILTER:
                return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$headerFilterCellComp_default, {
                    ctrl: cellCtrl,
                    key: cellCtrl.getInstanceId()
                });
            default:
                return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$headerCellComp_default, {
                    ctrl: cellCtrl,
                    key: cellCtrl.getInstanceId()
                });
        }
    }, []);
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: className,
        role: "row",
        style: style,
        "aria-rowindex": ariaRowIndex
    }, cellCtrls.map(createCellJsx));
};
var $89799df32d2d843b$var$headerRowComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$HeaderRowComp);
// packages/ag-grid-react/src/reactUi/header/headerRowContainerComp.tsx
var $89799df32d2d843b$var$HeaderRowContainerComp = (props)=>{
    const [displayed, setDisplayed] = (0, $aaLBe.useState)(true);
    const [headerRowCtrls, setHeaderRowCtrls] = (0, $aaLBe.useState)([]);
    const { context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const eGui = (0, $aaLBe.useRef)(null);
    const eCenterContainer = (0, $aaLBe.useRef)(null);
    const headerRowCtrlRef = (0, $aaLBe.useRef)(null);
    const pinnedLeft = props.pinned === "left";
    const pinnedRight = props.pinned === "right";
    const centre = !pinnedLeft && !pinnedRight;
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGui.current = e;
        if (!eGui.current) {
            context.destroyBean(headerRowCtrlRef.current);
            headerRowCtrlRef.current = null;
            return;
        }
        const compProxy = {
            setDisplayed: setDisplayed,
            setCtrls: (ctrls)=>setHeaderRowCtrls(ctrls),
            // centre only
            setCenterWidth: (width)=>{
                if (eCenterContainer.current) eCenterContainer.current.style.width = width;
            },
            setViewportScrollLeft: (left)=>{
                if (eGui.current) eGui.current.scrollLeft = left;
            },
            // pinned only
            setPinnedContainerWidth: (width)=>{
                if (eGui.current) {
                    eGui.current.style.width = width;
                    eGui.current.style.minWidth = width;
                    eGui.current.style.maxWidth = width;
                }
            }
        };
        headerRowCtrlRef.current = context.createBean(new (0, $7b57b57eaf5a9648$export$1e864ee88f54e7b)(props.pinned));
        headerRowCtrlRef.current.setComp(compProxy, eGui.current);
    }, []);
    const className = !displayed ? "ag-hidden" : "";
    const insertRowsJsx = ()=>headerRowCtrls.map((ctrl)=>/* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$headerRowComp_default, {
                ctrl: ctrl,
                key: ctrl.getInstanceId()
            }));
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, pinnedLeft && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: "ag-pinned-left-header " + className,
        "aria-hidden": !displayed,
        role: "rowgroup"
    }, insertRowsJsx()), pinnedRight && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: "ag-pinned-right-header " + className,
        "aria-hidden": !displayed,
        role: "rowgroup"
    }, insertRowsJsx()), centre && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: "ag-header-viewport " + className,
        role: "presentation"
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: eCenterContainer,
        className: "ag-header-container",
        role: "rowgroup"
    }, insertRowsJsx())));
};
var $89799df32d2d843b$var$headerRowContainerComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$HeaderRowContainerComp);
// packages/ag-grid-react/src/reactUi/header/gridHeaderComp.tsx
var $89799df32d2d843b$var$GridHeaderComp = ()=>{
    const [cssClasses, setCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses());
    const [height, setHeight] = (0, $aaLBe.useState)();
    const { context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const eGui = (0, $aaLBe.useRef)(null);
    const gridCtrlRef = (0, $aaLBe.useRef)(null);
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGui.current = e;
        if (!e) {
            context.destroyBean(gridCtrlRef.current);
            gridCtrlRef.current = null;
            return;
        }
        const compProxy = {
            addOrRemoveCssClass: (name, on)=>setCssClasses((prev)=>prev.setClass(name, on)),
            setHeightAndMinHeight: (height2)=>setHeight(height2)
        };
        gridCtrlRef.current = context.createBean(new (0, $7b57b57eaf5a9648$export$20b300eb69ca4d09)());
        gridCtrlRef.current.setComp(compProxy, eGui.current, eGui.current);
    }, []);
    const className = (0, $aaLBe.useMemo)(()=>{
        const res = cssClasses.toString();
        return "ag-header " + res;
    }, [
        cssClasses
    ]);
    const style = (0, $aaLBe.useMemo)(()=>({
            height: height,
            minHeight: height
        }), [
        height
    ]);
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: className,
        style: style,
        role: "presentation"
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$headerRowContainerComp_default, {
        pinned: "left"
    }), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$headerRowContainerComp_default, {
        pinned: null
    }), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$headerRowContainerComp_default, {
        pinned: "right"
    }));
};
var $89799df32d2d843b$var$gridHeaderComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$GridHeaderComp);
var $89799df32d2d843b$var$useReactCommentEffect = (comment, eForCommentRef)=>{
    (0, $aaLBe.useEffect)(()=>{
        const eForComment = eForCommentRef.current;
        if (eForComment) {
            const eParent = eForComment.parentElement;
            if (eParent) {
                const eComment = document.createComment(comment);
                eParent.insertBefore(eComment, eForComment);
                return ()=>{
                    eParent.removeChild(eComment);
                };
            }
        }
    }, [
        comment
    ]);
};
var $89799df32d2d843b$var$reactComment_default = $89799df32d2d843b$var$useReactCommentEffect;
var $89799df32d2d843b$var$CellEditorComponentProxy = class {
    constructor(cellEditorParams, refreshProps){
        this.cellEditorParams = cellEditorParams;
        this.refreshProps = refreshProps;
        this.instanceCreated = new (0, $7b57b57eaf5a9648$export$30ec7836a4847721)((resolve)=>{
            this.resolveInstanceCreated = resolve;
        });
        this.onValueChange = (value)=>this.updateValue(value);
        this.value = cellEditorParams.value;
    }
    getProps() {
        return {
            ...this.cellEditorParams,
            initialValue: this.cellEditorParams.value,
            value: this.value,
            onValueChange: this.onValueChange
        };
    }
    getValue() {
        return this.value;
    }
    refresh(params) {
        this.cellEditorParams = params;
        this.refreshProps();
    }
    setMethods(methods) {
        $89799df32d2d843b$var$addOptionalMethods(this.getOptionalMethods(), methods, this);
    }
    getInstance() {
        return this.instanceCreated.then(()=>this.componentInstance);
    }
    setRef(componentInstance) {
        this.componentInstance = componentInstance;
        this.resolveInstanceCreated?.();
        this.resolveInstanceCreated = void 0;
    }
    getOptionalMethods() {
        return [
            "isCancelBeforeStart",
            "isCancelAfterEnd",
            "focusIn",
            "focusOut",
            "afterGuiAttached"
        ];
    }
    updateValue(value) {
        this.value = value;
        this.refreshProps();
    }
};
var $89799df32d2d843b$var$useEffectOnce = (effect)=>{
    const effectFn = (0, $aaLBe.useRef)(effect);
    const destroyFn = (0, $aaLBe.useRef)();
    const effectCalled = (0, $aaLBe.useRef)(false);
    const rendered = (0, $aaLBe.useRef)(false);
    const [, setVal] = (0, $aaLBe.useState)(0);
    if (effectCalled.current) rendered.current = true;
    (0, $aaLBe.useEffect)(()=>{
        if (!effectCalled.current) {
            destroyFn.current = effectFn.current();
            effectCalled.current = true;
        }
        setVal((val)=>val + 1);
        return ()=>{
            if (!rendered.current) return;
            if (destroyFn.current) destroyFn.current();
        };
    }, []);
};
// packages/ag-grid-react/src/reactUi/cells/popupEditorComp.tsx
var $89799df32d2d843b$var$PopupEditorComp = (props)=>{
    const [popupEditorWrapper, setPopupEditorWrapper] = (0, $aaLBe.useState)();
    const { context: context , popupService: popupService , localeService: localeService , gos: gos , editService: editService  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    $89799df32d2d843b$var$useEffectOnce(()=>{
        const { editDetails: editDetails , cellCtrl: cellCtrl , eParentCell: eParentCell  } = props;
        const { compDetails: compDetails  } = editDetails;
        const useModelPopup = gos.get("stopEditingWhenCellsLoseFocus");
        const wrapper = context.createBean(editService.createPopupEditorWrapper(compDetails.params));
        const ePopupGui = wrapper.getGui();
        if (props.jsChildComp) {
            const eChildGui = props.jsChildComp.getGui();
            if (eChildGui) ePopupGui.appendChild(eChildGui);
        }
        const positionParams = {
            column: cellCtrl.getColumn(),
            rowNode: cellCtrl.getRowNode(),
            type: "popupCellEditor",
            eventSource: eParentCell,
            ePopup: ePopupGui,
            position: editDetails.popupPosition,
            keepWithinBounds: true
        };
        const positionCallback = popupService.positionPopupByComponent.bind(popupService, positionParams);
        const translate = localeService.getLocaleTextFunc();
        const addPopupRes = popupService.addPopup({
            modal: useModelPopup,
            eChild: ePopupGui,
            closeOnEsc: true,
            closedCallback: ()=>{
                cellCtrl.onPopupEditorClosed();
            },
            anchorToElement: eParentCell,
            positionCallback: positionCallback,
            ariaLabel: translate("ariaLabelCellEditor", "Cell Editor")
        });
        const hideEditorPopup = addPopupRes ? addPopupRes.hideFunc : void 0;
        setPopupEditorWrapper(wrapper);
        props.jsChildComp && props.jsChildComp.afterGuiAttached && props.jsChildComp.afterGuiAttached();
        return ()=>{
            if (hideEditorPopup != null) hideEditorPopup();
            context.destroyBean(wrapper);
        };
    });
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, popupEditorWrapper && props.wrappedContent && (0, $ba021dca0cbd5bec$exports.createPortal)(props.wrappedContent, popupEditorWrapper.getGui()));
};
var $89799df32d2d843b$var$popupEditorComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$PopupEditorComp);
var $89799df32d2d843b$var$useJsCellRenderer = (showDetails, showTools, eCellValue, cellValueVersion, jsCellRendererRef, eGui)=>{
    const { context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const destroyCellRenderer = (0, $aaLBe.useCallback)(()=>{
        const comp = jsCellRendererRef.current;
        if (!comp) return;
        const compGui = comp.getGui();
        if (compGui && compGui.parentElement) compGui.parentElement.removeChild(compGui);
        context.destroyBean(comp);
        jsCellRendererRef.current = void 0;
    }, []);
    (0, $aaLBe.useEffect)(()=>{
        const showValue = showDetails != null;
        const jsCompDetails = showDetails && showDetails.compDetails && !showDetails.compDetails.componentFromFramework;
        const waitingForToolsSetup = showTools && eCellValue == null;
        const showComp = showValue && jsCompDetails && !waitingForToolsSetup;
        if (!showComp) {
            destroyCellRenderer();
            return;
        }
        const compDetails = showDetails.compDetails;
        if (jsCellRendererRef.current) {
            const comp = jsCellRendererRef.current;
            const attemptRefresh = comp.refresh != null && showDetails.force == false;
            const refreshResult = attemptRefresh ? comp.refresh(compDetails.params) : false;
            const refreshWorked = refreshResult === true || refreshResult === void 0;
            if (refreshWorked) return;
            destroyCellRenderer();
        }
        const promise = compDetails.newAgStackInstance();
        if (promise == null) return;
        promise.then((comp)=>{
            if (!comp) return;
            const compGui = comp.getGui();
            if (!compGui) return;
            const parent = showTools ? eCellValue : eGui.current;
            parent.appendChild(compGui);
            jsCellRendererRef.current = comp;
        });
    }, [
        showDetails,
        showTools,
        cellValueVersion
    ]);
    (0, $aaLBe.useEffect)(()=>{
        return destroyCellRenderer;
    }, []);
};
var $89799df32d2d843b$var$showJsRenderer_default = $89799df32d2d843b$var$useJsCellRenderer;
// packages/ag-grid-react/src/reactUi/cells/cellComp.tsx
var $89799df32d2d843b$var$jsxEditorProxy = (editDetails, CellEditorClass, setRef2)=>{
    const { compProxy: compProxy  } = editDetails;
    setRef2(compProxy);
    const props = compProxy.getProps();
    const isStateless = $89799df32d2d843b$var$isComponentStateless(CellEditorClass);
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$export$9f6317c67b47ac67.Provider, {
        value: {
            setMethods: (methods)=>compProxy.setMethods(methods)
        }
    }, isStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(CellEditorClass, {
        ...props
    }), !isStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(CellEditorClass, {
        ...props,
        ref: (ref)=>compProxy.setRef(ref)
    }));
};
var $89799df32d2d843b$var$jsxEditor = (editDetails, CellEditorClass, setRef2)=>{
    const newFormat = editDetails.compProxy;
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, !newFormat && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(CellEditorClass, {
        ...editDetails.compDetails.params,
        ref: setRef2
    }), newFormat && $89799df32d2d843b$var$jsxEditorProxy(editDetails, CellEditorClass, setRef2));
};
var $89799df32d2d843b$var$jsxEditValue = (editDetails, setInlineCellEditorRef, setPopupCellEditorRef, eGui, cellCtrl, jsEditorComp)=>{
    const compDetails = editDetails.compDetails;
    const CellEditorClass = compDetails.componentClass;
    const reactInlineEditor = compDetails.componentFromFramework && !editDetails.popup;
    const reactPopupEditor = compDetails.componentFromFramework && editDetails.popup;
    const jsPopupEditor = !compDetails.componentFromFramework && editDetails.popup;
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, reactInlineEditor && $89799df32d2d843b$var$jsxEditor(editDetails, CellEditorClass, setInlineCellEditorRef), reactPopupEditor && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$popupEditorComp_default, {
        editDetails: editDetails,
        cellCtrl: cellCtrl,
        eParentCell: eGui,
        wrappedContent: $89799df32d2d843b$var$jsxEditor(editDetails, CellEditorClass, setPopupCellEditorRef)
    }), jsPopupEditor && jsEditorComp && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$popupEditorComp_default, {
        editDetails: editDetails,
        cellCtrl: cellCtrl,
        eParentCell: eGui,
        jsChildComp: jsEditorComp
    }));
};
var $89799df32d2d843b$var$jsxShowValue = (showDetails, key, parentId, cellRendererRef, showCellWrapper, reactCellRendererStateless, setECellValue)=>{
    const { compDetails: compDetails , value: value  } = showDetails;
    const noCellRenderer = !compDetails;
    const reactCellRenderer = compDetails && compDetails.componentFromFramework;
    const CellRendererClass = compDetails && compDetails.componentClass;
    const valueForNoCellRenderer = value?.toString ? value.toString() : value;
    const bodyJsxFunc = ()=>/* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, noCellRenderer && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, valueForNoCellRenderer), reactCellRenderer && !reactCellRendererStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(CellRendererClass, {
            ...compDetails.params,
            key: key,
            ref: cellRendererRef
        }), reactCellRenderer && reactCellRendererStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(CellRendererClass, {
            ...compDetails.params,
            key: key
        }));
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, showCellWrapper ? /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("span", {
        role: "presentation",
        id: `cell-${parentId}`,
        className: "ag-cell-value",
        ref: setECellValue
    }, bodyJsxFunc()) : bodyJsxFunc());
};
var $89799df32d2d843b$var$CellComp = (props)=>{
    const { context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const { cellCtrl: cellCtrl , printLayout: printLayout , editingRow: editingRow  } = props;
    const tabIndex = cellCtrl.getTabIndex();
    const colId = cellCtrl.getColumnIdSanitised();
    const cellInstanceId = cellCtrl.getInstanceId();
    const [renderDetails, setRenderDetails] = (0, $aaLBe.useState)(()=>cellCtrl.isCellRenderer() ? void 0 : {
            compDetails: void 0,
            value: cellCtrl.getValueToDisplay(),
            force: false
        });
    const [editDetails, setEditDetails] = (0, $aaLBe.useState)();
    const [renderKey, setRenderKey] = (0, $aaLBe.useState)(1);
    const [userStyles, setUserStyles] = (0, $aaLBe.useState)();
    const [includeSelection, setIncludeSelection] = (0, $aaLBe.useState)(false);
    const [includeRowDrag, setIncludeRowDrag] = (0, $aaLBe.useState)(false);
    const [includeDndSource, setIncludeDndSource] = (0, $aaLBe.useState)(false);
    const [jsEditorComp, setJsEditorComp] = (0, $aaLBe.useState)();
    const forceWrapper = (0, $aaLBe.useMemo)(()=>cellCtrl.isForceWrapper(), [
        cellCtrl
    ]);
    const cellAriaRole = (0, $aaLBe.useMemo)(()=>cellCtrl.getCellAriaRole(), [
        cellCtrl
    ]);
    const eGui = (0, $aaLBe.useRef)(null);
    const cellRendererRef = (0, $aaLBe.useRef)(null);
    const jsCellRendererRef = (0, $aaLBe.useRef)();
    const cellEditorRef = (0, $aaLBe.useRef)();
    const eCellWrapper = (0, $aaLBe.useRef)();
    const cellWrapperDestroyFuncs = (0, $aaLBe.useRef)([]);
    const eCellValue = (0, $aaLBe.useRef)();
    const [cellValueVersion, setCellValueVersion] = (0, $aaLBe.useState)(0);
    const setCellValueRef = (0, $aaLBe.useCallback)((ref)=>{
        eCellValue.current = ref;
        setCellValueVersion((v)=>v + 1);
    }, []);
    const showTools = renderDetails != null && (includeSelection || includeDndSource || includeRowDrag);
    const showCellWrapper = forceWrapper || showTools;
    const setCellEditorRef = (0, $aaLBe.useCallback)((popup, cellEditor)=>{
        cellEditorRef.current = cellEditor;
        if (cellEditor) {
            const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
            if (editingCancelledByUserComp) setTimeout(()=>{
                cellCtrl.stopEditing(true);
                cellCtrl.focusCell(true);
            });
        }
    }, [
        cellCtrl
    ]);
    const setPopupCellEditorRef = (0, $aaLBe.useCallback)((cellRenderer)=>setCellEditorRef(true, cellRenderer), [
        setCellEditorRef
    ]);
    const setInlineCellEditorRef = (0, $aaLBe.useCallback)((cellRenderer)=>setCellEditorRef(false, cellRenderer), [
        setCellEditorRef
    ]);
    const cssClassManager = (0, $aaLBe.useRef)();
    if (!cssClassManager.current) cssClassManager.current = new (0, $7b57b57eaf5a9648$export$a7053cb7eb605bd2)(()=>eGui.current);
    $89799df32d2d843b$var$showJsRenderer_default(renderDetails, showCellWrapper, eCellValue.current, cellValueVersion, jsCellRendererRef, eGui);
    const lastRenderDetails = (0, $aaLBe.useRef)();
    (0, $aaLBe.useLayoutEffect)(()=>{
        const oldDetails = lastRenderDetails.current;
        const newDetails = renderDetails;
        lastRenderDetails.current = renderDetails;
        if (oldDetails == null || oldDetails.compDetails == null || newDetails == null || newDetails.compDetails == null) return;
        const oldCompDetails = oldDetails.compDetails;
        const newCompDetails = newDetails.compDetails;
        if (oldCompDetails.componentClass != newCompDetails.componentClass) return;
        if (cellRendererRef.current == null || cellRendererRef.current.refresh == null) return;
        const result = cellRendererRef.current.refresh(newCompDetails.params);
        if (result != true) setRenderKey((prev)=>prev + 1);
    }, [
        renderDetails
    ]);
    (0, $aaLBe.useLayoutEffect)(()=>{
        const doingJsEditor = editDetails && !editDetails.compDetails.componentFromFramework;
        if (!doingJsEditor) return;
        const compDetails = editDetails.compDetails;
        const isPopup = editDetails.popup === true;
        const cellEditorPromise = compDetails.newAgStackInstance();
        cellEditorPromise.then((cellEditor)=>{
            if (!cellEditor) return;
            const compGui = cellEditor.getGui();
            setCellEditorRef(isPopup, cellEditor);
            if (!isPopup) {
                const parentEl = (forceWrapper ? eCellWrapper : eGui).current;
                parentEl?.appendChild(compGui);
                cellEditor.afterGuiAttached && cellEditor.afterGuiAttached();
            }
            setJsEditorComp(cellEditor);
        });
        return ()=>{
            cellEditorPromise.then((cellEditor)=>{
                const compGui = cellEditor.getGui();
                context.destroyBean(cellEditor);
                setCellEditorRef(isPopup, void 0);
                setJsEditorComp(void 0);
                if (compGui && compGui.parentElement) compGui.parentElement.removeChild(compGui);
            });
        };
    }, [
        editDetails
    ]);
    const setCellWrapperRef = (0, $aaLBe.useCallback)((ref)=>{
        eCellWrapper.current = ref;
        if (!eCellWrapper.current) {
            cellWrapperDestroyFuncs.current.forEach((f)=>f());
            cellWrapperDestroyFuncs.current = [];
            return;
        }
        const addComp = (comp)=>{
            if (comp) {
                const eGui2 = comp.getGui();
                eCellWrapper.current?.insertAdjacentElement("afterbegin", eGui2);
                cellWrapperDestroyFuncs.current.push(()=>{
                    context.destroyBean(comp);
                    (0, $7b57b57eaf5a9648$export$dd4d52e41fb4cef5)(eGui2);
                });
            }
            return comp;
        };
        if (includeSelection) {
            const checkboxSelectionComp = cellCtrl.createSelectionCheckbox();
            addComp(checkboxSelectionComp);
        }
        if (includeDndSource) addComp(cellCtrl.createDndSource());
        if (includeRowDrag) addComp(cellCtrl.createRowDragComp());
    }, [
        cellCtrl,
        context,
        includeDndSource,
        includeRowDrag,
        includeSelection
    ]);
    const setRef2 = (0, $aaLBe.useCallback)((ref)=>{
        eGui.current = ref;
        if (!eGui.current) return;
        if (!cellCtrl) return;
        const compProxy = {
            addOrRemoveCssClass: (name, on)=>cssClassManager.current.addOrRemoveCssClass(name, on),
            setUserStyles: (styles)=>setUserStyles(styles),
            getFocusableElement: ()=>eGui.current,
            setIncludeSelection: (include)=>setIncludeSelection(include),
            setIncludeRowDrag: (include)=>setIncludeRowDrag(include),
            setIncludeDndSource: (include)=>setIncludeDndSource(include),
            getCellEditor: ()=>cellEditorRef.current || null,
            getCellRenderer: ()=>cellRendererRef.current ? cellRendererRef.current : jsCellRendererRef.current,
            getParentOfValue: ()=>eCellValue.current ? eCellValue.current : eCellWrapper.current ? eCellWrapper.current : eGui.current,
            setRenderDetails: (compDetails, value, force)=>{
                setRenderDetails((prev)=>{
                    if (prev?.compDetails !== compDetails || prev?.value !== value || prev?.force !== force) return {
                        value: value,
                        compDetails: compDetails,
                        force: force
                    };
                    else return prev;
                });
            },
            setEditDetails: (compDetails, popup, popupPosition, reactiveCustomComponents)=>{
                if (compDetails) {
                    let compProxy2 = void 0;
                    if (reactiveCustomComponents) compProxy2 = new $89799df32d2d843b$var$CellEditorComponentProxy(compDetails.params, ()=>setRenderKey((prev)=>prev + 1));
                    else if (compDetails.componentFromFramework) $89799df32d2d843b$export$e83e01bcf62967be();
                    setEditDetails({
                        compDetails: compDetails,
                        popup: popup,
                        popupPosition: popupPosition,
                        compProxy: compProxy2
                    });
                    if (!popup) setRenderDetails(void 0);
                } else setEditDetails((editDetails2)=>{
                    if (editDetails2?.compProxy) cellEditorRef.current = void 0;
                    return void 0;
                });
            }
        };
        const cellWrapperOrUndefined = eCellWrapper.current || void 0;
        cellCtrl.setComp(compProxy, eGui.current, cellWrapperOrUndefined, printLayout, editingRow);
    }, []);
    const reactCellRendererStateless = (0, $aaLBe.useMemo)(()=>{
        const res = renderDetails && renderDetails.compDetails && renderDetails.compDetails.componentFromFramework && $89799df32d2d843b$var$isComponentStateless(renderDetails.compDetails.componentClass);
        return !!res;
    }, [
        renderDetails
    ]);
    (0, $aaLBe.useLayoutEffect)(()=>{
        if (!eGui.current) return;
        cssClassManager.current.addOrRemoveCssClass("ag-cell-value", !showCellWrapper);
        cssClassManager.current.addOrRemoveCssClass("ag-cell-inline-editing", !!editDetails && !editDetails.popup);
        cssClassManager.current.addOrRemoveCssClass("ag-cell-popup-editing", !!editDetails && !!editDetails.popup);
        cssClassManager.current.addOrRemoveCssClass("ag-cell-not-inline-editing", !editDetails || !!editDetails.popup);
        cellCtrl.getRowCtrl()?.setInlineEditingCss(!!editDetails);
        if (cellCtrl.shouldRestoreFocus() && !cellCtrl.isEditing()) eGui.current.focus({
            preventScroll: true
        });
    });
    const showContents = ()=>/* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, renderDetails != null && $89799df32d2d843b$var$jsxShowValue(renderDetails, renderKey, cellInstanceId, cellRendererRef, showCellWrapper, reactCellRendererStateless, setCellValueRef), editDetails != null && $89799df32d2d843b$var$jsxEditValue(editDetails, setInlineCellEditorRef, setPopupCellEditorRef, eGui.current, cellCtrl, jsEditorComp));
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        style: userStyles,
        tabIndex: tabIndex,
        role: cellAriaRole,
        "col-id": colId
    }, showCellWrapper ? /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        className: "ag-cell-wrapper",
        role: "presentation",
        ref: setCellWrapperRef
    }, showContents()) : showContents());
};
var $89799df32d2d843b$var$cellComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$CellComp);
// packages/ag-grid-react/src/reactUi/rows/rowComp.tsx
var $89799df32d2d843b$var$RowComp = (params)=>{
    const { context: context , gos: gos  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const { rowCtrl: rowCtrl , containerType: containerType  } = params;
    const tabIndex = rowCtrl.getTabIndex();
    const domOrderRef = (0, $aaLBe.useRef)(rowCtrl.getDomOrder());
    const isFullWidth = rowCtrl.isFullWidth();
    const isDisplayed = rowCtrl.getRowNode().displayed;
    const [rowIndex, setRowIndex] = (0, $aaLBe.useState)(()=>isDisplayed ? rowCtrl.getRowIndex() : null);
    const [rowId, setRowId] = (0, $aaLBe.useState)(()=>rowCtrl.getRowId());
    const [rowBusinessKey, setRowBusinessKey] = (0, $aaLBe.useState)(()=>rowCtrl.getBusinessKey());
    const [userStyles, setUserStyles] = (0, $aaLBe.useState)(()=>rowCtrl.getRowStyles());
    const cellCtrlsRef = (0, $aaLBe.useRef)(null);
    const prevCellCtrlsRef = (0, $aaLBe.useRef)(null);
    const [cellCtrls, setCellCtrls] = (0, $aaLBe.useState)(()=>null);
    const [fullWidthCompDetails, setFullWidthCompDetails] = (0, $aaLBe.useState)();
    const [top, setTop] = (0, $aaLBe.useState)(()=>isDisplayed ? rowCtrl.getInitialRowTop(containerType) : void 0);
    const [transform, setTransform] = (0, $aaLBe.useState)(()=>isDisplayed ? rowCtrl.getInitialTransform(containerType) : void 0);
    const eGui = (0, $aaLBe.useRef)(null);
    const fullWidthCompRef = (0, $aaLBe.useRef)();
    const autoHeightSetup = (0, $aaLBe.useRef)(false);
    const [autoHeightSetupAttempt, setAutoHeightSetupAttempt] = (0, $aaLBe.useState)(0);
    (0, $aaLBe.useEffect)(()=>{
        if (autoHeightSetup.current) return;
        if (!fullWidthCompDetails) return;
        if (autoHeightSetupAttempt > 10) return;
        const eChild = eGui.current?.firstChild;
        if (eChild) {
            rowCtrl.setupDetailRowAutoHeight(eChild);
            autoHeightSetup.current = true;
        } else setAutoHeightSetupAttempt((prev)=>prev + 1);
    }, [
        fullWidthCompDetails,
        autoHeightSetupAttempt
    ]);
    const cssClassManager = (0, $aaLBe.useRef)();
    if (!cssClassManager.current) cssClassManager.current = new (0, $7b57b57eaf5a9648$export$a7053cb7eb605bd2)(()=>eGui.current);
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGui.current = e;
        if (!eGui.current) {
            rowCtrl.unsetComp(containerType);
            return;
        }
        if (!rowCtrl.isAlive()) return;
        const compProxy = {
            setTop: // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
            // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
            setTop,
            setTransform: setTransform,
            // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
            // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
            addOrRemoveCssClass: (name, on)=>cssClassManager.current.addOrRemoveCssClass(name, on),
            setDomOrder: (domOrder)=>domOrderRef.current = domOrder,
            setRowIndex: setRowIndex,
            setRowId: setRowId,
            setRowBusinessKey: setRowBusinessKey,
            setUserStyles: setUserStyles,
            // if we don't maintain the order, then cols will be ripped out and into the dom
            // when cols reordered, which would stop the CSS transitions from working
            setCellCtrls: (next, useFlushSync)=>{
                prevCellCtrlsRef.current = cellCtrlsRef.current;
                cellCtrlsRef.current = next;
                const nextCells = $89799df32d2d843b$var$getNextValueIfDifferent(prevCellCtrlsRef.current, next, domOrderRef.current);
                if (nextCells !== prevCellCtrlsRef.current) $89799df32d2d843b$var$agFlushSync(useFlushSync, ()=>setCellCtrls(nextCells));
            },
            showFullWidth: (compDetails)=>setFullWidthCompDetails(compDetails),
            getFullWidthCellRenderer: ()=>fullWidthCompRef.current,
            refreshFullWidth: (getUpdatedParams)=>{
                if (canRefreshFullWidthRef.current) {
                    setFullWidthCompDetails((prevFullWidthCompDetails)=>({
                            ...prevFullWidthCompDetails,
                            params: getUpdatedParams()
                        }));
                    return true;
                } else {
                    if (!fullWidthCompRef.current || !fullWidthCompRef.current.refresh) return false;
                    return fullWidthCompRef.current.refresh(getUpdatedParams());
                }
            }
        };
        rowCtrl.setComp(compProxy, eGui.current, containerType);
    }, []);
    (0, $aaLBe.useLayoutEffect)(()=>$89799df32d2d843b$var$showJsComp(fullWidthCompDetails, context, eGui.current, fullWidthCompRef), [
        fullWidthCompDetails
    ]);
    const rowStyles = (0, $aaLBe.useMemo)(()=>{
        const res = {
            top: top,
            transform: transform
        };
        Object.assign(res, userStyles);
        return res;
    }, [
        top,
        transform,
        userStyles
    ]);
    const showFullWidthFramework = isFullWidth && fullWidthCompDetails && fullWidthCompDetails.componentFromFramework;
    const showCells = !isFullWidth && cellCtrls != null;
    const reactFullWidthCellRendererStateless = (0, $aaLBe.useMemo)(()=>{
        const res = fullWidthCompDetails?.componentFromFramework && $89799df32d2d843b$var$isComponentStateless(fullWidthCompDetails.componentClass);
        return !!res;
    }, [
        fullWidthCompDetails
    ]);
    const canRefreshFullWidthRef = (0, $aaLBe.useRef)(false);
    (0, $aaLBe.useEffect)(()=>{
        canRefreshFullWidthRef.current = reactFullWidthCellRendererStateless && !!fullWidthCompDetails && !!gos.get("reactiveCustomComponents");
    }, [
        reactFullWidthCellRendererStateless,
        fullWidthCompDetails
    ]);
    const showCellsJsx = ()=>cellCtrls?.map((cellCtrl)=>/* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$cellComp_default, {
                cellCtrl: cellCtrl,
                editingRow: rowCtrl.isEditing(),
                printLayout: rowCtrl.isPrintLayout(),
                key: cellCtrl.getInstanceId()
            }));
    const showFullWidthFrameworkJsx = ()=>{
        const FullWidthComp = fullWidthCompDetails.componentClass;
        return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, reactFullWidthCellRendererStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(FullWidthComp, {
            ...fullWidthCompDetails.params
        }), !reactFullWidthCellRendererStateless && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement(FullWidthComp, {
            ...fullWidthCompDetails.params,
            ref: fullWidthCompRef
        }));
    };
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        role: "row",
        style: rowStyles,
        "row-index": rowIndex,
        "row-id": rowId,
        "row-business-key": rowBusinessKey,
        tabIndex: tabIndex
    }, showCells && showCellsJsx(), showFullWidthFramework && showFullWidthFrameworkJsx());
};
var $89799df32d2d843b$var$rowComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$RowComp);
// packages/ag-grid-react/src/reactUi/rows/rowContainerComp.tsx
var $89799df32d2d843b$var$RowContainerComp = (params)=>{
    const { context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const { name: name  } = params;
    const containerOptions = (0, $aaLBe.useMemo)(()=>(0, $7b57b57eaf5a9648$export$a46aad9f8c79261f)(name), [
        name
    ]);
    const eViewport = (0, $aaLBe.useRef)(null);
    const eContainer = (0, $aaLBe.useRef)(null);
    const rowCtrlsRef = (0, $aaLBe.useRef)([]);
    const prevRowCtrlsRef = (0, $aaLBe.useRef)([]);
    const [rowCtrlsOrdered, setRowCtrlsOrdered] = (0, $aaLBe.useState)(()=>[]);
    const domOrderRef = (0, $aaLBe.useRef)(false);
    const rowContainerCtrlRef = (0, $aaLBe.useRef)();
    const viewportClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList(containerOptions.viewport), [
        containerOptions
    ]);
    const containerClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList(containerOptions.container), [
        containerOptions
    ]);
    const isCenter = containerOptions.type === "center";
    const topLevelRef = isCenter ? eViewport : eContainer;
    $89799df32d2d843b$var$reactComment_default(" AG Row Container " + name + " ", topLevelRef);
    const areElementsReady = (0, $aaLBe.useCallback)(()=>{
        if (isCenter) return eViewport.current != null && eContainer.current != null;
        return eContainer.current != null;
    }, []);
    const areElementsRemoved = (0, $aaLBe.useCallback)(()=>{
        if (isCenter) return eViewport.current == null && eContainer.current == null;
        return eContainer.current == null;
    }, []);
    const setRef2 = (0, $aaLBe.useCallback)(()=>{
        if (areElementsRemoved()) {
            context.destroyBean(rowContainerCtrlRef.current);
            rowContainerCtrlRef.current = null;
        }
        if (areElementsReady()) {
            const updateRowCtrlsOrdered = (useFlushSync)=>{
                const next = $89799df32d2d843b$var$getNextValueIfDifferent(prevRowCtrlsRef.current, rowCtrlsRef.current, domOrderRef.current);
                if (next !== prevRowCtrlsRef.current) {
                    prevRowCtrlsRef.current = next;
                    $89799df32d2d843b$var$agFlushSync(useFlushSync, ()=>setRowCtrlsOrdered(next));
                }
            };
            const compProxy = {
                setViewportHeight: (height)=>{
                    if (eViewport.current) eViewport.current.style.height = height;
                },
                setRowCtrls: ({ rowCtrls: rowCtrls , useFlushSync: useFlushSync  })=>{
                    const useFlush = !!useFlushSync && rowCtrlsRef.current.length > 0 && rowCtrls.length > 0;
                    rowCtrlsRef.current = rowCtrls;
                    updateRowCtrlsOrdered(useFlush);
                },
                setDomOrder: (domOrder)=>{
                    if (domOrderRef.current != domOrder) {
                        domOrderRef.current = domOrder;
                        updateRowCtrlsOrdered(false);
                    }
                },
                setContainerWidth: (width)=>{
                    if (eContainer.current) eContainer.current.style.width = width;
                },
                setOffsetTop: (offset)=>{
                    if (eContainer.current) eContainer.current.style.transform = `translateY(${offset})`;
                }
            };
            rowContainerCtrlRef.current = context.createBean(new (0, $7b57b57eaf5a9648$export$2d4385f6f566fe5e)(name));
            rowContainerCtrlRef.current.setComp(compProxy, eContainer.current, eViewport.current);
        }
    }, [
        areElementsReady,
        areElementsRemoved
    ]);
    const setContainerRef = (0, $aaLBe.useCallback)((e)=>{
        eContainer.current = e;
        setRef2();
    }, [
        setRef2
    ]);
    const setViewportRef = (0, $aaLBe.useCallback)((e)=>{
        eViewport.current = e;
        setRef2();
    }, [
        setRef2
    ]);
    const buildContainer = ()=>/* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
            className: containerClasses,
            ref: setContainerRef,
            role: "rowgroup"
        }, rowCtrlsOrdered.map((rowCtrl)=>/* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$rowComp_default, {
                rowCtrl: rowCtrl,
                containerType: containerOptions.type,
                key: rowCtrl.getInstanceId()
            })));
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, isCenter ? /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        className: viewportClasses,
        ref: setViewportRef,
        role: "presentation"
    }, buildContainer()) : buildContainer());
};
var $89799df32d2d843b$var$rowContainerComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$RowContainerComp);
// packages/ag-grid-react/src/reactUi/gridBodyComp.tsx
var $89799df32d2d843b$var$GridBodyComp = ()=>{
    const { context: context , resizeObserverService: resizeObserverService  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const [rowAnimationClass, setRowAnimationClass] = (0, $aaLBe.useState)("");
    const [topHeight, setTopHeight] = (0, $aaLBe.useState)(0);
    const [bottomHeight, setBottomHeight] = (0, $aaLBe.useState)(0);
    const [stickyTopHeight, setStickyTopHeight] = (0, $aaLBe.useState)("0px");
    const [stickyTopTop, setStickyTopTop] = (0, $aaLBe.useState)("0px");
    const [stickyTopWidth, setStickyTopWidth] = (0, $aaLBe.useState)("100%");
    const [stickyBottomHeight, setStickyBottomHeight] = (0, $aaLBe.useState)("0px");
    const [stickyBottomBottom, setStickyBottomBottom] = (0, $aaLBe.useState)("0px");
    const [stickyBottomWidth, setStickyBottomWidth] = (0, $aaLBe.useState)("100%");
    const [topDisplay, setTopDisplay] = (0, $aaLBe.useState)("");
    const [bottomDisplay, setBottomDisplay] = (0, $aaLBe.useState)("");
    const [forceVerticalScrollClass, setForceVerticalScrollClass] = (0, $aaLBe.useState)(null);
    const [topAndBottomOverflowY, setTopAndBottomOverflowY] = (0, $aaLBe.useState)("");
    const [cellSelectableCss, setCellSelectableCss] = (0, $aaLBe.useState)(null);
    const [layoutClass, setLayoutClass] = (0, $aaLBe.useState)("ag-layout-normal");
    const cssClassManager = (0, $aaLBe.useRef)();
    if (!cssClassManager.current) cssClassManager.current = new (0, $7b57b57eaf5a9648$export$a7053cb7eb605bd2)(()=>eRoot.current);
    const eRoot = (0, $aaLBe.useRef)(null);
    const eTop = (0, $aaLBe.useRef)(null);
    const eStickyTop = (0, $aaLBe.useRef)(null);
    const eStickyBottom = (0, $aaLBe.useRef)(null);
    const eBody = (0, $aaLBe.useRef)(null);
    const eBodyViewport = (0, $aaLBe.useRef)(null);
    const eBottom = (0, $aaLBe.useRef)(null);
    const beansToDestroy = (0, $aaLBe.useRef)([]);
    const destroyFuncs = (0, $aaLBe.useRef)([]);
    $89799df32d2d843b$var$reactComment_default(" AG Grid Body ", eRoot);
    $89799df32d2d843b$var$reactComment_default(" AG Pinned Top ", eTop);
    $89799df32d2d843b$var$reactComment_default(" AG Sticky Top ", eStickyTop);
    $89799df32d2d843b$var$reactComment_default(" AG Middle ", eBodyViewport);
    $89799df32d2d843b$var$reactComment_default(" AG Pinned Bottom ", eBottom);
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eRoot.current = e;
        if (!eRoot.current) {
            context.destroyBeans(beansToDestroy.current);
            destroyFuncs.current.forEach((f)=>f());
            beansToDestroy.current = [];
            destroyFuncs.current = [];
            return;
        }
        if (!context) return;
        const attachToDom = (eParent, eChild)=>{
            eParent.appendChild(eChild);
            destroyFuncs.current.push(()=>eParent.removeChild(eChild));
        };
        const newComp = (compClass)=>{
            const comp = context.createBean(new compClass());
            beansToDestroy.current.push(comp);
            return comp;
        };
        const addComp = (eParent, compClass, comment)=>{
            attachToDom(eParent, document.createComment(comment));
            attachToDom(eParent, newComp(compClass).getGui());
        };
        addComp(eRoot.current, (0, $7b57b57eaf5a9648$export$8f252e09ef6be2d3), " AG Fake Horizontal Scroll ");
        addComp(eRoot.current, (0, $7b57b57eaf5a9648$export$869f90871f63c638), " AG Overlay Wrapper ");
        if (eBody.current) addComp(eBody.current, (0, $7b57b57eaf5a9648$export$f496fc30dbebdfa3), " AG Fake Vertical Scroll ");
        const compProxy = {
            setRowAnimationCssOnBodyViewport: setRowAnimationClass,
            setColumnCount: (count)=>{
                if (eRoot.current) (0, $7b57b57eaf5a9648$export$56744a26086b5898)(eRoot.current, count);
            },
            setRowCount: (count)=>{
                if (eRoot.current) (0, $7b57b57eaf5a9648$export$1ad8496b26b660f8)(eRoot.current, count);
            },
            setTopHeight: setTopHeight,
            setBottomHeight: setBottomHeight,
            setStickyTopHeight: setStickyTopHeight,
            setStickyTopTop: setStickyTopTop,
            setStickyTopWidth: setStickyTopWidth,
            setTopDisplay: setTopDisplay,
            setBottomDisplay: setBottomDisplay,
            setColumnMovingCss: (cssClass, flag)=>cssClassManager.current.addOrRemoveCssClass(cssClass, flag),
            updateLayoutClasses: setLayoutClass,
            setAlwaysVerticalScrollClass: setForceVerticalScrollClass,
            setPinnedTopBottomOverflowY: setTopAndBottomOverflowY,
            setCellSelectableCss: (cssClass, flag)=>setCellSelectableCss(flag ? cssClass : null),
            setBodyViewportWidth: (width)=>{
                if (eBodyViewport.current) eBodyViewport.current.style.width = width;
            },
            registerBodyViewportResizeListener: (listener)=>{
                if (eBodyViewport.current) {
                    const unsubscribeFromResize = resizeObserverService.observeResize(eBodyViewport.current, listener);
                    destroyFuncs.current.push(()=>unsubscribeFromResize());
                }
            },
            setStickyBottomHeight: setStickyBottomHeight,
            setStickyBottomBottom: setStickyBottomBottom,
            setStickyBottomWidth: setStickyBottomWidth
        };
        const ctrl = context.createBean(new (0, $7b57b57eaf5a9648$export$8bebc3145b40d221)());
        beansToDestroy.current.push(ctrl);
        ctrl.setComp(compProxy, eRoot.current, eBodyViewport.current, eTop.current, eBottom.current, eStickyTop.current, eStickyBottom.current);
    }, []);
    const rootClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-root", "ag-unselectable", layoutClass), [
        layoutClass
    ]);
    const bodyViewportClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-body-viewport", rowAnimationClass, layoutClass, forceVerticalScrollClass, cellSelectableCss), [
        rowAnimationClass,
        layoutClass,
        forceVerticalScrollClass,
        cellSelectableCss
    ]);
    const bodyClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-body", layoutClass), [
        layoutClass
    ]);
    const topClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-floating-top", cellSelectableCss), [
        cellSelectableCss
    ]);
    const stickyTopClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-sticky-top", cellSelectableCss), [
        cellSelectableCss
    ]);
    const stickyBottomClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-sticky-bottom", cellSelectableCss), [
        cellSelectableCss
    ]);
    const bottomClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-floating-bottom", cellSelectableCss), [
        cellSelectableCss
    ]);
    const topStyle = (0, $aaLBe.useMemo)(()=>({
            height: topHeight,
            minHeight: topHeight,
            display: topDisplay,
            overflowY: topAndBottomOverflowY
        }), [
        topHeight,
        topDisplay,
        topAndBottomOverflowY
    ]);
    const stickyTopStyle = (0, $aaLBe.useMemo)(()=>({
            height: stickyTopHeight,
            top: stickyTopTop,
            width: stickyTopWidth
        }), [
        stickyTopHeight,
        stickyTopTop,
        stickyTopWidth
    ]);
    const stickyBottomStyle = (0, $aaLBe.useMemo)(()=>({
            height: stickyBottomHeight,
            bottom: stickyBottomBottom,
            width: stickyBottomWidth
        }), [
        stickyBottomHeight,
        stickyBottomBottom,
        stickyBottomWidth
    ]);
    const bottomStyle = (0, $aaLBe.useMemo)(()=>({
            height: bottomHeight,
            minHeight: bottomHeight,
            display: bottomDisplay,
            overflowY: topAndBottomOverflowY
        }), [
        bottomHeight,
        bottomDisplay,
        topAndBottomOverflowY
    ]);
    const createRowContainer = (container)=>/* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$rowContainerComp_default, {
            name: container,
            key: `${container}-container`
        });
    const createSection = ({ section: section , children: children , className: className , style: style  })=>/* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
            ref: section,
            className: className,
            role: "presentation",
            style: style
        }, children.map(createRowContainer));
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: rootClasses,
        role: "treegrid"
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$gridHeaderComp_default, null), createSection({
        section: eTop,
        className: topClasses,
        style: topStyle,
        children: [
            "topLeft",
            "topCenter",
            "topRight",
            "topFullWidth"
        ]
    }), /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        className: bodyClasses,
        ref: eBody,
        role: "presentation"
    }, createSection({
        section: eBodyViewport,
        className: bodyViewportClasses,
        children: [
            "left",
            "center",
            "right",
            "fullWidth"
        ]
    })), createSection({
        section: eStickyTop,
        className: stickyTopClasses,
        style: stickyTopStyle,
        children: [
            "stickyTopLeft",
            "stickyTopCenter",
            "stickyTopRight",
            "stickyTopFullWidth"
        ]
    }), createSection({
        section: eStickyBottom,
        className: stickyBottomClasses,
        style: stickyBottomStyle,
        children: [
            "stickyBottomLeft",
            "stickyBottomCenter",
            "stickyBottomRight",
            "stickyBottomFullWidth"
        ]
    }), createSection({
        section: eBottom,
        className: bottomClasses,
        style: bottomStyle,
        children: [
            "bottomLeft",
            "bottomCenter",
            "bottomRight",
            "bottomFullWidth"
        ]
    }));
};
var $89799df32d2d843b$var$gridBodyComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$GridBodyComp);
var $89799df32d2d843b$var$TabGuardCompRef = (props, forwardRef4)=>{
    const { children: children , eFocusableElement: eFocusableElement , onTabKeyDown: onTabKeyDown , gridCtrl: gridCtrl , forceFocusOutWhenTabGuardsAreEmpty: forceFocusOutWhenTabGuardsAreEmpty  } = props;
    const { context: context  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const topTabGuardRef = (0, $aaLBe.useRef)(null);
    const bottomTabGuardRef = (0, $aaLBe.useRef)(null);
    const tabGuardCtrlRef = (0, $aaLBe.useRef)();
    const setTabIndex = (value)=>{
        const processedValue = value == null ? void 0 : parseInt(value, 10).toString();
        [
            topTabGuardRef,
            bottomTabGuardRef
        ].forEach((tabGuard)=>{
            if (processedValue === void 0) tabGuard.current?.removeAttribute("tabindex");
            else tabGuard.current?.setAttribute("tabindex", processedValue);
        });
    };
    (0, $aaLBe.useImperativeHandle)(forwardRef4, ()=>({
            forceFocusOutOfContainer (up) {
                tabGuardCtrlRef.current?.forceFocusOutOfContainer(up);
            }
        }));
    const setupCtrl = (0, $aaLBe.useCallback)(()=>{
        if (!topTabGuardRef.current && !bottomTabGuardRef.current) {
            context.destroyBean(tabGuardCtrlRef.current);
            tabGuardCtrlRef.current = null;
            return;
        }
        if (topTabGuardRef.current && bottomTabGuardRef.current) {
            const compProxy = {
                setTabIndex: setTabIndex
            };
            tabGuardCtrlRef.current = context.createBean(new (0, $7b57b57eaf5a9648$export$3074753638c3772c)({
                comp: compProxy,
                eTopGuard: topTabGuardRef.current,
                eBottomGuard: bottomTabGuardRef.current,
                eFocusableElement: eFocusableElement,
                onTabKeyDown: onTabKeyDown,
                forceFocusOutWhenTabGuardsAreEmpty: forceFocusOutWhenTabGuardsAreEmpty,
                focusInnerElement: (fromBottom)=>gridCtrl.focusInnerElement(fromBottom)
            }));
        }
    }, []);
    const setTopRef = (0, $aaLBe.useCallback)((e)=>{
        topTabGuardRef.current = e;
        setupCtrl();
    }, [
        setupCtrl
    ]);
    const setBottomRef = (0, $aaLBe.useCallback)((e)=>{
        bottomTabGuardRef.current = e;
        setupCtrl();
    }, [
        setupCtrl
    ]);
    const createTabGuard = (side)=>{
        const className = side === "top" ? (0, $7b57b57eaf5a9648$export$3be5727576441c72).TAB_GUARD_TOP : (0, $7b57b57eaf5a9648$export$3be5727576441c72).TAB_GUARD_BOTTOM;
        return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
            className: `${(0, $7b57b57eaf5a9648$export$3be5727576441c72).TAB_GUARD} ${className}`,
            role: "presentation",
            ref: side === "top" ? setTopRef : setBottomRef
        });
    };
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).Fragment, null, createTabGuard("top"), children, createTabGuard("bottom"));
};
var $89799df32d2d843b$var$TabGuardComp = (0, $aaLBe.forwardRef)($89799df32d2d843b$var$TabGuardCompRef);
var $89799df32d2d843b$var$tabGuardComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$TabGuardComp);
// packages/ag-grid-react/src/reactUi/gridComp.tsx
var $89799df32d2d843b$var$GridComp = ({ context: context  })=>{
    const [rtlClass, setRtlClass] = (0, $aaLBe.useState)("");
    const [layoutClass, setLayoutClass] = (0, $aaLBe.useState)("");
    const [cursor, setCursor] = (0, $aaLBe.useState)(null);
    const [userSelect, setUserSelect] = (0, $aaLBe.useState)(null);
    const [initialised, setInitialised] = (0, $aaLBe.useState)(false);
    const [tabGuardReady, setTabGuardReady] = (0, $aaLBe.useState)();
    const gridCtrlRef = (0, $aaLBe.useRef)(null);
    const eRootWrapperRef = (0, $aaLBe.useRef)(null);
    const tabGuardRef = (0, $aaLBe.useRef)();
    const [eGridBodyParent, setGridBodyParent] = (0, $aaLBe.useState)(null);
    const focusInnerElementRef = (0, $aaLBe.useRef)(()=>void 0);
    const paginationCompRef = (0, $aaLBe.useRef)();
    const focusableContainersRef = (0, $aaLBe.useRef)([]);
    const onTabKeyDown = (0, $aaLBe.useCallback)(()=>void 0, []);
    const beans = (0, $aaLBe.useMemo)(()=>{
        if (context.isDestroyed()) return null;
        return context.getBeans();
    }, [
        context
    ]);
    $89799df32d2d843b$var$reactComment_default(" AG Grid ", eRootWrapperRef);
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eRootWrapperRef.current = e;
        if (!eRootWrapperRef.current) {
            context.destroyBean(gridCtrlRef.current);
            gridCtrlRef.current = null;
            return;
        }
        if (context.isDestroyed()) return;
        gridCtrlRef.current = context.createBean(new (0, $7b57b57eaf5a9648$export$f3c741dac0be9745)());
        const gridCtrl = gridCtrlRef.current;
        focusInnerElementRef.current = gridCtrl.focusInnerElement.bind(gridCtrl);
        const compProxy = {
            destroyGridUi: ()=>{},
            setRtlClass: // do nothing, as framework users destroy grid by removing the comp
            setRtlClass,
            forceFocusOutOfContainer: (up)=>{
                if (!up && paginationCompRef.current?.isDisplayed()) {
                    paginationCompRef.current.forceFocusOutOfContainer(up);
                    return;
                }
                tabGuardRef.current?.forceFocusOutOfContainer(up);
            },
            updateLayoutClasses: setLayoutClass,
            getFocusableContainers: ()=>{
                const comps = [];
                const gridBodyCompEl = eRootWrapperRef.current?.querySelector(".ag-root");
                if (gridBodyCompEl) comps.push({
                    getGui: ()=>gridBodyCompEl
                });
                focusableContainersRef.current.forEach((comp)=>{
                    if (comp.isDisplayed()) comps.push(comp);
                });
                return comps;
            },
            setCursor: setCursor,
            setUserSelect: setUserSelect
        };
        gridCtrl.setComp(compProxy, eRootWrapperRef.current, eRootWrapperRef.current);
        setInitialised(true);
    }, []);
    (0, $aaLBe.useEffect)(()=>{
        if (!tabGuardReady || !beans || !gridCtrlRef.current || !eGridBodyParent || !eRootWrapperRef.current) return;
        const gridCtrl = gridCtrlRef.current;
        const beansToDestroy = [];
        const { watermarkSelector: watermarkSelector , paginationSelector: paginationSelector , sideBarSelector: sideBarSelector , statusBarSelector: statusBarSelector , gridHeaderDropZonesSelector: gridHeaderDropZonesSelector  } = gridCtrl.getOptionalSelectors();
        const additionalEls = [];
        const eRootWrapper = eRootWrapperRef.current;
        if (gridHeaderDropZonesSelector) {
            const headerDropZonesComp = context.createBean(new gridHeaderDropZonesSelector.component());
            const eGui = headerDropZonesComp.getGui();
            eRootWrapper.insertAdjacentElement("afterbegin", eGui);
            additionalEls.push(eGui);
            beansToDestroy.push(headerDropZonesComp);
        }
        if (sideBarSelector) {
            const sideBarComp = context.createBean(new sideBarSelector.component());
            const eGui = sideBarComp.getGui();
            const bottomTabGuard = eGridBodyParent.querySelector(".ag-tab-guard-bottom");
            if (bottomTabGuard) {
                bottomTabGuard.insertAdjacentElement("beforebegin", eGui);
                additionalEls.push(eGui);
            }
            beansToDestroy.push(sideBarComp);
            focusableContainersRef.current.push(sideBarComp);
        }
        const addComponentToDom = (component)=>{
            const comp = context.createBean(new component());
            const eGui = comp.getGui();
            eRootWrapper.insertAdjacentElement("beforeend", eGui);
            additionalEls.push(eGui);
            beansToDestroy.push(comp);
            return comp;
        };
        if (statusBarSelector) addComponentToDom(statusBarSelector.component);
        if (paginationSelector) {
            const paginationComp = addComponentToDom(paginationSelector.component);
            paginationCompRef.current = paginationComp;
            focusableContainersRef.current.push(paginationComp);
        }
        if (watermarkSelector) addComponentToDom(watermarkSelector.component);
        return ()=>{
            context.destroyBeans(beansToDestroy);
            additionalEls.forEach((el)=>{
                if (el.parentElement) el.parentElement.removeChild(el);
            });
        };
    }, [
        tabGuardReady,
        eGridBodyParent,
        beans
    ]);
    const rootWrapperClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-root-wrapper", rtlClass, layoutClass), [
        rtlClass,
        layoutClass
    ]);
    const rootWrapperBodyClasses = (0, $aaLBe.useMemo)(()=>$89799df32d2d843b$var$classesList("ag-root-wrapper-body", "ag-focus-managed", layoutClass), [
        layoutClass
    ]);
    const topStyle = (0, $aaLBe.useMemo)(()=>({
            userSelect: userSelect != null ? userSelect : "",
            WebkitUserSelect: userSelect != null ? userSelect : "",
            cursor: cursor != null ? cursor : ""
        }), [
        userSelect,
        cursor
    ]);
    const setTabGuardCompRef = (0, $aaLBe.useCallback)((ref)=>{
        tabGuardRef.current = ref;
        setTabGuardReady(ref !== null);
    }, []);
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        ref: setRef2,
        className: rootWrapperClasses,
        style: topStyle,
        role: "presentation"
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        className: rootWrapperBodyClasses,
        ref: setGridBodyParent,
        role: "presentation"
    }, initialised && eGridBodyParent && beans && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$BeansContext.Provider, {
        value: beans
    }, /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$tabGuardComp_default, {
        ref: setTabGuardCompRef,
        eFocusableElement: eGridBodyParent,
        onTabKeyDown: onTabKeyDown,
        gridCtrl: gridCtrlRef.current,
        forceFocusOutWhenTabGuardsAreEmpty: true
    }, // we wait for initialised before rending the children, so GridComp has created and registered with it's
    // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
    // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
    // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
    // hangs the UI)
    /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$gridBodyComp_default, null)))));
};
var $89799df32d2d843b$var$gridComp_default = (0, $aaLBe.memo)($89799df32d2d843b$var$GridComp);
var $89799df32d2d843b$var$RenderStatusService = class extends (0, $7b57b57eaf5a9648$export$2032c8ef3788dfbd) {
    wireBeans(beans) {
        this.ctrlsService = beans.ctrlsService;
    }
    areHeaderCellsRendered() {
        return this.ctrlsService.getHeaderRowContainerCtrls().every((container)=>container.getAllCtrls().every((ctrl)=>ctrl.areCellsRendered()));
    }
};
// packages/ag-grid-react/src/reactUi/agGridReactUi.tsx
var $89799df32d2d843b$var$AgGridReactUi = (props)=>{
    const apiRef = (0, $aaLBe.useRef)();
    const eGui = (0, $aaLBe.useRef)(null);
    const portalManager = (0, $aaLBe.useRef)(null);
    const destroyFuncs = (0, $aaLBe.useRef)([]);
    const whenReadyFuncs = (0, $aaLBe.useRef)([]);
    const prevProps = (0, $aaLBe.useRef)(props);
    const frameworkOverridesRef = (0, $aaLBe.useRef)();
    const ready = (0, $aaLBe.useRef)(false);
    const [context, setContext] = (0, $aaLBe.useState)(void 0);
    const [, setPortalRefresher] = (0, $aaLBe.useState)(0);
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGui.current = e;
        if (!eGui.current) {
            destroyFuncs.current.forEach((f)=>f());
            destroyFuncs.current.length = 0;
            return;
        }
        const modules = props.modules || [];
        if (!portalManager.current) {
            portalManager.current = new $89799df32d2d843b$var$PortalManager(()=>setPortalRefresher((prev)=>prev + 1), props.componentWrappingElement, props.maxComponentCreationTimeMs);
            destroyFuncs.current.push(()=>{
                portalManager.current?.destroy();
                portalManager.current = null;
            });
        }
        const mergedGridOps = (0, $7b57b57eaf5a9648$export$bfe37fc2d3c03134)(props.gridOptions, props);
        const processQueuedUpdates = ()=>{
            if (ready.current) {
                const getFn = ()=>frameworkOverridesRef.current?.shouldQueueUpdates() ? void 0 : whenReadyFuncs.current.shift();
                let fn = getFn();
                while(fn){
                    fn();
                    fn = getFn();
                }
            }
        };
        const frameworkOverrides = $89799df32d2d843b$var$isReact17Minus() ? new $89799df32d2d843b$var$React17MinusFrameworkOverrides(processQueuedUpdates) : new $89799df32d2d843b$var$ReactFrameworkOverrides();
        frameworkOverridesRef.current = frameworkOverrides;
        const renderStatusService = new $89799df32d2d843b$var$RenderStatusService();
        const gridParams = {
            providedBeanInstances: {
                frameworkComponentWrapper: new $89799df32d2d843b$var$ReactFrameworkComponentWrapper(portalManager.current, mergedGridOps.reactiveCustomComponents ?? true),
                renderStatusService: renderStatusService
            },
            modules: modules,
            frameworkOverrides: frameworkOverrides
        };
        const createUiCallback = (context2)=>{
            setContext(context2);
            context2.createBean(renderStatusService);
            destroyFuncs.current.push(()=>{
                context2.destroy();
            });
            const ctrlsService = context2.getBean("ctrlsService");
            ctrlsService.whenReady(()=>{
                if (context2.isDestroyed()) return;
                const api = apiRef.current;
                if (api) {
                    if (props.setGridApi) props.setGridApi(api);
                }
            });
        };
        const acceptChangesCallback = (context2)=>{
            const ctrlsService = context2.getBean("ctrlsService");
            ctrlsService.whenReady(()=>{
                whenReadyFuncs.current.forEach((f)=>f());
                whenReadyFuncs.current.length = 0;
                ready.current = true;
            });
        };
        const gridCoreCreator = new (0, $7b57b57eaf5a9648$export$7759b93c6200a2f9)();
        apiRef.current = gridCoreCreator.create(eGui.current, mergedGridOps, createUiCallback, acceptChangesCallback, gridParams);
    }, []);
    const style = (0, $aaLBe.useMemo)(()=>{
        return {
            height: "100%",
            ...props.containerStyle || {}
        };
    }, [
        props.containerStyle
    ]);
    const processWhenReady = (0, $aaLBe.useCallback)((func)=>{
        if (ready.current && !frameworkOverridesRef.current?.shouldQueueUpdates()) func();
        else whenReadyFuncs.current.push(func);
    }, []);
    (0, $aaLBe.useEffect)(()=>{
        const changes = $89799df32d2d843b$var$extractGridPropertyChanges(prevProps.current, props);
        prevProps.current = props;
        processWhenReady(()=>{
            if (apiRef.current) (0, $7b57b57eaf5a9648$export$52208033bd24c2b2)(changes, apiRef.current);
        });
    }, [
        props
    ]);
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        style: style,
        className: props.className,
        ref: setRef2
    }, context && !context.isDestroyed() ? /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$gridComp_default, {
        context: context
    }) : null, portalManager.current?.getPortals() ?? null);
};
function $89799df32d2d843b$var$extractGridPropertyChanges(prevProps, nextProps) {
    const changes = {};
    Object.keys(nextProps).forEach((propKey)=>{
        const propValue = nextProps[propKey];
        if (prevProps[propKey] !== propValue) changes[propKey] = propValue;
    });
    return changes;
}
var $89799df32d2d843b$var$ReactFrameworkComponentWrapper = class extends (0, $7b57b57eaf5a9648$export$157f014d661b6f19) {
    constructor(parent, reactiveCustomComponents){
        super();
        this.parent = parent;
        this.reactiveCustomComponents = reactiveCustomComponents;
    }
    createWrapper(UserReactComponent, componentType) {
        if (this.reactiveCustomComponents) {
            const getComponentClass = (propertyName)=>{
                switch(propertyName){
                    case "filter":
                        return $89799df32d2d843b$var$FilterComponentWrapper;
                    case "floatingFilterComponent":
                        return $89799df32d2d843b$var$FloatingFilterComponentWrapper;
                    case "dateComponent":
                        return $89799df32d2d843b$var$DateComponentWrapper;
                    case "loadingOverlayComponent":
                        return $89799df32d2d843b$var$LoadingOverlayComponentWrapper;
                    case "noRowsOverlayComponent":
                        return $89799df32d2d843b$var$NoRowsOverlayComponentWrapper;
                    case "statusPanel":
                        return $89799df32d2d843b$var$StatusPanelComponentWrapper;
                    case "toolPanel":
                        return $89799df32d2d843b$var$ToolPanelComponentWrapper;
                    case "menuItem":
                        return $89799df32d2d843b$var$MenuItemComponentWrapper;
                    case "cellRenderer":
                        return $89799df32d2d843b$var$CellRendererComponentWrapper;
                }
            };
            const ComponentClass = getComponentClass(componentType.propertyName);
            if (ComponentClass) return new ComponentClass(UserReactComponent, this.parent, componentType);
        } else switch(componentType.propertyName){
            case "filter":
            case "floatingFilterComponent":
            case "dateComponent":
            case "loadingOverlayComponent":
            case "noRowsOverlayComponent":
            case "statusPanel":
            case "toolPanel":
            case "menuItem":
            case "cellRenderer":
                $89799df32d2d843b$export$e83e01bcf62967be();
                break;
        }
        const suppressFallbackMethods = !componentType.cellRenderer && componentType.propertyName !== "toolPanel";
        return new $89799df32d2d843b$var$ReactComponent(UserReactComponent, this.parent, componentType, suppressFallbackMethods);
    }
};
var $89799df32d2d843b$var$DetailCellRenderer = (0, $aaLBe.forwardRef)((props, ref)=>{
    const { ctrlsFactory: ctrlsFactory , context: context , gos: gos , resizeObserverService: resizeObserverService , rowModel: rowModel  } = (0, $aaLBe.useContext)($89799df32d2d843b$var$BeansContext);
    const [cssClasses, setCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses());
    const [gridCssClasses, setGridCssClasses] = (0, $aaLBe.useState)(()=>new $89799df32d2d843b$var$CssClasses());
    const [detailGridOptions, setDetailGridOptions] = (0, $aaLBe.useState)();
    const [detailRowData, setDetailRowData] = (0, $aaLBe.useState)();
    const ctrlRef = (0, $aaLBe.useRef)();
    const eGuiRef = (0, $aaLBe.useRef)(null);
    const resizeObserverDestroyFunc = (0, $aaLBe.useRef)();
    const parentModules = (0, $aaLBe.useMemo)(()=>(0, $7b57b57eaf5a9648$export$dc053975cc7f6c11).__getGridRegisteredModules(props.api.getGridId()), [
        props
    ]);
    const topClassName = (0, $aaLBe.useMemo)(()=>cssClasses.toString() + " ag-details-row", [
        cssClasses
    ]);
    const gridClassName = (0, $aaLBe.useMemo)(()=>gridCssClasses.toString() + " ag-details-grid", [
        gridCssClasses
    ]);
    if (ref) (0, $aaLBe.useImperativeHandle)(ref, ()=>({
            refresh () {
                return ctrlRef.current?.refresh() ?? false;
            }
        }));
    if (props.template) (0, $7b57b57eaf5a9648$export$2cf41453020eef66)("detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/");
    const setRef2 = (0, $aaLBe.useCallback)((e)=>{
        eGuiRef.current = e;
        if (!eGuiRef.current) {
            context.destroyBean(ctrlRef.current);
            if (resizeObserverDestroyFunc.current) resizeObserverDestroyFunc.current();
            return;
        }
        const compProxy = {
            addOrRemoveCssClass: (name, on)=>setCssClasses((prev)=>prev.setClass(name, on)),
            addOrRemoveDetailGridCssClass: (name, on)=>setGridCssClasses((prev)=>prev.setClass(name, on)),
            setDetailGrid: (gridOptions)=>setDetailGridOptions(gridOptions),
            setRowData: (rowData)=>setDetailRowData(rowData),
            getGui: ()=>eGuiRef.current
        };
        const ctrl = ctrlsFactory.getInstance("detailCellRenderer");
        if (!ctrl) return;
        context.createBean(ctrl);
        ctrl.init(compProxy, props);
        ctrlRef.current = ctrl;
        if (gos.get("detailRowAutoHeight")) {
            const checkRowSizeFunc = ()=>{
                if (eGuiRef.current == null) return;
                const clientHeight = eGuiRef.current.clientHeight;
                if (clientHeight != null && clientHeight > 0) {
                    const updateRowHeightFunc = ()=>{
                        props.node.setRowHeight(clientHeight);
                        if (rowModel.getType() === "clientSide") rowModel.onRowHeightChanged();
                        else if (rowModel.getType() === "serverSide") rowModel.onRowHeightChanged();
                    };
                    setTimeout(updateRowHeightFunc, 0);
                }
            };
            resizeObserverDestroyFunc.current = resizeObserverService.observeResize(eGuiRef.current, checkRowSizeFunc);
            checkRowSizeFunc();
        }
    }, []);
    const setGridApi = (0, $aaLBe.useCallback)((api)=>{
        ctrlRef.current?.registerDetailWithMaster(api);
    }, []);
    return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement("div", {
        className: topClassName,
        ref: setRef2
    }, detailGridOptions && /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$AgGridReactUi, {
        className: gridClassName,
        ...detailGridOptions,
        modules: parentModules,
        rowData: detailRowData,
        setGridApi: setGridApi
    }));
});
var $89799df32d2d843b$var$ReactFrameworkOverrides = class extends (0, $7b57b57eaf5a9648$export$8174ad74937c6482) {
    constructor(){
        super("react");
        this.frameworkComponents = {
            agGroupCellRenderer: $89799df32d2d843b$var$groupCellRenderer_default,
            agGroupRowRenderer: $89799df32d2d843b$var$groupCellRenderer_default,
            agDetailCellRenderer: $89799df32d2d843b$var$DetailCellRenderer
        };
        this.wrapIncoming = (callback, source)=>{
            if (source === "ensureVisible") return $89799df32d2d843b$var$runWithoutFlushSync(callback);
            return callback();
        };
        this.renderingEngine = "react";
    }
    frameworkComponent(name) {
        return this.frameworkComponents[name];
    }
    isFrameworkComponent(comp) {
        if (!comp) return false;
        const prototype = comp.prototype;
        const isJsComp = prototype && "getGui" in prototype;
        return !isJsComp;
    }
    shouldQueueUpdates() {
        return false;
    }
    getLockOnRefreshError() {
        return ` This error can also occur if using 'ReactDOM.render' instead of 'createRoot'. If so, please upgrade to 'createRoot'.`;
    }
};
var $89799df32d2d843b$var$React17MinusFrameworkOverrides = class extends $89799df32d2d843b$var$ReactFrameworkOverrides {
    constructor(processQueuedUpdates){
        super();
        this.processQueuedUpdates = processQueuedUpdates;
        this.queueUpdates = false;
    }
    getLockOnRefresh() {
        this.queueUpdates = true;
    }
    releaseLockOnRefresh() {
        this.queueUpdates = false;
        this.processQueuedUpdates();
    }
    shouldQueueUpdates() {
        return this.queueUpdates;
    }
    getLockOnRefreshError() {
        return "";
    }
};
// packages/ag-grid-react/src/agGridReact.tsx
var $89799df32d2d843b$export$4074462c5969a5d8 = class extends (0, $aaLBe.Component) {
    constructor(){
        super(...arguments);
        this.apiListeners = [];
        this.setGridApi = (api)=>{
            this.api = api;
            this.apiListeners.forEach((listener)=>listener(api));
        };
    }
    registerApiListener(listener) {
        this.apiListeners.push(listener);
    }
    componentWillUnmount() {
        this.apiListeners.length = 0;
    }
    render() {
        return /* @__PURE__ */ (0, (/*@__PURE__*/$parcel$interopDefault($aaLBe))).createElement($89799df32d2d843b$var$AgGridReactUi, {
            ...this.props,
            setGridApi: this.setGridApi
        });
    }
};
function $89799df32d2d843b$var$useGridCustomComponent(methods) {
    const { setMethods: setMethods  } = (0, $aaLBe.useContext)($89799df32d2d843b$export$9f6317c67b47ac67);
    setMethods(methods);
}
function $89799df32d2d843b$export$70780aa16b46d041(callbacks) {
    $89799df32d2d843b$var$useGridCustomComponent(callbacks);
}
function $89799df32d2d843b$export$ae0fe569b475a61(callbacks) {
    return $89799df32d2d843b$var$useGridCustomComponent(callbacks);
}
function $89799df32d2d843b$export$42838275cbf666c4(callbacks) {
    return $89799df32d2d843b$var$useGridCustomComponent(callbacks);
}
function $89799df32d2d843b$export$a2cd2617441b4952(callbacks) {
    $89799df32d2d843b$var$useGridCustomComponent(callbacks);
}
function $89799df32d2d843b$export$bfb597f578b2979b(callbacks) {
    $89799df32d2d843b$var$useGridCustomComponent(callbacks);
}






var $aaLBe = parcelRequire("aaLBe");


const $92213d6d3a277a3c$var$numFormatter = (params)=>(0, $23de77130e6fabd5$export$d9468344d3651243)(",.2~f")(params.value);
const $92213d6d3a277a3c$var$ColorCellRenderer = (params)=>{
    const backgroundColor = params.context.colorDRPrediction(params.value);
    const formattedText = $92213d6d3a277a3c$var$numFormatter(params);
    return /*#__PURE__*/ $aaLBe.createElement("div", null, /*#__PURE__*/ $aaLBe.createElement("div", {
        className: "colorbox",
        style: {
            backgroundColor: backgroundColor
        }
    }), /*#__PURE__*/ $aaLBe.createElement("span", null, formattedText));
};
let $92213d6d3a277a3c$export$46cf7c0d61fdaefc = class InstanceTable extends $aaLBe.Component {
    constructor(props){
        super(props);
        // @observable private _orderBy: string;
        // @observable private _order: 'asc' | 'desc';
        this.numDisplayed = 0;
        this.numDisplayed = this.props.instances.length;
    }
    render() {
        // const { instances, attributes } = this.props;
        //use variable declared in outer scope
        $92213d6d3a277a3c$var$currentTableData = this.props.instances.slice();
        const common = {
            sortable: true,
            resizable: true
        };
        const columnDefs = [
            {
                headerName: "ID",
                field: "id",
                sortable: true
            },
            {
                headerName: "Actual",
                field: "y",
                cellRenderer: $92213d6d3a277a3c$var$ColorCellRenderer,
                type: "numericColumn",
                valueFormatter: $92213d6d3a277a3c$var$numFormatter,
                ...common
            },
            {
                headerName: "Predicted",
                field: "prediction",
                cellRenderer: $92213d6d3a277a3c$var$ColorCellRenderer,
                type: "numericColumn",
                valueFormatter: $92213d6d3a277a3c$var$numFormatter,
                ...common
            },
            {
                headerName: "Difference",
                type: "numericColumn",
                valueGetter: (params)=>Math.abs(params.data.y - params.data.prediction),
                valueFormatter: $92213d6d3a277a3c$var$numFormatter,
                ...common
            },
            ...(0, $841120e180d215c5$export$a510af025ac2bbc1).model.features.filter((f)=>f.name !== "intercept").map((f)=>({
                    headerName: f.name,
                    field: f.name,
                    filter: f.valueType === (0, $bbdd41951bc984bf$export$c40deacab7e2491c).Numerical ? "agNumberColumnFilter" : "agTextColumnFilter",
                    type: f.valueType === (0, $bbdd41951bc984bf$export$c40deacab7e2491c).Numerical ? "numericColumn" : undefined,
                    ...common
                }))
        ];
        const defaultColDef = {
            width: 100,
            filter: "agNumberColumnFilter"
        };
        return /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "instance-table-area"
        }, /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "instance-table-options",
            key: "options"
        }, /*#__PURE__*/ $aaLBe.createElement("span", {
            className: "table-showing-count"
        }, "Showing ", /*#__PURE__*/ $aaLBe.createElement("span", {
            id: "table-selection-count"
        }, this.numDisplayed), " of ", /*#__PURE__*/ $aaLBe.createElement("span", {
            id: "num-of-instances"
        }, this.props.instances.length)), /*#__PURE__*/ $aaLBe.createElement("span", {
            style: {
                paddingLeft: "20px"
            }
        }, /*#__PURE__*/ $aaLBe.createElement((0, $12ad4d7e3c9070fc$export$2e2bcd8739ae039), {
            size: "small",
            variant: "outlined",
            onClick: (_)=>{
                if (this.api) this.api.setFilterModel(null);
            }
        }, "Clear Filters")), /*#__PURE__*/ $aaLBe.createElement("a", {
            href: "#",
            onClick: (e)=>{
                window.open("https://microsoft.github.io/SandDance/embed/v4/sanddance-embed.html", "_blank");
                e.preventDefault();
            },
            style: {
                position: "absolute",
                right: "0.5em",
                fontSize: "12px"
            }
        }, "open in SandDance")), /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "ag-theme-balham instance-table",
            key: "table"
        }, /*#__PURE__*/ $aaLBe.createElement((0, $89799df32d2d843b$export$4074462c5969a5d8), {
            gridOptions: {
                context: {
                    colorDRPrediction: this.props.colorDRPrediction
                }
            },
            columnDefs: columnDefs,
            rowData: $92213d6d3a277a3c$var$currentTableData,
            defaultColDef: defaultColDef,
            rowSelection: "multiple",
            //getRowNodeId={r => r.id}
            onRowSelected: (e)=>{
                if (e.node.isSelected()) {
                    if (e.api.getSelectedRows().length > 1) {
                        const currentSelection = (0, $841120e180d215c5$export$a510af025ac2bbc1).selectedInstance;
                        const firstUnselected = e.api.getSelectedRows().find((r)=>r.id !== currentSelection.id);
                        (0, $841120e180d215c5$export$a510af025ac2bbc1).updateSelection2(firstUnselected.id);
                    } else (0, $841120e180d215c5$export$a510af025ac2bbc1).updateSelection(e.data.id);
                }
            },
            onFilterChanged: (e)=>this.numDisplayed = e.api.getDisplayedRowCount()
        })));
    }
};
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $92213d6d3a277a3c$export$46cf7c0d61fdaefc.prototype, "numDisplayed", void 0);
$92213d6d3a277a3c$export$46cf7c0d61fdaefc = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $92213d6d3a277a3c$export$46cf7c0d61fdaefc);
let $92213d6d3a277a3c$var$currentTableData;
window.addEventListener("message", (e)=>{
    if (e.origin === "https://microsoft.github.io") {
        const { request: request  } = e.data;
        if (request) switch(request.action){
            case "init":
                {
                    const data = $92213d6d3a277a3c$var$currentTableData.map((d)=>{
                        return {
                            ...d,
                            Difference: Math.abs(d.y - d.prediction)
                        };
                    });
                    const message = {
                        data: data,
                        insight: {
                            chart: "scatterplot",
                            columns: {
                                color: "Difference",
                                x: "prediction",
                                y: "y"
                            },
                            scheme: "redblue"
                        }
                    };
                    e.source.postMessage(message, "*");
                    break;
                }
        }
    }
});


let $eaf8839829366ca4$export$7c6e2c02157bb7d2 = class Content extends $aaLBe.Component {
    constructor(...args){
        super(...args);
        this.instanceAreaSize = new $eaf8839829366ca4$var$SizeVariable($eaf8839829366ca4$var$COLLAPSED);
        this.shapeChartAreaSize = new $eaf8839829366ca4$var$SizeVariable();
    }
    render() {
        const { model: model  } = this.props;
        if (!model) return /*#__PURE__*/ $aaLBe.createElement("div", null);
        const instances = model.instanceData;
        const actualExtent = (0, $719ebe1dfe21c6ae$export$2e2bcd8739ae039)(instances, (d)=>d.y);
        const predictionExtent = (0, $719ebe1dfe21c6ae$export$2e2bcd8739ae039)(instances, (d)=>+model.getPrediction(d));
        const colorDRPrediction = (0, $231f47eacdf10284$export$2e2bcd8739ae039)((0, $2bc0efb4f93ab16b$export$c5cedbc1ab3be2c3)).domain([
            (0, $a9fca0efc4cc4e3d$export$2e2bcd8739ae039)([
                actualExtent[0],
                predictionExtent[0]
            ]),
            (0, $3c6663a447dc3064$export$2e2bcd8739ae039)([
                actualExtent[1],
                predictionExtent[1]
            ])
        ]);
        return /*#__PURE__*/ $aaLBe.createElement((0, $e4e47bbe06cfcef3$export$2e2bcd8739ae039), {
            split: "vertical",
            defaultSize: "50%",
            pane2Style: {
                overflow: "auto"
            }
        }, /*#__PURE__*/ $aaLBe.createElement((0, $e4e47bbe06cfcef3$export$2e2bcd8739ae039), {
            split: "horizontal",
            size: this.shapeChartAreaSize.size,
            onChange: (size)=>this.shapeChartAreaSize.size = size,
            pane2Style: {
                overflowY: "auto"
            }
        }, /*#__PURE__*/ $aaLBe.createElement((0, $ff19f33054265590$export$2d13e9563b23a413), {
            colorDRPrediction: colorDRPrediction
        }), /*#__PURE__*/ $aaLBe.createElement($eaf8839829366ca4$var$SplitPaneCollapser, {
            sizeVariable: this.shapeChartAreaSize
        }, /*#__PURE__*/ $aaLBe.createElement((0, $92213d6d3a277a3c$export$46cf7c0d61fdaefc), {
            colorDRPrediction: colorDRPrediction,
            instances: model.instances,
            attributes: model.attributes
        }))), /*#__PURE__*/ $aaLBe.createElement((0, $711b34c4742621de$export$47380024ae00923f), {
            colorDRPrediction: colorDRPrediction,
            model: model
        }));
    }
};
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $eaf8839829366ca4$export$7c6e2c02157bb7d2.prototype, "instanceAreaSize", void 0);
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $eaf8839829366ca4$export$7c6e2c02157bb7d2.prototype, "shapeChartAreaSize", void 0);
$eaf8839829366ca4$export$7c6e2c02157bb7d2 = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $eaf8839829366ca4$export$7c6e2c02157bb7d2);
class $eaf8839829366ca4$var$SizeVariable {
    constructor(size = $eaf8839829366ca4$var$EXPANDED){
        this.size = $eaf8839829366ca4$var$EXPANDED;
        this.size = size;
    }
}
(0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $11a86e62e4f971e6$export$5ab46cbf6120b33a)
], $eaf8839829366ca4$var$SizeVariable.prototype, "size", void 0);
class $eaf8839829366ca4$var$CollapserProps {
}
const $eaf8839829366ca4$var$COLLAPSED = "97%";
const $eaf8839829366ca4$var$EXPANDED = "50%";
let $eaf8839829366ca4$var$SplitPaneCollapser = class SplitPaneCollapser extends $aaLBe.Component {
    render() {
        const collapsed = this.props.sizeVariable.size === $eaf8839829366ca4$var$COLLAPSED;
        return [
            /*#__PURE__*/ $aaLBe.createElement("div", {
                className: "collapser-icon",
                key: "collapser"
            }, collapsed ? /*#__PURE__*/ $aaLBe.createElement((0, $391e58f71c9818f8$export$2e2bcd8739ae039), {
                onClick: (_)=>{
                    this.props.sizeVariable.size = $eaf8839829366ca4$var$EXPANDED;
                },
                title: "Expand"
            }, /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($8eb9945f6249aa81$exports))), {
                fontSize: "small"
            })) : /*#__PURE__*/ $aaLBe.createElement((0, $391e58f71c9818f8$export$2e2bcd8739ae039), {
                onClick: (_)=>{
                    this.props.sizeVariable.size = $eaf8839829366ca4$var$COLLAPSED;
                },
                title: "Collapse"
            }, /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($250892691146d37a$exports))), {
                fontSize: "small"
            }))),
            collapsed ? null : this.props.children
        ];
    }
};
$eaf8839829366ca4$var$SplitPaneCollapser = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $eaf8839829366ca4$var$SplitPaneCollapser);


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.


var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");

var $5tnPj = parcelRequire("5tnPj");
var $1735c851d7a9cb02$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            height: 1,
            margin: 0,
            // Reset browser default style.
            border: "none",
            flexShrink: 0,
            backgroundColor: theme.palette.divider
        },
        /* Styles applied to the root element if `absolute={true}`. */ absolute: {
            position: "absolute",
            bottom: 0,
            left: 0,
            width: "100%"
        },
        /* Styles applied to the root element if `variant="inset"`. */ inset: {
            marginLeft: 72
        },
        /* Styles applied to the root element if `light={true}`. */ light: {
            backgroundColor: (0, $5tnPj.alpha)(theme.palette.divider, 0.08)
        },
        /* Styles applied to the root element if `variant="middle"`. */ middle: {
            marginLeft: theme.spacing(2),
            marginRight: theme.spacing(2)
        },
        /* Styles applied to the root element if `orientation="vertical"`. */ vertical: {
            height: "100%",
            width: 1
        },
        /* Styles applied to the root element if `flexItem={true}`. */ flexItem: {
            alignSelf: "stretch",
            height: "auto"
        }
    };
};
var $1735c851d7a9cb02$var$Divider = /*#__PURE__*/ $aaLBe.forwardRef(function Divider(props, ref) {
    var _props$absolute = props.absolute, absolute = _props$absolute === void 0 ? false : _props$absolute, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "hr" : _props$component, _props$flexItem = props.flexItem, flexItem = _props$flexItem === void 0 ? false : _props$flexItem, _props$light = props.light, light = _props$light === void 0 ? false : _props$light, _props$orientation = props.orientation, orientation = _props$orientation === void 0 ? "horizontal" : _props$orientation, _props$role = props.role, role = _props$role === void 0 ? Component !== "hr" ? "separator" : undefined : _props$role, _props$variant = props.variant, variant = _props$variant === void 0 ? "fullWidth" : _props$variant, other = (0, $kqze3.default)(props, [
        "absolute",
        "classes",
        "className",
        "component",
        "flexItem",
        "light",
        "orientation",
        "role",
        "variant"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, variant !== "fullWidth" && classes[variant], absolute && classes.absolute, flexItem && classes.flexItem, light && classes.light, orientation === "vertical" && classes.vertical),
        role: role,
        ref: ref
    }, other));
});
var $1735c851d7a9cb02$export$2e2bcd8739ae039 = (0, $2LmR0.default)($1735c851d7a9cb02$export$9dd6ff9ea0189349, {
    name: "MuiDivider"
})($1735c851d7a9cb02$var$Divider);




var $aaLBe = parcelRequire("aaLBe");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.



var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");

var $aaLBe = parcelRequire("aaLBe");
/**
 * @ignore - internal component.
 */ var $07d98e7fa53e5d38$var$ListContext = $aaLBe.createContext({});
var $07d98e7fa53e5d38$export$2e2bcd8739ae039 = $07d98e7fa53e5d38$var$ListContext;


var $9df8988d97ad82c1$export$9dd6ff9ea0189349 = {
    /* Styles applied to the root element. */ root: {
        listStyle: "none",
        margin: 0,
        padding: 0,
        position: "relative"
    },
    /* Styles applied to the root element if `disablePadding={false}`. */ padding: {
        paddingTop: 8,
        paddingBottom: 8
    },
    /* Styles applied to the root element if dense. */ dense: {},
    /* Styles applied to the root element if a `subheader` is provided. */ subheader: {
        paddingTop: 0
    }
};
var $9df8988d97ad82c1$var$List = /*#__PURE__*/ $aaLBe.forwardRef(function List(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$component = props.component, Component = _props$component === void 0 ? "ul" : _props$component, _props$dense = props.dense, dense = _props$dense === void 0 ? false : _props$dense, _props$disablePadding = props.disablePadding, disablePadding = _props$disablePadding === void 0 ? false : _props$disablePadding, subheader = props.subheader, other = (0, $kqze3.default)(props, [
        "children",
        "classes",
        "className",
        "component",
        "dense",
        "disablePadding",
        "subheader"
    ]);
    var context = $aaLBe.useMemo(function() {
        return {
            dense: dense
        };
    }, [
        dense
    ]);
    return /*#__PURE__*/ $aaLBe.createElement((0, $07d98e7fa53e5d38$export$2e2bcd8739ae039).Provider, {
        value: context
    }, /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, dense && classes.dense, !disablePadding && classes.padding, subheader && classes.subheader),
        ref: ref
    }, other), subheader, children));
});
var $9df8988d97ad82c1$export$2e2bcd8739ae039 = (0, $2LmR0.default)($9df8988d97ad82c1$export$9dd6ff9ea0189349, {
    name: "MuiList"
})($9df8988d97ad82c1$var$List);



var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");


var $2LmR0 = parcelRequire("2LmR0");


var $aaLBe = parcelRequire("aaLBe");
function $ad8e706f06e1132a$export$2e2bcd8739ae039(element, muiNames) {
    return /*#__PURE__*/ $aaLBe.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
}





var $99a2a4fa7dd573a9$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the (normally root) `component` element. May be wrapped by a `container`. */ root: {
            display: "flex",
            justifyContent: "flex-start",
            alignItems: "center",
            position: "relative",
            textDecoration: "none",
            width: "100%",
            boxSizing: "border-box",
            textAlign: "left",
            paddingTop: 8,
            paddingBottom: 8,
            "&$focusVisible": {
                backgroundColor: theme.palette.action.selected
            },
            "&$selected, &$selected:hover": {
                backgroundColor: theme.palette.action.selected
            },
            "&$disabled": {
                opacity: 0.5
            }
        },
        /* Styles applied to the `container` element if `children` includes `ListItemSecondaryAction`. */ container: {
            position: "relative"
        },
        /* Pseudo-class applied to the `component`'s `focusVisibleClassName` prop if `button={true}`. */ focusVisible: {},
        /* Styles applied to the `component` element if dense. */ dense: {
            paddingTop: 4,
            paddingBottom: 4
        },
        /* Styles applied to the `component` element if `alignItems="flex-start"`. */ alignItemsFlexStart: {
            alignItems: "flex-start"
        },
        /* Pseudo-class applied to the inner `component` element if `disabled={true}`. */ disabled: {},
        /* Styles applied to the inner `component` element if `divider={true}`. */ divider: {
            borderBottom: "1px solid ".concat(theme.palette.divider),
            backgroundClip: "padding-box"
        },
        /* Styles applied to the inner `component` element if `disableGutters={false}`. */ gutters: {
            paddingLeft: 16,
            paddingRight: 16
        },
        /* Styles applied to the inner `component` element if `button={true}`. */ button: {
            transition: theme.transitions.create("background-color", {
                duration: theme.transitions.duration.shortest
            }),
            "&:hover": {
                textDecoration: "none",
                backgroundColor: theme.palette.action.hover,
                // Reset on touch devices, it doesn't add specificity
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        },
        /* Styles applied to the `component` element if `children` includes `ListItemSecondaryAction`. */ secondaryAction: {
            // Add some space to avoid collision as `ListItemSecondaryAction`
            // is absolutely positioned.
            paddingRight: 48
        },
        /* Pseudo-class applied to the root element if `selected={true}`. */ selected: {}
    };
};
var $99a2a4fa7dd573a9$var$useEnhancedEffect = typeof window === "undefined" ? $aaLBe.useEffect : $aaLBe.useLayoutEffect;
/**
 * Uses an additional container component if `ListItemSecondaryAction` is the last child.
 */ var $99a2a4fa7dd573a9$var$ListItem = /*#__PURE__*/ $aaLBe.forwardRef(function ListItem(props, ref) {
    var _props$alignItems = props.alignItems, alignItems = _props$alignItems === void 0 ? "center" : _props$alignItems, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus, _props$button = props.button, button = _props$button === void 0 ? false : _props$button, childrenProp = props.children, classes = props.classes, className = props.className, componentProp = props.component, _props$ContainerCompo = props.ContainerComponent, ContainerComponent = _props$ContainerCompo === void 0 ? "li" : _props$ContainerCompo, _props$ContainerProps = props.ContainerProps;
    _props$ContainerProps = _props$ContainerProps === void 0 ? {} : _props$ContainerProps;
    var ContainerClassName = _props$ContainerProps.className, ContainerProps = (0, $kqze3.default)(_props$ContainerProps, [
        "className"
    ]), _props$dense = props.dense, dense = _props$dense === void 0 ? false : _props$dense, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, _props$disableGutters = props.disableGutters, disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters, _props$divider = props.divider, divider = _props$divider === void 0 ? false : _props$divider, focusVisibleClassName = props.focusVisibleClassName, _props$selected = props.selected, selected = _props$selected === void 0 ? false : _props$selected, other = (0, $kqze3.default)(props, [
        "alignItems",
        "autoFocus",
        "button",
        "children",
        "classes",
        "className",
        "component",
        "ContainerComponent",
        "ContainerProps",
        "dense",
        "disabled",
        "disableGutters",
        "divider",
        "focusVisibleClassName",
        "selected"
    ]);
    var context = $aaLBe.useContext((0, $07d98e7fa53e5d38$export$2e2bcd8739ae039));
    var childContext = {
        dense: dense || context.dense || false,
        alignItems: alignItems
    };
    var listItemRef = $aaLBe.useRef(null);
    $99a2a4fa7dd573a9$var$useEnhancedEffect(function() {
        if (autoFocus) {
            if (listItemRef.current) listItemRef.current.focus();
        }
    }, [
        autoFocus
    ]);
    var children = $aaLBe.Children.toArray(childrenProp);
    var hasSecondaryAction = children.length && (0, $ad8e706f06e1132a$export$2e2bcd8739ae039)(children[children.length - 1], [
        "ListItemSecondaryAction"
    ]);
    var handleOwnRef = $aaLBe.useCallback(function(instance) {
        // #StrictMode ready
        listItemRef.current = $ba021dca0cbd5bec$exports.findDOMNode(instance);
    }, []);
    var handleRef = (0, $ec3bc30a9139d143$export$2e2bcd8739ae039)(handleOwnRef, ref);
    var componentProps = (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, childContext.dense && classes.dense, !disableGutters && classes.gutters, divider && classes.divider, disabled && classes.disabled, button && classes.button, alignItems !== "center" && classes.alignItemsFlexStart, hasSecondaryAction && classes.secondaryAction, selected && classes.selected),
        disabled: disabled
    }, other);
    var Component = componentProp || "li";
    if (button) {
        componentProps.component = componentProp || "div";
        componentProps.focusVisibleClassName = (0, $h0TGs.default)(classes.focusVisible, focusVisibleClassName);
        Component = (0, $c61f5105fcb078ef$export$2e2bcd8739ae039);
    }
    if (hasSecondaryAction) {
        // Use div by default.
        Component = !componentProps.component && !componentProp ? "div" : Component; // Avoid nesting of li > li.
        if (ContainerComponent === "li") {
            if (Component === "li") Component = "div";
            else if (componentProps.component === "li") componentProps.component = "div";
        }
        return /*#__PURE__*/ $aaLBe.createElement((0, $07d98e7fa53e5d38$export$2e2bcd8739ae039).Provider, {
            value: childContext
        }, /*#__PURE__*/ $aaLBe.createElement(ContainerComponent, (0, $29rXr.default)({
            className: (0, $h0TGs.default)(classes.container, ContainerClassName),
            ref: handleRef
        }, ContainerProps), /*#__PURE__*/ $aaLBe.createElement(Component, componentProps, children), children.pop()));
    }
    return /*#__PURE__*/ $aaLBe.createElement((0, $07d98e7fa53e5d38$export$2e2bcd8739ae039).Provider, {
        value: childContext
    }, /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        ref: handleRef
    }, componentProps), children));
});
var $99a2a4fa7dd573a9$export$2e2bcd8739ae039 = (0, $2LmR0.default)($99a2a4fa7dd573a9$export$9dd6ff9ea0189349, {
    name: "MuiListItem"
})($99a2a4fa7dd573a9$var$ListItem);



var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");
var $4e534e842cfe7519$export$9dd6ff9ea0189349 = {
    /* Styles applied to the root element. */ root: {
        position: "absolute",
        right: 16,
        top: "50%",
        transform: "translateY(-50%)"
    }
};
/**
 * Must be used as the last child of ListItem to function properly.
 */ var $4e534e842cfe7519$var$ListItemSecondaryAction = /*#__PURE__*/ $aaLBe.forwardRef(function ListItemSecondaryAction(props, ref) {
    var classes = props.classes, className = props.className, other = (0, $kqze3.default)(props, [
        "classes",
        "className"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement("div", (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className),
        ref: ref
    }, other));
});
$4e534e842cfe7519$var$ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
var $4e534e842cfe7519$export$2e2bcd8739ae039 = (0, $2LmR0.default)($4e534e842cfe7519$export$9dd6ff9ea0189349, {
    name: "MuiListItemSecondaryAction"
})($4e534e842cfe7519$var$ListItemSecondaryAction);



var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");


var $4c39a6341ab22910$export$9dd6ff9ea0189349 = {
    /* Styles applied to the root element. */ root: {
        flex: "1 1 auto",
        minWidth: 0,
        marginTop: 4,
        marginBottom: 4
    },
    /* Styles applied to the `Typography` components if primary and secondary are set. */ multiline: {
        marginTop: 6,
        marginBottom: 6
    },
    /* Styles applied to the `Typography` components if dense. */ dense: {},
    /* Styles applied to the root element if `inset={true}`. */ inset: {
        paddingLeft: 56
    },
    /* Styles applied to the primary `Typography` component. */ primary: {},
    /* Styles applied to the secondary `Typography` component. */ secondary: {}
};
var $4c39a6341ab22910$var$ListItemText = /*#__PURE__*/ $aaLBe.forwardRef(function ListItemText(props, ref) {
    var children = props.children, classes = props.classes, className = props.className, _props$disableTypogra = props.disableTypography, disableTypography = _props$disableTypogra === void 0 ? false : _props$disableTypogra, _props$inset = props.inset, inset = _props$inset === void 0 ? false : _props$inset, primaryProp = props.primary, primaryTypographyProps = props.primaryTypographyProps, secondaryProp = props.secondary, secondaryTypographyProps = props.secondaryTypographyProps, other = (0, $kqze3.default)(props, [
        "children",
        "classes",
        "className",
        "disableTypography",
        "inset",
        "primary",
        "primaryTypographyProps",
        "secondary",
        "secondaryTypographyProps"
    ]);
    var _React$useContext = $aaLBe.useContext((0, $07d98e7fa53e5d38$export$2e2bcd8739ae039)), dense = _React$useContext.dense;
    var primary = primaryProp != null ? primaryProp : children;
    if (primary != null && primary.type !== (0, $372cadd18a544d36$export$2e2bcd8739ae039) && !disableTypography) primary = /*#__PURE__*/ $aaLBe.createElement((0, $372cadd18a544d36$export$2e2bcd8739ae039), (0, $29rXr.default)({
        variant: dense ? "body2" : "body1",
        className: classes.primary,
        component: "span",
        display: "block"
    }, primaryTypographyProps), primary);
    var secondary = secondaryProp;
    if (secondary != null && secondary.type !== (0, $372cadd18a544d36$export$2e2bcd8739ae039) && !disableTypography) secondary = /*#__PURE__*/ $aaLBe.createElement((0, $372cadd18a544d36$export$2e2bcd8739ae039), (0, $29rXr.default)({
        variant: "body2",
        className: classes.secondary,
        color: "textSecondary",
        display: "block"
    }, secondaryTypographyProps), secondary);
    return /*#__PURE__*/ $aaLBe.createElement("div", (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, dense && classes.dense, inset && classes.inset, primary && secondary && classes.multiline),
        ref: ref
    }, other), primary, secondary);
});
var $4c39a6341ab22910$export$2e2bcd8739ae039 = (0, $2LmR0.default)($4c39a6341ab22910$export$9dd6ff9ea0189349, {
    name: "MuiListItemText"
})($4c39a6341ab22910$var$ListItemText);



var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

var $2LmR0 = parcelRequire("2LmR0");

var $gqsD7 = parcelRequire("gqsD7");
var $06add06d04d85c0d$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            boxSizing: "border-box",
            lineHeight: "48px",
            listStyle: "none",
            color: theme.palette.text.secondary,
            fontFamily: theme.typography.fontFamily,
            fontWeight: theme.typography.fontWeightMedium,
            fontSize: theme.typography.pxToRem(14)
        },
        /* Styles applied to the root element if `color="primary"`. */ colorPrimary: {
            color: theme.palette.primary.main
        },
        /* Styles applied to the root element if `color="inherit"`. */ colorInherit: {
            color: "inherit"
        },
        /* Styles applied to the inner `component` element if `disableGutters={false}`. */ gutters: {
            paddingLeft: 16,
            paddingRight: 16
        },
        /* Styles applied to the root element if `inset={true}`. */ inset: {
            paddingLeft: 72
        },
        /* Styles applied to the root element if `disableSticky={false}`. */ sticky: {
            position: "sticky",
            top: 0,
            zIndex: 1,
            backgroundColor: "inherit"
        }
    };
};
var $06add06d04d85c0d$var$ListSubheader = /*#__PURE__*/ $aaLBe.forwardRef(function ListSubheader(props, ref) {
    var classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "default" : _props$color, _props$component = props.component, Component = _props$component === void 0 ? "li" : _props$component, _props$disableGutters = props.disableGutters, disableGutters = _props$disableGutters === void 0 ? false : _props$disableGutters, _props$disableSticky = props.disableSticky, disableSticky = _props$disableSticky === void 0 ? false : _props$disableSticky, _props$inset = props.inset, inset = _props$inset === void 0 ? false : _props$inset, other = (0, $kqze3.default)(props, [
        "classes",
        "className",
        "color",
        "component",
        "disableGutters",
        "disableSticky",
        "inset"
    ]);
    return /*#__PURE__*/ $aaLBe.createElement(Component, (0, $29rXr.default)({
        className: (0, $h0TGs.default)(classes.root, className, color !== "default" && classes["color".concat((0, $gqsD7.default)(color))], inset && classes.inset, !disableSticky && classes.sticky, !disableGutters && classes.gutters),
        ref: ref
    }, other));
});
var $06add06d04d85c0d$export$2e2bcd8739ae039 = (0, $2LmR0.default)($06add06d04d85c0d$export$9dd6ff9ea0189349, {
    name: "MuiListSubheader"
})($06add06d04d85c0d$var$ListSubheader);



var $29rXr = parcelRequire("29rXr");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");


var $2LmR0 = parcelRequire("2LmR0");

var $5tnPj = parcelRequire("5tnPj");

var $gqsD7 = parcelRequire("gqsD7");

var $29rXr = parcelRequire("29rXr");

var $1CrQC = parcelRequire("1CrQC");

var $kqze3 = parcelRequire("kqze3");

var $aaLBe = parcelRequire("aaLBe");


var $h0TGs = parcelRequire("h0TGs");

/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */ 
var $aaLBe = parcelRequire("aaLBe");
function $a715aa2f083c32b5$export$2e2bcd8739ae039(_ref) {
    var controlled = _ref.controlled, defaultProp = _ref.default, name = _ref.name, _ref$state = _ref.state, state = _ref$state === void 0 ? "value" : _ref$state;
    var _React$useRef = $aaLBe.useRef(controlled !== undefined), isControlled = _React$useRef.current;
    var _React$useState = $aaLBe.useState(defaultProp), valueState = _React$useState[0], setValue = _React$useState[1];
    var value = isControlled ? controlled : valueState;
    var _React$useRef2, defaultValue;
    var setValueIfUncontrolled = $aaLBe.useCallback(function(newValue) {
        if (!isControlled) setValue(newValue);
    }, []);
    return [
        value,
        setValueIfUncontrolled
    ];
}



var $aaLBe = parcelRequire("aaLBe");

var $aaLBe = parcelRequire("aaLBe");
/**
 * @ignore - internal component.
 */ var $df72065bcf484d79$var$FormControlContext = $aaLBe.createContext();
function $df72065bcf484d79$export$62ecd8ad1bbe1a18() {
    return $aaLBe.useContext($df72065bcf484d79$var$FormControlContext);
}
var $df72065bcf484d79$export$2e2bcd8739ae039 = $df72065bcf484d79$var$FormControlContext;


function $db65b2ef87a46229$export$2e2bcd8739ae039() {
    return $aaLBe.useContext((0, $df72065bcf484d79$export$2e2bcd8739ae039));
}



var $2LmR0 = parcelRequire("2LmR0");

var $94fb7a0b0b85f4a1$export$9dd6ff9ea0189349 = {
    root: {
        padding: 9
    },
    checked: {},
    disabled: {},
    input: {
        cursor: "inherit",
        position: "absolute",
        opacity: 0,
        width: "100%",
        height: "100%",
        top: 0,
        left: 0,
        margin: 0,
        padding: 0,
        zIndex: 1
    }
};
/**
 * @ignore - internal component.
 */ var $94fb7a0b0b85f4a1$var$SwitchBase = /*#__PURE__*/ $aaLBe.forwardRef(function SwitchBase(props, ref) {
    var autoFocus = props.autoFocus, checkedProp = props.checked, checkedIcon = props.checkedIcon, classes = props.classes, className = props.className, defaultChecked = props.defaultChecked, disabledProp = props.disabled, icon = props.icon, id = props.id, inputProps = props.inputProps, inputRef = props.inputRef, name = props.name, onBlur = props.onBlur, onChange = props.onChange, onFocus = props.onFocus, readOnly = props.readOnly, required = props.required, tabIndex = props.tabIndex, type = props.type, value = props.value, other = (0, $kqze3.default)(props, [
        "autoFocus",
        "checked",
        "checkedIcon",
        "classes",
        "className",
        "defaultChecked",
        "disabled",
        "icon",
        "id",
        "inputProps",
        "inputRef",
        "name",
        "onBlur",
        "onChange",
        "onFocus",
        "readOnly",
        "required",
        "tabIndex",
        "type",
        "value"
    ]);
    var _useControlled = (0, $a715aa2f083c32b5$export$2e2bcd8739ae039)({
        controlled: checkedProp,
        default: Boolean(defaultChecked),
        name: "SwitchBase",
        state: "checked"
    }), _useControlled2 = (0, $1CrQC.default)(_useControlled, 2), checked = _useControlled2[0], setCheckedState = _useControlled2[1];
    var muiFormControl = (0, $db65b2ef87a46229$export$2e2bcd8739ae039)();
    var handleFocus = function handleFocus(event) {
        if (onFocus) onFocus(event);
        if (muiFormControl && muiFormControl.onFocus) muiFormControl.onFocus(event);
    };
    var handleBlur = function handleBlur(event) {
        if (onBlur) onBlur(event);
        if (muiFormControl && muiFormControl.onBlur) muiFormControl.onBlur(event);
    };
    var handleInputChange = function handleInputChange(event) {
        var newChecked = event.target.checked;
        setCheckedState(newChecked);
        if (onChange) // TODO v5: remove the second argument.
        onChange(event, newChecked);
    };
    var disabled = disabledProp;
    if (muiFormControl) {
        if (typeof disabled === "undefined") disabled = muiFormControl.disabled;
    }
    var hasLabelFor = type === "checkbox" || type === "radio";
    return /*#__PURE__*/ $aaLBe.createElement((0, $391e58f71c9818f8$export$2e2bcd8739ae039), (0, $29rXr.default)({
        component: "span",
        className: (0, $h0TGs.default)(classes.root, className, checked && classes.checked, disabled && classes.disabled),
        disabled: disabled,
        tabIndex: null,
        role: undefined,
        onFocus: handleFocus,
        onBlur: handleBlur,
        ref: ref
    }, other), /*#__PURE__*/ $aaLBe.createElement("input", (0, $29rXr.default)({
        autoFocus: autoFocus,
        checked: checkedProp,
        defaultChecked: defaultChecked,
        className: classes.input,
        disabled: disabled,
        id: hasLabelFor && id,
        name: name,
        onChange: handleInputChange,
        readOnly: readOnly,
        ref: inputRef,
        required: required,
        tabIndex: tabIndex,
        type: type,
        value: value
    }, inputProps)), checked ? checkedIcon : icon);
}); // NB: If changed, please update Checkbox, Switch and Radio
var $94fb7a0b0b85f4a1$export$2e2bcd8739ae039 = (0, $2LmR0.default)($94fb7a0b0b85f4a1$export$9dd6ff9ea0189349, {
    name: "PrivateSwitchBase"
})($94fb7a0b0b85f4a1$var$SwitchBase);


var $ee367d4ac76acb09$export$9dd6ff9ea0189349 = function styles(theme) {
    return {
        /* Styles applied to the root element. */ root: {
            display: "inline-flex",
            width: 58,
            height: 38,
            overflow: "hidden",
            padding: 12,
            boxSizing: "border-box",
            position: "relative",
            flexShrink: 0,
            zIndex: 0,
            // Reset the stacking context.
            verticalAlign: "middle",
            // For correct alignment with the text.
            "@media print": {
                colorAdjust: "exact"
            }
        },
        /* Styles applied to the root element if `edge="start"`. */ edgeStart: {
            marginLeft: -8
        },
        /* Styles applied to the root element if `edge="end"`. */ edgeEnd: {
            marginRight: -8
        },
        /* Styles applied to the internal `SwitchBase` component's `root` class. */ switchBase: {
            position: "absolute",
            top: 0,
            left: 0,
            zIndex: 1,
            // Render above the focus ripple.
            color: theme.palette.type === "light" ? theme.palette.grey[50] : theme.palette.grey[400],
            transition: theme.transitions.create([
                "left",
                "transform"
            ], {
                duration: theme.transitions.duration.shortest
            }),
            "&$checked": {
                transform: "translateX(20px)"
            },
            "&$disabled": {
                color: theme.palette.type === "light" ? theme.palette.grey[400] : theme.palette.grey[800]
            },
            "&$checked + $track": {
                opacity: 0.5
            },
            "&$disabled + $track": {
                opacity: theme.palette.type === "light" ? 0.12 : 0.1
            }
        },
        /* Styles applied to the internal SwitchBase component's root element if `color="primary"`. */ colorPrimary: {
            "&$checked": {
                color: theme.palette.primary.main,
                "&:hover": {
                    backgroundColor: (0, $5tnPj.alpha)(theme.palette.primary.main, theme.palette.action.hoverOpacity),
                    "@media (hover: none)": {
                        backgroundColor: "transparent"
                    }
                }
            },
            "&$disabled": {
                color: theme.palette.type === "light" ? theme.palette.grey[400] : theme.palette.grey[800]
            },
            "&$checked + $track": {
                backgroundColor: theme.palette.primary.main
            },
            "&$disabled + $track": {
                backgroundColor: theme.palette.type === "light" ? theme.palette.common.black : theme.palette.common.white
            }
        },
        /* Styles applied to the internal SwitchBase component's root element if `color="secondary"`. */ colorSecondary: {
            "&$checked": {
                color: theme.palette.secondary.main,
                "&:hover": {
                    backgroundColor: (0, $5tnPj.alpha)(theme.palette.secondary.main, theme.palette.action.hoverOpacity),
                    "@media (hover: none)": {
                        backgroundColor: "transparent"
                    }
                }
            },
            "&$disabled": {
                color: theme.palette.type === "light" ? theme.palette.grey[400] : theme.palette.grey[800]
            },
            "&$checked + $track": {
                backgroundColor: theme.palette.secondary.main
            },
            "&$disabled + $track": {
                backgroundColor: theme.palette.type === "light" ? theme.palette.common.black : theme.palette.common.white
            }
        },
        /* Styles applied to the root element if `size="small"`. */ sizeSmall: {
            width: 40,
            height: 24,
            padding: 7,
            "& $thumb": {
                width: 16,
                height: 16
            },
            "& $switchBase": {
                padding: 4,
                "&$checked": {
                    transform: "translateX(16px)"
                }
            }
        },
        /* Pseudo-class applied to the internal `SwitchBase` component's `checked` class. */ checked: {},
        /* Pseudo-class applied to the internal SwitchBase component's disabled class. */ disabled: {},
        /* Styles applied to the internal SwitchBase component's input element. */ input: {
            left: "-100%",
            width: "300%"
        },
        /* Styles used to create the thumb passed to the internal `SwitchBase` component `icon` prop. */ thumb: {
            boxShadow: theme.shadows[1],
            backgroundColor: "currentColor",
            width: 20,
            height: 20,
            borderRadius: "50%"
        },
        /* Styles applied to the track element. */ track: {
            height: "100%",
            width: "100%",
            borderRadius: 7,
            zIndex: -1,
            transition: theme.transitions.create([
                "opacity",
                "background-color"
            ], {
                duration: theme.transitions.duration.shortest
            }),
            backgroundColor: theme.palette.type === "light" ? theme.palette.common.black : theme.palette.common.white,
            opacity: theme.palette.type === "light" ? 0.38 : 0.3
        }
    };
};
var $ee367d4ac76acb09$var$Switch = /*#__PURE__*/ $aaLBe.forwardRef(function Switch(props, ref) {
    var classes = props.classes, className = props.className, _props$color = props.color, color = _props$color === void 0 ? "secondary" : _props$color, _props$edge = props.edge, edge = _props$edge === void 0 ? false : _props$edge, _props$size = props.size, size = _props$size === void 0 ? "medium" : _props$size, other = (0, $kqze3.default)(props, [
        "classes",
        "className",
        "color",
        "edge",
        "size"
    ]);
    var icon = /*#__PURE__*/ $aaLBe.createElement("span", {
        className: classes.thumb
    });
    return /*#__PURE__*/ $aaLBe.createElement("span", {
        className: (0, $h0TGs.default)(classes.root, className, {
            "start": classes.edgeStart,
            "end": classes.edgeEnd
        }[edge], size === "small" && classes["size".concat((0, $gqsD7.default)(size))])
    }, /*#__PURE__*/ $aaLBe.createElement((0, $94fb7a0b0b85f4a1$export$2e2bcd8739ae039), (0, $29rXr.default)({
        type: "checkbox",
        icon: icon,
        checkedIcon: icon,
        classes: {
            root: (0, $h0TGs.default)(classes.switchBase, classes["color".concat((0, $gqsD7.default)(color))]),
            input: classes.input,
            checked: classes.checked,
            disabled: classes.disabled
        },
        ref: ref
    }, other)), /*#__PURE__*/ $aaLBe.createElement("span", {
        className: classes.track
    }));
});
var $ee367d4ac76acb09$export$2e2bcd8739ae039 = (0, $2LmR0.default)($ee367d4ac76acb09$export$9dd6ff9ea0189349, {
    name: "MuiSwitch"
})($ee367d4ac76acb09$var$Switch);



var $d5f05e6b0b4f2ea7$exports = {};
"use strict";


Object.defineProperty($d5f05e6b0b4f2ea7$exports, "__esModule", {
    value: true
});
$d5f05e6b0b4f2ea7$exports.default = void 0;

var $d5f05e6b0b4f2ea7$var$React = $80a9c2f6d1811a06$exports((parcelRequire("aaLBe")));

var $d5f05e6b0b4f2ea7$var$_createSvgIcon = $69f4ded615f6c2c8$exports((parcelRequire("jxmMp")));
var $d5f05e6b0b4f2ea7$var$_default = (0, $d5f05e6b0b4f2ea7$var$_createSvgIcon.default)(/*#__PURE__*/ $d5f05e6b0b4f2ea7$var$React.createElement("path", {
    d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
}), "Visibility");
$d5f05e6b0b4f2ea7$exports.default = $d5f05e6b0b4f2ea7$var$_default;


var $bf2b9c54cc721cf0$exports = {};
"use strict";


Object.defineProperty($bf2b9c54cc721cf0$exports, "__esModule", {
    value: true
});
$bf2b9c54cc721cf0$exports.default = void 0;

var $bf2b9c54cc721cf0$var$React = $80a9c2f6d1811a06$exports((parcelRequire("aaLBe")));

var $bf2b9c54cc721cf0$var$_createSvgIcon = $69f4ded615f6c2c8$exports((parcelRequire("jxmMp")));
var $bf2b9c54cc721cf0$var$_default = (0, $bf2b9c54cc721cf0$var$_createSvgIcon.default)(/*#__PURE__*/ $bf2b9c54cc721cf0$var$React.createElement("path", {
    d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
}), "VisibilityOff");
$bf2b9c54cc721cf0$exports.default = $bf2b9c54cc721cf0$var$_default;




var $aaLBe = parcelRequire("aaLBe");


const { styleDiv: $9db9365359ab8967$var$styleDiv  } = (0, $b740921611e46f8c$export$99f00114e7637415)("FeatureArea");
const $9db9365359ab8967$var$Container = $9db9365359ab8967$var$styleDiv("Container", {
    flex: 0
});
let $9db9365359ab8967$export$e9a96750f1bb6f69 = class ChartOptions extends $aaLBe.Component {
    render() {
        return /*#__PURE__*/ $aaLBe.createElement($9db9365359ab8967$var$Container, null, /*#__PURE__*/ $aaLBe.createElement((0, $9df8988d97ad82c1$export$2e2bcd8739ae039), {
            subheader: /*#__PURE__*/ $aaLBe.createElement((0, $06add06d04d85c0d$export$2e2bcd8739ae039), null, "Chart Options")
        }, /*#__PURE__*/ $aaLBe.createElement((0, $99a2a4fa7dd573a9$export$2e2bcd8739ae039), null, /*#__PURE__*/ $aaLBe.createElement((0, $4c39a6341ab22910$export$2e2bcd8739ae039), {
            disableTypography: true
        }, /*#__PURE__*/ $aaLBe.createElement((0, $372cadd18a544d36$export$2e2bcd8739ae039), {
            variant: "subtitle1"
        }, /*#__PURE__*/ $aaLBe.createElement("label", {
            htmlFor: "normalizeAxes"
        }, "Normalize axes"))), /*#__PURE__*/ $aaLBe.createElement((0, $4e534e842cfe7519$export$2e2bcd8739ae039), null, /*#__PURE__*/ $aaLBe.createElement((0, $ee367d4ac76acb09$export$2e2bcd8739ae039), {
            id: "normalizeAxes",
            onChange: (e)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).normalizeAxes = e.target.checked,
            checked: (0, $841120e180d215c5$export$a510af025ac2bbc1).normalizeAxes
        }))), /*#__PURE__*/ $aaLBe.createElement((0, $99a2a4fa7dd573a9$export$2e2bcd8739ae039), null, /*#__PURE__*/ $aaLBe.createElement((0, $4c39a6341ab22910$export$2e2bcd8739ae039), {
            disableTypography: true
        }, /*#__PURE__*/ $aaLBe.createElement((0, $372cadd18a544d36$export$2e2bcd8739ae039), {
            variant: "subtitle1"
        }, /*#__PURE__*/ $aaLBe.createElement("label", {
            htmlFor: "showHistograms"
        }, "Show histograms"))), /*#__PURE__*/ $aaLBe.createElement((0, $4e534e842cfe7519$export$2e2bcd8739ae039), null, /*#__PURE__*/ $aaLBe.createElement((0, $ee367d4ac76acb09$export$2e2bcd8739ae039), {
            id: "showHistograms",
            onChange: (e)=>(0, $841120e180d215c5$export$a510af025ac2bbc1).showHistograms = e.target.checked,
            checked: (0, $841120e180d215c5$export$a510af025ac2bbc1).showHistograms
        }))), /*#__PURE__*/ $aaLBe.createElement((0, $99a2a4fa7dd573a9$export$2e2bcd8739ae039), {
            style: {
                paddingTop: 5,
                paddingBottom: 5
            }
        }, /*#__PURE__*/ $aaLBe.createElement((0, $4c39a6341ab22910$export$2e2bcd8739ae039), {
            primary: "All Features"
        }), /*#__PURE__*/ $aaLBe.createElement((0, $4e534e842cfe7519$export$2e2bcd8739ae039), null, /*#__PURE__*/ $aaLBe.createElement((0, $391e58f71c9818f8$export$2e2bcd8739ae039), {
            onClick: ()=>(0, $841120e180d215c5$export$a510af025ac2bbc1).toggleAllFeatureVisbility(true),
            title: "Show all features"
        }, /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($d5f05e6b0b4f2ea7$exports))), null)), /*#__PURE__*/ $aaLBe.createElement((0, $391e58f71c9818f8$export$2e2bcd8739ae039), {
            onClick: ()=>(0, $841120e180d215c5$export$a510af025ac2bbc1).toggleAllFeatureVisbility(false),
            title: "Hide all features"
        }, /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($bf2b9c54cc721cf0$exports))), null))))));
    }
};
$9db9365359ab8967$export$e9a96750f1bb6f69 = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $9db9365359ab8967$export$e9a96750f1bb6f69);


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.











var $aaLBe = parcelRequire("aaLBe");


const { styleDiv: $a345407ff4a00b70$var$styleDiv  } = (0, $b740921611e46f8c$export$99f00114e7637415)("FeatureArea");
const $a345407ff4a00b70$var$Container = $a345407ff4a00b70$var$styleDiv("Container", {
    flex: 1
});
let $a345407ff4a00b70$export$aa18130def4b6cb4 = class FeatureList extends $aaLBe.Component {
    render() {
        const { model: model  } = this.props;
        return /*#__PURE__*/ $aaLBe.createElement($a345407ff4a00b70$var$Container, null, /*#__PURE__*/ $aaLBe.createElement((0, $9df8988d97ad82c1$export$2e2bcd8739ae039), {
            subheader: /*#__PURE__*/ $aaLBe.createElement((0, $06add06d04d85c0d$export$2e2bcd8739ae039), null, "Features")
        }, model ? model.features.filter((f)=>f.name !== "intercept").map((feature)=>/*#__PURE__*/ $aaLBe.createElement((0, $99a2a4fa7dd573a9$export$2e2bcd8739ae039), {
                key: feature.name,
                style: {
                    paddingTop: 5,
                    paddingBottom: 5
                }
            }, /*#__PURE__*/ $aaLBe.createElement((0, $4c39a6341ab22910$export$2e2bcd8739ae039), {
                primary: feature.name,
                secondary: feature.description
            }), /*#__PURE__*/ $aaLBe.createElement((0, $4e534e842cfe7519$export$2e2bcd8739ae039), null, /*#__PURE__*/ $aaLBe.createElement((0, $391e58f71c9818f8$export$2e2bcd8739ae039), {
                onClick: ()=>(0, $841120e180d215c5$export$a510af025ac2bbc1).toggleFeatureVisibility(feature.name),
                title: "Toggle feature visibility"
            }, (0, $841120e180d215c5$export$a510af025ac2bbc1).isFeatureVisible(feature.name) ? /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($d5f05e6b0b4f2ea7$exports))), null) : /*#__PURE__*/ $aaLBe.createElement((0, (/*@__PURE__*/$parcel$interopDefault($bf2b9c54cc721cf0$exports))), null))))) : null));
    }
};
$a345407ff4a00b70$export$aa18130def4b6cb4 = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $a345407ff4a00b70$export$aa18130def4b6cb4);




const { styleDiv: $0abd6236d2a06607$var$styleDiv  } = (0, $b740921611e46f8c$export$99f00114e7637415)("FeatureArea");
const $0abd6236d2a06607$var$Container = $0abd6236d2a06607$var$styleDiv("Container", {
    display: "flex",
    flexDirection: "column",
    height: "100%",
    position: "relative",
    overflowY: "auto"
});
let $0abd6236d2a06607$export$d3abd74b7983e13a = class FeatureArea extends $aaLBe.Component {
    render() {
        const { model: model  } = this.props;
        return /*#__PURE__*/ $aaLBe.createElement($0abd6236d2a06607$var$Container, {
            className: "sidenav",
            style: {
                width: (0, $841120e180d215c5$export$a510af025ac2bbc1).sidebarOpen ? 250 : 0
            }
        }, /*#__PURE__*/ $aaLBe.createElement((0, $9db9365359ab8967$export$e9a96750f1bb6f69), null), /*#__PURE__*/ $aaLBe.createElement((0, $1735c851d7a9cb02$export$2e2bcd8739ae039), null), /*#__PURE__*/ $aaLBe.createElement((0, $a345407ff4a00b70$export$aa18130def4b6cb4), {
            model: model
        }));
    }
};
$0abd6236d2a06607$export$d3abd74b7983e13a = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $0abd6236d2a06607$export$d3abd74b7983e13a);


const $698364edfda1aa3f$var$theme = (0, $i3Ixz.default)({
    typography: {
        // In Japanese the characters are usually larger.
        fontSize: 12
    }
});
let $698364edfda1aa3f$export$86fbec116b87613f = class App extends $aaLBe.Component {
    render() {
        const model = (0, $841120e180d215c5$export$a510af025ac2bbc1).model;
        return /*#__PURE__*/ $aaLBe.createElement((0, $f493791dfb5b1ced$export$2e2bcd8739ae039), {
            theme: $698364edfda1aa3f$var$theme
        }, /*#__PURE__*/ $aaLBe.createElement((0, $17417c12731462fa$export$31a305e9779b48b4), null, /*#__PURE__*/ $aaLBe.createElement((0, $ef8b3f7a4714a72f$export$2e2bcd8739ae039), null), (0, $841120e180d215c5$export$a510af025ac2bbc1).ready ? [
            /*#__PURE__*/ $aaLBe.createElement((0, $0abd6236d2a06607$export$d3abd74b7983e13a), {
                key: "fa",
                model: model
            }),
            /*#__PURE__*/ $aaLBe.createElement((0, $eaf8839829366ca4$export$7c6e2c02157bb7d2), {
                key: "c",
                model: model
            })
        ] : /*#__PURE__*/ $aaLBe.createElement("div", {
            className: "loading"
        }, "Loading ", (0, $841120e180d215c5$export$a510af025ac2bbc1).datasetName, "...")));
    }
};
$698364edfda1aa3f$export$86fbec116b87613f = (0, $12cfff73c068c586$export$29e00dfd3077644b)([
    (0, $89be00fd7ffd1d5f$export$b6ae1bc530f4c149)
], $698364edfda1aa3f$export$86fbec116b87613f);



$ba021dca0cbd5bec$exports.render(/*#__PURE__*/ $aaLBe.createElement((0, $698364edfda1aa3f$export$86fbec116b87613f), null), document.getElementById("root"));


//# sourceMappingURL=index.de9c908d.js.map
